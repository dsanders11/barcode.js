self.CLOSURE_NO_DEPS = true;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when
 *     --process_closure_primitives is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  // void 0 always evaluates to undefined and hence we do not need to depend on
  // the definition of the global variable named 'undefined'.
  return val !== void 0;
};


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler
 * options or the value set in the CLOSURE_DEFINES object.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else if (goog.global.CLOSURE_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.define('goog.DEBUG', true);


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode
 *
 */
goog.define('goog.STRICT_MODE_COMPATIBLE', false);


/**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */
goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);


/**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */
goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);


/**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
  }

  goog.constructNamespace_(name);
};


/**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {Object=} opt_obj The object to embed in the namespace.
 * @private
 */
goog.constructNamespace_ = function(name, opt_obj) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name, opt_obj);
};


/**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;


/**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 */
goog.module = function(name) {
  if (!goog.isString(name) ||
      !name ||
      name.search(goog.VALID_MODULE_RE_) == -1) {
    throw Error('Invalid module identifier');
  }
  if (!goog.isInModuleLoader_()) {
    throw Error('Module ' + name + ' has been loaded incorrectly.');
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw Error('goog.module may only be called once per module.');
  }

  // Store the module name for the loader.
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      // goog.require only return a value with-in goog.module files.
      return name in goog.loadedModules_ ?
          goog.loadedModules_[name] :
          goog.getObjectByName(name);
    } else {
      return null;
    }
  }
};


/**
 * @private {?{moduleName: (string|undefined)}}
 */
goog.moduleLoaderState_ = null;


/**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */
goog.isInModuleLoader_ = function() {
  return goog.moduleLoaderState_ != null;
};


/**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw new Error('goog.module.declareLegacyNamespace must be called from ' +
        'within a goog.module');
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw Error('goog.module must be called prior to ' +
        'goog.module.declareLegacyNamespace.');
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


/**
 * Forward declare type information. Used to assign types to goog.global
 * referenced object that would otherwise result in unknown type references
 * and thus block property disambiguation.
 */
goog.forwardDeclare('Document');
goog.forwardDeclare('XMLHttpRequest');


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return (name in goog.loadedModules_) ||
        (!goog.implicitNamespaces_[name] &&
            goog.isDefAndNotNull(goog.getObjectByName(name)));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */
  goog.implicitNamespaces_ = {'goog.module': true};

  // NOTE: We add goog.module as an implicit namespace as goog.module is defined
  // here and because the existing module package has not been moved yet out of
  // the goog.module namespace. This satisifies both the debug loader and
  // ahead-of-time dependency management.
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {!Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean=} opt_isModule Whether this dependency must be loaded as
 *     a module as declared by goog.module.
 */
goog.addDependency = function(relPath, provides, requires, opt_isModule) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      deps.pathIsModule[path] = !!opt_isModule;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * @param {string} msg
 * @private
 */
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console['error'](msg);
  }
};


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --process_closure_primitives option is
 * used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 * @return {?} If called within a goog.module file, the associated namespace or
 *     module otherwise null.
 */
goog.require = function(name) {
  // If the object already exists we do not need do do anything.
  if (!COMPILED) {
    if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
      goog.maybeProcessDeferredDep_(name);
    }

    if (goog.isProvided_(name)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(name);
      } else {
        return null;
      }
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.writeScripts_(path);
        return null;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    goog.logToConsole_(errorMessage);

    throw Error(errorMessage);
  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * @define {boolean} Whether to load goog.modules using {@code eval} when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of {@code eval} is banned
 * so we provide an alternative.
 */
goog.define('goog.LOAD_MODULE_USING_EVAL', true);


/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);


/**
 * The registry of initialized modules:
 * the module identifier to module exports map.
 * @private @const {!Object<string, ?>}
 */
goog.loadedModules_ = {};


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {

  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {{
   *   pathIsModule: !Object<string, boolean>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */
  goog.dependencies_ = {
    pathIsModule: {}, // 1 to 1

    nameToPath: {}, // 1 to 1

    requires: {}, // 1 to many

    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},

    written: {}, // Used to keep track of script files we have written.

    deferred: {} // Used to track deferred module evaluations in old IEs
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    /** @type {Document} */
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    /** @type {Document} */
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('SCRIPT');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);
      var src = script.src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @private
   */
  goog.importScript_ = function(src, opt_sourceText) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (importScript(src, opt_sourceText)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /** @const @private {boolean} */
  goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document &&
      goog.global.document.all);


  /**
   * Given a URL initiate retrieval and execution of the module.
   * @param {string} src Script source URL.
   * @private
   */
  goog.importModule_ = function(src) {
    // In an attempt to keep browsers from timing out loading scripts using
    // synchronous XHRs, put each load in its own script block.
    var bootstrap = 'goog.retrieveAndExecModule_("' + src + '");';

    if (goog.importScript_('', bootstrap)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /** @private {!Array<string>} */
  goog.queuedModules_ = [];


  /**
   * Return an appropriate module text. Suitable to insert into
   * a script tag (that is unescaped).
   * @param {string} srcUrl
   * @param {string} scriptText
   * @return {string}
   * @private
   */
  goog.wrapModule_ = function(srcUrl, scriptText) {
    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
      return '' +
          'goog.loadModule(function(exports) {' +
          '"use strict";' +
          scriptText +
          '\n' + // terminate any trailing single line comment.
          ';return exports' +
          '});' +
          '\n//# sourceURL=' + srcUrl + '\n';
    } else {
      return '' +
          'goog.loadModule(' +
          goog.global.JSON.stringify(
              scriptText + '\n//# sourceURL=' + srcUrl + '\n') +
          ');';
    }
  };

  // On IE9 and earlier, it is necessary to handle
  // deferred module loads. In later browsers, the
  // code to be evaluated is simply inserted as a script
  // block in the correct order. To eval deferred
  // code at the right time, we piggy back on goog.require to call
  // goog.maybeProcessDeferredDep_.
  //
  // The goog.requires are used both to bootstrap
  // the loading process (when no deps are available) and
  // declare that they should be available.
  //
  // Here we eval the sources, if all the deps are available
  // either already eval'd or goog.require'd.  This will
  // be the case when all the dependencies have already
  // been loaded, and the dependent module is loaded.
  //
  // But this alone isn't sufficient because it is also
  // necessary to handle the case where there is no root
  // that is not deferred.  For that there we register for an event
  // and trigger goog.loadQueuedModules_ handle any remaining deferred
  // evaluations.

  /**
   * Handle any remaining deferred goog.module evals.
   * @private
   */
  goog.loadQueuedModules_ = function() {
    var count = goog.queuedModules_.length;
    if (count > 0) {
      var queue = goog.queuedModules_;
      goog.queuedModules_ = [];
      for (var i = 0; i < count; i++) {
        var path = queue[i];
        goog.maybeProcessDeferredPath_(path);
      }
    }
  };


  /**
   * Eval the named module if its dependencies are
   * available.
   * @param {string} name The module to load.
   * @private
   */
  goog.maybeProcessDeferredDep_ = function(name) {
    if (goog.isDeferredModule_(name) &&
        goog.allDepsAreAvailable_(name)) {
      var path = goog.getPathFromDeps_(name);
      goog.maybeProcessDeferredPath_(goog.basePath + path);
    }
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose evaluation has been deferred.
   * @private
   */
  goog.isDeferredModule_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && goog.dependencies_.pathIsModule[path]) {
      var abspath = goog.basePath + path;
      return (abspath) in goog.dependencies_.deferred;
    }
    return false;
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose declared dependencies have all been loaded
   *     (eval'd or a deferred module load)
   * @private
   */
  goog.allDepsAreAvailable_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && (path in goog.dependencies_.requires)) {
      for (var requireName in goog.dependencies_.requires[path]) {
        if (!goog.isProvided_(requireName) &&
            !goog.isDeferredModule_(requireName)) {
          return false;
        }
      }
    }
    return true;
  };


  /**
   * @param {string} abspath
   * @private
   */
  goog.maybeProcessDeferredPath_ = function(abspath) {
    if (abspath in goog.dependencies_.deferred) {
      var src = goog.dependencies_.deferred[abspath];
      delete goog.dependencies_.deferred[abspath];
      goog.globalEval(src);
    }
  };


  /**
   * @param {function(?):?|string} moduleDef The module definition.
   */
  goog.loadModule = function(moduleDef) {
    // NOTE: we allow function definitions to be either in the from
    // of a string to eval (which keeps the original source intact) or
    // in a eval forbidden environment (CSP) we allow a function definition
    // which in its body must call {@code goog.module}, and return the exports
    // of the module.
    var previousState = goog.moduleLoaderState_;
    try {
      goog.moduleLoaderState_ = {moduleName: undefined};
      var exports;
      if (goog.isFunction(moduleDef)) {
        exports = moduleDef.call(goog.global, {});
      } else if (goog.isString(moduleDef)) {
        exports = goog.loadModuleFromSource_.call(goog.global, moduleDef);
      } else {
        throw Error('Invalid module definition');
      }

      var moduleName = goog.moduleLoaderState_.moduleName;
      if (!goog.isString(moduleName) || !moduleName) {
        throw Error('Invalid module name \"' + moduleName + '\"');
      }

      // Don't seal legacy namespaces as they may be uses as a parent of
      // another namespace
      if (goog.moduleLoaderState_.declareLegacyNamespace) {
        goog.constructNamespace_(moduleName, exports);
      } else if (goog.SEAL_MODULE_EXPORTS && Object.seal) {
        Object.seal(exports);
      }

      goog.loadedModules_[moduleName] = exports;
    } finally {
      goog.moduleLoaderState_ = previousState;
    }
  };


  /**
   * @private @const {function(string):?}
   * @suppress {newCheckTypes}
   */
  goog.loadModuleFromSource_ = function() {
    // NOTE: we avoid declaring parameters or local variables here to avoid
    // masking globals or leaking values into the module definition.
    'use strict';
    var exports = {};
    eval(arguments[0]);
    return exports;
  };


  /**
   * Writes a new script pointing to {@code src} directly into the DOM.
   *
   * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
   * the fallback mechanism.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.writeScriptSrcNode_ = function(src) {
    goog.global.document.write(
        '<script type="text/javascript" src="' + src + '"></' + 'script>');
  };


  /**
   * Appends a new script node to the DOM using a CSP-compliant mechanism. This
   * method exists as a fallback for document.write (which is not allowed in a
   * strict CSP context, e.g., Chrome apps).
   *
   * NOTE: This method is not analogous to using document.write to insert a
   * <script> tag; specifically, the user agent will execute a script added by
   * document.write immediately after the current script block finishes
   * executing, whereas the DOM-appended script node will not be executed until
   * the entire document is parsed and executed. That is to say, this script is
   * added to the end of the script execution queue.
   *
   * The page must not attempt to call goog.required entities until after the
   * document has loaded, e.g., in or after the window.onload callback.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.appendScriptSrcNode_ = function(src) {
    /** @type {Document} */
    var doc = goog.global.document;
    var scriptEl = doc.createElement('script');
    scriptEl.type = 'text/javascript';
    scriptEl.src = src;
    scriptEl.defer = false;
    scriptEl.async = false;
    doc.head.appendChild(scriptEl);
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      /** @type {Document} */
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page. This does not apply to the CSP-compliant method
      // of writing script tags.
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
          doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      var isOldIE = goog.IS_OLD_IE_;

      if (opt_sourceText === undefined) {
        if (!isOldIE) {
          if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            goog.appendScriptSrcNode_(src);
          } else {
            goog.writeScriptSrcNode_(src);
          }
        } else {
          var state = " onreadystatechange='goog.onScriptLoad_(this, " +
              ++goog.lastNonModuleScriptIndex_ + ")' ";
          doc.write(
              '<script type="text/javascript" src="' +
                  src + '"' + state + '></' + 'script>');
        }
      } else {
        doc.write(
            '<script type="text/javascript">' +
            opt_sourceText +
            '</' + 'script>');
      }
      return true;
    } else {
      return false;
    }
  };


  /** @private {number} */
  goog.lastNonModuleScriptIndex_ = 0;


  /**
   * A readystatechange handler for legacy IE
   * @param {!HTMLScriptElement} script
   * @param {number} scriptIndex
   * @return {boolean}
   * @private
   */
  goog.onScriptLoad_ = function(script, scriptIndex) {
    // for now load the modules when we reach the last script,
    // later allow more inter-mingling.
    if (script.readyState == 'complete' &&
        goog.lastNonModuleScriptIndex_ == scriptIndex) {
      goog.loadQueuedModules_();
    }
    return true;
  };

  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @param {string} pathToLoad The path from which to start discovering
   *     dependencies.
   * @private
   */
  goog.writeScripts_ = function(pathToLoad) {
    /** @type {!Array<string>} The scripts we need to write this time. */
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    /** @param {string} path */
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    visitNode(pathToLoad);

    // record that we are going to load all these scripts.
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      goog.dependencies_.written[path] = true;
    }

    // If a module is loaded synchronously then we need to
    // clear the current inModuleLoader value, and restore it when we are
    // done loading the current "requires".
    var moduleState = goog.moduleLoaderState_;
    goog.moduleLoaderState_ = null;

    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      if (path) {
        if (!deps.pathIsModule[path]) {
          goog.importScript_(goog.basePath + path);
        } else {
          goog.importModule_(goog.basePath + path);
        }
      } else {
        goog.moduleLoaderState_ = moduleState;
        throw Error('Undefined script input');
      }
    }

    // restore the current "module loading state"
    goog.moduleLoaderState_ = moduleState;
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}


/**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */
goog.normalizePath_ = function(path) {
  var components = path.split('/');
  var i = 0;
  while (i < components.length) {
    if (components[i] == '.') {
      components.splice(i, 1);
    } else if (i && components[i] == '..' &&
        components[i - 1] && components[i - 1] != '..') {
      components.splice(--i, 2);
    } else {
      i++;
    }
  }
  return components.join('/');
};


/**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {string} File contents.
 * @private
 */
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    /** @type {XMLHttpRequest} */
    var xhr = new goog.global['XMLHttpRequest']();
    xhr.open('get', src, false);
    xhr.send();
    return xhr.responseText;
  }
};


/**
 * Retrieve and execute a module.
 * @param {string} src Script source URL.
 * @private
 */
goog.retrieveAndExecModule_ = function(src) {
  if (!COMPILED) {
    // The full but non-canonicalized URL for later use.
    var originalPath = src;
    // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
    // console doesn't auto-canonicalize XHR loads as it does <script> srcs.
    src = goog.normalizePath_(src);

    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;

    var scriptText = goog.loadFileSync_(src);

    if (scriptText != null) {
      var execModuleScript = goog.wrapModule_(src, scriptText);
      var isOldIE = goog.IS_OLD_IE_;
      if (isOldIE) {
        goog.dependencies_.deferred[originalPath] = execModuleScript;
        goog.queuedModules_.push(originalPath);
      } else {
        importScript(src, execModuleScript);
      }
    } else {
      throw new Error('load of ' + src + 'failed');
    }
  }
};


//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. As a special case, a function value is not array like, because its
 * length property is fixed to correspond to the number of expected arguments.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  // We do not use goog.isObject here in order to exclude function values.
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like goog.bind(), except that a 'this object' is not required. Useful when
 * the target function is already bound.
 *
 * Usage:
 * var g = goog.partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _evalTest_ = 1;');
      if (typeof goog.global['_evalTest_'] != 'undefined') {
        try {
          delete goog.global['_evalTest_'];
        } catch (ignore) {
          // Microsoft edge fails the deletion above in strict mode.
        }
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      /** @type {Document} */
      var doc = goog.global.document;
      var scriptElt = doc.createElement('SCRIPT');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --process_closure_primitives flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {!Function} childCtor Child class.
 * @param {!Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
    throw Error('arguments.caller not defined.  goog.base() cannot be used ' +
                'with strict mode code. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
  }

  if (caller.superClass_) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var ctorArgs = new Array(arguments.length - 1);
    for (var i = 1; i < arguments.length; i++) {
      ctorArgs[i - 1] = arguments[i];
    }
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(me, ctorArgs);
  }

  // Copying using loop to avoid deop due to passing arguments object to
  // function. This is faster in many JS engines as of late 2014.
  var args = new Array(arguments.length - 2);
  for (var i = 2; i < arguments.length; i++) {
    args[i - 2] = arguments[i];
  }
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}



//==============================================================================
// goog.defineClass implementation
//==============================================================================


/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw Error('cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {
 *     !Object|
 *     {constructor:!Function}|
 *     {constructor:!Function, statics:(Object|function(Function):void)}}
 * @suppress {missingProvide}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by
 * goog.defineClass should be sealed when possible.
 */
goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (goog.defineClass.SEAL_CLASS_INSTANCES &&
      Object.seal instanceof Function) {
    // Don't seal subclasses of unsealable-tagged legacy classes.
    if (superClass && superClass.prototype &&
        superClass.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
      return ctr;
    }
    /**
     * @this {Object}
     * @return {?}
     */
    var wrappedCtr = function() {
      // Don't seal an instance of a subclass when it calls the constructor of
      // its super class as there is most likely still setup to do.
      var instance = ctr.apply(this, arguments) || this;
      instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];
      if (this.constructor === wrappedCtr) {
        Object.seal(instance);
      }
      return instance;
    };
    return wrappedCtr;
  }
  return ctr;
};


// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properties from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};


/**
 * Sealing classes breaks the older idiom of assigning properties on the
 * prototype rather than in the constructor.  As such, goog.defineClass
 * must not seal subclasses of these old-style classes until they are fixed.
 * Until then, this marks a class as "broken", instructing defineClass
 * not to seal subclasses.
 * @param {!Function} ctr The legacy constructor to tag as unsealable.
 */
goog.tagUnsealableClass = function(ctr) {
  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
  }
};


/**
 * Name for unsealable tag property.
 * @const @private {string}
 */
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */

goog.provide('goog.debug.Error');



/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function(opt_msg) {

  // Attempt to ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    var stack = new Error().stack;
    if (stack) {
      this.stack = stack;
    }
  }

  if (opt_msg) {
    this.message = String(opt_msg);
  }

  /**
   * Whether to report this error to the server. Setting this to false will
   * cause the error reporter to not report the error back to the server,
   * which can be useful if the client knows that the error has already been
   * logged on the server.
   * @type {boolean}
   */
  this.reportErrorToServer = true;
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 * @author arv@google.com (Erik Arvidsson)
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * @define {boolean} Enables HTML escaping of lowercase letter "e" which helps
 * with detection of double-escaping as this letter is frequently used.
 */
goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);


/**
 * @define {boolean} Whether to force non-dom html unescaping.
 */
goog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(
      prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(
      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if {@code str1} and {@code str2} are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = function(str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function(str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';

  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length &&
         // Replace up to the last split part. We are inserting in the
         // positions between split parts.
         splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }

  return returnString + splitParts.join('%s'); // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} Whether {@code str} is empty or whitespace only.
 */
goog.string.isEmptyOrWhitespace = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is empty.
 * @param {string} str The string to check.
 * @return {boolean} Whether {@code str} is empty.
 */
goog.string.isEmptyString = function(str) {
  return str.length == 0;
};


/**
 * Checks if a string is empty or contains only whitespaces.
 *
 * TODO(user): Deprecate this when clients have been switched over to
 * goog.string.isEmptyOrWhitespace.
 *
 * @param {string} str The string to check.
 * @return {boolean} Whether {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = goog.string.isEmptyOrWhitespace;


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} Whether {@code str} is null, undefined, empty, or
 *     whitespace only.
 * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))
 *     instead.
 */
goog.string.isEmptyOrWhitespaceSafe = function(str) {
  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 *
 * TODO(user): Deprecate this when clients have been switched over to
 * goog.string.isEmptyOrWhitespaceSafe.
 *
 * @param {*} str The string to check.
 * @return {boolean} Whether {@code str} is null, undefined, empty, or
 *     whitespace only.
 */
goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {@code ch} is a space.
 */
goog.string.isSpace = function(ch) {
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {@code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
         ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(
      /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = (goog.TRUSTED_SITE && String.prototype.trim) ?
    function(str) {
      return str.trim();
    } :
    function(str) {
      // Since IE doesn't include non-breaking-space (0xa0) in their \s
      // character class (as required by section 7.2 of the ECMAScript spec),
      // we explicitly include it in the regexp to enforce consistent
      // cross-browser behavior.
      return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
    };


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function(str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

  var count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {

      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII-betical string
  // comparison to stablize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
 * lowercase letter "e".
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    str = str.replace(goog.string.AMP_RE_, '&amp;')
          .replace(goog.string.LT_RE_, '&lt;')
          .replace(goog.string.GT_RE_, '&gt;')
          .replace(goog.string.QUOT_RE_, '&quot;')
          .replace(goog.string.SINGLE_QUOTE_RE_, '&#39;')
          .replace(goog.string.NULL_RE_, '&#0;');
    if (goog.string.DETECT_DOUBLE_ESCAPING) {
      str = str.replace(goog.string.E_RE_, '&#101;');
    }
    return str;

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.ALL_RE_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.AMP_RE_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.LT_RE_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.GT_RE_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.QUOT_RE_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
    }
    if (str.indexOf('\x00') != -1) {
      str = str.replace(goog.string.NULL_RE_, '&#0;');
    }
    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
      str = str.replace(goog.string.E_RE_, '&#101;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.AMP_RE_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.LT_RE_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.GT_RE_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.QUOT_RE_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.SINGLE_QUOTE_RE_ = /'/g;


/**
 * Regular expression that matches null character, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.NULL_RE_ = /\x00/g;


/**
 * Regular expression that matches a lowercase letter "e", for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.E_RE_ = /e/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @const {!RegExp}
 * @private
 */
goog.string.ALL_RE_ = (goog.string.DETECT_DOUBLE_ESCAPING ?
    /[\x00&<>"'e]/ :
    /[\x00&<>"']/);


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one or we explicitly
    // requested non-DOM html unescaping.
    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&
        'document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes a HTML string using the provided document.
 *
 * @param {string} str The string to unescape.
 * @param {!Document} document A document to use in escaping the string.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  if (goog.string.contains(str, '&')) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @param {Document=} opt_document An optional document to use for creating
 *     elements. If this is not specified then the default window.document
 *     will be used.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  /** @type {!Object<string, string>} */
  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  var div;
  if (opt_document) {
    div = opt_document.createElement('div');
  } else {
    div = goog.global.document.createElement('div');
  }
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          var n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  // This doesn't use goog.string.preserveSpaces for backwards compatibility.
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Preserve spaces that would be otherwise collapsed in HTML by replacing them
 * with non-breaking space Unicode characters.
 * @param {string} str The string in which to preserve whitespace.
 * @return {string} A copy of {@code str} with preserved whitespace.
 */
goog.string.preserveSpaces = function(str) {
  return str.replace(/(^|[\n ]) /g, '$1' + goog.string.Unicode.NBSP);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function(str, chars,
    opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private {!Object<string, string>}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B', // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private {!Object<string, string>}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function(s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
          ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) { // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Determines whether a string contains a substring.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether {@code str} contains {@code subString}.
 */
goog.string.contains = function(str, subString) {
  return str.indexOf(subString) != -1;
};


/**
 * Determines whether a string contains a substring, ignoring case.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether {@code str} contains {@code subString}.
 */
goog.string.caseInsensitiveContains = function(str, subString) {
  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = (String.prototype.repeat) ?
    function(string, length) {
      // The native method is over 100 times faster than the alternative.
      return string.repeat(length);
    } :
    function(string, length) {
      return new Array(length + 1).join(string);
    };


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function(obj) {
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    // Normalize to 4 byte range, 0 ... 2^32.
    result = (31 * result + str.charCodeAt(i)) >>> 0;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Infinity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {
    return NaN;
  }
  return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function(str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function(str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ?
      goog.string.regExpEscape(opt_delimiters) : '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};


/**
 * Capitalizes a string, i.e. converts the first letter to uppercase
 * and all other letters to lowercase, e.g.:
 *
 * goog.string.capitalize('one')     => 'One'
 * goog.string.capitalize('ONE')     => 'One'
 * goog.string.capitalize('one two') => 'One two'
 *
 * Note that this function does not trim initial whitespace.
 *
 * @param {string} str String value to capitalize.
 * @return {string} String value with first letter in uppercase.
 */
goog.string.capitalize = function(str) {
  return String(str.charAt(0)).toUpperCase() +
      String(str.substr(1)).toLowerCase();
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (goog.isString(value)) {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ?
        parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array<string>} The string, split.
 */

goog.string.splitLimit = function(str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];

  // Only continue doing this while we haven't hit the limit and we have
  // parts left.
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }

  // If there are remaining parts, append them to the end.
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }

  return returnVal;
};


/**
 * Computes the Levenshtein edit distance between two strings.
 * @param {string} a
 * @param {string} b
 * @return {number} The edit distance between the two strings.
 */
goog.string.editDistance = function(a, b) {
  var v0 = [];
  var v1 = [];

  if (a == b) {
    return 0;
  }

  if (!a.length || !b.length) {
    return Math.max(a.length, b.length);
  }

  for (var i = 0; i < b.length + 1; i++) {
    v0[i] = i;
  }

  for (var i = 0; i < a.length; i++) {
    v1[0] = i + 1;

    for (var j = 0; j < b.length; j++) {
      var cost = a[i] != b[j];
      // Cost for the substring is the minimum of adding one character, removing
      // one character, or a swap.
      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
    }

    for (var j = 0; j < v0.length; j++) {
      v0[j] = v1[j];
    }
  }

  return v1[b.length];
};

// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  // Remove the messagePattern afterwards to avoid permanently modifying the
  // passed in array.
  messageArgs.shift();

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * The default error handler.
 * @param {!goog.asserts.AssertionError} e The exception to be handled.
 */
goog.asserts.DEFAULT_ERROR_HANDLER = function(e) { throw e; };


/**
 * The handler responsible for throwing or logging assertion errors.
 * @private {function(!goog.asserts.AssertionError)}
 */
goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  var e = new goog.asserts.AssertionError('' + message, args || []);
  goog.asserts.errorHandler_(e);
};


/**
 * Sets a custom error handler that can be used to customize the behavior of
 * assertion failures, for example by turning all assertion failures into log
 * messages.
 * @param {function(!goog.asserts.AssertionError)} errorHandler
 */
goog.asserts.setErrorHandler = function(errorHandler) {
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_ = errorHandler;
  }
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @template T
 * @param {T} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {T} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_(new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1)));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
        [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array<?>} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array<?>} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not an Element.
 */
goog.asserts.assertElement = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) ||
      value.nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_('Expected Element but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {T}
 * @template T
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.',
        [goog.asserts.getType_(type), goog.asserts.getType_(value)],
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */
goog.asserts.assertObjectPrototypeIsIntact = function() {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};


/**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 * @private
 */
goog.asserts.getType_ = function(value) {
  if (value instanceof Function) {
    return value.displayName || value.name || 'unknown type name';
  } else if (value instanceof Object) {
    return value.constructor.displayName || value.constructor.name ||
        Object.prototype.toString.call(value);
  } else {
    return value === null ? 'null' : typeof value;
  }
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., {@code Array#filter}) and remove the
 * unused pure JS implementation.
 */
goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * Same as goog.array.last.
 * @param {Array<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Returns the last element in an array without removing it.
 * Same as goog.array.peek.
 * @param {Array<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.last = goog.array.peek;


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {Array<T>|goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.indexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!Array<T>|!goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.lastIndexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (goog.isString(arr)) {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.forEach) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.filter) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array<VALUE>|goog.array.ArrayLike} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
 *     for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return something. The result will be
 *     inserted into a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array<RESULT>} a new array with the results from f.
 * @template THIS, VALUE, RESULT
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                  goog.array.ARRAY_PROTOTYPE_.map) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.reduce) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEach(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.reduceRight) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEachRight(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                   goog.array.ARRAY_PROTOTYPE_.some) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                    goog.array.ARRAY_PROTOTYPE_.every) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!(Array<T>|goog.array.ArrayLike)} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
goog.array.count = function(arr, f, opt_obj) {
  var count = 0;
  goog.array.forEach(arr, function(element, index, arr) {
    if (f.call(opt_obj, element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = 0; i < l; i++) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function(arr, f, opt_obj) {
  var i = goog.array.findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function(arr, obj) {
  if (!goog.array.contains(arr, obj)) {
    arr.push(obj);
  }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function(arr, obj, opt_obj2) {
  var i;
  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    goog.array.insertAt(arr, obj, i);
  }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {Array<T>|goog.array.ArrayLike} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  goog.asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  if (i >= 0) {
    goog.array.removeAt(arr, i);
    return true;
  }
  return false;
};


/**
 * Removes all values that satisfy the given condition.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The number of items removed
 * @template T,S
 */
goog.array.removeAllIf = function(arr, f, opt_obj) {
  var removedCount = 0;
  goog.array.forEachRight(arr, function(val, index) {
    if (f.call(opt_obj, val, index, arr)) {
      if (goog.array.removeAt(arr, index)) {
        removedCount++;
      }
    }
  });
  return removedCount;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array<?>} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Returns a new array that contains the contents of all the arrays passed.
 * @param {...!Array<T>} var_args
 * @return {!Array<T>}
 * @template T
 */
goog.array.join = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {Array<T>|goog.array.ArrayLike} object  The object to convert to an
 *     array.
 * @return {!Array<T>} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 * @template T
 */
goog.array.toArray = function(object) {
  var length = object.length;

  // If length is not a number the following it false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    var rv = new Array(length);
    for (var i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
};


/**
 * Does a shallow copy of an array.
 * @param {Array<T>|goog.array.ArrayLike} arr  Array or array-like object to
 *     clone.
 * @return {!Array<T>} Clone of the input array.
 * @template T
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array<VALUE>} arr1  The array to modify.
 * @param {...(Array<VALUE>|VALUE)} var_args The elements or arrays of elements
 *     to add to arr1.
 * @template VALUE
 */
goog.array.extend = function(arr1, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var arr2 = arguments[i];
    if (goog.isArrayLike(arr2)) {
      var len1 = arr1.length || 0;
      var len2 = arr2.length || 0;
      arr1.length = len1 + len2;
      for (var j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {Array<T>|goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array<T>} the removed elements.
 * @template T
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  goog.asserts.assert(arr.length != null);

  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function(arr, start, opt_end) {
  goog.asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {Array<T>|goog.array.ArrayLike} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
  var returnArray = opt_rv || arr;
  var defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(item) ? 'o' + goog.getUid(item) :
        (typeof item).charAt(0) + item;
  };
  var hashFn = opt_hashFn || defaultHashFn;

  var seen = {}, cursorInsert = 0, cursorRead = 0;
  while (cursorRead < arr.length) {
    var current = arr[cursorRead++];
    var key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {Array<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {TARGET} target The sought value.
 * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template TARGET, VALUE
 */
goog.array.binarySearch = function(arr, target, opt_compareFn) {
  return goog.array.binarySearch_(arr,
      opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
      target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {Array<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(this:THIS, VALUE, number, ?): number} evaluator
 *     Evaluator function that receives 3 arguments (the element, the index and
 *     the array). Should return a negative number, zero, or a positive number
 *     depending on whether the desired index is before, at, or after the
 *     element passed to it.
 * @param {THIS=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 * @template THIS, VALUE
 */
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
  return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
      undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {Array<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(TARGET, VALUE): number|
 *         function(this:THIS, VALUE, number, ?): number} compareFn Either an
 *     evaluator or a comparison function, as defined by binarySearch
 *     and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {TARGET=} opt_target If the function is a comparison function, then
 *     this is the target to binary search for.
 * @param {THIS=} opt_selfObj If the function is an evaluator, this is an
  *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template THIS, VALUE, TARGET
 * @private
 */
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
    opt_selfObj) {
  var left = 0;  // inclusive
  var right = arr.length;  // exclusive
  var found;
  while (left < right) {
    var middle = (left + right) >> 1;
    var compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      compareResult = compareFn(opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // ~left is a shorthand for -left - 1.
  return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  arr.sort(opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function(arr, opt_compareFn) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = {index: i, value: arr[i]};
  }
  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  };
  goog.array.sort(arr, stableCompareFn);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = arr[i].value;
  }
};


/**
 * Sort the specified array into ascending order based on item keys
 * returned by the specified key function.
 * If no opt_compareFn is specified, the keys are compared in ascending order
 * using <code>goog.array.defaultCompare</code>.
 *
 * Runtime: O(S(f(n)), where S is runtime of <code>goog.array.sort</code>
 * and f(n) is runtime of the key function.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {function(T): K} keyFn Function taking array element and returning
 *     a key used for sorting this element.
 * @param {?function(K, K): number=} opt_compareFn Optional comparison function
 *     by which the keys are to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T,K
 */
goog.array.sortByKey = function(arr, keyFn, opt_compareFn) {
  var keyCompareFn = opt_compareFn || goog.array.defaultCompare;
  goog.array.sort(arr, function(a, b) {
    return keyCompareFn(keyFn(a), keyFn(b));
  });
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
  goog.array.sortByKey(arr,
      function(obj) { return obj[key]; },
      opt_compareFn);
};


/**
 * Tells if the array is sorted.
 * @param {!Array<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  for (var i = 1; i < arr.length; i++) {
    var compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};


/**
 * 3-way array compare function.
 * @param {!Array<VALUE>|!goog.array.ArrayLike} arr1 The first array to
 *     compare.
 * @param {!Array<VALUE>|!goog.array.ArrayLike} arr2 The second array to
 *     compare.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is to be ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template VALUE
 */
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  var l = Math.min(arr1.length, arr2.length);
  for (var i = 0; i < l; i++) {
    var result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second,
 *     respectively.
 * @template VALUE
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for inverse order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second,
 *     respectively.
 * @template VALUE
 */
goog.array.inverseDefaultCompare = function(a, b) {
  return -goog.array.defaultCompare(a, b);
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array<VALUE>|goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to insert.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template VALUE
 */
goog.array.binaryInsert = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    goog.array.insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
};


/**
 * Removes a value from a sorted array.
 * @param {!Array<VALUE>|!goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to remove.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was removed.
 * @template VALUE
 */
goog.array.binaryRemove = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array<T>} array The array.
 * @param {function(this:S, T,number,Array<T>):?} sorter Function to call for
 *     every element.  This takes 3 arguments (the element, the index and the
 *     array) and must return a valid object key (a string, number, etc), or
 *     undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
goog.array.bucket = function(array, sorter, opt_obj) {
  var buckets = {};

  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    var key = sorter.call(opt_obj, value, i, array);
    if (goog.isDef(key)) {
      // Push the value to the right bucket, creating it if necessary.
      var bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
};


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {Array<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object<T>} The new object.
 * @template T,S
 */
goog.array.toObject = function(arr, keyFunc, opt_obj) {
  var ret = {};
  goog.array.forEach(arr, function(element, index) {
    ret[keyFunc.call(opt_obj, element, index, arr)] = element;
  });
  return ret;
};


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
goog.array.range = function(startOrEnd, opt_end, opt_step) {
  var array = [];
  var start = 0;
  var end = startOrEnd;
  var step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (var i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (var i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {VALUE} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array<VALUE>} An array with the repeated value.
 * @template VALUE
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array<?>} An array containing the flattened values.
 */
goog.array.flatten = function(var_args) {
  var CHUNK_SIZE = 8192;

  var result = [];
  for (var i = 0; i < arguments.length; i++) {
    var element = arguments[i];
    if (goog.isArray(element)) {
      for (var c = 0; c < element.length; c += CHUNK_SIZE) {
        var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);
        var recurseResult = goog.array.flatten.apply(null, chunk);
        for (var r = 0; r < recurseResult.length; r++) {
          result.push(recurseResult[r]);
        }
      }
    } else {
      result.push(element);
    }
  }
  return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array<T>} The array.
 * @template T
 */
goog.array.rotate = function(array, n) {
  goog.asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
};


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!(Array|Arguments|{length:number})} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     {@code arr.length - 1}.
 * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
 */
goog.array.moveItem = function(arr, fromIndex, toIndex) {
  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array<!Array<?>>} A new array of arrays created from
 *     provided arrays.
 */
goog.array.zip = function(var_args) {
  if (!arguments.length) {
    return [];
  }
  var result = [];
  for (var i = 0; true; i++) {
    var value = [];
    for (var j = 0; j < arguments.length; j++) {
      var arr = arguments[j];
      // If i is larger than the array length, this is the shortest array.
      if (i >= arr.length) {
        return result;
      }
      value.push(arr[i]);
    }
    result.push(value);
  }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array<?>} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function(arr, opt_randFn) {
  var randFn = opt_randFn || Math.random;

  for (var i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    var j = Math.floor(randFn() * (i + 1));

    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
};


/**
 * Returns a new array of elements from arr, based on the indexes of elements
 * provided by index_arr. For example, the result of index copying
 * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].
 *
 * @param {!Array<T>} arr The array to get a indexed copy from.
 * @param {!Array<number>} index_arr An array of indexes to get from arr.
 * @return {!Array<T>} A new array of elements from arr in index_arr order.
 * @template T
 */
goog.array.copyByIndex = function(arr, index_arr) {
  var result = [];
  goog.array.forEach(index_arr, function(index) {
    result.push(arr[index]);
  });
  return result;
};

// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities used by goog.labs.userAgent tools. These functions
 * should not be used outside of goog.labs.userAgent.*.
 *
 *
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('goog.labs.userAgent.util');

goog.require('goog.string');


/**
 * Gets the native userAgent string from navigator if it exists.
 * If navigator or navigator.userAgent string is missing, returns an empty
 * string.
 * @return {string}
 * @private
 */
goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
  var navigator = goog.labs.userAgent.util.getNavigator_();
  if (navigator) {
    var userAgent = navigator.userAgent;
    if (userAgent) {
      return userAgent;
    }
  }
  return '';
};


/**
 * Getter for the native navigator.
 * This is a separate function so it can be stubbed out in testing.
 * @return {Navigator}
 * @private
 */
goog.labs.userAgent.util.getNavigator_ = function() {
  return goog.global.navigator;
};


/**
 * A possible override for applications which wish to not check
 * navigator.userAgent but use a specified value for detection instead.
 * @private {string}
 */
goog.labs.userAgent.util.userAgent_ =
    goog.labs.userAgent.util.getNativeUserAgentString_();


/**
 * Applications may override browser detection on the built in
 * navigator.userAgent object by setting this string. Set to null to use the
 * browser object instead.
 * @param {?string=} opt_userAgent The User-Agent override.
 */
goog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {
  goog.labs.userAgent.util.userAgent_ = opt_userAgent ||
      goog.labs.userAgent.util.getNativeUserAgentString_();
};


/**
 * @return {string} The user agent string.
 */
goog.labs.userAgent.util.getUserAgent = function() {
  return goog.labs.userAgent.util.userAgent_;
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string, ignoring
 *     case.
 */
goog.labs.userAgent.util.matchUserAgent = function(str) {
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.contains(userAgent, str);
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string.
 */
goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.caseInsensitiveContains(userAgent, str);
};


/**
 * Parses the user agent into tuples for each section.
 * @param {string} userAgent
 * @return {!Array<!Array<string>>} Tuples of key, version, and the contents
 *     of the parenthetical.
 */
goog.labs.userAgent.util.extractVersionTuples = function(userAgent) {
  // Matches each section of a user agent string.
  // Example UA:
  // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)
  // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405
  // This has three version tuples: Mozilla, AppleWebKit, and Mobile.

  var versionRegExp = new RegExp(
      // Key. Note that a key may have a space.
      // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')
      '(\\w[\\w ]+)' +

      '/' +                // slash
      '([^\\s]+)' +        // version (i.e. '5.0b')
      '\\s*' +             // whitespace
      '(?:\\((.*?)\\))?',  // parenthetical info. parentheses not matched.
      'g');

  var data = [];
  var match;

  // Iterate and collect the version tuples.  Each iteration will be the
  // next regex match.
  while (match = versionRegExp.exec(userAgent)) {
    data.push([
      match[1],  // key
      match[2],  // value
      // || undefined as this is not undefined in IE7 and IE8
      match[3] || undefined  // info
    ]);
  }

  return data;
};


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 * @author arv@google.com (Erik Arvidsson)
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object<K,V>):?} f The function to call
 *     for every element. This function takes 3 arguments (the value, the
 *     key and the object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @template T,K,V
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call
 *     for every element. This
 *     function takes 3 arguments (the value, the key and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object<K,V>):R} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the value, the key and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object<K,V>} obj The object to check.
 * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the value, the key and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
goog.object.some = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the value, the key and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return false;
    }
  }
  return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function(obj) {
  for (var key in obj) {
    return key;
  }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
goog.object.getAnyValue = function(obj) {
  for (var key in obj) {
    return obj[key];
  }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object<K,V>} obj The object from which to get the values.
 * @return {!Array<V>} The values in the object/map/hash.
 * @template K,V
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array<number|string>)} var_args A number of keys
 *     (as strings, or numbers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function(obj, var_args) {
  var isArrayLike = goog.isArrayLike(var_args);
  var keys = isArrayLike ? var_args : arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    obj = obj[keys[i]];
    if (!goog.isDef(obj)) {
      break;
    }
  }

  return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function(obj, key) {
  return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object<K,V>):boolean} f The
 *      function to call for every element. Takes 3 arguments (the value,
 *     the key and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findKey = function(obj, f, opt_this) {
  for (var key in obj) {
    if (f.call(opt_this, obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object<K,V>):boolean} f The function
 *     to call for every element. Takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findValue = function(obj, f, opt_this) {
  var key = goog.object.findKey(obj, f, opt_this);
  return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @template K,V
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setIfUndefined = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Sets a key and value to an object if the key is not set. The value will be
 * the return value of the given function. If the key already exists, the
 * object will not be changed and the function will not be called (the function
 * will be lazily evaluated -- only called if necessary).
 *
 * This function is particularly useful for use with a map used a as a cache.
 *
 * @param {!Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {function():V} f The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setWithReturnValueIfNotSet = function(obj, key, f) {
  if (key in obj) {
    return obj[key];
  }

  var val = f();
  obj[key] = val;
  return val;
};


/**
 * Compares two objects for equality using === on the values.
 *
 * @param {!Object<K,V>} a
 * @param {!Object<K,V>} b
 * @return {boolean}
 * @template K,V
 */
goog.object.equals = function(a, b) {
  for (var k in a) {
    if (!(k in b) || a[k] !== b[k]) {
      return false;
    }
  }
  for (var k in b) {
    if (!(k in a)) {
      return false;
    }
  }
  return true;
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object<K,V>} obj Object to clone.
 * @return {!Object<K,V>} Clone of the input object.
 * @template K,V
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (goog.isFunction(obj.clone)) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.object.unsafeClone(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function(obj) {
  var transposed = {};
  for (var key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {b: 2, c: 3});
 * o; // {a: 0, b: 2, c: 3}
 *
 * @param {Object} target The object to modify. Existing properties will be
 *     overwritten if they are also present in one of the objects in
 *     {@code var_args}.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }

  var rv = {};
  for (var i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
};


/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 *
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 *
 * @param {!Object<K,V>} obj An object.
 * @return {!Object<K,V>} An immutable view of that object, or the
 *     original object if this browser does not support immutables.
 * @template K,V
 */
goog.object.createImmutableView = function(obj) {
  var result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
};


/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
goog.object.isImmutableView = function(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
};

// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Closure user agent detection (Browser).
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on rendering engine, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,
 * goog.labs.userAgent.device respectively.)
 *
 * @author martone@google.com (Andy Martone)
 */

goog.provide('goog.labs.userAgent.browser');

goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.object');
goog.require('goog.string');


// TODO(nnaze): Refactor to remove excessive exclusion logic in matching
// functions.


/**
 * @return {boolean} Whether the user's browser is Opera.
 * @private
 */
goog.labs.userAgent.browser.matchOpera_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Opera') ||
      goog.labs.userAgent.util.matchUserAgent('OPR');
};


/**
 * @return {boolean} Whether the user's browser is IE.
 * @private
 */
goog.labs.userAgent.browser.matchIE_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the user's browser is Edge.
 * @private
 */
goog.labs.userAgent.browser.matchEdge_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Edge');
};


/**
 * @return {boolean} Whether the user's browser is Firefox.
 * @private
 */
goog.labs.userAgent.browser.matchFirefox_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Firefox');
};


/**
 * @return {boolean} Whether the user's browser is Safari.
 * @private
 */
goog.labs.userAgent.browser.matchSafari_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Safari') &&
      !(goog.labs.userAgent.browser.matchChrome_() ||
        goog.labs.userAgent.browser.matchCoast_() ||
        goog.labs.userAgent.browser.matchOpera_() ||
        goog.labs.userAgent.browser.matchEdge_() ||
        goog.labs.userAgent.browser.isSilk() ||
        goog.labs.userAgent.util.matchUserAgent('Android'));
};


/**
 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
 *     iOS browser).
 * @private
 */
goog.labs.userAgent.browser.matchCoast_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Coast');
};


/**
 * @return {boolean} Whether the user's browser is iOS Webview.
 * @private
 */
goog.labs.userAgent.browser.matchIosWebview_ = function() {
  // iOS Webview does not show up as Chrome or Safari. Also check for Opera's
  // WebKit-based iOS browser, Coast.
  return (goog.labs.userAgent.util.matchUserAgent('iPad') ||
          goog.labs.userAgent.util.matchUserAgent('iPhone')) &&
      !goog.labs.userAgent.browser.matchSafari_() &&
      !goog.labs.userAgent.browser.matchChrome_() &&
      !goog.labs.userAgent.browser.matchCoast_() &&
      goog.labs.userAgent.util.matchUserAgent('AppleWebKit');
};


/**
 * @return {boolean} Whether the user's browser is Chrome.
 * @private
 */
goog.labs.userAgent.browser.matchChrome_ = function() {
  return (goog.labs.userAgent.util.matchUserAgent('Chrome') ||
      goog.labs.userAgent.util.matchUserAgent('CriOS')) &&
      !goog.labs.userAgent.browser.matchOpera_() &&
      !goog.labs.userAgent.browser.matchEdge_();
};


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 * @private
 */
goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
  // Android can appear in the user agent string for Chrome on Android.
  // This is not the Android standalone browser if it does.
  return goog.labs.userAgent.util.matchUserAgent('Android') &&
      !(goog.labs.userAgent.browser.isChrome() ||
        goog.labs.userAgent.browser.isFirefox() ||
        goog.labs.userAgent.browser.isOpera() ||
        goog.labs.userAgent.browser.isSilk());
};


/**
 * @return {boolean} Whether the user's browser is Opera.
 */
goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;


/**
 * @return {boolean} Whether the user's browser is IE.
 */
goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;


/**
 * @return {boolean} Whether the user's browser is Edge.
 */
goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdge_;


/**
 * @return {boolean} Whether the user's browser is Firefox.
 */
goog.labs.userAgent.browser.isFirefox =
    goog.labs.userAgent.browser.matchFirefox_;


/**
 * @return {boolean} Whether the user's browser is Safari.
 */
goog.labs.userAgent.browser.isSafari =
    goog.labs.userAgent.browser.matchSafari_;


/**
 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
 *     iOS browser).
 */
goog.labs.userAgent.browser.isCoast =
    goog.labs.userAgent.browser.matchCoast_;


/**
 * @return {boolean} Whether the user's browser is iOS Webview.
 */
goog.labs.userAgent.browser.isIosWebview =
    goog.labs.userAgent.browser.matchIosWebview_;


/**
 * @return {boolean} Whether the user's browser is Chrome.
 */
goog.labs.userAgent.browser.isChrome =
    goog.labs.userAgent.browser.matchChrome_;


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 */
goog.labs.userAgent.browser.isAndroidBrowser =
    goog.labs.userAgent.browser.matchAndroidBrowser_;


/**
 * For more information, see:
 * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html
 * @return {boolean} Whether the user's browser is Silk.
 */
goog.labs.userAgent.browser.isSilk = function() {
  return goog.labs.userAgent.util.matchUserAgent('Silk');
};


/**
 * @return {string} The browser version or empty string if version cannot be
 *     determined. Note that for Internet Explorer, this returns the version of
 *     the browser, not the version of the rendering engine. (IE 8 in
 *     compatibility mode will return 8.0 rather than 7.0. To determine the
 *     rendering engine version, look at document.documentMode instead. See
 *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more
 *     details.)
 */
goog.labs.userAgent.browser.getVersion = function() {
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  // Special case IE since IE's version is inside the parenthesis and
  // without the '/'.
  if (goog.labs.userAgent.browser.isIE()) {
    return goog.labs.userAgent.browser.getIEVersion_(userAgentString);
  }

  var versionTuples = goog.labs.userAgent.util.extractVersionTuples(
      userAgentString);

  // Construct a map for easy lookup.
  var versionMap = {};
  goog.array.forEach(versionTuples, function(tuple) {
    // Note that the tuple is of length three, but we only care about the
    // first two.
    var key = tuple[0];
    var value = tuple[1];
    versionMap[key] = value;
  });

  var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);

  // Gives the value with the first key it finds, otherwise empty string.
  function lookUpValueWithKeys(keys) {
    var key = goog.array.find(keys, versionMapHasKey);
    return versionMap[key] || '';
  }

  // Check Opera before Chrome since Opera 15+ has "Chrome" in the string.
  // See
  // http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond
  if (goog.labs.userAgent.browser.isOpera()) {
    // Opera 10 has Version/10.0 but Opera/9.8, so look for "Version" first.
    // Opera uses 'OPR' for more recent UAs.
    return lookUpValueWithKeys(['Version', 'Opera', 'OPR']);
  }

  // Check Edge before Chrome since it has Chrome in the string.
  if (goog.labs.userAgent.browser.isEdge()) {
    return lookUpValueWithKeys(['Edge']);
  }

  if (goog.labs.userAgent.browser.isChrome()) {
    return lookUpValueWithKeys(['Chrome', 'CriOS']);
  }

  // Usually products browser versions are in the third tuple after "Mozilla"
  // and the engine.
  var tuple = versionTuples[2];
  return tuple && tuple[1] || '';
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the browser version is higher or the same as the
 *     given version.
 */
goog.labs.userAgent.browser.isVersionOrHigher = function(version) {
  return goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(),
                                     version) >= 0;
};


/**
 * Determines IE version. More information:
 * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString
 * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
 * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
 * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
 *
 * @param {string} userAgent the User-Agent.
 * @return {string}
 * @private
 */
goog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {
  // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade
  // bug. Example UA:
  // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)
  // like Gecko.
  // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.
  var rv = /rv: *([\d\.]*)/.exec(userAgent);
  if (rv && rv[1]) {
    return rv[1];
  }

  var version = '';
  var msie = /MSIE +([\d\.]+)/.exec(userAgent);
  if (msie && msie[1]) {
    // IE in compatibility mode usually identifies itself as MSIE 7.0; in this
    // case, use the Trident version to determine the version of IE. For more
    // details, see the links above.
    var tridentVersion = /Trident\/(\d.\d)/.exec(userAgent);
    if (msie[1] == '7.0') {
      if (tridentVersion && tridentVersion[1]) {
        switch (tridentVersion[1]) {
          case '4.0':
            version = '8.0';
            break;
          case '5.0':
            version = '9.0';
            break;
          case '6.0':
            version = '10.0';
            break;
          case '7.0':
            version = '11.0';
            break;
        }
      } else {
        version = '7.0';
      }
    } else {
      version = msie[1];
    }
  }
  return version;
};

// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Closure user agent platform detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on browser brand, rendering engine, or device see the
 * other sub-namespaces in goog.labs.userAgent (browser, engine, and device
 * respectively).
 *
 */

goog.provide('goog.labs.userAgent.platform');

goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the platform is Android.
 */
goog.labs.userAgent.platform.isAndroid = function() {
  return goog.labs.userAgent.util.matchUserAgent('Android');
};


/**
 * @return {boolean} Whether the platform is iPod.
 */
goog.labs.userAgent.platform.isIpod = function() {
  return goog.labs.userAgent.util.matchUserAgent('iPod');
};


/**
 * @return {boolean} Whether the platform is iPhone.
 */
goog.labs.userAgent.platform.isIphone = function() {
  return goog.labs.userAgent.util.matchUserAgent('iPhone') &&
      !goog.labs.userAgent.util.matchUserAgent('iPod') &&
      !goog.labs.userAgent.util.matchUserAgent('iPad');
};


/**
 * @return {boolean} Whether the platform is iPad.
 */
goog.labs.userAgent.platform.isIpad = function() {
  return goog.labs.userAgent.util.matchUserAgent('iPad');
};


/**
 * @return {boolean} Whether the platform is iOS.
 */
goog.labs.userAgent.platform.isIos = function() {
  return goog.labs.userAgent.platform.isIphone() ||
      goog.labs.userAgent.platform.isIpad() ||
      goog.labs.userAgent.platform.isIpod();
};


/**
 * @return {boolean} Whether the platform is Mac.
 */
goog.labs.userAgent.platform.isMacintosh = function() {
  return goog.labs.userAgent.util.matchUserAgent('Macintosh');
};


/**
 * Note: ChromeOS is not considered to be Linux as it does not report itself
 * as Linux in the user agent string.
 * @return {boolean} Whether the platform is Linux.
 */
goog.labs.userAgent.platform.isLinux = function() {
  return goog.labs.userAgent.util.matchUserAgent('Linux');
};


/**
 * @return {boolean} Whether the platform is Windows.
 */
goog.labs.userAgent.platform.isWindows = function() {
  return goog.labs.userAgent.util.matchUserAgent('Windows');
};


/**
 * @return {boolean} Whether the platform is ChromeOS.
 */
goog.labs.userAgent.platform.isChromeOS = function() {
  return goog.labs.userAgent.util.matchUserAgent('CrOS');
};


/**
 * The version of the platform. We only determine the version for Windows,
 * Mac, and Chrome OS. It doesn't make much sense on Linux. For Windows, we only
 * look at the NT version. Non-NT-based versions (e.g. 95, 98, etc.) are given
 * version 0.0.
 *
 * @return {string} The platform version or empty string if version cannot be
 *     determined.
 */
goog.labs.userAgent.platform.getVersion = function() {
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  var version = '', re;
  if (goog.labs.userAgent.platform.isWindows()) {
    re = /Windows (?:NT|Phone) ([0-9.]+)/;
    var match = re.exec(userAgentString);
    if (match) {
      version = match[1];
    } else {
      version = '0.0';
    }
  } else if (goog.labs.userAgent.platform.isIos()) {
    re = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/;
    var match = re.exec(userAgentString);
    // Report the version as x.y.z and not x_y_z
    version = match && match[1].replace(/_/g, '.');
  } else if (goog.labs.userAgent.platform.isMacintosh()) {
    re = /Mac OS X ([0-9_.]+)/;
    var match = re.exec(userAgentString);
    // Note: some old versions of Camino do not report an OSX version.
    // Default to 10.
    version = match ? match[1].replace(/_/g, '.') : '10';
  } else if (goog.labs.userAgent.platform.isAndroid()) {
    re = /Android\s+([^\);]+)(\)|;)/;
    var match = re.exec(userAgentString);
    version = match && match[1];
  } else if (goog.labs.userAgent.platform.isChromeOS()) {
    re = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/;
    var match = re.exec(userAgentString);
    version = match && match[1];
  }
  return version || '';
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the browser version is higher or the same as the
 *     given version.
 */
goog.labs.userAgent.platform.isVersionOrHigher = function(version) {
  return goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),
                                     version) >= 0;
};

// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Closure user agent detection.
 * @see http://en.wikipedia.org/wiki/User_agent
 * For more information on browser brand, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent (browser, platform, and device).
 *
 */

goog.provide('goog.labs.userAgent.engine');

goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the rendering engine is Presto.
 */
goog.labs.userAgent.engine.isPresto = function() {
  return goog.labs.userAgent.util.matchUserAgent('Presto');
};


/**
 * @return {boolean} Whether the rendering engine is Trident.
 */
goog.labs.userAgent.engine.isTrident = function() {
  // IE only started including the Trident token in IE8.
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the rendering engine is Edge.
 */
goog.labs.userAgent.engine.isEdge = function() {
  return goog.labs.userAgent.util.matchUserAgent('Edge');
};


/**
 * @return {boolean} Whether the rendering engine is WebKit.
 */
goog.labs.userAgent.engine.isWebKit = function() {
  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit') &&
      !goog.labs.userAgent.engine.isEdge();
};


/**
 * @return {boolean} Whether the rendering engine is Gecko.
 */
goog.labs.userAgent.engine.isGecko = function() {
  return goog.labs.userAgent.util.matchUserAgent('Gecko') &&
      !goog.labs.userAgent.engine.isWebKit() &&
      !goog.labs.userAgent.engine.isTrident() &&
      !goog.labs.userAgent.engine.isEdge();
};


/**
 * @return {string} The rendering engine's version or empty string if version
 *     can't be determined.
 */
goog.labs.userAgent.engine.getVersion = function() {
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  if (userAgentString) {
    var tuples = goog.labs.userAgent.util.extractVersionTuples(
        userAgentString);

    var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);
    if (engineTuple) {
      // In Gecko, the version string is either in the browser info or the
      // Firefox version.  See Gecko user agent string reference:
      // http://goo.gl/mULqa
      if (engineTuple[0] == 'Gecko') {
        return goog.labs.userAgent.engine.getVersionForKey_(
            tuples, 'Firefox');
      }

      return engineTuple[1];
    }

    // MSIE has only one version identifier, and the Trident version is
    // specified in the parenthetical. IE Edge is covered in the engine tuple
    // detection.
    var browserTuple = tuples[0];
    var info;
    if (browserTuple && (info = browserTuple[2])) {
      var match = /Trident\/([^\s;]+)/.exec(info);
      if (match) {
        return match[1];
      }
    }
  }
  return '';
};


/**
 * @param {!Array<!Array<string>>} tuples Extracted version tuples.
 * @return {!Array<string>|undefined} The engine tuple or undefined if not
 *     found.
 * @private
 */
goog.labs.userAgent.engine.getEngineTuple_ = function(tuples) {
  if (!goog.labs.userAgent.engine.isEdge()) {
    return tuples[1];
  }
  for (var i = 0; i < tuples.length; i++) {
    var tuple = tuples[i];
    if (tuple[0] == 'Edge') {
      return tuple;
    }
  }
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the rendering engine version is higher or the same
 *     as the given version.
 */
goog.labs.userAgent.engine.isVersionOrHigher = function(version) {
  return goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),
                                     version) >= 0;
};


/**
 * @param {!Array<!Array<string>>} tuples Version tuples.
 * @param {string} key The key to look for.
 * @return {string} The version string of the given key, if present.
 *     Otherwise, the empty string.
 * @private
 */
goog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {
  // TODO(nnaze): Move to util if useful elsewhere.

  var pair = goog.array.find(tuples, function(pair) {
    return key == pair[0];
  });

  return pair && pair[1] || '';
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @author arv@google.com (Erik Arvidsson)
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.engine');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is EDGE.
 */
goog.define('goog.userAgent.ASSUME_EDGE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_EDGE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 *
 * @return {string} The userAgent string.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.labs.userAgent.util.getUserAgent();
};


/**
 * TODO(nnaze): Change type to "Navigator" and update compilation targets.
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'] || null;
};


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA :
    goog.labs.userAgent.browser.isOpera();


/**
 * Whether the user agent is Internet Explorer.
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE :
    goog.labs.userAgent.browser.isIE();


/**
 * Whether the user agent is Microsoft Edge.
 * @type {boolean}
 */
goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_EDGE :
    goog.labs.userAgent.engine.isEdge();


/**
 * Whether the user agent is MS Internet Explorer or MS Edge.
 * @type {boolean}
 */
goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Firefox, and others.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.labs.userAgent.engine.isGecko();


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.labs.userAgent.engine.isWebKit();


/**
 * Whether the user agent is running on a mobile device.
 *
 * This is a separate function so that the logic can be tested.
 *
 * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().
 *
 * @return {boolean} Whether the user agent is running on a mobile device.
 * @private
 */
goog.userAgent.isMobile_ = function() {
  return goog.userAgent.WEBKIT &&
         goog.labs.userAgent.util.matchUserAgent('Mobile');
};


/**
 * Whether the user agent is running on a mobile device.
 *
 * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent
 *   is promoted as the gecko/webkit logic is likely inaccurate.
 *
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.isMobile_();


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11 ||
    goog.userAgent.ASSUME_ANDROID ||
    goog.userAgent.ASSUME_IPHONE ||
    goog.userAgent.ASSUME_IPAD;


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh();


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS :
    goog.labs.userAgent.platform.isWindows();


/**
 * Whether the user agent is Linux per the legacy behavior of
 * goog.userAgent.LINUX, which considered ChromeOS to also be
 * Linux.
 * @return {boolean}
 * @private
 */
goog.userAgent.isLegacyLinux_ = function() {
  return goog.labs.userAgent.platform.isLinux() ||
      goog.labs.userAgent.platform.isChromeOS();
};


/**
 * Whether the user agent is running on a Linux operating system.
 *
 * Note that goog.userAgent.LINUX considers ChromeOS to be Linux,
 * while goog.labs.userAgent.platform considers ChromeOS and
 * Linux to be different OSes.
 *
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX :
    goog.userAgent.isLegacyLinux_();


/**
 * @return {boolean} Whether the user agent is an X11 windowing system.
 * @private
 */
goog.userAgent.isX11_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return !!navigator &&
      goog.string.contains(navigator['appVersion'] || '', 'X11');
};


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 :
    goog.userAgent.isX11_();


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID :
    goog.labs.userAgent.platform.isAndroid();


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE :
    goog.labs.userAgent.platform.isIphone();


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD :
    goog.labs.userAgent.platform.isIpad();


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * Assumes user agent is opera.
 * @private
 */
goog.userAgent.operaVersion_ = function() {
  var version = goog.global.opera.version;
  try {
    return version();
  } catch (e) {
    return version;
  }
};


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  if (goog.userAgent.OPERA && goog.global['opera']) {
    return goog.userAgent.operaVersion_();
  }

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '';
  var arr = goog.userAgent.getVersionRegexResult_();
  if (arr) {
    version = arr ? arr[1] : '';
  }

  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }

  return version;
};


/**
 * @return {Array|undefined} The version regex matches from parsing the user
 *     agent string. These regex statements must be executed inline so they can
 *     be compiled out by the closure compiler with the rest of the useragent
 *     detection logic when ASSUME_* is specified.
 * @private
 */
goog.userAgent.getVersionRegexResult_ = function() {
  var userAgent = goog.userAgent.getUserAgentString();
  if (goog.userAgent.GECKO) {
    return /rv\:([^\);]+)(\)|;)/.exec(userAgent);
  }
  if (goog.userAgent.EDGE) {
    return /Edge\/([\d\.]+)/.exec(userAgent);
  }
  if (goog.userAgent.IE) {
    return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(userAgent);
  }
  if (goog.userAgent.WEBKIT) {
    // WebKit/125.4
    return /WebKit\/(\S+)/.exec(userAgent);
  }
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(user): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.userAgent.isVersionOrHigherCache_[version] ||
      (goog.userAgent.isVersionOrHigherCache_[version] =
          goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
  return goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
  var doc = goog.global['document'];
  var mode = goog.userAgent.getDocumentMode_();
  if (!doc || !goog.userAgent.IE) {
    return undefined;
  }
  return mode || (doc['compatMode'] == 'CSS1Compat' ?
      parseInt(goog.userAgent.VERSION, 10) : 5);
})();

// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Detects the specific browser and not just the rendering engine.
 *
 */

goog.provide('goog.userAgent.product');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether the code is running on the Firefox web browser.
 */
goog.define('goog.userAgent.product.ASSUME_FIREFOX', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     iPhone.
 */
goog.define('goog.userAgent.product.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     iPad.
 */
goog.define('goog.userAgent.product.ASSUME_IPAD', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     AOSP browser or WebView inside a pre KitKat Android phone or tablet.
 */
goog.define('goog.userAgent.product.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the code is running on the Chrome web browser on
 * any platform or AOSP browser or WebView in a KitKat+ Android phone or tablet.
 */
goog.define('goog.userAgent.product.ASSUME_CHROME', false);


/**
 * @define {boolean} Whether the code is running on the Safari web browser.
 */
goog.define('goog.userAgent.product.ASSUME_SAFARI', false);


/**
 * Whether we know the product type at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.product.PRODUCT_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_OPERA ||
    goog.userAgent.product.ASSUME_FIREFOX ||
    goog.userAgent.product.ASSUME_IPHONE ||
    goog.userAgent.product.ASSUME_IPAD ||
    goog.userAgent.product.ASSUME_ANDROID ||
    goog.userAgent.product.ASSUME_CHROME ||
    goog.userAgent.product.ASSUME_SAFARI;


/**
 * Whether the code is running on the Opera web browser.
 * @type {boolean}
 */
goog.userAgent.product.OPERA = goog.userAgent.OPERA;


/**
 * Whether the code is running on an IE web browser.
 * @type {boolean}
 */
goog.userAgent.product.IE = goog.userAgent.IE;


/**
 * Whether the code is running on the Firefox web browser.
 * @type {boolean}
 */
goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_FIREFOX :
    goog.labs.userAgent.browser.isFirefox();


/**
 * Whether the user agent is an iPhone or iPod (as in iPod touch).
 * @return {boolean}
 * @private
 */
goog.userAgent.product.isIphoneOrIpod_ = function() {
  return goog.labs.userAgent.platform.isIphone() ||
      goog.labs.userAgent.platform.isIpod();
};


/**
 * Whether the code is running on an iPhone or iPod touch.
 *
 * iPod touch is considered an iPhone for legacy reasons.
 * @type {boolean}
 */
goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_IPHONE :
    goog.userAgent.product.isIphoneOrIpod_();


/**
 * Whether the code is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_IPAD :
    goog.labs.userAgent.platform.isIpad();


/**
 * Whether the code is running on AOSP browser or WebView inside
 * a pre KitKat Android phone or tablet.
 * @type {boolean}
 */
goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_ANDROID :
    goog.labs.userAgent.browser.isAndroidBrowser();


/**
 * Whether the code is running on the Chrome web browser on any platform
 * or AOSP browser or WebView in a KitKat+ Android phone or tablet.
 * @type {boolean}
 */
goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_CHROME :
    goog.labs.userAgent.browser.isChrome();


/**
 * @return {boolean} Whether the browser is Safari on desktop.
 * @private
 */
goog.userAgent.product.isSafariDesktop_ = function() {
  return goog.labs.userAgent.browser.isSafari() &&
      !goog.labs.userAgent.platform.isIos();
};


/**
 * Whether the code is running on the desktop Safari web browser.
 * Note: the legacy behavior here is only true for Safari not running
 * on iOS.
 * @type {boolean}
 */
goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_SAFARI :
    goog.userAgent.product.isSafariDesktop_();

// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.BitMatrixLike');

goog.scope(function() {
  /**
   * Interface for readable bitmatrix.
   * @interface
   */
  w69b.img.BitMatrixLike = function() {
  };

  /**
   * @return {number} The width of the matrix.
   */
  w69b.img.BitMatrixLike.prototype.getWidth = function() {
  };

  /**
   * @return {number} The height of the matrix.
   */
  w69b.img.BitMatrixLike.prototype.getHeight = function() {
  };

  /**
   * @param {number} x x pos.
   * @param {number} y y pos.
   * @return {boolean} bit at given position.
   */
  w69b.img.BitMatrixLike.prototype.get = function(x, y) {
  };
});

// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.RGBABitMatrix');
goog.require('w69b.img.BitMatrixLike');

goog.scope(function() {
  /**
   * Wraps rgba image data in an read-only BitMatix-like interface.
   * @param {number} width in pixels.
   * @param {number} height in pixels.
   * @param {(Uint8Array|Uint8ClampedArray)} data image data with
   * values 255 = white, 0 = black.
   * array.
   * @constructor
   * @implements {w69b.img.BitMatrixLike}
   */
  w69b.img.RGBABitMatrix = function(width, height, data) {
    this.data = data;
    this.width = width;
    this.height = height;
  };
  var pro = w69b.img.RGBABitMatrix.prototype;

  /**
   * @return {number} The width of the matrix.
   */
  pro.getWidth = function() {
    return this.width;
  };

  /**
   * @return {number} The height of the matrix.
   */
  pro.getHeight = function() {
    return this.height;
  };


  /**
   * @param {number} x x pos.
   * @param {number} y y pos.
   * @return {boolean} bit at given position.
   */
  pro.get = function(x, y) {
    var pos = 4 * (y * this.width + x);
    if (this.data[pos] > 0)
      return false;
    else
      return true;
  };


});

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.FormatError');
goog.provide('w69b.qr.InvalidCharsetError');
goog.provide('w69b.qr.NotFoundError');
goog.provide('w69b.qr.ReaderError');
goog.require('goog.debug.Error');

goog.scope(function() {
  /**
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {goog.debug.Error}
   */
  w69b.qr.ReaderError = function(opt_msg) {
    goog.base(this, opt_msg);
  };
  goog.inherits(w69b.qr.ReaderError, goog.debug.Error);

  /**
   * Thrown if decoding fails.
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {w69b.qr.ReaderError}
   */
  w69b.qr.FormatError = function(opt_msg) {
    goog.base(this, opt_msg);
  };
  goog.inherits(w69b.qr.FormatError, w69b.qr.ReaderError);

  /**
   * Thrown if detection fails.
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {w69b.qr.ReaderError}
   */
  w69b.qr.NotFoundError = function(opt_msg) {
    goog.base(this, opt_msg);
  };
  goog.inherits(w69b.qr.NotFoundError, w69b.qr.ReaderError);


  /**
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {goog.debug.Error}
   */
  w69b.qr.InvalidCharsetError = function(opt_msg) {
    goog.base(this, opt_msg || 'InvalidCharset');
  };
  goog.inherits(w69b.qr.InvalidCharsetError, goog.debug.Error);
});

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.QRImage');

goog.scope(function() {

  /** @typedef {(Uint8ClampedArray|Uint8Array)} */
  w69b.qr.ImageData;
  /**
   * Image data container with width/height.
   * @param {number} width image width in pixels.
   * @param {number} height image height in pixels.
   * @param {w69b.qr.ImageData} data data array.
   * @constructor
   */
  w69b.qr.QRImage = function(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data;
  };
  var QRImage = w69b.qr.QRImage;
  var pro = QRImage.prototype;

  /**
   * Get value at given position.
   * @param {number} x x pos (col).
   * @param {number} y y pos (row).
   * @return {number} value.
   */
  pro.get = function(x, y) {
    return this.data[y * this.width + x];
  };

  /**
   * @return {number} width.
   */
  pro.getWidth = function() {
    return this.width;
  };

  /**
   * @return {number} height.
   */
  pro.getHeight = function() {
    return this.height;
  };

  /**
   * @return {w69b.qr.ImageData} raw data.
   */
  pro.getMatrix = function() {
    return this.data;
  };

  /**
   * @param {number} y index.
   * @param {Uint8Array} opt_row pre-allocated.
   * @return {Uint8Array} row.
   */
  pro.getRow = function(y, opt_row) {
    var row;
    if (opt_row == null || opt_row.length < this.width)
      row = new Uint8Array(this.width);
    else
      row = opt_row;
    var offset = y * this.width;
    for (var x = 0; x < this.width; ++x)
      row[x] = this.data[offset + x];
    return row;
  };


  /**
   * Get index in data for given position.
   * @param {number} x x pos (col).
   * @param {number} y y pos (row).
   * @return {number} index in data.
   */
  pro.getIndex = function(x, y) {
    return this.width * y + x;
  };

  /**
   * Set value at given position.
   * @param {number} x x pos (col).
   * @param {number} y y pos (row).
   * @param {number} value value to set.
   */
  pro.setValue = function(x, y, value) {
    this.data[y * this.width + x] = value;
  };

  /**
   * Construct Image with new empty buffer.
   * @param {number} width image width.
   * @param {number} height image height.
   * @return {w69b.qr.QRImage} image with given size and a new, empty buffer.
   */
  QRImage.newEmpty = function(width, height) {
    return new QRImage(width, height,
      new Uint8Array(new ArrayBuffer(width * height)));
  };
});


// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.WorkerMessageType');

/**
 * Constants for worker message types.
 * @enum {string}
 */
w69b.qr.WorkerMessageType = {
  DECODED: 'success',
  NOTFOUND: 'notfound',
  PATTERN: 'pattern'
};

goog.exportSymbol('w69b.qr.WorkerMessageType', w69b.qr.WorkerMessageType);
goog.exportSymbol('w69b.qr.WorkerMessageType.DECODED',
  w69b.qr.WorkerMessageType.DECODED);
goog.exportSymbol('w69b.qr.WorkerMessageType.NOTFOUND',
  w69b.qr.WorkerMessageType.NOTFOUND);

// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 * @author brenneman@google.com (Shawn Brenneman)
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @struct
 * @constructor
 */
goog.math.Size = function(width, height) {
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size.
   * @return {string} In the form (50 x 73).
   * @override
   */
  goog.math.Size.prototype.toString = function() {
    return '(' + this.width + ' x ' + this.height + ')';
  };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function() {
  return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function() {
  return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function() {
  return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function() {
  return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function() {
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function(target) {
  return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function() {
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function() {
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
 * given, then {@code sx} is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.width *= sx;
  this.height *= sy;
  return this;
};


/**
 * Uniformly scales the size to perfectly cover the dimensions of a given size.
 * If the size is already larger than the target, it will be scaled down to the
 * minimum size at which it still covers the entire target. The original aspect
 * ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToCover = function(target) {
  var s = this.aspectRatio() <= target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function(target) {
  var s = this.aspectRatio() > target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};

// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.RGBAImageData');

goog.scope(function() {
  /**
   * @param {number} width in pixels.
   * @param {number} height in pixels.
   * @param {Uint8Array=} opt_data optional image data. Defaults to empty
   * array.
   * @constructor
   */
  w69b.img.RGBAImageData = function(width, height, opt_data) {
    this.data = opt_data || new Uint8Array(4 * width * height);
    this.width = width;
    this.height = height;
  };
  var pro = w69b.img.RGBAImageData.prototype;

  pro.set = function(x, y, red, green, blue, opt_alpha) {
    var pos = 4 * (y * this.width + x);
    this.data[pos] = red;
    this.data[pos + 1] = green;
    this.data[pos + 2] = blue;
    this.data[pos + 3] = opt_alpha || 255;
  };

  pro.setGray = function(x, y, gray) {
    this.set(x, y, gray, gray, gray, 255);
  };

  /**
   * @param {number} x pos.
   * @param {number} y pos.
   * @return {Array} [red, green, blue, alpha] values.
   */
  pro.get = function(x, y) {
    var pos = 4 * (y * this.width + x);
    return [this.data[pos], this.data[pos + 1],
      this.data[pos + 2], this.data[pos + 3]];
  };
});

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.img.WebGLParams');
goog.require('goog.object');

goog.scope(function() {
  /**
   * Helps to apply parameters to a webgl programm.
   * @constructor
   * @param {Object=} opt_config initial config, see set().
   */
  w69b.img.WebGLParams = function(opt_config) {
    this.data_ = {};
    if (opt_config)
      this.set(opt_config);
  };
  var pro = w69b.img.WebGLParams.prototype;

  /**
   * @return {w69b.img.WebGLParams} params object.
   */
  pro.clone = function() {
    var params = new w69b.img.WebGLParams();
    params.data_ = goog.object.clone(this.data_);
    return params;
  };

  /**
   * Sets parameters. Example:
   * {'width': 12.4,
   * 'dimensions': [1024.0, 718.0]
   * 'imageId': ['i', 1]
   * }
   *
   * @param {Object} config mapping of names to either:
     *  one or multiple float values,
     * ['i', 21, 45, 6] one or multiple integers with a preceeding 'i'.
   * @return {w69b.img.WebGLParams} this for chaining.
   */
  pro.set = function(config) {
    goog.object.forEach(config, function(value, key) {
      if (value.length > 0 && value[0] == 'i')
        this.setInt(key, value.slice(1));
      else
        this.setFloat(key, value);
    }, this);
    return this;
  };

  /**
   * @param {string} name parameter name.
   * @param {string} type param type.
   * @param {(number|Array.<number>)} value to set.
   * @private
   */
  pro.setInternal_ = function(name, type, value) {
    this.data_[name] = [type, value];
  };

  /**
   * @param {string} name as passed to shader.
   * @param {(number|Array.<number>)} value integer.
   * @return {w69b.img.WebGLParams} this for chaining.
   */
  pro.setInt = function(name, value) {
    var len = value.length || 1;
    this.setInternal_(name, len + 'i', value);
    return this;
  };

  /**
   * @param {string} name as passed to shader.
   * @param {(number|Array.<number>)} value float.
   * @return {w69b.img.WebGLParams} this for chaining.
   */
  pro.setFloat = function(name, value) {
    var len = value.length || 1;
    this.setInternal_(name, len + 'f', value);
    return this;
  };


  /**
   * @param {string} name parameter name.
   * @return {?number} value or null.
   */
  pro.getValue = function(name) {
    var tuple = this.data_[name];
    if (tuple)
      return tuple[1];
    else
      return null;
  };

  /**
   * Apply parameters to program. You need to call program.use() and
   * program.initCommonAttributes() yourself.
   * @param {w69b.img.WebGLProgram} program webgl program.
   */
  pro.apply = function(program) {
    var setters = program.getNamedSetterFunctions();
    goog.object.forEach(this.data_, function(value, name) {
      var type = value[0];
      var valueArgs = value[1];
      setters[type].apply(program, [name].concat(valueArgs));
    }, this);
  };

  /**
   * Same as apply() but takes care of calling program.use() and
   * initCommonAttribtues()
   * @param {w69b.img.WebGLProgram} program webgl program.
   */
  pro.useAndApply = function(program) {
    program.use();
    program.initCommonAttributes();
    this.apply(program);
  };
});

// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.WebGLPipeline');

goog.scope(function() {
  /**
   * Helps to execute multipass webgl programms by applying multiple programs
   * and parameter successively.
   * @param {w69b.img.WebGLFilter} filter webgl filter.
   * @constructor
   */
  w69b.img.WebGLPipeline = function(filter) {
    this.passes_ = [];
    this.filter_ = filter;
  };
  var pro = w69b.img.WebGLPipeline.prototype;

  /**
   *
   * @param {w69b.img.WebGLProgram} program to run.
   * @param {w69b.img.WebGLParams} parameters to apply.
   */
  pro.addPass = function(program, parameters) {
    this.passes_.push([program, parameters]);
  };

  /**
   * Add custom pass.
   * @param {function(number, number, number)} callback that takes three
   * paramters:
   * - input texture id.
   * - out texture id
   * - working texture id (for intermediate results).
   */
  pro.addCustomPass = function(callback) {
    this.passes_.push(callback);
  };


  pro.render = function(inTextureId, outTextureId, workTextureId,
                        opt_resultOnScreen) {
    var prevProgarm = null;
    var filter = this.filter_;
    var numPasses = this.passes_.length;
    var pingPongTextureIds;
    // Ensures last pass goes on outTextureId.
    if (numPasses % 2 == 0)
      pingPongTextureIds = [workTextureId, outTextureId];
    else
      pingPongTextureIds = [outTextureId, workTextureId];

    var prevTextureId = inTextureId;
    for (var i = 0; i < numPasses; ++i) {
      var pass = this.passes_[i];
      if (pass.length) {
        var program = pass[0];
        var params = pass[1];
        if (program != prevProgarm) {
          program.use();
          program.initCommonAttributes();
          prevProgarm = program;
        }
        program.setUniform1i('imageIn', prevTextureId);
        params.apply(program);
        if (i == numPasses - 1 && opt_resultOnScreen) {
          filter.unbindFramebuffer();
        } else {
          var texId = pingPongTextureIds[i % 2];
          filter.attachTextureToFB(texId);
          prevTextureId = texId;
        }
        var offset = params.getValue('outOffset');
        filter.setViewport(
          offset ? offset[0] : 0,
          offset ? offset[1] : 0,
          params.getValue('width'),
          params.getValue('height'));
        program.drawRect();

      } else {
        // custom pass
        var outTex = pingPongTextureIds[i % 2];
        var workTex = pingPongTextureIds[(i + 1) % 2];
        pass(prevTextureId, outTex, workTex);
        prevTextureId = outTex;
      }

    }
  };


});

goog.provide('w69b.shaders.rectVertex');
w69b.shaders.rectVertex = 'attribute vec2 position;\n' +
  'void main(void) {\n' +
  'gl_Position = vec4(position, 0, 1);\n' +
  '}';
goog.provide('w69b.shaders.scale');
w69b.shaders.scale = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'uniform float outOffsetX;\n' +
  'uniform float inOffsetX;\n' +
  'vec2 outOffset = vec2(outOffsetX, 0);\n' +
  'vec2 inOffset = vec2(inOffsetX, 0) / texdim;\n' +
  'vec2 stepX = vec2(0.7, 0) / indim;\n' +
  'vec2 stepY = vec2(0, 0.7) / indim;\n' +
  'vec2 scale = indim / dim;\n' +
  'vec3 combine(vec3 color1, vec3 color2) {\n' +
  'return vec3(\n' +
  'min(color1.x, color2.x),\n' +
  'max(color1.y, color2.y),\n' +
  'color1.z + color2.z);\n' +
  '}\n' +
  'vec3 sample(vec2 p, vec2 offset) {\n' +
  'vec2 pos = (p + offset);\n' +
  'pos = min(vec2(1.0, 1.0), pos);\n' +
  'pos = max(vec2(0.0, 0.0), pos);\n' +
  'pos = inOffset + texscale * pos;\n' +
  'return texture2D(imageIn, pos).xyz;\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() - outOffset) / dim;\n' +
  'vec3 result = sample(p, - stepX - stepY);\n' +
  'result = combine(result, sample(p, stepX + stepY));\n' +
  'result = combine(result, sample(p, stepX - stepY));\n' +
  'result = combine(result, sample(p, -stepX + stepY));\n' +
  'result.z /= 4.0;\n' +
  'gl_FragColor = vec4(result, 1.0);\n' +
  '}';
goog.provide('w69b.shaders.threshold');
w69b.shaders.threshold = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'uniform sampler2D origImage;\n' +
  'vec2 texscaleBlackLevels = indim / texdim;\n' +
  'void main() {\n' +
  'vec2 p = getNormalizedFragCoord() / dim;\n' +
  'vec4 color = texture2D(origImage, p);\n' +
  'float gray = (color.r + color.g + color.b) / 3.0;\n' +
  'float black = texture2D(imageIn, p * texscaleBlackLevels).z;\n' +
  'float binary = gray > black ? 1.0 : 0.0;\n' +
  'gl_FragColor = vec4(binary, binary, binary, 1.0);\n' +
  '}';
goog.provide('w69b.shaders.binarizeAvg1');
w69b.shaders.binarizeAvg1 = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'vec2 mirrorMargin = 1.0 / indim;\n' +
  'vec2 mirrorBorder = 1.0 - mirrorMargin;\n' +
  'void mirror(inout vec2 pos) {\n' +
  'pos = pos - step(mirrorBorder, pos) * (pos - mirrorBorder);\n' +
  'pos *= 2.0 * (0.5 - step(0.0, -pos));\n' +
  '}\n' +
  'uniform vec2 sampleDirection;\n' +
  'vec2 sampleStep = sampleDirection / indim;\n' +
  'void addSample(inout vec4 result, vec2 p, float offset, float weight) {\n' +
  'vec2 pos = (p + offset * sampleStep);\n' +
  'mirror(pos);\n' +
  'pos *= texscale;\n' +
  'vec4 color = texture2D(imageIn, pos);\n' +
  'float gray = (color.r + color.g + color.b) / 3.0;\n' +
  'result.r = min(result.r, gray);\n' +
  'result.g = max(result.g, gray);\n' +
  'result.b += gray * weight;\n' +
  '}\n' +
  'void gauss9(inout vec4 result, vec2 p) {\n' +
  'addSample(result, p, -4.0, 0.0459);\n' +
  'addSample(result, p, -3.0, 0.0822);\n' +
  'addSample(result, p, -2.0, 0.1247);\n' +
  'addSample(result, p, -1.0, 0.1601);\n' +
  'addSample(result, p, 0.0, 0.1741);\n' +
  'addSample(result, p, 1.0, 0.1601);\n' +
  'addSample(result, p, 2.0, 0.1247);\n' +
  'addSample(result, p, 3.0, 0.0822);\n' +
  'addSample(result, p, 4.0, 0.0459);\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = getNormalizedFragCoord() / dim;\n' +
  'vec4 result  = vec4(1.0, 0.0, 0.0, 1.0);\n' +
  'gauss9(result, p);\n' +
  'gl_FragColor = result;\n' +
  '}';
goog.provide('w69b.shaders.binarizeGroup');
w69b.shaders.binarizeGroup = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'vec2 mirrorMargin = 1.0 / indim;\n' +
  'vec2 mirrorBorder = 1.0 - mirrorMargin;\n' +
  'void mirror(inout vec2 pos) {\n' +
  'pos = pos - step(mirrorBorder, pos) * (pos - mirrorBorder);\n' +
  'pos *= 2.0 * (0.5 - step(0.0, -pos));\n' +
  '}\n' +
  'uniform vec2 sampleDirection;\n' +
  'uniform vec2 outOffset;\n' +
  'uniform vec2 inOffset;\n' +
  'vec2 inOffsetNormalized = inOffset / texdim;\n' +
  'vec2 sampleStep = sampleDirection / indim;\n' +
  'void addSample(inout vec4 result, vec2 p, float offset, float weight) {\n' +
  'vec2 pos = (p + offset * sampleStep);\n' +
  'mirror(pos);\n' +
  'pos *= texscale;\n' +
  'pos += inOffsetNormalized;\n' +
  'vec4 color = texture2D(imageIn, pos);\n' +
  'result.r = min(result.r, color.r);\n' +
  'result.g = max(result.g, color.g);\n' +
  'result.b += color.b * weight;\n' +
  '}\n' +
  'void gauss9(inout vec4 result, vec2 p) {\n' +
  'addSample(result, p, -4.0, 0.0459);\n' +
  'addSample(result, p, -3.0, 0.0822);\n' +
  'addSample(result, p, -2.0, 0.1247);\n' +
  'addSample(result, p, -1.0, 0.1601);\n' +
  'addSample(result, p, 0.0, 0.1741);\n' +
  'addSample(result, p, 1.0, 0.1601);\n' +
  'addSample(result, p, 2.0, 0.1247);\n' +
  'addSample(result, p, 3.0, 0.0822);\n' +
  'addSample(result, p, 4.0, 0.0459);\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() - outOffset) / dim;\n' +
  'vec4 result  = vec4(0.0, 0.0, 0.0, 1.0);\n' +
  'gauss9(result, p);\n' +
  '// //\n' +
  'gl_FragColor = result;\n' +
  '//\n' +
  '}';
goog.provide('w69b.shaders.debug');
w69b.shaders.debug = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'uniform vec2 outOffset;\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() - outOffset) / dim;\n' +
  'vec4 color = vec4(1.0);\n' +
  'color.rg = p;\n' +
  'gl_FragColor = color;\n' +
  '}';
goog.provide('w69b.shaders.dummy');
w69b.shaders.dummy = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'vec2 mirrorMargin = 1.0 / indim;\n' +
  'vec2 mirrorBorder = 1.0 - mirrorMargin;\n' +
  'void mirror(inout vec2 pos) {\n' +
  'pos = pos - step(mirrorBorder, pos) * (pos - mirrorBorder);\n' +
  'pos *= 2.0 * (0.5 - step(0.0, -pos));\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() / dim);\n' +
  'mirror(p);\n' +
  'p *= texscale;\n' +
  'gl_FragColor = texture2D(imageIn, p);\n' +
  '}';
goog.provide('w69b.shaders.estimateBlack');
w69b.shaders.estimateBlack = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'vec2 mirrorMargin = 1.0 / indim;\n' +
  'vec2 mirrorBorder = 1.0 - mirrorMargin;\n' +
  'void mirror(inout vec2 pos) {\n' +
  'pos = pos - step(mirrorBorder, pos) * (pos - mirrorBorder);\n' +
  'pos *= 2.0 * (0.5 - step(0.0, -pos));\n' +
  '}\n' +
  'vec4 sampleAt(vec2 pos, float scale) {\n' +
  'mirror(pos);\n' +
  'vec2 offset = scale * vec2(indim.x, 0) / texdim;\n' +
  'pos = pos * texscale + offset;\n' +
  'return texture2D(imageIn, pos);\n' +
  '}\n' +
  'float getDynRange(vec4 color) {\n' +
  'return color.g - color.r;\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = getNormalizedFragCoord() / dim;\n' +
  'vec4 color;\n' +
  'float minDynRange = 0.3;\n' +
  'color = sampleAt(p, 0.0);\n' +
  'if (getDynRange(color) < minDynRange) {\n' +
  'color = sampleAt(p, 1.0);\n' +
  'if (getDynRange(color) < minDynRange) {\n' +
  'color = sampleAt(p, 2.0);\n' +
  '}\n' +
  '}\n' +
  'color.z -= 0.02;\n' +
  'gl_FragColor = color;\n' +
  '}';
goog.provide('w69b.shaders.extractChannel');
w69b.shaders.extractChannel = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'uniform int channel;\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() / dim);\n' +
  'p *= texscale;\n' +
  'vec4 color = texture2D(imageIn, p);\n' +
  'float gray = color.b;\n' +
  'gl_FragColor = vec4(gray, gray, gray, 1.0);\n' +
  '}';
goog.provide('w69b.shaders.fragCoordTest');
w69b.shaders.fragCoordTest = 'precision mediump float;\n' +
  'void main() {\n' +
  'vec4 result = vec4(1.0);\n' +
  'result.rg = gl_FragCoord.xy / 10.0;\n' +
  'gl_FragColor = result;\n' +
  '}';
goog.provide('w69b.shaders.gaussBlur');
w69b.shaders.gaussBlur = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'vec2 mirrorMargin = 1.0 / indim;\n' +
  'vec2 mirrorBorder = 1.0 - mirrorMargin;\n' +
  'void mirror(inout vec2 pos) {\n' +
  'pos = pos - step(mirrorBorder, pos) * (pos - mirrorBorder);\n' +
  'pos *= 2.0 * (0.5 - step(0.0, -pos));\n' +
  '}\n' +
  'uniform vec2 sampleDirection;\n' +
  'uniform vec2 outOffset;\n' +
  'uniform vec2 inOffset;\n' +
  'vec2 sampleStep = sampleDirection / texdim;\n' +
  'vec2 inOffsetNormalized = inOffset / texdim;\n' +
  'void addSample(inout vec4 result, vec2 p, float offset, float weight) {\n' +
  'vec2 pos = (p + (offset * sampleStep));\n' +
  'mirror(pos);\n' +
  'pos *= texscale;\n' +
  'pos += inOffsetNormalized;\n' +
  'vec4 color = texture2D(imageIn, pos);\n' +
  'result.rgb += color.rgb * weight;\n' +
  '}\n' +
  'void gauss9(inout vec4 result, vec2 p) {\n' +
  'addSample(result, p, -4.0, 0.0459);\n' +
  'addSample(result, p, -3.0, 0.0822);\n' +
  'addSample(result, p, -2.0, 0.1247);\n' +
  'addSample(result, p, -1.0, 0.1601);\n' +
  'addSample(result, p, 0.0, 0.1741);\n' +
  'addSample(result, p, 1.0, 0.1601);\n' +
  'addSample(result, p, 2.0, 0.1247);\n' +
  'addSample(result, p, 3.0, 0.0822);\n' +
  'addSample(result, p, 4.0, 0.0459);\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() - outOffset) / dim;\n' +
  'vec4 result  = vec4(0.0, 0.0, 0.0, 1.0);\n' +
  'gauss9(result, p);\n' +
  'gl_FragColor = result;\n' +
  '}';
goog.provide('w69b.shaders.grayscale');
w69b.shaders.grayscale = 'precision mediump float;\n' +
  'uniform float width;\n' +
  'uniform float height;\n' +
  'uniform float inwidth;\n' +
  'uniform float inheight;\n' +
  'uniform float texwidth;\n' +
  'uniform float texheight;\n' +
  'uniform vec2 fragCoordOffset;\n' +
  'uniform sampler2D imageIn;\n' +
  'vec2 dim = vec2(width, height);\n' +
  'vec2 texdim = vec2(texwidth, texheight);\n' +
  'vec2 indim = vec2(inwidth, inheight);\n' +
  'vec2 texscale = indim / texdim;\n' +
  'vec2 getNormalizedFragCoord() {\n' +
  'return (gl_FragCoord.xy - fragCoordOffset) + 0.5;\n' +
  '}\n' +
  'void main() {\n' +
  'vec2 p = (getNormalizedFragCoord() / dim);\n' +
  'p *= texscale;\n' +
  'vec4 color = texture2D(imageIn, p);\n' +
  'float gray = (color.r + color.g + color.b) / 3.0;\n' +
  'gl_FragColor = vec4(gray, gray, gray, 1.0);\n' +
  '}';
// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.WebGLProgram');
goog.require('w69b.shaders.rectVertex');

goog.scope(function() {
  /**
   * Filters images using webgl shaders.
   * @param {WebGLRenderingContext} gl rendering context.
   * @param {string} fragmentSource fragmentSource.
   * @param {string=} opt_vertexSource vertex shader.
   * @constructor
   */
  w69b.img.WebGLProgram = function(gl, fragmentSource, opt_vertexSource) {
    this.context_ = gl;
    var vertexShader = this.buildShader_(
      opt_vertexSource || w69b.shaders.rectVertex, true);
    var fragmentShader = this.buildShader_(fragmentSource, false);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      throw Error('Could not link shader program: ' +
        gl.getProgramInfoLog(shaderProgram));
    }
    this.glProgram = shaderProgram;
  };
  var pro = w69b.img.WebGLProgram.prototype;

  /**
   * Linked shader program.
   */
  pro.glProgram = null;

  /**
   * @type {WebGLRenderingContext} gl rendering context.
   */
  pro.contex_ = null;



  /**
   * Initialize common shader attributes.
   */
  pro.initCommonAttributes = function() {
    var gl = this.context_;
    var program = this.glProgram;
    var positionLocation = gl.getAttribLocation(program, 'position');
    var buffer = gl.createBuffer();
    var vertices = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];

    //set position attribute data
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  };

  /**
   * Activates this program.
   */
  pro.use = function() {
    this.context_.useProgram(this.glProgram);
  };

  /**
   * Draws rectangele. InitCommonAttributes needs to have been called first.
   */
  pro.drawRect = function() {
    var gl = this.context_;
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  };

  /**
   * @param {string} name variable name.
   * @param {number} value float value.
   */
  pro.setUniform1f = function(name, value) {
    var location = this.context_.getUniformLocation(this.glProgram, name);
    this.context_.uniform1f(location, value);
  };

  /**
   * For vec2.
   * @param {string} name variable name.
   * @param {number} x float value.
   * @param {number} y float value.
   */
  pro.setUniform2f = function(name, x, y) {
    var location = this.context_.getUniformLocation(this.glProgram, name);
    this.context_.uniform2f(location, x, y);
  };

  /**
   * @param {string} name variable name.
   * @param {(Array.<number>|Float32Array)} value float value.
   */
  pro.setUniform1fv = function(name, value) {
    var location = this.context_.getUniformLocation(this.glProgram, name);
    this.context_.uniform1fv(location, value);
  };

  /**
   * @param {string} name variable name.
   * @param {number} value int value.
   */
  pro.setUniform1i = function(name, value) {
    var location = this.context_.getUniformLocation(this.glProgram, name);
    this.context_.uniform1i(location, value);
  };


  /**
   * @return {Object} mapping of type names to unbound setter functions.
   */
  pro.getNamedSetterFunctions = function() {
    return this.namedSetterFns_;
  };

  /**
   * @type {Object} mapping type names to setter functions.
   * @private
   */
  pro.namedSetterFns_ = {
    '1i': pro.setUniform1i,
    '1f': pro.setUniform1f,
    '2f': pro.setUniform2f
  };

  /**
   * @param {string} source shader source.
   * @param {boolean} isVertex true for vertex shader, false for fragment
   * shader.
   * @return {WebGLShader} shader.
   */
  pro.buildShader_ = function(source, isVertex) {
    var gl = this.context_;
    var shader = gl.createShader(
      isVertex ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw Error('Could not compile shader: ' +
        gl.getShaderInfoLog(shader));
    }
    return shader;
  };

});


// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.img.NotSupportedError');
goog.provide('w69b.img.WebGLFilter');
goog.require('goog.debug.Error');
goog.require('w69b.img.RGBAImageData');
goog.require('w69b.img.WebGLParams');
goog.require('w69b.img.WebGLPipeline');
goog.require('w69b.img.WebGLProgram');
goog.require('w69b.shaders.fragCoordTest');


goog.scope(function() {
  var WebGLProgram = w69b.img.WebGLProgram;
  var RGBAImageData = w69b.img.RGBAImageData;
  /**
   * Thrown when webgl is not supported.
   * @constructor
   * @extends {goog.debug.Error}
   */
  w69b.img.NotSupportedError = function() {
    goog.base(this);
  };
  goog.inherits(w69b.img.NotSupportedError, goog.debug.Error);
  /** @override */
  w69b.img.NotSupportedError.prototype.name = 'NotSupported';

  /**
   * Filters images using webgl shaders.
   * @param {HTMLCanvasElement=} opt_canvas canvas to use.
   * @constructor
   */
  w69b.img.WebGLFilter = function(opt_canvas) {
    this.textures = [];
    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = /** @type {HTMLCanvasElement} */ (
      opt_canvas || document.createElement('canvas'));
    try {
      this.context_ = /** @type {WebGLRenderingContext} */ (
        this.canvas_.getContext('webgl') ||
          this.canvas_.getContext('experimental-webgl'));
    } catch (ignored) {
    }
    if (!this.context_)
      throw new w69b.img.NotSupportedError();
    w69b.img.WebGLFilter.testFragCoordOffset();

    this.framebuffer_ = this.context_.createFramebuffer();
  };
  var _ = w69b.img.WebGLFilter;
  /**
   * @type {Array.<number>}
   * @private
   */
  _.fragCoordOffset_ = null;
  // Simple vertex shader.

  var pro = w69b.img.WebGLFilter.prototype;


  /**
   * Rendering context of back canvas.
   * @type {WebGLRenderingContext}
   * @private
   */
  pro.context_ = null;


  /**
   * @param {number} width canvas width.
   * @param {number} height canvas height.
   */
  pro.setSize = function(width, height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  };

  /**
   * @return {number} width.
   */
  pro.getWidth = function() {
    return this.canvas_.width;
  };

  /**
   * @return {number} height.
   */
  pro.getHeight = function() {
    return this.canvas_.height;
  };

  /**
   * Set viewport for next rendering call.
   * @param {number} x left offset.
   * @param {number} y bottom offset.
   * @param {number} width size.
   * @param {number} height size.
   */
  pro.setViewport = function(x, y, width, height) {
    this.context_.viewport(x, y, width, height);
  };

  /**
   * Unbind framebuffer.
   */
  pro.unbindFramebuffer = function() {
    var gl = this.context_;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };

  /**
   * @return {WebGLRenderingContext} webgl context.
   */
  pro.getContext = function() {
    return this.context_;
  };

  /**
   * @param {number} id texture id.
   * @return {WebGLTexture} texture.
   */
  pro.getTexture = function(id) {
    return this.textures[id];
  };

  /**
   * Creates num textures. The first texture is
   */
  pro.createTextures = function(num) {
    var width = this.getWidth();
    var height = this.getHeight();
    for (var i = 0; i < num; ++i)
      this.textures[i] = this.createTexture(i, width, height);
  };

  /**
   * Sets UNPACK_FLIP_Y_WEBGL parameter on given texture.
   * @param {number} id texture id.
   */
  pro.setTextureFlipped = function(id) {
    var gl = this.context_;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.textures[id]);
    // flipped coordinates
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.bindTexture(gl.TEXTURE_2D, null);
  };


  /**
   * Create texture with default parameters.
   * @param {number} id texture unit id.
   * @param {number=} opt_width in pixels.
   * @param {number=} opt_height in pixsels.
   * @return {WebGLTexture} texture.
   */
  pro.createTexture = function(id, opt_width, opt_height) {
    var gl = this.context_;
    var texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + id);
    //set properties for the texture
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    if (opt_width && opt_height)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, opt_width, opt_height, 0,
        gl.RGBA, gl.UNSIGNED_BYTE, null);

    // gl.bindTexture(gl.TEXTURE_2D, null);

    return texture;
  };

  /**
   * Attach texture to framebuffer.
   * @param {number} textureId texture id.
   * @param {WebGLFramebuffer=} opt_framebuffer defaults to this.framebuffer.
   */
  pro.attachTextureToFB = function(textureId, opt_framebuffer) {
    var gl = this.context_;
    var texture = this.textures[textureId];
    gl.bindFramebuffer(gl.FRAMEBUFFER, opt_framebuffer || this.framebuffer_);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D, texture, 0);
  };

  /**
   * Returns offset for normalizing gl_FragCoord.
   * @return {Array.<number>} offset.
   */
  pro.getFragCoordOffset = function() {
    return _.fragCoordOffset_;
  };

  /**
   * Get image data of canvas.
   * @return {RGBAImageData} image data.
   */
  pro.getImageData = function() {
    var gl = this.context_;
    var width = this.getWidth();
    var height = this.getHeight();
    var imgdata = new Uint8Array(4 * width * height);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, imgdata);
    return new RGBAImageData(width, height, imgdata);
  };


  /**
   * WebGL implementation supply different offsets for gl_FragCoord to
   * fragment shaders. For the first pixel this can be (0,0), (0.5, 0.5)
   * or (1.0, 1.0). We need to take this into account in our shaders.
   */
  _.testFragCoordOffset = function() {
    if (_.fragCoordOffset_)
      return;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') ||
      canvas.getContext('experimental-webgl');
    canvas.width = 20;
    canvas.height = 20;
    canvas.imageSmoothingEnabled = false;
    var program = new WebGLProgram(gl, w69b.shaders.fragCoordTest);

    program.use();
    program.initCommonAttributes();


    program.drawRect();
    var imgdata = new Uint8Array(4 * canvas.width * canvas.height);
    gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA,
      gl.UNSIGNED_BYTE, imgdata);

    function round(val) {
      return Math.round(100 * val / 255) / 10;
    }

    var xOffset = imgdata[0];
    var yOffset = imgdata[1];
    // assume 0.1 steps.
    xOffset = round(xOffset);
    yOffset = round(yOffset);
    _.fragCoordOffset_ = [xOffset, yOffset];
    // window.console.log('detected fragment coord offset: (' +
    //   xOffset + ' ' + yOffset + ')');
  };


});

// (c) 2013 Manuel Braun (mb@w69b.com)

goog.require('goog.math.Size');
goog.provide('w69b.img.WebGLBinarizer');
goog.require('w69b.img.RGBABitMatrix');
goog.require('w69b.img.RGBAImageData');
goog.require('w69b.img.WebGLFilter');
goog.require('w69b.img.WebGLParams');
goog.require('w69b.img.WebGLPipeline');
goog.require('w69b.img.WebGLProgram');
goog.require('w69b.shaders.binarizeAvg1');
goog.require('w69b.shaders.binarizeGroup');
goog.require('w69b.shaders.debug');
goog.require('w69b.shaders.estimateBlack');
goog.require('w69b.shaders.extractChannel');
goog.require('w69b.shaders.fragCoordTest');
goog.require('w69b.shaders.gaussBlur');
goog.require('w69b.shaders.grayscale');
goog.require('w69b.shaders.rectVertex');
goog.require('w69b.shaders.scale');


goog.scope(function() {
  var WebGLFilter = w69b.img.WebGLFilter;
  var WebGLProgram = w69b.img.WebGLProgram;
  var WebGLParams = w69b.img.WebGLParams;
  var WebGLPipeline = w69b.img.WebGLPipeline;
  var RGBAImageData = w69b.img.RGBAImageData;
  var RGBABitMatrix = w69b.img.RGBABitMatrix;
  /**
   * WebGL shader based image binarizer.
   * The basic idea is to estimate an average black level for each pixel by looking at
   * neighbouring pixels, while choosing the neighbourhood large enough to cover a sufficently
   * large dynamic range.
   * Then simply apply thresholding based on that value.
   *
   * In detail:
   * - Successively apply shaders to compute a scale space and the dynamic range
   * (gaussBlur, binarizeAvg1, binarizeGroup).
   * - Run estimateBlack shader to pick a gray level estimation. It just chooses the
   * gray level from the smallest scale that still satisfies a dynamic range constraint.
   * - Run thresholding shader to apply thresholding on input image gray values with
   * black level estimations.
   *
   * @constructor
   * @param {HTMLCanvasElement=} opt_canvas canvas to use.
   */
  w69b.img.WebGLBinarizer = function(opt_canvas) {
    this.filter_ = new WebGLFilter(opt_canvas);
  };
  var pro = w69b.img.WebGLBinarizer.prototype;
  var _ = w69b.img.WebGLBinarizer;
  /**
   * @type {?boolean}
   */
  _.isSupported_ = null;

  pro.pipeline_ = null;
  pro.setupCalled_ = false;
  /**
   * If canvas is displayed directly, input data needs to be flipped around
   * y axis.
   * @type {boolean}
   * @private
   */
  pro.flipInput_ = false;


  /**
   * Size of native input image/video.
   * @type {?goog.math.Size}
   * @private
   */
  pro.inSize_ = null;

  /**
   * @param {string} source fragment source.
   * @return {w69b.img.WebGLProgram} compiled program.
   */
  pro.getProgram = function(source) {
    return new WebGLProgram(this.filter_.getContext(), source);
  };

  /**
   * @param {boolean} flip whether to flip input arround y axis.
   */
  pro.setFlipInput = function(flip) {
    this.flipInput_ = flip;
  };

  /**
   * Setup binarizer for given image dimensions.
   * Only call this once.
   * @param {number} width in pixels.
   * @param {number} height in pixels.
   * @param {number=} opt_inWidth in pixels.
   * @param {number=} opt_inHeight in pixels.
   */
  pro.setup = function(width, height, opt_inWidth, opt_inHeight) {
    if (!opt_inHeight)
      opt_inHeight = height;
    if (!opt_inWidth)
      opt_inWidth = width;
    if (!this.setupCalled_) {
      // compile shaders
      this.programDynRange1 = this.getProgram(w69b.shaders.binarizeAvg1);
      this.programDynRange2 = this.getProgram(w69b.shaders.binarizeGroup);
      this.programEstimateBlack = this.getProgram(w69b.shaders.estimateBlack);
      this.programThreshold = this.getProgram(w69b.shaders.threshold);
      this.programGauss = this.getProgram(w69b.shaders.gaussBlur);
    }

    if (!this.setupCalled_ ||
      this.filter_.getWidth() != width ||
      this.filter_.getHeight() != height ||
      this.inSize_.width != opt_inWidth ||
      this.inSize_.height != opt_inHeight) {
      this.filter_.setSize(width, height);
      this.inSize_ = new goog.math.Size(opt_inWidth, opt_inHeight);
      this.filter_.createTextures(3);
      if (this.flipInput_)
        this.filter_.setTextureFlipped(0);
      this.pipeline_ = this.createPipeline();
    }
    this.setupCalled_ = true;
  };

  pro.createPipeline = function() {
    var width = this.filter_.getWidth();
    var height = this.filter_.getHeight();
    var inSize = this.inSize_;

    var pipeline = new WebGLPipeline(this.filter_);
    // Some shaders that are useful for debugging.
    // var grayscale = new WebGLProgram(gl, w69b.shaders.grayscale);
    // var dummy = this.getProgram(w69b.shaders.dummy);
    // var extractChannel = this.getProgram(w69b.shaders.extractChannel);
    // var debug = new WebGLProgram(gl, w69b.shaders.debug);
    var baseParams = new WebGLParams(
      {
        'width': width,
        'height': height,
        'inwidth': width,
        'inheight': height,
        'texwidth': width,
        'texheight': height,
        'inOffset': [0, 0],
        'outOffset': [0, 0],
        'fragCoordOffset': this.filter_.getFragCoordOffset()
      });
    var downScalePower = 3;
    var scaledWith = Math.max(1, width >> downScalePower);
    var scaledHeight = Math.max(1, height >> downScalePower);
    var smallImgParams = baseParams.clone().set({
      'width': scaledWith,
      'height': scaledHeight,
      'inwidth': scaledWith,
      'inheight': scaledHeight
    });

    // Apply gauss and downsample to scaledWidth/Height
    pipeline.addPass(this.programGauss,
      baseParams.clone().set({
        'width': scaledWith,
        'sampleDirection': [0, 1],
        'texwidth': inSize.width,
        'texheight': inSize.height
      }));

    pipeline.addPass(this.programGauss,
      smallImgParams.clone().set({
        'inheight': height,
        'sampleDirection': [1, 0]
      }));

    // Compute more dynamic ranges and two more scales on gray
    // level image, in a layout next to each other. Kernel size increases
    // from left to right.
    pipeline.addPass(this.programDynRange1, smallImgParams.clone().set({
      'sampleDirection': [0, 1]
    }));
    pipeline.addPass(this.programDynRange2, smallImgParams.clone().set({
      'sampleDirection': [1, 0]
    }));

    pipeline.addPass(this.programDynRange2, smallImgParams.clone().set({
      'sampleDirection': [0, 2]
    }));
    pipeline.addPass(this.programDynRange2, smallImgParams.clone().set({
      'sampleDirection': [2, 0],
      'outOffset': [scaledWith, 0]
    }));

    pipeline.addPass(this.programDynRange2, smallImgParams.clone().set({
      'sampleDirection': [0, 2],
      'inOffset': [scaledWith, 0]
    }));
    pipeline.addPass(this.programDynRange2, smallImgParams.clone().set({
      'sampleDirection': [2, 0],
      'outOffset': [scaledWith * 2, 0]
    }));
    // Use scale space and dynamic range estimations to estimate black level.
    pipeline.addPass(this.programEstimateBlack, smallImgParams);
    // pipeline.addPass(extractChannel,
    //  smallImgParams.clone().setInt('channel', 2));

    pipeline.addPass(this.programThreshold, smallImgParams.clone()
      .setInt('origImage', 0)
      .set({
        'width': inSize.width, 'height': inSize.height,
        'inwidth': scaledWith, 'inheight': scaledHeight
      }));
    return pipeline;
  };


  /**
   * @return {w69b.img.RGBAImageData} image data.
   */
  pro.getImageData = function() {
    return this.filter_.getImageData();
  };

  /**
   * @return {w69b.img.RGBABitMatrix} image data wrapped in RGBABitmatrix.
   */
  pro.getBitMatrix = function() {
    var imgdata = this.filter_.getImageData();
    return new RGBABitMatrix(imgdata.width, imgdata.height, imgdata.data);
  };

  /**
   * @param {(Image|HTMLVideoElement|RGBAImageData|ImageData)} image image
   * to render.
   */
  pro.render = function(image) {
    if (!this.setupCalled_) {
      throw new Error();
    }
    var gl = this.filter_.getContext();
    // bind input image to texture 0.
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.filter_.getTexture(0));
    if (image instanceof RGBAImageData) {
      // custom image data
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0,
        gl.RGBA, gl.UNSIGNED_BYTE, image.data);

    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
        image);
    }

    this.pipeline_.render(0, 1, 2, true);
  };

  /**
   * @param {number} width in pixels.
   * @param {number} height in pixels.
   * @return {w69b.img.RGBAImageData} test image.
   */
  _.createSupportCheckImage = function(width, height) {
    var imgdata = new Uint8Array(4 * width * height);
    // build gradient
    for (var y = 0; y < height; ++y) {
      for (var x = 0; x < width; ++x) {
        var pos = 4 * (width * y + x);
        var gray = x;
        imgdata[pos] = gray;
        imgdata[pos + 1] = gray;
        imgdata[pos + 2] = gray;
        imgdata[pos + 3] = 255;
      }
    }
    return new RGBAImageData(width, height, imgdata);
  };

  /**
   *
   */
  _.isSupported = function() {
    // create test image
    if (_.isSupported_ === null) {
      var width = 100;
      var height = 20;
      var img = _.createSupportCheckImage(width, height);
      // set contrast on some pixels.
      img.setGray(30, 4, 18);
      img.setGray(90, 4, 50);
      try {
        var binarizer = new w69b.img.WebGLBinarizer();
      } catch (ignored) {
        // No webgl support.
        return false;
      }
      binarizer.setFlipInput(false);
      binarizer.setup(width, height);
      binarizer.render(img);
      var binary = binarizer.getImageData();
      // Check some black and white values.
      _.isSupported_ = (binary.get(30, 4)[0] == 0 &&
      binary.get(90, 4)[0] == 0 &&
      binary.get(31, 4)[0] == 255 &&
      binary.get(29, 4)[0] == 255);
    }
    return _.isSupported_;
  };

});

// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Namespace with crypto related helper functions.
 */

goog.provide('goog.crypt');

goog.require('goog.array');
goog.require('goog.asserts');


/**
 * Turns a string into an array of bytes; a "byte" being a JS number in the
 * range 0-255.
 * @param {string} str String value to arrify.
 * @return {!Array<number>} Array of numbers corresponding to the
 *     UCS character codes of each character in str.
 */
goog.crypt.stringToByteArray = function(str) {
  var output = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    while (c > 0xff) {
      output[p++] = c & 0xff;
      c >>= 8;
    }
    output[p++] = c;
  }
  return output;
};


/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
goog.crypt.byteArrayToString = function(bytes) {
  var CHUNK_SIZE = 8192;

  // Special-case the simple case for speed's sake.
  if (bytes.length <= CHUNK_SIZE) {
    return String.fromCharCode.apply(null, bytes);
  }

  // The remaining logic splits conversion by chunks since
  // Function#apply() has a maximum parameter count.
  // See discussion: http://goo.gl/LrWmZ9

  var str = '';
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    var chunk = goog.array.slice(bytes, i, i + CHUNK_SIZE);
    str += String.fromCharCode.apply(null, chunk);
  }
  return str;
};


/**
 * Turns an array of numbers into the hex string given by the concatenation of
 * the hex values to which the numbers correspond.
 * @param {Uint8Array|Array<number>} array Array of numbers representing
 *     characters.
 * @return {string} Hex string.
 */
goog.crypt.byteArrayToHex = function(array) {
  return goog.array.map(array, function(numByte) {
    var hexByte = numByte.toString(16);
    return hexByte.length > 1 ? hexByte : '0' + hexByte;
  }).join('');
};


/**
 * Converts a hex string into an integer array.
 * @param {string} hexString Hex string of 16-bit integers (two characters
 *     per integer).
 * @return {!Array<number>} Array of {0,255} integers for the given string.
 */
goog.crypt.hexToByteArray = function(hexString) {
  goog.asserts.assert(hexString.length % 2 == 0,
                      'Key string length must be multiple of 2');
  var arr = [];
  for (var i = 0; i < hexString.length; i += 2) {
    arr.push(parseInt(hexString.substring(i, i + 2), 16));
  }
  return arr;
};


/**
 * Converts a JS string to a UTF-8 "byte" array.
 * @param {string} str 16-bit unicode string.
 * @return {!Array<number>} UTF-8 byte array.
 */
goog.crypt.stringToUtf8ByteArray = function(str) {
  // TODO(user): Use native implementations if/when available
  var out = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = (c >> 6) | 192;
      out[p++] = (c & 63) | 128;
    } else {
      out[p++] = (c >> 12) | 224;
      out[p++] = ((c >> 6) & 63) | 128;
      out[p++] = (c & 63) | 128;
    }
  }
  return out;
};


/**
 * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
 * @param {Uint8Array|Array<number>} bytes UTF-8 byte array.
 * @return {string} 16-bit Unicode string.
 */
goog.crypt.utf8ByteArrayToString = function(bytes) {
  // TODO(user): Use native implementations if/when available
  var out = [], pos = 0, c = 0;
  while (pos < bytes.length) {
    var c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] = String.fromCharCode(
          (c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join('');
};


/**
 * XOR two byte arrays.
 * @param {!ArrayBufferView|!Array<number>} bytes1 Byte array 1.
 * @param {!ArrayBufferView|!Array<number>} bytes2 Byte array 2.
 * @return {!Array<number>} Resulting XOR of the two byte arrays.
 */
goog.crypt.xorByteArray = function(bytes1, bytes2) {
  goog.asserts.assert(
      bytes1.length == bytes2.length,
      'XOR array lengths must match');

  var result = [];
  for (var i = 0; i < bytes1.length; i++) {
    result.push(bytes1[i] ^ bytes2[i]);
  }
  return result;
};

// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Base64 en/decoding. Not much to say here except that we
 * work with decoded values in arrays of bytes. By "byte" I mean a number
 * in [0, 255].
 *
 * @author doughtie@google.com (Gavin Doughtie)
 */

goog.provide('goog.crypt.base64');

goog.require('goog.asserts');
goog.require('goog.crypt');
goog.require('goog.userAgent');

// Static lookup maps, lazily populated by init_()


/**
 * Maps bytes to characters.
 * @type {Object}
 * @private
 */
goog.crypt.base64.byteToCharMap_ = null;


/**
 * Maps characters to bytes.
 * @type {Object}
 * @private
 */
goog.crypt.base64.charToByteMap_ = null;


/**
 * Maps bytes to websafe characters.
 * @type {Object}
 * @private
 */
goog.crypt.base64.byteToCharMapWebSafe_ = null;


/**
 * Maps websafe characters to bytes.
 * @type {Object}
 * @private
 */
goog.crypt.base64.charToByteMapWebSafe_ = null;


/**
 * Our default alphabet, shared between
 * ENCODED_VALS and ENCODED_VALS_WEBSAFE
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS_BASE =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
    'abcdefghijklmnopqrstuvwxyz' +
    '0123456789';


/**
 * Our default alphabet. Value 64 (=) is special; it means "nothing."
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS =
    goog.crypt.base64.ENCODED_VALS_BASE + '+/=';


/**
 * Our websafe alphabet.
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS_WEBSAFE =
    goog.crypt.base64.ENCODED_VALS_BASE + '-_.';


/**
 * Whether this browser supports the atob and btoa functions. This extension
 * started at Mozilla but is now implemented by many browsers. We use the
 * ASSUME_* variables to avoid pulling in the full useragent detection library
 * but still allowing the standard per-browser compilations.
 *
 * @type {boolean}
 */
goog.crypt.base64.HAS_NATIVE_SUPPORT = goog.userAgent.GECKO ||
                                       goog.userAgent.WEBKIT ||
                                       goog.userAgent.OPERA ||
                                       typeof(goog.global.atob) == 'function';


/**
 * Base64-encode an array of bytes.
 *
 * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
 *     value in [0, 255]) to encode.
 * @param {boolean=} opt_webSafe Boolean indicating we should use the
 *     alternative alphabet.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeByteArray = function(input, opt_webSafe) {
  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce
  // size of jscompiler output, and which yields slight performance increase.
  goog.asserts.assert(goog.isArrayLike(input),
                      'encodeByteArray takes an array as a parameter');

  goog.crypt.base64.init_();

  var byteToCharMap = opt_webSafe ?
                      goog.crypt.base64.byteToCharMapWebSafe_ :
                      goog.crypt.base64.byteToCharMap_;

  var output = [];

  for (var i = 0; i < input.length; i += 3) {
    var byte1 = input[i];
    var haveByte2 = i + 1 < input.length;
    var byte2 = haveByte2 ? input[i + 1] : 0;
    var haveByte3 = i + 2 < input.length;
    var byte3 = haveByte3 ? input[i + 2] : 0;

    var outByte1 = byte1 >> 2;
    var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
    var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);
    var outByte4 = byte3 & 0x3F;

    if (!haveByte3) {
      outByte4 = 64;

      if (!haveByte2) {
        outByte3 = 64;
      }
    }

    output.push(byteToCharMap[outByte1],
                byteToCharMap[outByte2],
                byteToCharMap[outByte3],
                byteToCharMap[outByte4]);
  }

  return output.join('');
};


/**
 * Base64-encode a string.
 *
 * @param {string} input A string to encode.
 * @param {boolean=} opt_webSafe If true, we should use the
 *     alternative alphabet.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeString = function(input, opt_webSafe) {
  // Shortcut for Mozilla browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_SUPPORT && !opt_webSafe) {
    return goog.global.btoa(input);
  }
  return goog.crypt.base64.encodeByteArray(
      goog.crypt.stringToByteArray(input), opt_webSafe);
};


/**
 * Base64-decode a string.
 *
 * @param {string} input to decode.
 * @param {boolean=} opt_webSafe True if we should use the
 *     alternative alphabet.
 * @return {string} string representing the decoded value.
 */
goog.crypt.base64.decodeString = function(input, opt_webSafe) {
  // Shortcut for Mozilla browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_SUPPORT && !opt_webSafe) {
    return goog.global.atob(input);
  }
  return goog.crypt.byteArrayToString(
      goog.crypt.base64.decodeStringToByteArray(input, opt_webSafe));
};


/**
 * Base64-decode a string.
 *
 * In base-64 decoding, groups of four characters are converted into three
 * bytes.  If the encoder did not apply padding, the input length may not
 * be a multiple of 4.
 *
 * In this case, the last group will have fewer than 4 characters, and
 * padding will be inferred.  If the group has one or two characters, it decodes
 * to one byte.  If the group has three characters, it decodes to two bytes.
 *
 * @param {string} input Input to decode.
 * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
 * @return {!Array<number>} bytes representing the decoded value.
 */
goog.crypt.base64.decodeStringToByteArray = function(input, opt_webSafe) {
  goog.crypt.base64.init_();

  var charToByteMap = opt_webSafe ?
                      goog.crypt.base64.charToByteMapWebSafe_ :
                      goog.crypt.base64.charToByteMap_;

  var output = [];

  for (var i = 0; i < input.length; ) {
    var byte1 = charToByteMap[input.charAt(i++)];

    var haveByte2 = i < input.length;
    var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
    ++i;

    var haveByte3 = i < input.length;
    var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
    ++i;

    var haveByte4 = i < input.length;
    var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
    ++i;

    if (byte1 == null || byte2 == null ||
        byte3 == null || byte4 == null) {
      throw Error();
    }

    var outByte1 = (byte1 << 2) | (byte2 >> 4);
    output.push(outByte1);

    if (byte3 != 64) {
      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);
      output.push(outByte2);

      if (byte4 != 64) {
        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;
        output.push(outByte3);
      }
    }
  }

  return output;
};


/**
 * Lazy static initialization function. Called before
 * accessing any of the static map variables.
 * @private
 */
goog.crypt.base64.init_ = function() {
  if (!goog.crypt.base64.byteToCharMap_) {
    goog.crypt.base64.byteToCharMap_ = {};
    goog.crypt.base64.charToByteMap_ = {};
    goog.crypt.base64.byteToCharMapWebSafe_ = {};
    goog.crypt.base64.charToByteMapWebSafe_ = {};

    // We want quick mappings back and forth, so we precompute two maps.
    for (var i = 0; i < goog.crypt.base64.ENCODED_VALS.length; i++) {
      goog.crypt.base64.byteToCharMap_[i] =
          goog.crypt.base64.ENCODED_VALS.charAt(i);
      goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[i]] = i;
      goog.crypt.base64.byteToCharMapWebSafe_[i] =
          goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i);
      goog.crypt.base64.charToByteMapWebSafe_[
          goog.crypt.base64.byteToCharMapWebSafe_[i]] = i;

      // Be forgiving when decoding and correctly decode both encodings.
      if (i >= goog.crypt.base64.ENCODED_VALS_BASE.length) {
        goog.crypt.base64.charToByteMap_[
            goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
        goog.crypt.base64.charToByteMapWebSafe_[
            goog.crypt.base64.ENCODED_VALS.charAt(i)] = i;
      }
    }
  }
};

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.imgtools');
goog.require('goog.asserts');
goog.require('goog.crypt.base64');
goog.require('goog.math.Size');

goog.scope(function() {
  var _ = w69b.imgtools;
  var Size = goog.math.Size;
  var base64 = goog.crypt.base64;

  /**
   * Get content of canvas as png stored in a blob.
   * @param {HTMLCanvasElement} canvas canvas element.
   * @param {function(Blob)} callback called with blob data.
   */
  _.getCanvasAsBlob = function(canvas, callback) {
    if (canvas['toBlob']) {
      // toBlob supported
      canvas['toBlob'](callback);
    } else if (canvas.toDataURL) {
      var url = canvas.toDataURL();
      var prefix = 'data:image/png;base64,';
      if (!goog.string.startsWith(url, prefix))
        throw Error();
      var data = url.substring(prefix.length);
      data = new Uint8Array(base64.decodeStringToByteArray(data));
      var blob = new Blob([data], {'type': 'image/png'});
      callback(blob);
    } else {
      throw Error();
    }
  };

  /**
   * Get Image data of given Image object. Same origin policy applies to
   * image src. Image has to be loaded. Image is scaled down to opt_maxSize
   * if its width or height is larger.
   * @param {Image|HTMLVideoElement} img image.
   * @param {(number|Size)=} opt_maxSize max size of any dimension in pixels or Size object
   * that img data should cover (cropping bottom-right corners).
   * @return {!ImageData} image data.
   */
  _.getImageData = function(img, opt_maxSize) {
    var size = new Size(
      /** @type {number} */ (img.width || img.videoWidth),
      /** @type {number} */ (img.height || img.videoHeight));

    goog.asserts.assert(size.width > 0 && size.height > 0);
    var canvas = document.createElement('canvas');
    if (opt_maxSize) {
      if (goog.isNumber(opt_maxSize)) {
        opt_maxSize = new Size(opt_maxSize, opt_maxSize);
        if (!size.fitsInside(opt_maxSize))
          size = size.scaleToFit(opt_maxSize);
      } else {
        if (!size.fitsInside(opt_maxSize))
          size = size.scaleToCover(opt_maxSize);
      }
      size.floor();
    }
    canvas.width = size.width;
    canvas.height = size.height;
    var context = canvas.getContext('2d');
    context.drawImage(img, 0, 0, size.width, size.height);
    return context.getImageData(0, 0, size.width, size.height);
  };

  /**
   * Scales size in-place to fit max if larger keeping the aspect ratio.
   * @param {Size} size original size.
   * @param {number} max size in pixels.
   */
  _.scaleIfLarger = function(size, max) {
    var s = Math.min(max / size.width, max / size.height);
    if (s <= 1) {
      size.scale(s).round();
    }
  };

  goog.exportSymbol('w69b.imgtools.getImageData', _.getImageData);
  goog.exportSymbol('w69b.imgtools.getCanvasAsBlob', _.getCanvasAsBlob);
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.DecodeResult');
goog.require('goog.asserts');
goog.require('w69b.qr.ReaderError');

goog.scope(function() {
  /**
   * Encapsulates decoded result reader error.
   * @param {(string|w69b.qr.ReaderError)} text decoded text or error.
   * @param {Array.<w69b.qr.ResultPoint>=} opt_patterns sed for decoding.
   * @constructor
   */
  w69b.qr.DecodeResult = function(text, opt_patterns) {
    /**
     * @type {(string|w69b.qr.ReaderError)}
     * @private
     */
    this.result_ = text;
    this.patterns_ = opt_patterns || [];
  };
  var pro = w69b.qr.DecodeResult.prototype;

  /**
   * Only available if result is not an error.
   * @return {?string} decoded string.
   */
  pro.getText = function() {
    if (this.isError())
      return null;
    else
      return /** @type {string} */ (this.result_);
  };

  /**
   * @return {boolean} if result was an error.
   */
  pro.isError = function() {
    return (this.result_ instanceof w69b.qr.ReaderError);
  };

  /**
   * @return {?w69b.qr.ReaderError} error.
   */
  pro.getError = function() {
    if (this.isError())
      return /** @type {w69b.qr.ReaderError} */ (this.result_);
    else
      return null;
  };

  /**
   * @return {Array.<w69b.qr.ResultPoint>} decoded string.
   */
  pro.getPatterns = function() {
    return this.patterns_;
  };

  /**
   * @return {Object} JSON object.
   */
  pro['toJSON'] = function() {
    return {
      'text': this.getText(),
      'patterns': this.getPatterns()};
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.ResultPoint');

goog.scope(function() {
  /**
   * @constructor
   * @param {number} posX x pos.
   * @param {number} posY y pos.
   */
  w69b.qr.ResultPoint = function(posX, posY) {
    this.x = posX;
    this.y = posY;
  };
  var ResultPoint = w69b.qr.ResultPoint;
  var pro = ResultPoint.prototype;

  /**
   * @return {number} x pos.
   */
    pro.getX = function() {
    return this.x;
  };

  /**
   * @return {number} y pos.
   */
  pro.getY = function() {
    return this.y;
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.AlignmentPattern');
goog.require('w69b.qr.ResultPoint');

goog.scope(function() {
  /**
   * Encapsulates an alignment pattern, which are the smaller square
   * patterns found in all but the simplest QR Codes.
   * @author Sean Owen
   * ported to js by Manuel Braun
   *
   * @param {number} posX x pos.
   * @param {number} posY y pos.
   * @param {number} estimatedModuleSize module size.
   * @constructor
   * @extends {w69b.qr.ResultPoint}
   */
  w69b.qr.AlignmentPattern = function(posX, posY, estimatedModuleSize) {
    goog.base(this, posX, posY);
    this.count = 1;
    this.estimatedModuleSize = estimatedModuleSize;
  };
  var AlignmentPattern = w69b.qr.AlignmentPattern;
  goog.inherits(AlignmentPattern, w69b.qr.ResultPoint);
  var pro = AlignmentPattern.prototype;

  pro.incrementCount = function() {
    this.count++;
  };

  /**
   * Determines if this alignment pattern "about equals" an alignment
   * pattern at the stated
   * position and size -- meaning, it is at nearly the same center with nearly
   * the same size.
   */
  pro.aboutEquals = function(moduleSize, i, j) {
    if (Math.abs(i - this.y) <= moduleSize &&
      Math.abs(j - this.x) <= moduleSize) {
      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
      return moduleSizeDiff <= 1.0 ||
        moduleSizeDiff / this.estimatedModuleSize <= 1.0;
    }
    return false;
  };

  /**
   * @return {number} module size.
   */
  pro.getEstimatedModuleSize = function() {
    return this.estimatedModuleSize;
  };

  /**
   * Combines this object's current estimate of a finder pattern position
   * and module size
   * with a new estimate.
   * @return {AlignmentPattern} a new containing an average of the two.
   */
  pro.combineEstimate = function(i, j, newModuleSize) {
    var combinedX = (this.x + j) / 2.0;
    var combinedY = (this.y + i) / 2.0;
    var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;
    return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
  };


  /**
   * @return {Object} JSON object for pattern.
   */
  pro['toJSON'] = function() {
    return {
      'x': this.getX(),
      'y': this.getY(),
      'size': this.getEstimatedModuleSize()};
  };



});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011
 lazarsoft@gmail.com, www.lazarsoft.info
 */
/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


goog.provide('w69b.qr.AlignmentPatternFinder');
goog.require('w69b.img.BitMatrixLike');
goog.require('w69b.qr.AlignmentPattern');
goog.require('w69b.qr.NotFoundError');


goog.scope(function() {
  var AlignmentPattern = w69b.qr.AlignmentPattern;
  var NotFoundError = w69b.qr.NotFoundError;
  /**
   * This class attempts to find alignment patterns in a QR Code.
   * Alignment patterns look like finder
   * patterns but are smaller and appear at regular intervals throughout the
   * image.
   *
   * At the moment this only looks for the bottom-right alignment pattern.
   *
   *
   * This is mostly a simplified copy of {@link FinderPatternFinder}.
   * It is copied,
   * pasted and stripped down here for maximum performance but does
   * unfortunately duplicate
   * some code.
   *
   * This class is thread-safe but not reentrant. Each thread must allocate
   * its own object.
   *
   * @author Sean Owen
   * @author mb@w69b.com (Manuel Braun) - ported to js
   *
   * @constructor
   * @param {!w69b.img.BitMatrixLike} image image to search.
   * @param {number} startX left column from which to start searching.
   * @param {number} startY stat top row from which to start searching.
   * @param {number} width width of region to search.
   * @param {number} height height of region to search.
   * @param {number} moduleSize size module size so far.
   * @param {?w69b.qr.ResultPointCallback} resultPointCallback callback.
   */
  w69b.qr.AlignmentPatternFinder = function(image, startX, startY, width,
                                            height, moduleSize,
                                            resultPointCallback) {
    /**
     * @type {!w69b.img.BitMatrixLike}
     */
    this.image = image;
    this.possibleCenters = [];
    this.startX = startX;
    this.startY = startY;
    this.width = width;
    this.height = height;
    this.moduleSize = moduleSize;
    this.crossCheckStateCount = new Array(0, 0, 0);
    this.resultPointCallback = resultPointCallback;
  };
  var AlignmentPatternFinder = w69b.qr.AlignmentPatternFinder;
  var pro = AlignmentPatternFinder.prototype;

  pro.centerFromEnd = function(stateCount, end) {
    return (end - stateCount[2]) - stateCount[1] / 2.0;
  };
  pro.foundPatternCross = function(stateCount) {
    var moduleSize = this.moduleSize;
    var maxVariance = moduleSize / 2.0;
    for (var i = 0; i < 3; i++) {
      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
        return false;
      }
    }
    return true;
  };

  pro.crossCheckVertical = function(startI, centerJ, maxCount,
                                    originalStateCountTotal) {
    var image = this.image;

    var maxI = image.getHeight();
    var stateCount = this.crossCheckStateCount;
    stateCount[0] = 0;
    stateCount[1] = 0;
    stateCount[2] = 0;

    // Start counting up from center
    var i = startI;
    while (i >= 0 && image.get(centerJ, i) &&
      stateCount[1] <= maxCount) {
      stateCount[1]++;
      i--;
    }
    // If already too many modules in this state or ran off the edge:
    if (i < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i >= 0 && !image.get(centerJ, + i) &&
      stateCount[0] <= maxCount) {
      stateCount[0]++;
      i--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }

    // Now also count down from center
    i = startI + 1;
    while (i < maxI && image.get(centerJ, i) &&
      stateCount[1] <= maxCount) {
      stateCount[1]++;
      i++;
    }
    if (i == maxI || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i < maxI && !image.get(centerJ, i) &&
      stateCount[2] <= maxCount) {
      stateCount[2]++;
      i++;
    }
    if (stateCount[2] > maxCount) {
      return NaN;
    }

    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >=
      2 * originalStateCountTotal) {
      return NaN;
    }

    return this.foundPatternCross(stateCount) ?
      this.centerFromEnd(stateCount,
        i) : NaN;
  };

  /** <p>This method attempts to find the bottom-right alignment pattern in the
   * image. It is a bit messy since it's pretty performance-critical and so is
   * written to be fast foremost.</p>
   *
   * @return {AlignmentPattern} if found throws NotFoundError if not
   * found.
   */
  pro.handlePossibleCenter = function(stateCount, i, j) {
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
    var centerJ = this.centerFromEnd(stateCount, j);
    var centerI = this.crossCheckVertical(i, Math.floor(centerJ),
      2 * stateCount[1], stateCountTotal);
    if (!isNaN(centerI)) {
      var estimatedModuleSize = (stateCount[0] + stateCount[1] +
        stateCount[2]) / 3.0;
      var max = this.possibleCenters.length;
      for (var index = 0; index < max; index++) {
        var center = this.possibleCenters[index];
        // Look for about the same center and module size:
        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
          return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
        }
      }
      // Hadn't found this before; save it
      var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
      this.possibleCenters.push(point);
      if (this.resultPointCallback != null) {
        this.resultPointCallback(point);
      }
    }
    return null;
  };

  /** <p>This method attempts to find the bottom-right alignment pattern in the
   * image. It is a bit messy since it's pretty performance-critical and so is
   * written to be fast foremost.</p>
   *
   * @return {AlignmentPattern} if found NotFoundException if not
   * found.
   */

  pro.find = function() {
    var startX = this.startX;
    var height = this.height;
    var image = this.image;
    var maxJ = startX + this.width;
    var middleI = this.startY + (height >> 1);
    // We are looking for black/white/black modules in 1:1:1 ratio;
    // this tracks the number of black/white/black modules seen so far
    var stateCount = new Array(0, 0, 0);
    for (var iGen = 0; iGen < height; iGen++) {
      // Search from middle outwards
      var i = middleI +
        ((iGen & 0x01) == 0 ? ((iGen + 1) >> 1) : -((iGen + 1) >> 1));
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;
      var j = startX;
      // Burn off leading white pixels before anything else; if we start in the
      // middle of a white run, it doesn't make sense to count its length,
      // since we don't know if the white run continued to the left of the
      // start point
      while (j < maxJ && image.get(j, i)) {
        j++;
      }
      var currentState = 0;
      while (j < maxJ) {
        if (image.get(j, i)) {
          // Black pixel
          if (currentState == 1) {
            // Counting black pixels
            stateCount[currentState]++;
          } else {
            // Counting white pixels
            if (currentState == 2) {
              // A winner?
              if (this.foundPatternCross(stateCount)) {
                // Yes
                var confirmed = this.handlePossibleCenter(stateCount, i, j);
                if (confirmed != null) {
                  return confirmed;
                }
              }
              stateCount[0] = stateCount[2];
              stateCount[1] = 1;
              stateCount[2] = 0;
              currentState = 1;
            } else {
              stateCount[++currentState]++;
            }
          }
        } else {
          // White pixel
          if (currentState == 1) {
            // Counting black pixels
            currentState++;
          }
          stateCount[currentState]++;
        }
        j++;
      }
      if (this.foundPatternCross(stateCount)) {
        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
        if (confirmed != null) {
          return confirmed;
        }
      }
    }

    // Hmm, nothing we saw was observed and confirmed twice. If we had
    // any guess at all, return it.
    if (this.possibleCenters.length > 0) {
      return this.possibleCenters[0];
    }

    throw new NotFoundError();
  };
});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.BitMatrix');
goog.require('w69b.img.BitMatrixLike');

goog.scope(function() {

  /**
   * @param {number} width width.
   * @param {number=} opt_height height defaults to width.
   * @constructor
   * @implements {w69b.img.BitMatrixLike}
   */
  w69b.qr.BitMatrix = function(width, opt_height) {
    var height = goog.isDef(opt_height) ? opt_height : width;
    if (width < 1 || height < 1) {
      throw Error();
    }
    this.width = width;
    this.height = height;
    var rowSize = width >> 5;
    if ((width & 0x1f) != 0) {
      rowSize++;
    }
    this.rowSize = rowSize;
    this.bits = new Uint32Array(rowSize * height);
  };

  var BitMatrix = w69b.qr.BitMatrix;
  var pro = BitMatrix.prototype;

  /**
   * @return {number} The width of the matrix.
   */
  pro.getWidth = function() {
    return this.width;
  };

  /**
   * @return {number} The height of the matrix.
   */
  pro.getHeight = function() {
    return this.height;
  };


  /**
   * @param {number} x x pos.
   * @param {number} y y pos.
   * @return {boolean} bit at given position.
   */
  pro.get = function(x, y) {
    var offset = y * this.rowSize + (x >> 5);
    return ((this.bits[offset] >> (x & 0x1f)) & 1) != 0;
  };

  /**
   * Set bit at given position.
   * @param {number} x x pos.
   * @param {number} y y pos.
   */
  pro.set = function(x, y) {
    var offset = y * this.rowSize + (x >> 5);
    this.bits[offset] |= 1 << (x & 0x1f);
  };

  /**
   * Flip bit at given position.
   * @param {number} x x pos.
   * @param {number} y y pos.
   */
  pro.flip = function(x, y) {
    var offset = y * this.rowSize + (x >> 5);
    this.bits[offset] ^= 1 << (x & 0x1f);
  };

  /**
   * Clear matrix.
   */
  pro.clear = function() {
    var max = this.bits.length;
    for (var i = 0; i < max; i++) {
      this.bits[i] = 0;
    }
  };

  /**
   * Set bits in given rectangle.
   * @param {number} left left pos.
   * @param {number} top top pos.
   * @param {number} width width.
   * @param {number} height height.
   */
  pro.setRegion = function(left, top, width, height) {
    if (top < 0 || left < 0) {
      throw Error();
    }
    if (height < 1 || width < 1) {
      throw Error();   // Height and width must be at least 1
    }
    var right = left + width;
    var bottom = top + height;
    if (bottom > this.height || right > this.width) {
      throw Error();  // The region must fit inside the matrix
    }
    for (var y = top; y < bottom; y++) {
      var offset = y * this.rowSize;
      for (var x = left; x < right; x++) {
        this.bits[offset + (x >> 5)] |= 1 << (x & 0x1f);
      }
    }
  };

  /**
   * @return {string} matrix as string.
   */
  pro.toString = function() {
    var result = [];
    for (var y = 0; y < this.height; y++) {
      for (var x = 0; x < this.width; x++) {
        result.push(this.get(x, y) ? 'X ' : '  ');
      }
      result.push('\n');
    }
    return result.join('');
  };

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.GridSampler');
goog.provide('w69b.qr.GridSamplerInterface');
goog.require('w69b.qr.NotFoundError');

goog.scope(function() {


  /** Implementations of this class can, given locations of finder patterns for
   * a QR code in an image, sample the right points in the image to reconstruct
   * the QR code, accounting for perspective distortion. It is abstracted since
   * it is relatively expensive and should be allowed to take advantage of
   * platform-specific optimized implementations, like Sun's Java Advanced
   * Imaging library, but which may not be available in other environments such
   * as J2ME, and vice versa.
   *
   * The implementation used can be controlled by calling {
   * setGridSampler(GridSampler)} with an instance of a class which implements
   * this interface.
   *
   * @author Sean Owen
   * @author Manuel Braun (mb@w69b.com) - ported to js
   */

  var _ = w69b.qr.GridSampler;

  _.gridSampler = null;

  /**
   * Sets the implementation of GridSampler used by the library. One global
   * instance is stored, which may sound problematic. But, the implementation
   * provided ought to be appropriate for the entire platform, and all uses of
   * this library in the whole lifetime of the JVM. For instance, an Android
   * activity can swap in an implementation that takes advantage of native
   * platform libraries.
   *
   * @param {w69b.qr.GridSamplerInterface} newGridSampler The
   * platform-specific object to install.
   */
  _.setGridSampler = function(newGridSampler) {
    _.gridSampler = newGridSampler;
  };

  /**
   * @return {w69b.qr.GridSamplerInterface} the current implementation of GridSampler.
   */
  _.getInstance = function() {
    return _.gridSampler;
  };

  /**
   * Grid sample interface.
   * @interface
   */
  w69b.qr.GridSamplerInterface = function() {
  };

  /**
   * Samples an image for a rectangular matrix of bits of the given dimension.
   * @param {w69b.qr.BitMatrix} image image to sample.
   * @param {number} dimensionX width of BitMatrix to sample from image.
   * @param {number} dimensionY height of BitMatrix to sample from
   * image.
   * @return {w69b.qr.BitMatrix} representing a grid of points sampled from
   * the image within a region defined by the "from" parameters by the given
   * points is invalid or results in sampling outside the image boundaries.
   */
  w69b.qr.GridSamplerInterface.prototype.sampleGrid = function(image, dimensionX, dimensionY,
                                             p1ToX, p1ToY, p2ToX, p2ToY, p3ToX,
                                             p3ToY, p4ToX, p4ToY, p1FromX,
                                             p1FromY, p2FromX, p2FromY,
                                             p3FromX, p3FromY, p4FromX,
                                             p4FromY) {

  };

  /**
   * Samples an image for a rectangular matrix of bits of the given dimension.
   * @param {w69b.qr.BitMatrix} image image to sample.
   * @param {number} dimensionX width of BitMatrix to sample from image.
   * @param {number} dimensionY height of BitMatrix to sample from
   * image.
   * @param {w69b.qr.PerspectiveTransform} transform transformation matrix.
   * @return {w69b.qr.BitMatrix} representing a grid of points sampled from
   * the image within a region defined by the "from" parameters by the given
   * points is invalid or results in sampling outside the image boundaries.
   */
  w69b.qr.GridSamplerInterface.prototype.sampleGridTransform = function(image, dimensionX,
                                                      dimensionY, transform) {
  };

  /**
   * <p>Checks a set of points that have been transformed to sample points on
   * an image against the image's dimensions to see if the point are even
   * within the image.</p>
   *
   * <p>This method will actually "nudge" the endpoints back onto the image if
   * they are found to be barely (less than 1 pixel) off the image. This
   * accounts for imperfect detection of finder patterns in an image where the
   * QR Code runs all the way to the image border.</p>
   *
   * <p>For efficiency, the method will check points from either end of the
   * line until one is found to be within the image. Because the set of points
   * are assumed to be linear, this is valid.</p>
   *
   * @param {w69b.qr.BitMatrix} image image into which the points should map.
   * @param {Array.<number>} points actual points in x1,y1,...,xn,yn form.
   */
  _.checkAndNudgePoints = function(image, points) {
    var width = image.getWidth();
    var height = image.getHeight();
    // Check and nudge points from start until we see some that are OK:
    var nudged = true;
    var x, y, offset;
    for (offset = 0; offset < points.length && nudged; offset += 2) {
      x = points[offset] >> 0;
      y = points[offset + 1] >> 0;
      if (x < -1 || x > width || y < -1 || y > height) {
        throw new w69b.qr.NotFoundError();
      }
      nudged = false;
      if (x == -1) {
        points[offset] = 0.;
        nudged = true;
      } else if (x == width) {
        points[offset] = width - 1;
        nudged = true;
      }
      if (y == -1) {
        points[offset + 1] = 0.;
        nudged = true;
      } else if (y == height) {
        points[offset + 1] = height - 1;
        nudged = true;
      }
    }
    // Check and nudge points from end:
    nudged = true;
    for (offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
      x = points[offset] >> 0;
      y = points[offset + 1] >> 0;
      if (x < -1 || x > width || y < -1 || y > height) {
        throw new w69b.qr.NotFoundError();
      }
      nudged = false;
      if (x == -1) {
        points[offset] = 0.;
        nudged = true;
      } else if (x == width) {
        points[offset] = width - 1;
        nudged = true;
      }
      if (y == -1) {
        points[offset + 1] = 0.;
        nudged = true;
      } else if (y == height) {
        points[offset + 1] = height - 1;
        nudged = true;
      }
    }
  };


});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.PerspectiveTransform');

goog.scope(function() {
  /**
   * @constructor
   */
  w69b.qr.PerspectiveTransform = function(a11, a21, a31, a12, a22, a32, a13,
                                          a23, a33) {
    this.a11 = a11;
    this.a12 = a12;
    this.a13 = a13;
    this.a21 = a21;
    this.a22 = a22;
    this.a23 = a23;
    this.a31 = a31;
    this.a32 = a32;
    this.a33 = a33;
  };
  var PerspectiveTransform = w69b.qr.PerspectiveTransform;
  var pro = PerspectiveTransform.prototype;
  pro.transformPoints1 = function(points) {
    var max = points.length;
    var a11 = this.a11;
    var a12 = this.a12;
    var a13 = this.a13;
    var a21 = this.a21;
    var a22 = this.a22;
    var a23 = this.a23;
    var a31 = this.a31;
    var a32 = this.a32;
    var a33 = this.a33;
    for (var i = 0; i < max; i += 2) {
      var x = points[i];
      var y = points[i + 1];
      var denominator = a13 * x + a23 * y + a33;
      points[i] = (a11 * x + a21 * y + a31) / denominator;
      points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
    }
  };

  pro.transformPoints2 = function(xValues, yValues) {
    var n = xValues.length;
    for (var i = 0; i < n; i++) {
      var x = xValues[i];
      var y = yValues[i];
      var denominator = this.a13 * x + this.a23 * y + this.a33;
      xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
      yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
    }
  };

  pro.buildAdjoint = function() {
    // Adjoint is the transpose of the cofactor matrix:
    return new PerspectiveTransform(this.a22 * this.a33 -
      this.a23 * this.a32,
      this.a23 * this.a31 - this.a21 * this.a33,
      this.a21 * this.a32 - this.a22 * this.a31,
      this.a13 * this.a32 - this.a12 * this.a33,
      this.a11 * this.a33 - this.a13 * this.a31,
      this.a12 * this.a31 - this.a11 * this.a32,
      this.a12 * this.a23 - this.a13 * this.a22,
      this.a13 * this.a21 - this.a11 * this.a23,
      this.a11 * this.a22 - this.a12 * this.a21);
  };

  pro.times = function(other) {
    return new PerspectiveTransform(this.a11 * other.a11 +
      this.a21 * other.a12 + this.a31 * other.a13,
      this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23,
      this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33,
      this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13,
      this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23,
      this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33,
      this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13,
      this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23,
      this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
  };

  PerspectiveTransform.quadrilateralToQuadrilateral = function(
    x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {

    var qToS = PerspectiveTransform.quadrilateralToSquare(
      x0, y0, x1, y1, x2, y2, x3, y3);
    var sToQ = PerspectiveTransform.squareToQuadrilateral(
      x0p, y0p, x1p, y1p, x2p, y2p, x3p,
      y3p);
    return sToQ.times(qToS);
  };

  PerspectiveTransform.squareToQuadrilateral = function(x0, y0, x1, y1,
                                                        x2, y2, x3, y3) {
    var dy2 = y3 - y2;
    var dy3 = y0 - y1 + y2 - y3;
    if (dy2 == 0.0 && dy3 == 0.0) {
      return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1,
        y0,
        0.0, 0.0, 1.0);
    } else {
      var dx1 = x1 - x2;
      var dx2 = x3 - x2;
      var dx3 = x0 - x1 + x2 - x3;
      var dy1 = y1 - y2;
      var denominator = dx1 * dy2 - dx2 * dy1;
      var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
      var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
      return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3,
        x0,
        y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
    }
  };

  PerspectiveTransform.quadrilateralToSquare = function(x0, y0, x1, y1,
                                                        x2, y2, x3, y3) {
    // Here, the adjoint serves as the inverse:
    return PerspectiveTransform.squareToQuadrilateral(
      x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.DefaultGridSampler');
goog.require('w69b.qr.BitMatrix');
goog.require('w69b.qr.GridSampler');
goog.require('w69b.qr.GridSamplerInterface');
goog.require('w69b.qr.PerspectiveTransform');

goog.scope(function() {

  var PerspectiveTransform = w69b.qr.PerspectiveTransform;
  var GridSampler = w69b.qr.GridSampler;
  var BitMatrix = w69b.qr.BitMatrix;
  /**
   * @author Sean Owen
   * @author Manuel Braun (mb@w69b.com) - ported to js.
   * @constructor
   * @implements {w69b.qr.GridSamplerInterface}
   */
  w69b.qr.DefaultGridSampler = function() {
  };
  var pro = w69b.qr.DefaultGridSampler.prototype;

  pro.sampleGrid = function(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX,
                            p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX,
                            p1FromY, p2FromX, p2FromY, p3FromX, p3FromY,
                            p4FromX, p4FromY) {

    var transform = PerspectiveTransform.quadrilateralToQuadrilateral(
      p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY,
      p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);

    return this.sampleGridTransform(image, dimensionX, dimensionY, transform);
  };

  pro.sampleGridTransform = function(image, dimensionX, dimensionY,
                                     transform) {
    if (dimensionX <= 0 || dimensionY <= 0) {
      throw new w69b.qr.NotFoundError();
    }
    var bits = new BitMatrix(dimensionX, dimensionY);
    var points = new Array(dimensionX << 1);
    var x;
    for (var y = 0; y < dimensionY; y++) {
      var max = points.length;
      var iValue = y + 0.5;
      for (x = 0; x < max; x += 2) {
        points[x] = (x >> 1) + 0.5;
        points[x + 1] = iValue;
      }
      transform.transformPoints1(points);
      // Quick check to see if points transformed to something inside the
      // image; sufficient to check the endpoints
      GridSampler.checkAndNudgePoints(image, points);
      try {
        for (x = 0; x < max; x += 2) {
          if (image.get(points[x] >> 0, points[x + 1] >> 0)) {
            // Black(-ish) pixel
            bits.set(x >> 1, y);
          }
        }
      } catch (aioobe) {
        // This feels wrong, but, sometimes if the finder patterns are
        // misidentified, the resulting transform gets "twisted" such that it
        // maps a straight line of points to a set of points whose endpoints
        // are in bounds, but others are not. There is probably some
        // mathematical way to detect this about the transformation that I
        // don't know yet.  This results in an ugly runtime exception despite
        // our clever checks above -- can't have that. We could check each
        // point's coordinates but that feels duplicative. We settle for
        // catching and wrapping ArrayIndexOutOfBoundsException.
        throw new w69b.qr.NotFoundError();
      }
    }
    return bits;
  };

  // set default grid sampler.
  GridSampler.setGridSampler(new w69b.qr.DefaultGridSampler());

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.DecodeHintType');

/**
 * Decode hint key constants.
 * @enum {number}
 */
w69b.qr.DecodeHintType = {
  TRY_HARDER: 1,
  CHARACTER_SET: 2
};

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.FinderPattern');
goog.provide('w69b.qr.FinderPatternInfo');
goog.require('w69b.qr.ResultPoint');

goog.scope(function() {
  /**
   * @param {number} posX x pos.
   * @param {number} posY y pos.
   * @param {number} estimatedModuleSize estimated size.
   * @param {number=} opt_count count, defaults to 1.
   * @extends {w69b.qr.ResultPoint}
   * @constructor
   */
  w69b.qr.FinderPattern = function(posX, posY, estimatedModuleSize,
                                   opt_count) {
    goog.base(this, posX, posY);
    this.count = goog.isDef(opt_count) ? opt_count : 1;
    this.estimatedModuleSize = estimatedModuleSize;
  };
  var FinderPattern = w69b.qr.FinderPattern;
  goog.inherits(FinderPattern, w69b.qr.ResultPoint);
  var pro = FinderPattern.prototype;

  pro.incrementCount = function() {
    this.count++;
  };

  pro.getCount = function() {
    return this.count;
  };

  pro.aboutEquals = function(moduleSize, i, j) {
    if (Math.abs(i - this.y) <= moduleSize &&
      Math.abs(j - this.x) <= moduleSize) {
      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
      return moduleSizeDiff <= 1.0 ||
        moduleSizeDiff <= this.estimatedModuleSize;
    }
    return false;
  };

  /**
   * Combines this object's current estimate of a finder pattern position and
   * module size
   * with a new estimate. It returns a new {@code FinderPattern} containing
   * a weighted average based on count.
   * @param {number} i position.
   * @param {number} j position.
   * @param {number} newModuleSize size.
   * @return {FinderPattern} combined pattern.
   */
  pro.combineEstimate = function(i, j, newModuleSize) {
    var count = this.count;
    var combinedCount = count + 1;
    var combinedX = (count * this.x + j) / combinedCount;
    var combinedY = (count * this.y + i) / combinedCount;
    var combinedModuleSize = (count * this.estimatedModuleSize +
      newModuleSize) / combinedCount;
    return new FinderPattern(combinedX, combinedY,
      combinedModuleSize, combinedCount);
  };



  /**
   * @return {number} module size.
   */
  pro.getEstimatedModuleSize = function() {
    return this.estimatedModuleSize;
  };

  /**
   * @return {number} x pos.
   */
  pro.getX = function() {
    return this.x;
  };

  /**
   * @return {number} y pos.
   */
  pro.getY = function() {
    return this.y;
  };

  /**
   * Orders an array of three ResultPoints in an order [A,B,C] such that
   * AB < AC and
   * BC < AC and
   * the angle between BC and BA is less than 180 degrees.

   * @param {Array.<w69b.qr.FinderPattern>} patterns patterns to sort.
   */
  FinderPattern.orderBestPatterns = function(patterns) {
    function distance(pattern1, pattern2) {
      var xDiff = pattern1.x - pattern2.x;
      var yDiff = pattern1.y - pattern2.y;
      return (xDiff * xDiff + yDiff * yDiff);
    }

    // Returns the z component of the cross product between
    // vectors BC and BA.
    function crossProductZ(pointA, pointB, pointC) {
      var bX = pointB.x;
      var bY = pointB.y;
      return ((pointC.x - bX) * (pointA.y - bY)) -
        ((pointC.y - bY) * (pointA.x - bX));
    }


    // Find distances between pattern centers
    var zeroOneDistance = distance(patterns[0], patterns[1]);
    var oneTwoDistance = distance(patterns[1], patterns[2]);
    var zeroTwoDistance = distance(patterns[0], patterns[2]);

    var pointA, pointB, pointC;
    // Assume one closest to other two is B; A and C will just be guesses at
    // first.
    if (oneTwoDistance >= zeroOneDistance &&
      oneTwoDistance >= zeroTwoDistance) {
      pointB = patterns[0];
      pointA = patterns[1];
      pointC = patterns[2];
    } else if (zeroTwoDistance >= oneTwoDistance &&
      zeroTwoDistance >= zeroOneDistance) {
      pointB = patterns[1];
      pointA = patterns[0];
      pointC = patterns[2];
    } else {
      pointB = patterns[2];
      pointA = patterns[0];
      pointC = patterns[1];
    }

    // Use cross product to figure out whether A and C are correct or flipped.
    // This asks whether BC x BA has a positive z component, which is the
    // arrangement we want for A, B, C. If it's negative, then we've got it
    // flipped around and should swap A and C.
    if (crossProductZ(pointA, pointB, pointC) < 0.0) {
      var temp = pointA;
      pointA = pointC;
      pointC = temp;
    }

    patterns[0] = pointA;
    patterns[1] = pointB;
    patterns[2] = pointC;
  };


  /**
   * @return {Object} JSON object for pattern.
   */
  pro['toJSON'] = function() {
    return {
      'x': this.getX(),
      'y': this.getY(),
      'size': this.getEstimatedModuleSize()};
  };


  /**
   * @param {Array.<FinderPattern>} patternCenters size 3 array with
   * bottom left, top left and top right corner.
   * @constructor
   */
  w69b.qr.FinderPatternInfo = function(patternCenters) {
    // Bottom left and top right is flipped. Why?
    this.bottomLeft = patternCenters[0];
    this.topLeft = patternCenters[1];
    this.topRight = patternCenters[2];
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.FinderPatternFinder');
goog.require('goog.array');
goog.require('w69b.img.BitMatrixLike');
goog.require('w69b.qr.DecodeHintType');
goog.require('w69b.qr.FinderPattern');
goog.require('w69b.qr.FinderPatternInfo');
goog.require('w69b.qr.NotFoundError');
goog.require('w69b.qr.QRImage');


goog.scope(function() {
  var FinderPattern = w69b.qr.FinderPattern;
  var FinderPatternInfo = w69b.qr.FinderPatternInfo;

  /** @typedef {function((w69b.qr.AlignmentPattern|w69b.qr.FinderPattern))} */
  w69b.qr.ResultPointCallback;

  /**
   * <p>This class attempts to find finder patterns in a QR Code. Finder
   * patterns are the square
   * markers at three corners of a QR Code.</p>
   *
   * <p>This class is thread-safe but not reentrant. Each thread must allocate
   * its own object.
   *
   * @author Sean Owen
   * ported to js by Manuel Braun
   */

  /**
   * @param {!w69b.img.BitMatrixLike} image binary image.
   * @param {?w69b.qr.ResultPointCallback=} opt_callback callback.
   * @constructor
   */
  w69b.qr.FinderPatternFinder = function(image, opt_callback) {
    /**
     * @type {!w69b.img.BitMatrixLike}
     * @private
     */
    this.image_ = image;
    /**
     * @type {Array.<FinderPattern>}
     */
    this.possibleCenters_ = [];
    /**
     *
     * @type {Array}
     * @private
     */
    this.crossCheckStateCount_ = new Array(5);
    /**
     * @type {?w69b.qr.ResultPointCallback}
     * @private
     */
    this.resultPointCallback_ = opt_callback || null;
    /**
     * @type {boolean}
     * @private
     */
    this.hasSkipped_ = false;

  };
  var _ = w69b.qr.FinderPatternFinder;
  var pro = w69b.qr.FinderPatternFinder.prototype;

  // manu: changed from 2 to 3 for more robustness.
  _.CENTER_QUORUM = 2;
  _.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center
  _.MAX_MODULES = 57; // support up to version 10 for mobile clients
  _.INTEGER_MATH_SHIFT = 8;

  // Maximum skew error to skip scanning soon.
  _.SKEW_THRESHOLD = 0.05;
  // Precomputed combinations for 3 out of 6.
  _.SKEW_COMBINATIONS = [
    [0, 1, 2],
    [0, 1, 3],
    [0, 1, 4],
    [0, 1, 5],
    [0, 2, 3],
    [0, 2, 4],
    [0, 2, 5],
    [0, 3, 4],
    [0, 3, 5],
    [0, 4, 5],
    [1, 2, 3],
    [1, 2, 4],
    [1, 2, 5],
    [1, 3, 4],
    [1, 3, 5],
    [1, 4, 5],
    [2, 3, 4],
    [2, 3, 5],
    [2, 4, 5],
    [3, 4, 5]
  ];


  /**
   * @param {Object=} opt_hints hints.
   * @return {FinderPatternInfo} info.
   */
  pro.find = function(opt_hints) {
    var tryHarder = opt_hints && !!opt_hints[w69b.qr.DecodeHintType.TRY_HARDER];
    var maxI = this.image_.height;
    var maxJ = this.image_.width;
    // We are looking for black/white/black/white/black modules in
    // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far

    // Let's assume that the maximum version QR Code we support takes up 1/4
    // the height of the
    // this.image_, and then account for the center being 3 modules in size.
    // This gives the smallest
    // number of pixels the center could be, so skip this often. When trying
    // harder, look for all
    // QR versions regardless of how dense they are.
    var iSkip = Math.floor((3 * maxI) / (4 * _.MAX_MODULES));
    if (iSkip < _.MIN_SKIP || tryHarder) {
      iSkip = _.MIN_SKIP;
    }

    var done = false;
    var stateCount = new Array(5);
    var confirmed;
    for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
      // Get a row of black/white values
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;
      stateCount[3] = 0;
      stateCount[4] = 0;
      var currentState = 0;
      for (var j = 0; j < maxJ; j++) {
        if (this.image_.get(j, i)) {
          // Black pixel
          if ((currentState & 1) == 1) { // Counting white pixels
            currentState++;
          }
          stateCount[currentState]++;
        } else { // White pixel
          if ((currentState & 1) == 0) { // Counting black pixels
            if (currentState == 4) { // A winner?
              if (_.foundPatternCross(stateCount)) { // Yes
                confirmed = this.handlePossibleCenter(stateCount, i, j);
                if (confirmed) {
                  // Start examining every other line. Checking each line
                  // turned out to be too
                  // expensive and didn't improve performance.
                  iSkip = 2;
                  if (this.hasSkipped_) {
                    done = this.haveMultiplyConfirmedCenters();
                  } else {
                    var rowSkip = this.findRowSkip();
                    if (rowSkip > stateCount[2]) {
                      // Skip rows between row of lower confirmed center
                      // and top of presumed third confirmed center
                      // but back up a bit to get a full chance of detecting
                      // it, entire width of center of finder pattern

                      // Skip by rowSkip, but back off by stateCount[2]
                      // (size of last center
                      // of pattern we saw) to be conservative, and also
                      // back off by iSkip which
                      // is about to be re-added
                      i += rowSkip - stateCount[2] - iSkip;
                      j = maxJ - 1;
                    }
                  }
                } else {
                  stateCount[0] = stateCount[2];
                  stateCount[1] = stateCount[3];
                  stateCount[2] = stateCount[4];
                  stateCount[3] = 1;
                  stateCount[4] = 0;
                  currentState = 3;
                  continue;
                }
                // Clear state to start looking again
                currentState = 0;
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                stateCount[3] = 0;
                stateCount[4] = 0;
              } else { // No, shift counts back by two
                stateCount[0] = stateCount[2];
                stateCount[1] = stateCount[3];
                stateCount[2] = stateCount[4];
                stateCount[3] = 1;
                stateCount[4] = 0;
                currentState = 3;
              }
            } else {
              stateCount[++currentState]++;
            }
          } else { // Counting white pixels
            stateCount[currentState]++;
          }
        }
      }
      if (_.foundPatternCross(stateCount)) {
        confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
        if (confirmed) {
          iSkip = stateCount[0];
          if (this.hasSkipped_) {
            // Found a third one
            done = this.haveMultiplyConfirmedCenters();
          }
        }
      }
    }

    var patternInfo = this.selectBestPatterns(true);
    w69b.qr.FinderPattern.orderBestPatterns(patternInfo);

    return new FinderPatternInfo(patternInfo);
  };

  /**
   * Given a count of black/white/black/white/black pixels just seen and an
   * end position,
   * figures the location of the center of this run.
   * @param {Array.<number>} stateCount state count.
   * @param {number} end end position.
   * @return {number} position.
   */
  pro.centerFromEnd = function(stateCount, end) {
    return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.;
  };

  /**
   * @param {Array.<number>} stateCount count of
   * black/white/black/white/black pixels just read.
   * @return {boolean} true iff the proportions of the counts is close enough
   * to the 1/1/3/1/1 ratios used by finder patterns to be considered a match.
   */
  _.foundPatternCross = function(stateCount) {
    var totalModuleSize = 0;
    for (var i = 0; i < 5; i++) {
      var count = stateCount[i];
      if (count == 0) {
        return false;
      }
      totalModuleSize += count;
    }
    if (totalModuleSize < 7) {
      return false;
    }
    var moduleSize = Math.floor((totalModuleSize << _.INTEGER_MATH_SHIFT) / 7);
    var maxVariance = Math.floor(moduleSize / 2);
    // Allow less than 50% variance from 1-1-3-1-1 proportions
    return Math.abs(moduleSize - (stateCount[0] << _.INTEGER_MATH_SHIFT)) <
      maxVariance &&
      Math.abs(moduleSize - (stateCount[1] << _.INTEGER_MATH_SHIFT)) <
        maxVariance &&
      Math.abs(3 * moduleSize - (stateCount[2] << _.INTEGER_MATH_SHIFT)) <
        3 * maxVariance &&
      Math.abs(moduleSize - (stateCount[3] << _.INTEGER_MATH_SHIFT)) <
        maxVariance &&
      Math.abs(moduleSize - (stateCount[4] << _.INTEGER_MATH_SHIFT)) <
        maxVariance;
  };

  /**
   * @return {Array.<number>} count.
   */
  pro.getCrossCheckStateCount = function() {
    this.crossCheckStateCount_[0] = 0;
    this.crossCheckStateCount_[1] = 0;
    this.crossCheckStateCount_[2] = 0;
    this.crossCheckStateCount_[3] = 0;
    this.crossCheckStateCount_[4] = 0;
    return this.crossCheckStateCount_;
  };

  /**
   * <p>After a horizontal scan finds a potential finder pattern, this method
   * "cross-checks" by scanning down vertically through the center of the
   * possible finder pattern to see if the same proportion is detected.</p>
   *
   * @param {number} startI row where a finder pattern was detected.
   * @param {number} centerJ center of the section that appears to cross
   * a finder pattern.
   * @param {number} maxCount maximum reasonable number of modules that
   * should beobserved in any reading state, based on the results of the
   * horizontal scan.
   * @param {number} originalStateCountTotal nodoc.
   * @return {number} vertical center of finder pattern, or {@link NaN}
   * if not found.
   */
  pro.crossCheckVertical = function(startI, centerJ, maxCount,
                                    originalStateCountTotal) {
    var image = this.image_;

    var maxI = image.height;
    var stateCount = this.getCrossCheckStateCount();

    // Start counting up from center
    var i = startI;
    while (i >= 0 && image.get(centerJ, i)) {
      stateCount[2]++;
      i--;
    }
    if (i < 0) {
      return NaN;
    }
    while (i >= 0 && !image.get(centerJ, i) &&
      stateCount[1] <= maxCount) {
      stateCount[1]++;
      i--;
    }
    // If already too many modules in this state or ran off the edge:
    if (i < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i >= 0 && image.get(centerJ, i) &&
      stateCount[0] <= maxCount) {
      stateCount[0]++;
      i--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }

    // Now also count down from center
    i = startI + 1;
    while (i < maxI && image.get(centerJ, i)) {
      stateCount[2]++;
      i++;
    }
    if (i == maxI) {
      return NaN;
    }
    while (i < maxI && !image.get(centerJ, i) &&
      stateCount[3] < maxCount) {
      stateCount[3]++;
      i++;
    }
    if (i == maxI || stateCount[3] >= maxCount) {
      return NaN;
    }
    while (i < maxI && image.get(centerJ, i) &&
      stateCount[4] < maxCount) {
      stateCount[4]++;
      i++;
    }
    if (stateCount[4] >= maxCount) {
      return NaN;
    }

    // If we found a finder-pattern-like section, but its size is more than
    // 40% different than the original, assume it's a false positive
    var stateCountTotal = stateCount[0] + stateCount[1] +
      stateCount[2] + stateCount[3] +
      stateCount[4];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >=
      2 * originalStateCountTotal) {
      return NaN;
    }

    return _.foundPatternCross(stateCount) ?
      this.centerFromEnd(stateCount, i) : NaN;
  };

  /**
   * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact
   * is basically identical, except it reads horizontally instead of
   * vertically. This is used to cross-cross check a vertical cross check
   * and locate the real center of the alignment pattern.</p>
   * @param {number} startJ col where a finder pattern was detected.
   * @param {number} centerI center of the section that appears to cross a
   * finder pattern.
   * @param {number} maxCount maximum reasonable number of modules that should
   * be observed in any reading state, based on the results of the horizontal
   * scan.
   * @param {number} originalStateCountTotal nodoc.
   * @return {number} horizontal center of finder pattern, or NaN if not found.
   */
  pro.crossCheckHorizontal = function(startJ, centerI, maxCount,
                                      originalStateCountTotal) {
    var image = this.image_;

    var maxJ = image.width;
    var stateCount = this.getCrossCheckStateCount();

    var j = startJ;
    while (j >= 0 && image.get(j, centerI)) {
      stateCount[2]++;
      j--;
    }
    if (j < 0) {
      return NaN;
    }
    while (j >= 0 && !image.get(j, centerI) &&
      stateCount[1] <= maxCount) {
      stateCount[1]++;
      j--;
    }
    if (j < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (j >= 0 && image.get(j, centerI) &&
      stateCount[0] <= maxCount) {
      stateCount[0]++;
      j--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }

    j = startJ + 1;
    while (j < maxJ && image.get(j, centerI)) {
      stateCount[2]++;
      j++;
    }
    if (j == maxJ) {
      return NaN;
    }
    while (j < maxJ && !image.get(j, centerI) &&
      stateCount[3] < maxCount) {
      stateCount[3]++;
      j++;
    }
    if (j == maxJ || stateCount[3] >= maxCount) {
      return NaN;
    }
    while (j < maxJ && image.get(j, centerI) &&
      stateCount[4] < maxCount) {
      stateCount[4]++;
      j++;
    }
    if (stateCount[4] >= maxCount) {
      return NaN;
    }

    // If we found a finder-pattern-like section, but its size is
    // significantly different than
    // the original, assume it's a false positive
    var stateCountTotal = stateCount[0] + stateCount[1] +
      stateCount[2] + stateCount[3] + stateCount[4];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >=
      originalStateCountTotal) {
      return NaN;
    }

    return _.foundPatternCross(stateCount) ?
      this.centerFromEnd(stateCount, j) : NaN;
  };

  /**
   * <p>This is called when a horizontal scan finds a possible alignment
   * pattern. It will cross check with a vertical scan, and if successful,
   * will, ah, cross-cross-check with another horizontal scan. This is needed
   * primarily to locate the real horizontal center of the pattern in cases of
   * extreme skew.</p>
   *
   * <p>If that succeeds the finder pattern location is added to a list that
   * tracks the number of times each location has been nearly-matched as a
   * finder pattern.  Each additional find is more evidence that the location
   * is in fact a finder pattern center
   *
   * @param {Array.<number>} stateCount reading state module counts from
   * horizontal scan.
   * @param {number} i row where finder pattern may be found.
   * @param {number} j end of possible finder pattern in row.
   * @return {boolean} true if a finder pattern candidate was found this time.
   */
  pro.handlePossibleCenter = function(stateCount, i, j) {
    var stateCountTotal = stateCount[0] + stateCount[1] +
      stateCount[2] + stateCount[3] + stateCount[4];
    var centerJ = this.centerFromEnd(stateCount, j);
    var centerI = this.crossCheckVertical(i, Math.floor(centerJ),
      stateCount[2], stateCountTotal);
    if (!isNaN(centerI)) {
      // Re-cross check
      centerJ = this.crossCheckHorizontal(Math.floor(centerJ),
        Math.floor(centerI), stateCount[2], stateCountTotal);
      if (!isNaN(centerJ)) {
        var estimatedModuleSize = stateCountTotal / 7.;
        var found = false;
        for (var index = 0; index < this.possibleCenters_.length; index++) {
          var center = this.possibleCenters_[index];
          // Look for about the same center and module size:
          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
            this.possibleCenters_[index] =
              center.combineEstimate(centerI, centerJ, estimatedModuleSize);
            found = true;
            break;
          }
        }
        if (!found) {
          var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);
          this.possibleCenters_.push(point);
          if (this.resultPointCallback_ != null) {
            this.resultPointCallback_(point);
          }
        }
        return true;
      }
    }
    return false;
  };

  /**
   * @return {number} number of rows we could safely skip during scanning,
   * based on the first two finder patterns that have been located. In some
   * cases their position will allow us to infer that the third pattern must
   * lie below a certain point farther down in the image.
   */
  pro.findRowSkip = function() {
    var max = this.possibleCenters_.length;
    if (max <= 1) {
      return 0;
    }
    var firstConfirmedCenter = null;
    for (var i = 0; i < this.possibleCenters_.length; ++i) {
      var center = this.possibleCenters_[i];
      if (center.getCount() >= _.CENTER_QUORUM) {
        if (firstConfirmedCenter == null) {
          firstConfirmedCenter = center;
        } else {
          // We have two confirmed centers
          // How far down can we skip before resuming looking for the next
          // pattern? In the worst case, only the difference between the
          // difference in the x / y coordinates of the two centers.
          // This is the case where you find top left last.
          this.hasSkipped_ = true;
          return Math.floor((
            Math.abs(firstConfirmedCenter.getX() - center.getX()) -
              Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
        }
      }
    }
    return 0;
  };

  /**
   * @return {boolean} true iff we have found at least 3 finder patterns that
   * have been detected at least {@link #CENTER_QUORUM} times each, and
   * , the estimated module size of the candidates is "pretty similar".
   */
  pro.haveMultiplyConfirmedCenters = function() {
    var confirmedCount = 0;
    var totalModuleSize = 0.;
    var max = this.possibleCenters_.length;
    this.possibleCenters_.forEach(function(pattern) {
      if (pattern.getCount() >= _.CENTER_QUORUM) {
        confirmedCount++;
        totalModuleSize += pattern.getEstimatedModuleSize();
      }
    }, this);
    if (confirmedCount < 3) {
      return false;
    }
    // OK, we have at least 3 confirmed centers, but, it's possible that one
    // is a "false positive"
    // and that we need to keep looking. We detect this by asking if the
    // estimated module sizes
    // vary too much. We arbitrarily say that when the total deviation
    // from average exceeds
    // 5% of the total module size estimates, it's too much.
    // manu: Does it make sense to divide by max while counting
    // only those with >= CENTER_QUORUM.
    var average = totalModuleSize / max;
    var totalDeviation = 0.;
    this.possibleCenters_.forEach(function(pattern) {
      totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
    });
    if (totalDeviation > 0.05 * totalModuleSize)
      return false;

    // Check skew of best patterns.
    var centers = this.selectBestPatterns();
    var skew = _.computeSkew(centers);

    return skew < _.SKEW_THRESHOLD;
  };

  /**
   * @param {boolean=} opt_checkSkew check skew, defaults to false.
   * @return {Array.<FinderPattern>} the 3 best FinderPatterns from our list
   * of candidates. The "best" are those that have been detected at
   * least CENTER_QUORUM times, and whose module size differs from the
   * average among those patterns the least.
   */
  pro.selectBestPatterns = function(opt_checkSkew) {
    var startSize = this.possibleCenters_.length;
    if (startSize < 3) {
      // Couldn't find enough finder patterns
      throw new w69b.qr.NotFoundError();
    }
    var average;
    var centers = goog.array.clone(this.possibleCenters_);

    // Filter outlier possibilities whose module size is too different
    if (startSize > 3) {
      // But we can only afford to do so if we have at least 4 possibilities
      // to choose from
      var totalModuleSize = 0.;
      var square = 0.;
      centers.forEach(function(center) {
        var size = center.getEstimatedModuleSize();
        totalModuleSize += size;
        square += size * size;
      });
      average = totalModuleSize / startSize;
      var stdDev = Math.sqrt(square / startSize - average * average);

      centers.sort(_.FurthestFromAverageComparator(average));

      var limit = Math.max(0.2 * average, stdDev);

      for (var i = 0; i < centers.length &&
        centers.length > 3; i++) {
        var pattern = centers[i];
        if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
          goog.array.removeAt(centers, i);
          i--;
        }
      }
    }

    if (centers.length > 3) {
      // Throw away all but those first size candidate points we found.

      totalModuleSize = 0.;
      centers.forEach(function(possibleCenter) {
        totalModuleSize += possibleCenter.getEstimatedModuleSize();
      });

      average = totalModuleSize / centers.length;

      centers.sort(_.CenterComparator(average));

      if (opt_checkSkew) {
        // check skew error of first few sets.
        var withSkew = _.getCombinations(centers).map(function(combination) {
          return {centers: combination,
            skew: _.computeSkew(combination)};
        });
        withSkew.sort(function(a, b) {
          return goog.array.defaultCompare(a.skew, b.skew);
        });
        // pick canidates with lowest skew.
        centers = withSkew[0].centers;
      } else {
        centers = centers.slice(0, 3);
      }


    }

    return centers;
  };

  /**
   * Get c
   * @param {Array.<FinderPattern>} centers finder pattern candidates.
   * @return {Array.<Array.<FinderPattern>>} result.
   */
  _.getCombinations = function(centers) {
    var len = centers.length;
    var result = [];
    _.SKEW_COMBINATIONS.forEach(function(indices) {
      if (indices[0] < len && indices[1] && len && indices[2] < len) {
        result.push([centers[indices[0]], centers[indices[1]],
          centers[indices[2]]]);
      }
    });
    return result;
  };

  /**
   * <p>Orders by furthest from average</p>
   * @param {number} average average.
   * @return {function(FinderPattern, FinderPattern):number} compare function.
   */
  _.FurthestFromAverageComparator = function(average) {
    return function(center1, center2) {
      var dA = Math.abs(center2.getEstimatedModuleSize() - average);
      var dB = Math.abs(center1.getEstimatedModuleSize() - average);
      return dA < dB ? -1 : dA == dB ? 0 : 1;
    };
  };

  /**
   * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
   * @param {number} average average.
   * @return {function(FinderPattern, FinderPattern):number} compare function.
   */
  _.CenterComparator = function(average) {
    return function(center1, center2) {
      if (center2.getCount() == center1.getCount()) {
        var dA = Math.abs(center2.getEstimatedModuleSize() - average);
        var dB = Math.abs(center1.getEstimatedModuleSize() - average);
        return dA < dB ? 1 : dA == dB ? 0 : -1;
      } else {
        return center2.getCount() - center1.getCount();
      }
    };
  };

  /**
   * Computes a - b / |a-b|.
   * @param {w69b.qr.ResultPoint} pattern1 a.
   * @param {w69b.qr.ResultPoint} pattern2 b.
   * @return {Array.<number>} result as array [x, y].
   */
  _.diff = function(pattern1, pattern2) {
    var diffX = pattern1.getX() - pattern2.getX();
    var diffY = pattern1.getY() - pattern2.getY();
    var len = Math.sqrt(diffX * diffX + diffY * diffY);
    return [diffX / len, diffY / len];
  };

  /**
   * Scalar product
   * @param {Array.<number>} a vector a.
   * @param {Array.<number>} b vector a.
   * @return {number} scalar product.
   */
  _.scalarProduct = function(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  };

  // Square root of 1/2
  _.SQRT_05 = Math.sqrt(0.5);
  /**
   * Computes a number that expresses how good alignement of the givevn
   * patterns can be explained by a simliarity transformation. This
   * assumes that they are oriented in triangular shape.
   * @param {Array.<w69b.qr.ResultPoint>} patterns array of size 3.
   * @return {number} skew error.
   */
  _.computeSkew = function(patterns) {
    var diff01 = _.diff(patterns[0], patterns[1]);
    var diff02 = _.diff(patterns[0], patterns[2]);
    var diff12 = _.diff(patterns[1], patterns[2]);
    var scalars = [Math.abs(_.scalarProduct(diff01, diff02)),
      Math.abs(_.scalarProduct(diff01, diff12)),
      Math.abs(_.scalarProduct(diff02, diff12))
    ];

    scalars.sort();
    var error = scalars[0] +
      Math.abs(scalars[1] - _.SQRT_05) +
      Math.abs(scalars[2] - _.SQRT_05);
    return error;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.MathUtils');

goog.scope(function() {
  var _ = w69b.qr.MathUtils;

  /**
   * Euclidean distance.
   */
  _.distance = function(aX, aY, bX, bY) {
    var xDiff = aX - bX;
    var yDiff = aY - bY;
    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  };


});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.Version');
goog.require('w69b.qr.BitMatrix');
goog.require('w69b.qr.FormatError');

goog.scope(function() {
  var FormatError = w69b.qr.FormatError;
  /**
   * @constructor
   */
  w69b.qr.ECB = function(count, dataCodewords) {
    this.count = count;
    this.dataCodewords = dataCodewords;
  };
  var ECB = w69b.qr.ECB;

  /**
   * @constructor
   * @param {number} ecCodewordsPerBlock code words per block.
   * @param {!ECB} ecBlocks1 block1.
   * @param {ECB=} opt_ecBlocks2 block2.
   */
  w69b.qr.ECBlocks = function(ecCodewordsPerBlock, ecBlocks1, opt_ecBlocks2) {
    this.ecCodewordsPerBlock = ecCodewordsPerBlock;
    if (opt_ecBlocks2)
      this.ecBlocks = [ecBlocks1, opt_ecBlocks2];
    else
      this.ecBlocks = [ecBlocks1];

  };
  var ECBlocks = w69b.qr.ECBlocks;

  ECBlocks.prototype.getECBlocks = function() {
    return this.ecBlocks;
  };

  ECBlocks.prototype.getTotalECCodewords = function() {
    return this.ecCodewordsPerBlock * this.getNumBlocks();
  };

  ECBlocks.prototype.getNumBlocks = function() {
    var total = 0;
    for (var i = 0; i < this.ecBlocks.length; i++) {
      total += this.ecBlocks[i].count;
    }
    return total;
  };

  /**
   * @constructor
   */
  w69b.qr.Version = function(versionNumber, alignmentPatternCenters, ecBlocks1,
                             ecBlocks2, ecBlocks3, ecBlocks4) {
    /**
     * @type {number}
     */
    this.versionNumber = versionNumber;
    this.alignmentPatternCenters = alignmentPatternCenters;
    this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);

    var total = 0;
    var ecCodewords = ecBlocks1.ecCodewordsPerBlock;
    var ecbArray = ecBlocks1.getECBlocks();
    for (var i = 0; i < ecbArray.length; i++) {
      var ecBlock = ecbArray[i];
      total += ecBlock.count * (ecBlock.dataCodewords + ecCodewords);
    }
    this.totalCodewords = total;
  };
  var Version = w69b.qr.Version;
  var pro = Version.prototype;

  pro.getVersionNumber = function() {
    return this.versionNumber;
  };

  pro.getTotalCodewords = function() {
    return this.totalCodewords;
  };

  /**
   * @return {string} debug string.
   */
  pro.toString = function() {
    return '' + this.versionNumber;
  };

  /**
   * @return {number} dimension.
   */
  pro.getDimensionForVersion = function() {
    return 17 + 4 * this.versionNumber;
  };

  pro.buildFunctionPattern = function() {
    var dimension = this.getDimensionForVersion();
    var bitMatrix = new w69b.qr.BitMatrix(dimension);

    // Top left finder pattern + separator + format
    bitMatrix.setRegion(0, 0, 9, 9);
    // Top right finder pattern + separator + format
    bitMatrix.setRegion(dimension - 8, 0, 8, 9);
    // Bottom left finder pattern + separator + format
    bitMatrix.setRegion(0, dimension - 8, 9, 8);

    // Alignment patterns
    var max = this.alignmentPatternCenters.length;
    for (var x = 0; x < max; x++) {
      var i = this.alignmentPatternCenters[x] - 2;
      for (var y = 0; y < max; y++) {
        if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {
          // No alignment patterns near the three finder paterns
          continue;
        }
        bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
      }
    }

    // Vertical timing pattern
    bitMatrix.setRegion(6, 9, 1, dimension - 17);
    // Horizontal timing pattern
    bitMatrix.setRegion(9, 6, dimension - 17, 1);

    if (this.versionNumber > 6) {
      // Version info, top right
      bitMatrix.setRegion(dimension - 11, 0, 3, 6);
      // Version info, bottom left
      bitMatrix.setRegion(0, dimension - 11, 6, 3);
    }

    return bitMatrix;
  };
  pro.getECBlocksForLevel = function(ecLevel) {
    return this.ecBlocks[ecLevel.ordinal];
  };

  Version.VERSION_DECODE_INFO = new Array(0x07C94, 0x085BC, 0x09A99, 0x0A4D3,
    0x0BBF6, 0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78, 0x1145D, 0x12A17,
    0x13532, 0x149A6, 0x15683, 0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,
    0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250, 0x209D5, 0x216F0, 0x228BA,
    0x2379F, 0x24B0B, 0x2542E, 0x26A64, 0x27541, 0x28C69);

  Version.VERSIONS = function() {
    return new Array(new Version(1, [],
      new ECBlocks(7, new ECB(1, 19)),
      new ECBlocks(10, new ECB(1, 16)), new ECBlocks(13, new ECB(1, 13)),
      new ECBlocks(17, new ECB(1, 9))),
      new Version(2, new Array(6, 18), new ECBlocks(10, new ECB(1, 34)),
        new ECBlocks(16, new ECB(1, 28)), new ECBlocks(22, new ECB(1, 22)),
        new ECBlocks(28, new ECB(1, 16))),
      new Version(3, new Array(6, 22), new ECBlocks(15, new ECB(1, 55)),
        new ECBlocks(26, new ECB(1, 44)), new ECBlocks(18, new ECB(2, 17)),
        new ECBlocks(22, new ECB(2, 13))),
      new Version(4, new Array(6, 26), new ECBlocks(20, new ECB(1, 80)),
        new ECBlocks(18, new ECB(2, 32)), new ECBlocks(26, new ECB(2, 24)),
        new ECBlocks(16, new ECB(4, 9))),
      new Version(5, new Array(6, 30), new ECBlocks(26, new ECB(1, 108)),
        new ECBlocks(24, new ECB(2, 43)),
        new ECBlocks(18, new ECB(2, 15), new ECB(2, 16)),
        new ECBlocks(22, new ECB(2, 11), new ECB(2, 12))),
      new Version(6, new Array(6, 34), new ECBlocks(18, new ECB(2, 68)),
        new ECBlocks(16, new ECB(4, 27)), new ECBlocks(24, new ECB(4, 19)),
        new ECBlocks(28, new ECB(4, 15))),
      new Version(7, new Array(6, 22, 38), new ECBlocks(20, new ECB(2, 78)),
        new ECBlocks(18, new ECB(4, 31)),
        new ECBlocks(18, new ECB(2, 14), new ECB(4, 15)),
        new ECBlocks(26, new ECB(4, 13), new ECB(1, 14))),
      new Version(8, new Array(6, 24, 42), new ECBlocks(24, new ECB(2, 97)),
        new ECBlocks(22, new ECB(2, 38), new ECB(2, 39)),
        new ECBlocks(22, new ECB(4, 18), new ECB(2, 19)),
        new ECBlocks(26, new ECB(4, 14), new ECB(2, 15))),
      new Version(9, new Array(6, 26, 46), new ECBlocks(30, new ECB(2, 116)),
        new ECBlocks(22, new ECB(3, 36), new ECB(2, 37)),
        new ECBlocks(20, new ECB(4, 16), new ECB(4, 17)),
        new ECBlocks(24, new ECB(4, 12), new ECB(4, 13))),
      new Version(10, new Array(6, 28, 50),
        new ECBlocks(18, new ECB(2, 68), new ECB(2, 69)),
        new ECBlocks(26, new ECB(4, 43), new ECB(1, 44)),
        new ECBlocks(24, new ECB(6, 19), new ECB(2, 20)),
        new ECBlocks(28, new ECB(6, 15), new ECB(2, 16))),
      new Version(11, new Array(6, 30, 54), new ECBlocks(20, new ECB(4, 81)),
        new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)),
        new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)),
        new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))),
      new Version(12, new Array(6, 32, 58),
        new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)),
        new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)),
        new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)),
        new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))),
      new Version(13, new Array(6, 34, 62), new ECBlocks(26, new ECB(4, 107)),
        new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)),
        new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)),
        new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))),
      new Version(14, new Array(6, 26, 46, 66),
        new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)),
        new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)),
        new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)),
        new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))),
      new Version(15, new Array(6, 26, 48, 70),
        new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)),
        new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)),
        new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)),
        new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))),
      new Version(16, new Array(6, 26, 50, 74),
        new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)),
        new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)),
        new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)),
        new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))),
      new Version(17, new Array(6, 30, 54, 78),
        new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)),
        new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)),
        new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)),
        new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))),
      new Version(18, new Array(6, 30, 56, 82),
        new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)),
        new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)),
        new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)),
        new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))),
      new Version(19, new Array(6, 30, 58, 86),
        new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)),
        new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)),
        new ECBlocks(26, new ECB(17, 21), new ECB(4, 22)),
        new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))),
      new Version(20, new Array(6, 34, 62, 90),
        new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)),
        new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)),
        new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)),
        new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))),
      new Version(21, new Array(6, 28, 50, 72, 94),
        new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)),
        new ECBlocks(26, new ECB(17, 42)),
        new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)),
        new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))),
      new Version(22, new Array(6, 26, 50, 74, 98),
        new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)),
        new ECBlocks(28, new ECB(17, 46)),
        new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)),
        new ECBlocks(24, new ECB(34, 13))),
      new Version(23, new Array(6, 30, 54, 74, 102),
        new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)),
        new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)),
        new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)),
        new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))),
      new Version(24, new Array(6, 28, 54, 80, 106),
        new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)),
        new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)),
        new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)),
        new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))),
      new Version(25, new Array(6, 32, 58, 84, 110),
        new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)),
        new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)),
        new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)),
        new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))),
      new Version(26, new Array(6, 30, 58, 86, 114),
        new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)),
        new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)),
        new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)),
        new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))),
      new Version(27, new Array(6, 34, 62, 90, 118),
        new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)),
        new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)),
        new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)),
        new ECBlocks(30, new ECB(12, 15), new ECB(28, 16))),
      new Version(28, new Array(6, 26, 50, 74, 98, 122),
        new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)),
        new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)),
        new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)),
        new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))),
      new Version(29, new Array(6, 30, 54, 78, 102, 126),
        new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)),
        new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)),
        new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)),
        new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))),
      new Version(30, new Array(6, 26, 52, 78, 104, 130),
        new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)),
        new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)),
        new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)),
        new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))),
      new Version(31, new Array(6, 30, 56, 82, 108, 134),
        new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)),
        new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)),
        new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)),
        new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))),
      new Version(32, new Array(6, 34, 60, 86, 112, 138),
        new ECBlocks(30, new ECB(17, 115)),
        new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)),
        new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)),
        new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))),
      new Version(33, new Array(6, 30, 58, 86, 114, 142),
        new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)),
        new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)),
        new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)),
        new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))),
      new Version(34, new Array(6, 34, 62, 90, 118, 146),
        new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)),
        new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)),
        new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)),
        new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))),
      new Version(35, new Array(6, 30, 54, 78, 102, 126, 150),
        new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)),
        new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)),
        new ECBlocks(30, new ECB(39, 24), new ECB(14, 25)),
        new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))),
      new Version(36, new Array(6, 24, 50, 76, 102, 128, 154),
        new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)),
        new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)),
        new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)),
        new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))),
      new Version(37, new Array(6, 28, 54, 80, 106, 132, 158),
        new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)),
        new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)),
        new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)),
        new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))),
      new Version(38, new Array(6, 32, 58, 84, 110, 136, 162),
        new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)),
        new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)),
        new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)),
        new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))),
      new Version(39, new Array(6, 26, 54, 82, 110, 138, 166),
        new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)),
        new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)),
        new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)),
        new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))),
      new Version(40, new Array(6, 30, 58, 86, 114, 142, 170),
        new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)),
        new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)),
        new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)),
        new ECBlocks(30, new ECB(20, 15), new ECB(61, 16))));
  }();

  Version.getVersionForNumber = function(versionNumber) {
    if (versionNumber < 1 || versionNumber > 40) {
      throw new FormatError();
    }
    return Version.VERSIONS[versionNumber - 1];
  };

  Version.getProvisionalVersionForDimension = function(dimension) {
    if (dimension % 4 != 1) {
      throw new FormatError();
    }
    return Version.getVersionForNumber((dimension - 17) >> 2);
  };

  Version.decodeVersionInformation = function(versionBits) {
    var bestDifference = 0xffffffff;
    var bestVersion = 0;
    for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
      var targetVersion = Version.VERSION_DECODE_INFO[i];
      // Do the version info bits match exactly? done.
      if (targetVersion == versionBits) {
        return Version.getVersionForNumber(i + 7);
      }
      // Otherwise see if this is the closest to a real version info bit string
      // we have seen so far
      var bitsDifference = w69b.qr.FormatInformation.numBitsDiffering(
        versionBits, targetVersion);
      if (bitsDifference < bestDifference) {
        bestVersion = i + 7;
        bestDifference = bitsDifference;
      }
    }
    // We can tolerate up to 3 bits of error since no two version info codewords
    // will differ in less than 4 bits.
    if (bestDifference <= 3) {
      return Version.getVersionForNumber(bestVersion);
    }
    // If we didn't find a close enough match, fail
    return null;
  };
});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.Detector');
goog.require('w69b.img.BitMatrixLike');
goog.require('w69b.qr.AlignmentPattern');
goog.require('w69b.qr.AlignmentPatternFinder');
goog.require('w69b.qr.BitMatrix');
goog.require('w69b.qr.DefaultGridSampler');
goog.require('w69b.qr.FinderPatternFinder');
goog.require('w69b.qr.MathUtils');
goog.require('w69b.qr.NotFoundError');
goog.require('w69b.qr.Version');


goog.scope(function() {
  var Version = w69b.qr.Version;
  var PerspectiveTransform = w69b.qr.PerspectiveTransform;
  var NotFoundError = w69b.qr.NotFoundError;
  var MathUtils = w69b.qr.MathUtils;
  var AlignmentPattern = w69b.qr.AlignmentPattern;

  /**
   * @constructor
   */
  w69b.qr.DetectorResult = function(bits, points) {
    this.bits = bits;
    this.points = points;
  };
  var DetectorResult = w69b.qr.DetectorResult;

  /**
   * Encapsulates logic that can detect a QR Code in an image, even if the
   * QR Code is rotated or skewed, or partially obscured.
   *
   * @author Sean Owen
   * @author mb@w69b.com (Manuel Braun) - ported to js
   *
   * @constructor
   * @param {!w69b.img.BitMatrixLike} image the image.
   * @param {?w69b.qr.ResultPointCallback=} opt_callback callback.
   */
  w69b.qr.Detector = function(image, opt_callback) {
    /**
     * @type {!w69b.img.BitMatrixLike}
     */
    this.image = image;
    this.resultPointCallback = opt_callback || null;
  };
  var pro = w69b.qr.Detector.prototype;

  /**
   * <p>This method traces a line from a point in the image, in the
   * direction towards another point.
   * It begins in a black region, and keeps going until it finds white,
   * then black, then white again.
   * It reports the distance from the start to this point.</p>
   *
   * <p>This is used when figuring out how wide a finder pattern is,
   * when the finder pattern may be skewed or rotated.</p>
   */
  /**
   * <p>This method traces a line from a point in the image, in the direction
   * towards another point.
   * It begins in a black region, and keeps going until it finds white, then
   * black, then white again.
   * It reports the distance from the start to this point.</p>
   *
   * <p>This is used when figuring out how wide a finder pattern is, when the
   * finder pattern
   * may be skewed or rotated.</p>
   */
  pro.sizeOfBlackWhiteBlackRun = function(fromX, fromY, toX, toY) {
    // Mild variant of Bresenham's algorithm;
    // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
    if (steep) {
      var temp = fromX;
      fromX = fromY;
      fromY = temp;
      temp = toX;
      toX = toY;
      toY = temp;
    }

    var dx = Math.abs(toX - fromX);
    var dy = Math.abs(toY - fromY);
    var error = -dx >> 1;
    var xstep = fromX < toX ? 1 : -1;
    var ystep = fromY < toY ? 1 : -1;

    // In black pixels, looking for white, first or second time.
    var state = 0;
    // Loop up until x == toX, but not beyond
    var xLimit = toX + xstep;
    for (var x = fromX, y = fromY; x != xLimit; x += xstep) {
      var realX = steep ? y : x;
      var realY = steep ? x : y;

      // Does current pixel mean we have moved white to black or vice versa?
      // Scanning black in state 0,2 and white in state 1, so if we find
      // the wrong
      // color, advance to next state or end if we are in state 2 already
      if ((state == 1) == !!this.image.get(realX, realY)) {
        if (state == 2) {
          return MathUtils.distance(x, y, fromX, fromY);
        }
        state++;
      }

      error += dy;
      if (error > 0) {
        if (y == toY) {
          break;
        }
        y += ystep;
        error -= dx;
      }
    }
    // Found black-white-black; give the benefit of the doubt that the next
    // pixel outside the image
    // is "white" so this last point at (toX+xStep,toY) is the right ending.
    // This is really a
    // small approximation; (toX+xStep,toY+yStep) might be really correct.
    // Ignore this.
    if (state == 2) {
      return MathUtils.distance(toX + xstep, toY, fromX, fromY);
    }
    // else we didn't find even black-white-black; no estimate is really
    // possible
    return NaN;
  };


  /**
   * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes
   * the total width of
   * a finder pattern by looking for a black-white-black run from the center
   * in the direction
   * of another point (another finder pattern center), and in the opposite
   * direction too.</p>
   */
  pro.sizeOfBlackWhiteBlackRunBothWays = function(fromX, fromY, toX, toY) {

    var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);

    // Now count other way -- don't run off image though of course
    var scale = 1.0;
    var otherToX = fromX - (toX - fromX);
    if (otherToX < 0) {
      scale = fromX / (fromX - otherToX);
      otherToX = 0;
    } else if (otherToX >= this.image.width) {
      scale = (this.image.width - 1 - fromX) / (otherToX - fromX);
      otherToX = this.image.width - 1;
    }
    var otherToY = Math.floor(fromY - (toY - fromY) * scale);

    scale = 1.0;
    if (otherToY < 0) {
      scale = fromY / (fromY - otherToY);
      otherToY = 0;
    } else if (otherToY >= this.image.height) {
      scale = (this.image.height - 1 - fromY) / (otherToY - fromY);
      otherToY = this.image.height - 1;
    }
    otherToX = Math.floor(fromX + (otherToX - fromX) * scale);

    result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
    return result - 1.0; // -1 because we counted the middle pixel twice
  };

  /**
   * <p>Estimates module size based on two finder patterns -- it uses
   * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to
   * figure the
   * width of each, measuring along the axis between their centers.</p>
   */
  pro.calculateModuleSizeOneWay = function(pattern, otherPattern) {
    var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
      Math.floor(pattern.x),
      Math.floor(pattern.y), Math.floor(otherPattern.x),
      Math.floor(otherPattern.y));
    var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
      Math.floor(otherPattern.x),
      Math.floor(otherPattern.y), Math.floor(pattern.x),
      Math.floor(pattern.y));
    if (isNaN(moduleSizeEst1)) {
      return moduleSizeEst2 / 7.0;
    }
    if (isNaN(moduleSizeEst2)) {
      return moduleSizeEst1 / 7.0;
    }
    // Average them, and divide by 7 since we've counted the width of 3 black
    // modules, and 1 white and 1 black module on either side. Ergo, divide sum
    // by 14.
    return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
  };

  /**
   * <p>Computes an average estimated module size based on estimated derived
   * from the positions of the three finder patterns.</p>
   */
  pro.calculateModuleSize = function(topLeft, topRight, bottomLeft) {
    // Take the average
    return (this.calculateModuleSizeOneWay(topLeft,
      topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
  };

  pro.distance = function(pattern1, pattern2) {
    var xDiff = pattern1.x - pattern2.x;
    var yDiff = pattern1.y - pattern2.y;
    return Math.sqrt((xDiff * xDiff + yDiff * yDiff));
  };

  pro.computeDimension = function(topLeft, topRight, bottomLeft, moduleSize) {

    var tltrCentersDimension = this.distance(topLeft,
      topRight) / moduleSize;
    var tlblCentersDimension = this.distance(topLeft,
      bottomLeft) / moduleSize;
    var dimension = Math.round((
      tltrCentersDimension + tlblCentersDimension) / 2) + 7;
    switch (dimension % 4) {
      // mod 4
      case 0:
        dimension++;
        break;
      // 1? do nothing

      case 2:
        dimension--;
        break;

      case 3:
        // would it be better to do something like dimension += 2; ?
        // throw new NotFoundError();
        dimension += 2;
    }
    // Sometimes dimension is 17 - which is invalid. Why?
    return dimension;
  };

  /**
   * <p>Attempts to locate an alignment pattern in a limited region of the
   * image, which is
   * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
   *
   * @param {number} overallEstModuleSize estimated module size so far.
   * @param {number} estAlignmentX x coordinate of center of area probably
   * containing alignment pattern.
   * @param {number} estAlignmentY y coordinate of above.
   * @param {number} allowanceFactor number of pixels in all directions to
   * search from the center.
   * @return {AlignmentPattern} if found, or null otherwise.
   */
  pro.findAlignmentInRegion = function(overallEstModuleSize, estAlignmentX,
                                       estAlignmentY, allowanceFactor) {
    // Look for an alignment pattern (3 modules in size) around where it
    // should be
    var allowance = Math.floor(allowanceFactor * overallEstModuleSize);
    var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
    var alignmentAreaRightX = Math.min(this.image.width - 1,
      estAlignmentX + allowance);
    if (alignmentAreaRightX - alignmentAreaLeftX <
      overallEstModuleSize * 3) {
      throw new NotFoundError();
    }

    var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
    var alignmentAreaBottomY = Math.min(this.image.height - 1,
      estAlignmentY + allowance);

    var alignmentFinder = new w69b.qr.AlignmentPatternFinder(this.image,
      alignmentAreaLeftX, alignmentAreaTopY,
      alignmentAreaRightX - alignmentAreaLeftX,
      alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize,
      this.resultPointCallback);
    return alignmentFinder.find();
  };

  pro.createTransform = function(topLeft, topRight, bottomLeft,
                                 alignmentPattern, dimension) {
    var dimMinusThree = dimension - 3.5;
    var bottomRightX;
    var bottomRightY;
    var sourceBottomRightX;
    var sourceBottomRightY;
    if (alignmentPattern != null) {
      bottomRightX = alignmentPattern.x;
      bottomRightY = alignmentPattern.y;
      sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;
    } else {
      // Don't have an alignment pattern, just make up the bottom-right point
      bottomRightX = (topRight.x - topLeft.x) + bottomLeft.x;
      bottomRightY = (topRight.y - topLeft.y) + bottomLeft.y;
      sourceBottomRightX = sourceBottomRightY = dimMinusThree;
    }

    var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5,
      3.5,
      dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5,
      dimMinusThree, topLeft.x, topLeft.y, topRight.x, topRight.y,
      bottomRightX,
      bottomRightY, bottomLeft.x, bottomLeft.y);

    return transform;
  };

  pro.sampleGrid = function(image, transform, dimension) {
    var sampler = w69b.qr.GridSampler.getInstance();
    return sampler.sampleGridTransform(image, dimension, dimension, transform);
  };

  /**
   * TODO.
   * @param {w69b.qr.FinderPatternInfo} info info.
   * @return {!w69b.qr.DetectorResult} result.
   */
  pro.processFinderPatternInfo = function(info) {

    var topLeft = info.topLeft;
    var topRight = info.topRight;
    var bottomLeft = info.bottomLeft;

    var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
    if (moduleSize < 1.0) {
      throw new NotFoundError();
    }
    var dimension = this.computeDimension(topLeft, topRight, bottomLeft,
      moduleSize);
    var provisionalVersion = Version.getProvisionalVersionForDimension(
      dimension);
    var modulesBetweenFPCenters =
      provisionalVersion.getDimensionForVersion() - 7;

    var alignmentPattern = null;
    // Anything above version 1 has an alignment pattern
    if (provisionalVersion.alignmentPatternCenters.length > 0) {

      // Guess where a "bottom right" finder pattern would have been
      var bottomRightX = topRight.x - topLeft.x + bottomLeft.x;
      var bottomRightY = topRight.y - topLeft.y + bottomLeft.y;

      // Estimate that alignment pattern is closer by 3 modules
      // from "bottom right" to known top left location
      var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
      var estAlignmentX = Math.floor(topLeft.x +
        correctionToTopLeft * (bottomRightX - topLeft.x));
      var estAlignmentY = Math.floor(topLeft.y +
        correctionToTopLeft * (bottomRightY - topLeft.y));

      // Kind of arbitrary -- expand search radius before giving up
      for (var i = 4; i <= 16; i *= 2) {
        try {
          alignmentPattern =
            this.findAlignmentInRegion(moduleSize, estAlignmentX,
              estAlignmentY, i);
          break;
        }
        catch (err) {
          if (!(err instanceof NotFoundError))
            throw err;
          // try next round
        }
      }
      // If we didn't find alignment pattern... well try anyway without it
    }

    var transform = this.createTransform(topLeft, topRight, bottomLeft,
      alignmentPattern, dimension);

    var bits = this.sampleGrid(this.image, transform, dimension);

    var points;
    if (alignmentPattern == null) {
      points = [bottomLeft, topLeft, topRight];
    } else {
      points = [bottomLeft, topLeft, topRight, alignmentPattern];
    }
    return new DetectorResult(bits, points);
  };


  /**
   * @return {!w69b.qr.DetectorResult} result.
   */
  pro.detect = function() {
    var info = new w69b.qr.FinderPatternFinder(this.image,
      this.resultPointCallback).find();
    return this.processFinderPatternInfo(info);
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.ErrorCorrectionLevel');

goog.scope(function() {
  /**
   * See ISO 18004:2006, 6.5.1. This enum encapsulates the four error
   * correction levels defined by the QR code standard.
   *
   * @author Sean Owen
   * @author mb@w69b.com (Manuel Braun)
   *
   * @constructor
   */
  w69b.qr.ErrorCorrectionLevel = function(ordinal, bits, name) {
    this.ordinal = ordinal;
    this.bits = bits;
    this.name = name;
  };
  var ErrorCorrectionLevel = w69b.qr.ErrorCorrectionLevel;

  ErrorCorrectionLevel.L = new ErrorCorrectionLevel(0, 0x01, 'L');
  ErrorCorrectionLevel.M = new ErrorCorrectionLevel(1, 0x00, 'M');
  ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(2, 0x03, 'Q');
  ErrorCorrectionLevel.H = new ErrorCorrectionLevel(3, 0x02, 'H');
  ErrorCorrectionLevel.FOR_BITS = [
    ErrorCorrectionLevel.M,
    ErrorCorrectionLevel.L,
    ErrorCorrectionLevel.H,
    ErrorCorrectionLevel.Q];

  /**
   * get by name.
   * @param {string} name one of 'L', 'M', 'Q', 'H';.
   * @return {ErrorCorrectionLevel} ec level or null if name is invalid.
   */
  ErrorCorrectionLevel.getByName = function(name) {
    var map = {'L': ErrorCorrectionLevel.L,
      'M': ErrorCorrectionLevel.M,
      'Q': ErrorCorrectionLevel.Q,
      'H': ErrorCorrectionLevel.H};
    if (map.hasOwnProperty(name)) {
      return map[name];
    } else {
      return null;
    }
  };

  var pro = ErrorCorrectionLevel.prototype;

  pro.getBits = function() {
    return this.bits;
  };

  /**
   * @return {string} debug string.
   */
  pro.toString = function() {
    return this.name;
  };

  /**
   * @param {number} bits int containing the two bits encoding a QR Code's
   * error correction level.
   * @return {!ErrorCorrectionLevel} representing the encoded error
   * correction level.
   */
  ErrorCorrectionLevel.forBits = function(bits) {
    if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.length) {
      throw new Error();
    }
    return ErrorCorrectionLevel.FOR_BITS[bits];
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.FormatInformation');
goog.provide('w69b.qr.URShift');
goog.require('w69b.qr.ErrorCorrectionLevel');

goog.scope(function() {


  /**
   *
   * @param {number} number todo.
   * @param {number} bits todo.
   * @return {number} todo.
   */
  w69b.qr.URShift = function(number, bits) {
    if (number >= 0)
      return number >> bits;
    else
      return (number >> bits) + (2 << ~bits);
  };
  var URShift = w69b.qr.URShift;


  /**
   * @param {number} formatInfo format information.
   * @constructor
   */
  w69b.qr.FormatInformation = function(formatInfo) {
    this.errorCorrectionLevel =
      w69b.qr.ErrorCorrectionLevel.forBits((formatInfo >> 3) & 0x03);
    this.dataMask = (formatInfo & 0x07);
  };
  var FormatInformation = w69b.qr.FormatInformation;
  var pro = FormatInformation.prototype;

  FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;
  FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
    [0x5412, 0x00],
    [0x5125, 0x01],
    [0x5E7C, 0x02],
    [0x5B4B, 0x03],
    [0x45F9, 0x04],
    [0x40CE, 0x05],
    [0x4F97, 0x06],
    [0x4AA0, 0x07],
    [0x77C4, 0x08],
    [0x72F3, 0x09],
    [0x7DAA, 0x0A],
    [0x789D, 0x0B],
    [0x662F, 0x0C],
    [0x6318, 0x0D],
    [0x6C41, 0x0E],
    [0x6976, 0x0F],
    [0x1689, 0x10],
    [0x13BE, 0x11],
    [0x1CE7, 0x12],
    [0x19D0, 0x13],
    [0x0762, 0x14],
    [0x0255, 0x15],
    [0x0D0C, 0x16],
    [0x083B, 0x17],
    [0x355F, 0x18],
    [0x3068, 0x19],
    [0x3F31, 0x1A],
    [0x3A06, 0x1B],
    [0x24B4, 0x1C],
    [0x2183, 0x1D],
    [0x2EDA, 0x1E],
    [0x2BED, 0x1F]
  ];

  /**
   * Offset i holds the number of 1 bits in the binary representation of i
   */
  FormatInformation.BITS_SET_IN_HALF_BYTE = [0, 1, 1, 2, 1, 2, 2, 3,
    1, 2, 2, 3, 2, 3, 3, 4];

  pro.GetHashCode = function() {
    return (this.errorCorrectionLevel.ordinal << 3) | this.dataMask;
  };

  pro.Equals = function(other) {
    return this.errorCorrectionLevel == other.errorCorrectionLevel &&
      this.dataMask == other.dataMask;
  };

  FormatInformation.numBitsDiffering = function(a, b) {
    a ^= b; // a now has a 1 bit exactly where its bit differs with b's
    // Count bits set quickly with a series of lookups:
    return FormatInformation.BITS_SET_IN_HALF_BYTE[a & 0x0F] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 4) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 8) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 12) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 16) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 20) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 24) & 0x0F)] +
      FormatInformation.BITS_SET_IN_HALF_BYTE[(URShift(a, 28) & 0x0F)];
  };

  FormatInformation.decodeFormatInformation = function(maskedFormatInfo) {
    var formatInfo = FormatInformation.doDecodeFormatInformation(
      maskedFormatInfo);
    if (formatInfo != null) {
      return formatInfo;
    }
    // Should return null, but, some QR codes apparently
    // do not mask this info. Try again by actually masking the pattern
    // first
    return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^
      FormatInformation.FORMAT_INFO_MASK_QR);
  };

  FormatInformation.doDecodeFormatInformation = function(maskedFormatInfo) {
    // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
    var bestDifference = 0xffffffff;
    var bestFormatInfo = 0;
    for (var i = 0; i < FormatInformation.FORMAT_INFO_DECODE_LOOKUP.length;
         i++) {
      var decodeInfo = FormatInformation.FORMAT_INFO_DECODE_LOOKUP[i];
      var targetInfo = decodeInfo[0];
      if (targetInfo == maskedFormatInfo) {
        // Found an exact match
        return new FormatInformation(decodeInfo[1]);
      }
      var bitsDifference = FormatInformation.numBitsDiffering(
        maskedFormatInfo, targetInfo);
      if (bitsDifference < bestDifference) {
        bestFormatInfo = decodeInfo[1];
        bestDifference = bitsDifference;
      }
    }
    // Hamming distance of the 32 masked codes is 7, by construction,
    // so <= 3 bits differing means we found a match
    if (bestDifference <= 3) {
      return new FormatInformation(bestFormatInfo);
    }
    return null;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.DataMask');
goog.require('w69b.qr.URShift');

goog.scope(function() {
  var URShift = w69b.qr.URShift;

  var _ = w69b.qr.DataMask;

  /** @interface */
  _.DataMaskInterface = function() {};

  /**
   * @param {w69b.qr.BitMatrix} bits bits.
   * @param {number} dim dimensions.
   */
  _.DataMaskInterface.prototype.unmaskBitMatrix = function(bits, dim) {};

  /**
   * @param {number} i idx.
   * @param {number} j idx.
   * @return {boolean} if position is masked.
   */
  _.DataMaskInterface.prototype.isMasked = function(i, j) {};


  /**
   * @param {number} reference mask number.
   * @return {!_.DataMaskInterface} data mask.
   */
  _.forReference = function(reference) {
    if (reference < 0 || reference > 7) {
      throw Error();
    }
    return _.DATA_MASKS_[reference];
  };

  /**
   * @constructor
   */
  _.DataMask000 = function() {
  };
  _.DataMask000.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask000.prototype.isMasked = function(i, j) {
    return ((i + j) & 0x01) == 0;
  };

  /**
   * @constructor
   */
  _.DataMask001 = function() {
  };
  _.DataMask001.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask001.prototype.isMasked = function(i, j) {
    return (i & 0x01) == 0;
  };

  /**
   * @constructor
   */
  _.DataMask010 = function() {
  };
  _.DataMask010.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask010.prototype.isMasked = function(i, j) {
    return j % 3 == 0;
  };

  /**
   * @constructor
   */
  _.DataMask011 = function() {

  };
  _.DataMask011.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask011.prototype.isMasked = function(i, j) {
    return (i + j) % 3 == 0;
  };


  /**
   * @constructor
   */
  _.DataMask100 = function() {
  };
  _.DataMask100.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask100.prototype.isMasked = function(i, j) {
    return (((URShift(i, 1)) + (j / 3)) & 0x01) == 0;
  };

  /**
   * @constructor
   */
  _.DataMask101 = function() {
  };

  _.DataMask101.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };

  _.DataMask101.prototype.isMasked = function(i, j) {
    var temp = i * j;
    return (temp & 0x01) + (temp % 3) == 0;
  };

  /**
   * @constructor
   */
  _.DataMask110 = function() {
  };
  _.DataMask110.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask110.prototype.isMasked = function(i, j) {
    var temp = i * j;
    return (((temp & 0x01) + (temp % 3)) & 0x01) == 0;
  };

  /**
   * @constructor
   */
  _.DataMask111 = function() {
  };
  _.DataMask111.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  _.DataMask111.prototype.isMasked = function(i, j) {
    return ((((i + j) & 0x01) + ((i * j) % 3)) & 0x01) == 0;
  };

  /**
   * @type {Array.<!_.DataMaskInterface>}
   * @private
   */
  _.DATA_MASKS_ = new Array(new _.DataMask000(), new _.DataMask001(),
    new _.DataMask010(), new _.DataMask011(), new _.DataMask100(),
    new _.DataMask101(),
    new _.DataMask110(), new _.DataMask111());

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.BitMatrixParser');
goog.require('w69b.qr.DataMask');
goog.require('w69b.qr.FormatError');
goog.require('w69b.qr.FormatInformation');
goog.require('w69b.qr.Version');

goog.scope(function() {
  var FormatInformation = w69b.qr.FormatInformation;
  var Version = w69b.qr.Version;
  var DataMask = w69b.qr.DataMask;
  var FormatError = w69b.qr.FormatError;

  /**
   * @param {w69b.qr.BitMatrix} bitMatrix matrix.
   * @constructor
   */
  w69b.qr.BitMatrixParser = function(bitMatrix) {
    var dimension = bitMatrix.getHeight();
    if (dimension < 21 || (dimension & 0x03) != 1) {
      throw new FormatError();
    }
    this.bitMatrix = bitMatrix;
    /**
     * @type {w69b.qr.Version}
     */
    this.parsedVersion = null;
    /**
     * @type {w69b.qr.FormatInformation}
     */
    this.parsedFormatInfo = null;
  };
  var BitMatrixParser = w69b.qr.BitMatrixParser;
  var pro = BitMatrixParser.prototype;

  pro.copyBit = function(i, j, versionBits) {
    return this.bitMatrix.get(i,
      j) ? (versionBits << 1) | 0x1 : versionBits << 1;
  };

  /**
   * @return {!w69b.qr.FormatInformation} format information.
   */
  pro.readFormatInformation = function() {
    if (this.parsedFormatInfo != null) {
      return this.parsedFormatInfo;
    }

    // Read top-left format info bits
    var formatInfoBits = 0;
    for (var i = 0; i < 6; i++) {
      formatInfoBits = this.copyBit(i, 8, formatInfoBits);
    }
    // .. and skip a bit in the timing pattern ...
    formatInfoBits = this.copyBit(7, 8, formatInfoBits);
    formatInfoBits = this.copyBit(8, 8, formatInfoBits);
    formatInfoBits = this.copyBit(8, 7, formatInfoBits);
    // .. and skip a bit in the timing pattern ...
    for (var j = 5; j >= 0; j--) {
      formatInfoBits = this.copyBit(8, j, formatInfoBits);
    }

    this.parsedFormatInfo =
      FormatInformation.decodeFormatInformation(formatInfoBits);
    if (this.parsedFormatInfo != null) {
      return this.parsedFormatInfo;
    }

    // Hmm, failed. Try the top-right/bottom-left pattern
    var dimension = this.bitMatrix.getHeight();
    formatInfoBits = 0;
    var iMin = dimension - 8;
    for (var i = dimension - 1; i >= iMin; i--) {
      formatInfoBits = this.copyBit(i, 8, formatInfoBits);
    }
    for (var j = dimension - 7; j < dimension; j++) {
      formatInfoBits = this.copyBit(8, j, formatInfoBits);
    }

    this.parsedFormatInfo =
      FormatInformation.decodeFormatInformation(formatInfoBits);
    if (this.parsedFormatInfo != null) {
      return this.parsedFormatInfo;
    }
    throw new FormatError();
  };

  /**
   * @return {w69b.qr.Version} version.
   */
  pro.readVersion = function() {
    if (this.parsedVersion != null) {
      return this.parsedVersion;
    }

    var dimension = this.bitMatrix.getHeight();

    var provisionalVersion = (dimension - 17) >> 2;
    if (provisionalVersion <= 6) {
      return Version.getVersionForNumber(provisionalVersion);
    }

    // Read top-right version info: 3 wide by 6 tall
    var versionBits = 0;
    var ijMin = dimension - 11;
    for (var j = 5; j >= 0; j--) {
      for (var i = dimension - 9; i >= ijMin; i--) {
        versionBits = this.copyBit(i, j, versionBits);
      }
    }

    this.parsedVersion = Version.decodeVersionInformation(versionBits);
    if (this.parsedVersion != null &&
      this.parsedVersion.getDimensionForVersion() == dimension) {
      return this.parsedVersion;
    }

    // Hmm, failed. Try bottom left: 6 wide by 3 tall
    versionBits = 0;
    for (var i = 5; i >= 0; i--) {
      for (var j = dimension - 9; j >= ijMin; j--) {
        versionBits = this.copyBit(i, j, versionBits);
      }
    }

    this.parsedVersion = Version.decodeVersionInformation(versionBits);
    if (this.parsedVersion != null &&
      this.parsedVersion.getDimensionForVersion() == dimension) {
      return this.parsedVersion;
    }
    throw new FormatError();
  };

  pro.readCodewords = function() {

    var formatInfo = this.readFormatInformation();
    var version = this.readVersion();

    // Get the data mask for the format used in this QR Code. This will exclude
    // some bits from reading as we wind through the bit matrix.
    var dataMask = DataMask.forReference(formatInfo.dataMask);
    var dimension = this.bitMatrix.getHeight();
    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

    var functionPattern = version.buildFunctionPattern();

    var readingUp = true;
    var result = new Array(version.totalCodewords);
    var resultOffset = 0;
    var currentByte = 0;
    var bitsRead = 0;
    // Read columns in pairs, from right to left
    for (var j = dimension - 1; j > 0; j -= 2) {
      if (j == 6) {
        // Skip whole column with vertical alignment pattern;
        // saves time and makes the other code proceed more cleanly
        j--;
      }
      // Read alternatingly from bottom to top then top to bottom
      for (var count = 0; count < dimension; count++) {
        var i = readingUp ? dimension - 1 - count : count;
        for (var col = 0; col < 2; col++) {
          // Ignore bits covered by the function pattern
          if (!functionPattern.get(j - col, i)) {
            // Read a bit
            bitsRead++;
            currentByte <<= 1;
            if (this.bitMatrix.get(j - col, i)) {
              currentByte |= 1;
            }
            // If we've made a whole byte, save it off
            if (bitsRead == 8) {
              result[resultOffset++] = currentByte;
              bitsRead = 0;
              currentByte = 0;
            }
          }
        }
      }
      readingUp ^= true; // readingUp = !readingUp; // switch directions
    }
    if (resultOffset != version.totalCodewords) {
      throw new FormatError();
    }
    return result;
  };
});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.DataBlock');

goog.scope(function() {

  /**
   * @constructor
   */
  w69b.qr.DataBlock = function(numDataCodewords, codewords) {
    this.numDataCodewords = numDataCodewords;
    this.codewords = codewords;
  };
  var DataBlock = w69b.qr.DataBlock;

  DataBlock.getDataBlocks = function(rawCodewords, version, ecLevel) {

    if (rawCodewords.length != version.totalCodewords) {
      throw 'ArgumentException';
    }

    // Figure out the number and size of data blocks used by this version and
    // error correction level
    var ecBlocks = version.getECBlocksForLevel(ecLevel);

    // First count the total number of data blocks
    var totalBlocks = 0;
    var ecBlockArray = ecBlocks.getECBlocks();
    for (var i = 0; i < ecBlockArray.length; i++) {
      totalBlocks += ecBlockArray[i].count;
    }

    // Now establish DataBlocks of the appropriate size and number of data
    // codewords
    var result = new Array(totalBlocks);
    var numResultBlocks = 0;
    for (var j = 0; j < ecBlockArray.length; j++) {
      var ecBlock = ecBlockArray[j];
      for (var i = 0; i < ecBlock.count; i++) {
        var numDataCodewords = ecBlock.dataCodewords;
        var numBlockCodewords = ecBlocks.ecCodewordsPerBlock + numDataCodewords;
        result[numResultBlocks++] = new DataBlock(numDataCodewords,
          new Array(numBlockCodewords));
      }
    }

    // All blocks have the same amount of data, except that the last n
    // (where n may be 0) have 1 more byte. Figure out where these start.
    var shorterBlocksTotalCodewords = result[0].codewords.length;
    var longerBlocksStartAt = result.length - 1;
    while (longerBlocksStartAt >= 0) {
      var numCodewords = result[longerBlocksStartAt].codewords.length;
      if (numCodewords == shorterBlocksTotalCodewords) {
        break;
      }
      longerBlocksStartAt--;
    }
    longerBlocksStartAt++;

    var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords -
      ecBlocks.ecCodewordsPerBlock;
    // The last elements of result may be 1 element longer;
    // first fill out as many elements as all of them have
    var rawCodewordsOffset = 0;
    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
      }
    }
    // Fill out the last data block in the longer ones
    for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
      result[j].codewords[shorterBlocksNumDataCodewords] =
        rawCodewords[rawCodewordsOffset++];
    }
    // Now add in error correction blocks
    var max = result[0].codewords.length;
    for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        var iOffset = j < longerBlocksStartAt ? i : i + 1;
        result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
      }
    }
    return result;
  };

});


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility for fast string concatenation.
 */

goog.provide('goog.string.StringBuffer');



/**
 * Utility class to facilitate string concatenation.
 *
 * @param {*=} opt_a1 Optional first initial item to append.
 * @param {...*} var_args Other initial items to
 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
 * @constructor
 */
goog.string.StringBuffer = function(opt_a1, var_args) {
  if (opt_a1 != null) {
    this.append.apply(this, arguments);
  }
};


/**
 * Internal buffer for the string to be concatenated.
 * @type {string}
 * @private
 */
goog.string.StringBuffer.prototype.buffer_ = '';


/**
 * Sets the contents of the string buffer object, replacing what's currently
 * there.
 *
 * @param {*} s String to set.
 */
goog.string.StringBuffer.prototype.set = function(s) {
  this.buffer_ = '' + s;
};


/**
 * Appends one or more items to the buffer.
 *
 * Calling this with null, undefined, or empty arguments is an error.
 *
 * @param {*} a1 Required first string.
 * @param {*=} opt_a2 Optional second string.
 * @param {...*} var_args Other items to append,
 *     e.g., sb.append('foo', 'bar', 'baz').
 * @return {!goog.string.StringBuffer} This same StringBuffer object.
 * @suppress {duplicate}
 */
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
  // Use a1 directly to avoid arguments instantiation for single-arg case.
  this.buffer_ += a1;
  if (opt_a2 != null) { // second argument is undefined (null == undefined)
    for (var i = 1; i < arguments.length; i++) {
      this.buffer_ += arguments[i];
    }
  }
  return this;
};


/**
 * Clears the internal buffer.
 */
goog.string.StringBuffer.prototype.clear = function() {
  this.buffer_ = '';
};


/**
 * @return {number} the length of the current contents of the buffer.
 */
goog.string.StringBuffer.prototype.getLength = function() {
  return this.buffer_.length;
};


/**
 * @return {string} The concatenated string.
 * @override
 */
goog.string.StringBuffer.prototype.toString = function() {
  return this.buffer_;
};

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Ported to js by Manuel Braun
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.BitSource');

goog.scope(function() {
  /** <p>This provides an easy abstraction to read bits at a time from a
   * sequence of bytes, where the number of bits read is not often a multiple
   * of 8.</p>
   *
   * <p>This class is thread-safe but not reentrant -- unless the caller
   * modifies the bytes array it passed in, in which case all bets are off.</p>
   *
   * @param {Array.<number>} bytes bytes bytes from which this will read bits.
   * Bits will be read from the first byte first.  Bits are read within a byte
   * from most-significant to least-significant bit.  @constructor
   * @constructor
   */
  w69b.qr.BitSource = function(bytes) {
    this.bytes_ = bytes;
    this.byteOffset_ = 0;
    this.bitOffset_ = 0;
  };
  var BitSource = w69b.qr.BitSource;
  var pro = BitSource.prototype;

  /**
   * @return {number} index of next bit in current byte which would be read by
   * the next call to readBits().
   */
  pro.getBitOffset = function() {
    return this.bitOffset_;
  };

  /**
  * @return {number} index of next byte in input byte array which would be read
  * by the next call to readBits().
   */
  pro.getByteOffset = function() {
    return this.byteOffset_;
  };

  /**
   * @param {number} numBits number of bits to read.  @return {number} int
   * representing the bits read. The bits will appear as the least-significant
   * bits of the int.
   */
  pro.readBits = function(numBits) {
    if (numBits < 1 || numBits > 32 || numBits > this.available()) {
      throw new Error();
    }

    var result = 0;

    // First, read remainder from current byte
    if (this.bitOffset_ > 0) {
      var bitsLeft = 8 - this.bitOffset_;
      var toRead = numBits < bitsLeft ? numBits : bitsLeft;
      var bitsToNotRead = bitsLeft - toRead;
      var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
      result = (this.bytes_[this.byteOffset_] & mask) >> bitsToNotRead;
      numBits -= toRead;
      this.bitOffset_ += toRead;
      if (this.bitOffset_ == 8) {
        this.bitOffset_ = 0;
        this.byteOffset_++;
      }
    }

    // Next read whole bytes
    if (numBits > 0) {
      while (numBits >= 8) {
        result = (result << 8) | (this.bytes_[this.byteOffset_] & 0xFF);
        this.byteOffset_++;
        numBits -= 8;
      }

      // Finally read a partial byte
      if (numBits > 0) {
        var bitsToNotRead = 8 - numBits;
        var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
        result = (result << numBits) |
          ((this.bytes_[this.byteOffset_] & mask) >> bitsToNotRead);
        this.bitOffset_ += numBits;
      }
    }
    return result;
  };

  /**
   * @return {number} number of bits that can be read successfully.
   */
  pro.available = function() {
    return 8 * (this.bytes_.length - this.byteOffset_) - this.bitOffset_;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.CharacterSetECI');
goog.require('goog.object');

goog.scope(function() {

  var _ = w69b.qr.CharacterSetECI;
  /**
   * @type {Object} mapping eci codes to arrays of encoding names.
   */
  _.valuesToNames = {
    0: ['CP437'],
    2: ['CP437'],
    1: ['ISO-8859-1'],
    3: ['ISO-8859-1'],
    4: ['ISO-8859-2'],
    5: ['ISO-8859-3'],
    6: ['ISO-8859-4'],
    7: ['ISO-8859-5'],
    8: ['ISO-8859-6'],
    9: ['ISO-8859-7'],
    10: ['ISO-8859-7'],
    11: ['ISO-8859-9'],
    12: ['ISO-8859-10'],
    13: ['ISO-8859-11'],
    14: ['ISO-8859-12'],
    15: ['ISO-8859-13'],
    16: ['ISO-8859-14'],
    17: ['ISO-8859-15'],
    18: ['ISO-8859-16'],
    20: ['SHIFT_JIS'],
    21: ['ISO-8859-16'],
    22: ['Cp1251', 'windows-1251'],
    23: ['Cp1252', 'windows-1252'],
    24: ['Cp1256', 'windows-1256'],
    25: ['UTF-16BE', 'UnicodeBig'],
    26: ['UTF-8'],
    27: ['ASCII', 'US-ASCII'],
    170: ['ASCII', 'US-ASCII'],
    28: ['Big5'],
    29: ['GB18030', 'GB2312', 'EUC_CN', 'GBK'],
    30: ['EUC-KR']
  };
  _.namesToValues = {};
  /**
   * @private
   */
  _.buildNamesToValues_ = function() {
    goog.object.forEach(_.valuesToNames, function(names, num) {
      names.forEach(function(name) {
        if (!_.namesToValues[name])
          _.namesToValues[name] = num;
      });
    });
  };
  _.buildNamesToValues_();

  /**
   * @param {string} name of encoding.
   * @return {?number} eci value.
   */
  _.getValue = function(name) {
    return Number(_.namesToValues[name]);
  };

  /**
   * @param {number} value eci value.
   * @return {?string} main encoding name.
   */
  _.getName = function(value) {
    var names = _.valuesToNames[value];
    if (names)
      return names[0];
    else
      return null;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.Mode');
goog.provide('w69b.qr.ModeEnum');

goog.scope(function() {
  /**
   * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the
   * various modes in which data can be encoded to bits in the QR code
   * standard.</p>
   *
   * @author Sean Owen
   */
  /**
   *
   * @param {Array.<number>} characterCountBitsForVersions nodoc.
   * @param {number} bits nodoc.
   * @param {string=} opt_name name for testing.
   * @constructor
   */
  w69b.qr.Mode = function(characterCountBitsForVersions, bits, opt_name) {
    this.characterCountBitsForVersions = characterCountBitsForVersions;
    this.bits = bits;
    this.name_ = opt_name || 'NONAME';
  };
  var Mode = w69b.qr.Mode;
  var pro = Mode.prototype;


  /** @enum {Mode} */

  w69b.qr.ModeEnum = {
    // Not really a mode...
    TERMINATOR: new Mode([0, 0, 0], 0x00, 'TERMINATOR'),
    NUMERIC: new Mode([10, 12, 14], 0x01, 'NUMERIC'),
    ALPHANUMERIC: new Mode([9, 11, 13], 0x02, 'ALPHANUMERIC'),
    // Not supported
    STRUCTURED_APPEND: new Mode([0, 0, 0], 0x03, 'STRUCTURED_APPEND'),
    BYTE: new Mode([8, 16, 16], 0x04, 'BYTE'),
    ECI: new Mode([0, 0, 0], 0x07, 'ECI'), // character counts don't apply
    KANJI: new Mode([8, 10, 12], 0x08, 'KANJI'),
    FNC1_FIRST_POSITION: new Mode([0, 0, 0], 0x05, 'FNC1_FIRST_POSITION'),
    FNC1_SECOND_POSITION: new Mode([0, 0, 0], 0x09, 'FNC1_SECOND_POSITION'),
    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
    HANZI: new Mode([8, 10, 12], 0x0D, 'HANZI')
  };
  var ModeEnum = w69b.qr.ModeEnum;


  /**
   * @param {w69b.qr.Version} version version in question.
   * @return {number} number of bits used, in this QR Code symbol {@link Version} , to
   * encode the count of characters that will follow encoded in this Mode.
   */
  pro.getCharacterCountBits = function(version) {
    var number = version.versionNumber;
    var offset;
    if (number <= 9) {
      offset = 0;
    } else if (number <= 26) {
      offset = 1;
    } else {
      offset = 2;
    }
    return this.characterCountBitsForVersions[offset];
  };

  pro.getBits = function() {
    return this.bits;
  };

  /**
   * @return {string} debug string.
   */
  pro.toString = function() {
    return this.name_;
  };


  /**
   * @param {number} bits four bits encoding a QR Code data mode.
   * @return {Mode} Mode encoded by these bits.
   */
  Mode.forBits = function(bits) {
    switch (bits) {
      case 0x0:
        return ModeEnum.TERMINATOR;
      case 0x1:
        return ModeEnum.NUMERIC;
      case 0x2:
        return ModeEnum.ALPHANUMERIC;
      case 0x3:
        return ModeEnum.STRUCTURED_APPEND;
      case 0x4:
        return ModeEnum.BYTE;
      case 0x5:
        return ModeEnum.FNC1_FIRST_POSITION;
      case 0x7:
        return ModeEnum.ECI;
      case 0x8:
        return ModeEnum.KANJI;
      case 0x9:
        return ModeEnum.FNC1_SECOND_POSITION;
      case 0xD:
        // 0xD is defined in GBT 18284-2000, may not be supported in foreign
        // country
        return ModeEnum.HANZI;
      default:
        throw new Error();
    }
  };
});


goog.provide('w69b.utf8');
/**
 * @license
 * utf8.js
 * License: Apache2, v2 see http://www.apache.org/licenses/LICENSE-2.0
 * @author mb@w69b.com (Manuel Braun)
 */
(function(global) {
  /**
   * @license
   * Snippet fixedCharCodeAt borrowed from http://goo.gl/3lRpR.
   * (c) see contributers of site.
   * License: MIT
  */
  function fixedCharCodeAt(str, idx) {
      var code = str.charCodeAt(idx);
      var hi, low;
      // High surrogate (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 <= code && code <= 0xDBFF) {
          hi = code;
          low = str.charCodeAt(idx + 1);
          if (isNaN(low)) {
            throw 'fixedCharCodeAt: Invalid Encoding';
          }
          return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
      }
      // We return false to allow loops to skip this iteration since should
      // have already handled high surrogate above in the previous iteration
      // Low surrogate
      if (0xDC00 <= code && code <= 0xDFFF) {
          return false;
      }
      return code;
  }

  /**
   * @license
   * fixedFromCodePoint
  * Convert array of unicode code points to string.
  * Originally from:
  * ES6 Unicode Shims 0.1
  * (c) 2012 Steven Levithan <http://slevithan.com/>
  * MIT License
  * @param {Array.<number>} codePoints codePoints sequence.
  * @return {string} resulting string.
  */
  function fixedFromCodePoint(codePoints) {
    var chars = [], point, offset, units, i;
    for (i = 0; i < codePoints.length; ++i) {
      point = codePoints[i];
      offset = point - 0x10000;
      units = point > 0xFFFF ?
        [0xD800 + (offset >> 10), 0xDC00 + (offset & 0x3FF)] : [point];
      chars.push(String.fromCharCode.apply(null, units));
    }
    return chars.join('');
  }

  /**
   * Convert string to UTF8 byte sequence.
   * @param {string} str javascript string (unicode).
   * @return {Array.<number>} byte sequence.
   */
  function stringToUTF8Bytes(str) {
    var bytes = [];
    for (var i = 0; i < str.length; ++i) {
      var codePoint = fixedCharCodeAt(str, i);
      // already handeled
      if (!codePoint) continue;
      if (codePoint <= 0x7F) {
        bytes.push(codePoint);
      } else if (codePoint <= 0x07FF) {
        bytes.push(0xC0 | (codePoint >> 6));
        bytes.push(0x80 | (codePoint & 0x3F));
      } else if (codePoint <= 0xFFFF) {
        bytes.push(0xE0 | (codePoint >> 12));
        bytes.push(0x80 | (0x3F & (codePoint >> 6)));
        bytes.push(0x80 | (codePoint & 0x3F));
      } else if (codePoint <= 0x1FFFFF) {
        bytes.push(0xF0 | (codePoint >> 18));
        bytes.push(0x80 | (0x3F & (codePoint >> 12)));
        bytes.push(0x80 | (0x3F & (codePoint >> 6)));
        bytes.push(0x80 | (codePoint & 0x3F));
      } else if (codePoint <= 0x3FFFFFF) {
        bytes.push(0xF0 | (codePoint >> 24));
        bytes.push(0x80 | (0x3F & (codePoint >> 18)));
        bytes.push(0x80 | (0x3F & (codePoint >> 12)));
        bytes.push(0x80 | (0x3F & (codePoint >> 6)));
        bytes.push(0x80 | (codePoint & 0x3F));
      } else {
        bytes.push(0xF0 | (0x01 & (codePoint >> 30)));
        bytes.push(0x80 | (0x3F & (codePoint >> 24)));
        bytes.push(0x80 | (0x3F & (codePoint >> 18)));
        bytes.push(0x80 | (0x3F & (codePoint >> 12)));
        bytes.push(0x80 | (0x3F & (codePoint >> 6)));
        bytes.push(0x80 | (codePoint & 0x3F));
      }
    }
    return bytes;
  }

  /**
   * Convert UTF8 byte sequence to string.
   * @param {Array.<number>} bytes UTF8 byte sequence.
   * @return {?string} result string or null on error (invalid input).
   */
  function UTF8BytesToString(bytes) {
    var length = bytes.length;
    var getContinuation = function(idx) {
      if (idx > length) throw new Error();
      var b = bytes[idx];
      if ((b & 0xC0) !== 0x80) throw new Error();
      return b & 0x3F;
    };
    var codePoints = [];
    try {
      for (var i = 0; i < length; ++i) {
        var b = bytes[i];
        if (b > 0xFF) return null;
        var code;
        if ((b & 0x80) === 0x00) {
          // First bit not set, so it is a 1-byte char.
          code = b;
        } else if ((b & 0xE0) === 0xC0) {
          // 2 bytes.
          code = ((0x1F & b) << 6) | getContinuation(i + 1);
          i += 1;
        } else if ((b & 0xF0) === 0xE0) {
          // 3 bytes.
          code = ((0x0F & b) << 12) |
            (getContinuation(i + 1) << 6) |
            getContinuation(i + 2);
          i += 2;
        } else if ((b & 0xF8) === 0xF0) {
          // 4 bytes.
          code = ((0x07 & b) << 18) |
            (getContinuation(i + 1) << 12) |
            (getContinuation(i + 2) << 6) |
            getContinuation(i + 3);
          i += 3;
        } else if ((b & 0xFC) === 0xF8) {
          // 5 bytes.
          code = ((0x03 & b) << 24) |
            (getContinuation(i + 1) << 18) |
            (getContinuation(i + 2) << 12) |
            (getContinuation(i + 3) << 6) |
            getContinuation(i + 4);
          i += 4;
        } else if ((b & 0xFE) === 0xFC) {
          // 6 bytes.
          code = ((0x01 & b) << 30) |
            (getContinuation(i + 1) << 24) |
            (getContinuation(i + 2) << 18) |
            (getContinuation(i + 3) << 12) |
            (getContinuation(i + 4) << 6) |
            getContinuation(i + 5);
          i += 5;
        }
        codePoints.push(code);
      }
    } catch (ignored) {
      // Our invalid-incoding exception is the only one thrown
      // this block, so just return null.
      return null;
    }
    return fixedFromCodePoint(codePoints);
  }

  // Public API.
  var exports = {
    stringToUTF8Bytes: stringToUTF8Bytes,
    UTF8BytesToString: UTF8BytesToString
  };

  if (typeof(goog) == 'object' && goog.provide) {
    // Google Closure Tools compatibility hook.
    w69b.utf8.stringToUTF8Bytes = stringToUTF8Bytes;
    w69b.utf8.UTF8BytesToString = UTF8BytesToString;
  } else if (typeof(global.define) == 'function') {
    // require js compatibility hook.
    global.define(exports);
  } else {
    // Plain old global export fallback.
    global['utf8'] = exports;
  }
})(self);

/*
 @license
 Singlebyte encodings values ported from iconv-lite (for nodejs).
 google closure/browser port 2013 by Manuel Braun (mb@w69b.com)

 LICENSE of iconve-lite:

 Copyright (c) 2011 Alexander Shtuchkin

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

goog.provide('w69b.iconvlite');
goog.require('w69b.utf8');
goog.require('goog.object');


goog.scope(function() {
  var _ = w69b.iconvlite;
  _.SINGLEBYTES = {
    'Cp1251': '\xa0',
    'Cp1252': '\xa0',
    'Cp1256': '\xa0',
    'ISO-8859-1': '\xa0',
    'ISO-8859-2': '\xa0',
    'ISO-8859-3': '\xa0',
    'ISO-8859-4': '\xa0',
    'ISO-8859-5': '\xa0',
    'ISO-8859-6': '\xa0',
    'ISO-8859-7': '\xa0',
    'ISO-8859-8': '\xa0',
    'ISO-8859-9': '\xa0',
    'ISO-8859-10': '\xa0',
    'ISO-8859-11': '\xa0',
    'ISO-8859-13': '\xa0',
    'ISO-8859-14': '\xa0',
    'ISO-8859-15': '\xa0',
    'ISO-8859-16': '\xa0'
  };
  _.ASCII = '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f' +
    ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f';

  _.REVERSE_MAPS_ = {};

  /**
   * @param {Array.<number>} bytes sequence of given charset.
   * @param {string} charset name of charset.
   * @return {string} decoded string.
   */
  _.toString = function(bytes, charset) {
    var chars = _.ASCII + _.SINGLEBYTES[charset];
    if (!chars) throw new Error();
    return bytes.map(function(b) {
      return chars[b];
    }).join('');
  };

  /**
   * @param {string} charset name as specified above.
   * @return {boolean} if charset is supported.
   */
  _.isSupported = function(charset) {
    return !!_.SINGLEBYTES[charset];
  };

  /**
   *
   * @param {string} string encoded in charset.
   * @param {string} charset charset name
   * @return {Array.<number>} bytes.
   */
  _.toBytes = function(string, charset) {
    var map = _.getReverseMap_(charset);
    var bytes = [];
    for (var i = 0; i < string.length; ++i) {
      var b = map[string[i]];
      if (b === undefined) return null;
      bytes.push(b);
    }
    return bytes;
  };

  /**
   * @param {string} charset name.
   * @return {Object} reverse map (mapping str to bytes).
   * @private
   */
  _.getReverseMap_ = function(charset) {
    var map = _.REVERSE_MAPS_[charset];
    if (!map) {
      map = {};
      var chars = _.ASCII + _.SINGLEBYTES[charset];
      if (!chars)
        throw new Error();
      for (var i = 0; i < chars.length; ++i) {
        map[chars[i]] = i;
      }
    }
    _.REVERSE_MAPS_[charset] = map;
    return map;
  };

  /**
   * @return {Array.<string>} supported charsets.
   */
  _.getSupportedCharsets = function() {
    return goog.object.getKeys(_.SINGLEBYTES);
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.stringutils');
goog.require('w69b.iconvlite');
goog.require('w69b.qr.DecodeHintType');
goog.require('w69b.qr.InvalidCharsetError');
goog.require('w69b.utf8');

goog.scope(function() {
  var _ = w69b.qr.stringutils;
  var utf8 = w69b.utf8;
  var iconv = self.iconv;
  var iconvlite = w69b.iconvlite;
  var InvalidCharsetError = w69b.qr.InvalidCharsetError;

  _.SHIFT_JIS = 'SHIFT_JIS';
  _.GB2312 = 'GB18030';
  _.EUC_JP = 'EUC-JP';
  _.UTF8 = 'UTF-8';
  _.ISO88591 = 'ISO-8859-1';
  _.PLATFORM_DEFAULT_ENCODING = _.UTF8;
  _.ASSUME_SHIFT_JIS = false;
  // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
  // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);


  /**
   * Decodes bytes bytes array as returned by getBytes().
   * @param {Array.<number>} bytes sequence of given charset.
   * @param {string=} opt_charset name of charset.
   * @return {string} decoded string.
   */
  _.bytesToString = function(bytes, opt_charset) {
    var charset = opt_charset || 'UTF-8';
    var str = null;

    // try native TextDecoder first
    if (self.TextDecoder && self.Uint8Array && self.Uint8Array['from']) {
      try {
        var decoder = new self.TextDecoder(charset);
        return decoder.decode(self.Uint8Array['from'](bytes));
      } catch (ignored) {
        // try other methods if charset is not supported by native decoder (eg. CP437 on Chrome).
      }
    }
    if (charset == 'UTF-8') {
      str = utf8.UTF8BytesToString(bytes);
    } else if (iconvlite.isSupported(charset)) {
      str = iconvlite.toString(bytes, charset);
    } else {
      if (!iconv)
        throw new InvalidCharsetError(
          'iconv not loaded, cannot handle ' + charset);
      var utf8Bytes = iconv.convert(bytes, charset, 'UTF-8');
      if (utf8Bytes === null)
        throw new InvalidCharsetError(
          'toStr ' + charset + ' to UTF-8 ' + bytes);
      bytes = utf8Bytes;
      str = utf8.UTF8BytesToString(bytes);
    }
    if (str === null)
      throw new InvalidCharsetError();
    return str;
  };

  /**
   * Note: charset is currently ignored.
   * Decodes bytes bytes array as returned by getBytes().
   * @param {string} str to encode.
   * @param {string=} opt_charset name of charset.
   * @return {Array.<number>} bytes.
   */
  _.stringToBytes = function(str, opt_charset) {
    var charset = opt_charset || 'UTF-8';
    var bytes = null;
    if (charset == 'UTF-8') {
      bytes = utf8.stringToUTF8Bytes(str);
      if (bytes === null)
        throw new InvalidCharsetError();
    } else if (iconvlite.isSupported(charset)) {
      bytes = iconvlite.toBytes(str, charset);
    } else {
      bytes = utf8.stringToUTF8Bytes(str);
      if (!iconv)
        throw new InvalidCharsetError('iconv not loaded');
      bytes = iconv.convert(bytes, 'UTF-8', charset);
    }
    if (bytes === null)
      throw new InvalidCharsetError(charset + ' to bytes: ' + str);
    return bytes;
  };

  /**
   * @param {Array.<number>} bytes bytes encoding a string, whose encoding
   * should be guessed.
   * @param {Object=} opt_hints decode hints if applicable.
   * @return {string} name of guessed encoding; at the moment will only
   * guess one of:
   *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
   *  default encoding if none of these can possibly be correct.
   */
  _.guessEncoding = function(bytes, opt_hints) {
    if (opt_hints) {
      var characterSet = opt_hints.get(w69b.qr.DecodeHintType.CHARACTER_SET);
      if (characterSet) {
        return characterSet;
      }
    }
    // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,
    // which should be by far the most common encodings.
    var length = bytes.length;
    var canBeISO88591 = true;
    var canBeShiftJIS = true;
    var canBeUTF8 = true;
    var utf8BytesLeft = 0;
    //var utf8LowChars = 0;
    var utf2BytesChars = 0;
    var utf3BytesChars = 0;
    var utf4BytesChars = 0;
    var sjisBytesLeft = 0;
    //var sjisLowChars = 0;
    var sjisKatakanaChars = 0;
    //var sjisDoubleBytesChars = 0;
    var sjisCurKatakanaWordLength = 0;
    var sjisCurDoubleBytesWordLength = 0;
    var sjisMaxKatakanaWordLength = 0;
    var sjisMaxDoubleBytesWordLength = 0;
    //var isoLowChars = 0;
    //var isoHighChars = 0;
    var isoHighOther = 0;

    var utf8bom = bytes.length > 3 &&
      bytes[0] == 0xEF &&
      bytes[1] == 0xBB &&
      bytes[2] == 0xBF;

    for (var i = 0;
         i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8);
         i++) {

      var value = bytes[i] & 0xFF;

      // UTF-8 stuff
      if (canBeUTF8) {
        if (utf8BytesLeft > 0) {
          if ((value & 0x80) == 0) {
            canBeUTF8 = false;
          } else {
            utf8BytesLeft--;
          }
        } else if ((value & 0x80) != 0) {
          if ((value & 0x40) == 0) {
            canBeUTF8 = false;
          } else {
            utf8BytesLeft++;
            if ((value & 0x20) == 0) {
              utf2BytesChars++;
            } else {
              utf8BytesLeft++;
              if ((value & 0x10) == 0) {
                utf3BytesChars++;
              } else {
                utf8BytesLeft++;
                if ((value & 0x08) == 0) {
                  utf4BytesChars++;
                } else {
                  canBeUTF8 = false;
                }
              }
            }
          }
        } //else {
        //utf8LowChars++;
        //}
      }

      // ISO-8859-1 stuff
      if (canBeISO88591) {
        if (value > 0x7F && value < 0xA0) {
          canBeISO88591 = false;
        } else if (value > 0x9F) {
          if (value < 0xC0 || value == 0xD7 || value == 0xF7) {
            isoHighOther++;
          } //else {
          //isoHighChars++;
          //}
        } //else {
        //isoLowChars++;
        //}
      }

      // Shift_JIS stuff
      if (canBeShiftJIS) {
        if (sjisBytesLeft > 0) {
          if (value < 0x40 || value == 0x7F || value > 0xFC) {
            canBeShiftJIS = false;
          } else {
            sjisBytesLeft--;
          }
        } else if (value == 0x80 || value == 0xA0 || value > 0xEF) {
          canBeShiftJIS = false;
        } else if (value > 0xA0 && value < 0xE0) {
          sjisKatakanaChars++;
          sjisCurDoubleBytesWordLength = 0;
          sjisCurKatakanaWordLength++;
          if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
          }
        } else if (value > 0x7F) {
          sjisBytesLeft++;
          //sjisDoubleBytesChars++;
          sjisCurKatakanaWordLength = 0;
          sjisCurDoubleBytesWordLength++;
          if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
          }
        } else {
          //sjisLowChars++;
          sjisCurKatakanaWordLength = 0;
          sjisCurDoubleBytesWordLength = 0;
        }
      }
    }

    if (canBeUTF8 && utf8BytesLeft > 0) {
      canBeUTF8 = false;
    }
    if (canBeShiftJIS && sjisBytesLeft > 0) {
      canBeShiftJIS = false;
    }

    // Easy -- if there is BOM or at least 1 valid not-single byte character
    // (and no evidence it can't be UTF-8), done
    if (canBeUTF8 &&
      (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
      return _.UTF8;
    }
    // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii
    // characters (and no evidence it can't be), done
    if (canBeShiftJIS &&
      (_.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 ||
        sjisMaxDoubleBytesWordLength >= 3)) {
      return _.SHIFT_JIS;
    }
    // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short
    // words. The crude heuristic is:
    // - If we saw
    //   - only two consecutive katakana chars in the whole text, or
    //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,
    // - then we conclude Shift_JIS, else ISO-8859-1
    if (canBeISO88591 && canBeShiftJIS) {
      return (sjisMaxKatakanaWordLength == 2 && sjisKatakanaChars == 2) ||
        isoHighOther * 10 >= length ? _.SHIFT_JIS : _.ISO88591;
    }

    // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to
    // default platform encoding
    if (canBeISO88591) {
      return _.ISO88591;
    }
    if (canBeShiftJIS) {
      return _.SHIFT_JIS;
    }
    if (canBeUTF8) {
      return _.UTF8;
    }
    // Otherwise, we take a wild guess with platform encoding
    return _.PLATFORM_DEFAULT_ENCODING;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.DecodedBitStreamParser');
goog.require('goog.string.StringBuffer');
goog.require('w69b.qr.BitSource');
goog.require('w69b.qr.CharacterSetECI');
goog.require('w69b.qr.FormatError');
goog.require('w69b.qr.Mode');
goog.require('w69b.qr.ModeEnum');
goog.require('w69b.qr.stringutils');

goog.scope(function() {
  var _ = w69b.qr.DecodedBitStreamParser;
  var BitSource = w69b.qr.BitSource;
  var Mode = w69b.qr.Mode;
  var ModeEnum = w69b.qr.ModeEnum;
  var StringBuffer = goog.string.StringBuffer;
  var stringutils = w69b.qr.stringutils;
  var FormatError = w69b.qr.FormatError;
  var CharacterSetECI = w69b.qr.CharacterSetECI;

  /**
   * <p>QR Codes can encode text as bits in one of several modes, and can use
   * multiple modes in one QR Code. This class decodes the bits back into
   * text.</p>
   *
   * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
   *
   * @author Sean Owen
   */

  /**
   * See ISO 18004:2006, 6.4.4 Table 5
   */
  _.ALPHANUMERIC_CHARS = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
    'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    ' ', '$', '%', '*', '+', '-', '.', '/', ':'
  ];
  _.GB2312_SUBSET = 1;


  /**
   * @param {Array.<number>} bytes byte blocks.
   * @param {w69b.qr.Version} version qr code version.
   * @param {w69b.qr.ErrorCorrectionLevel} ecLevel error correction level.
   * @return {string} decoded string.
   */
  _.decode = function(bytes, version, ecLevel) {
    var bits = new BitSource(bytes);
    var result = new StringBuffer();
    /**
     * @type {Array.<number>}
     */
    var byteSegments = [];
    var fc1InEffect = false;
    var mode;
    var currentCharacterSet = null;
    do {
      // While still another segment to read...
      if (bits.available() < 4) {
        // OK, assume we're done. Really, a TERMINATOR mode should have been
        // recorded here
        mode = ModeEnum.TERMINATOR;
      } else {
        mode = Mode.forBits(bits.readBits(4)); // mode is encoded by 4 bits
      }
      if (mode != ModeEnum.TERMINATOR) {
        if (mode == ModeEnum.FNC1_FIRST_POSITION ||
          mode == ModeEnum.FNC1_SECOND_POSITION) {
          // We do little with FNC1 except alter the parsed result a bit
          // according to the spec
          fc1InEffect = true;
        } else if (mode == ModeEnum.STRUCTURED_APPEND) {
          if (bits.available() < 16) {
            throw new FormatError();  // FormatException.getFormatInstance();
          }
          // not really supported; all we do is ignore it Read next 8 bits
          // (symbol sequence #) and 8 bits (parity data), then continue
          bits.readBits(16);
        } else if (mode == ModeEnum.ECI) {
          // Count doesn't apply to ECI
          var value = _.parseECIValue(bits);
          currentCharacterSet = CharacterSetECI.getName(value);
          if (currentCharacterSet == null)
            throw new FormatError();
        } else {
          // First handle Hanzi mode which does not start with character count
          if (mode == ModeEnum.HANZI) {
            //chinese mode contains a sub set indicator right after mode
            //indicator
            var subset = bits.readBits(4);
            var countHanzi = bits.readBits(
              mode.getCharacterCountBits(version));
            if (subset == _.GB2312_SUBSET) {
              _.decodeHanziSegment(bits, result, countHanzi);
            }
          } else {
            // "Normal" QR code modes:
            // How many characters will follow, encoded in this mode?
            var count = bits.readBits(mode.getCharacterCountBits(version));
            if (mode == ModeEnum.NUMERIC) {
              _.decodeNumericSegment(bits, result, count);
            } else if (mode == ModeEnum.ALPHANUMERIC) {
              _.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
            } else if (mode == ModeEnum.BYTE) {
              _.decodeByteSegment(bits, result, count,
                currentCharacterSet, byteSegments);
            } else if (mode == ModeEnum.KANJI) {
              _.decodeKanjiSegment(bits, result, count);
            } else {
              throw new FormatError();  //FormatException.getFormatInstance();
            }
          }
        }
      }
    } while (mode != ModeEnum.TERMINATOR);

    return result.toString();
  };

  /**
   * See specification GBT 18284-2000
   * @param {BitSource} bits bits.
   * @param {StringBuffer} result string buffer.
   * @param {number} count bytes to decode.
   */
  _.decodeHanziSegment = function(bits, result, count) {
    // Don't crash trying to read more bits than we have available.
    if (count * 13 > bits.available()) {
      throw new FormatError();  // FormatException.getFormatInstance();
    }

    // Each character will require 2 bytes. Read the characters as 2-byte pairs
    // and decode as GB2312 afterwards
    var buffer = new Array(2 * count);
    var offset = 0;
    while (count > 0) {
      // Each 13 bits encodes a 2-byte character
      var twoBytes = bits.readBits(13);
      var assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);
      if (assembledTwoBytes < 0x003BF) {
        // In the 0xA1A1 to 0xAAFE range
        assembledTwoBytes += 0x0A1A1;
      } else {
        // In the 0xB0A1 to 0xFAFE range
        assembledTwoBytes += 0x0A6A1;
      }
      buffer[offset] = ((assembledTwoBytes >> 8) & 0xFF);
      buffer[offset + 1] = (assembledTwoBytes & 0xFF);
      offset += 2;
      count--;
    }

    result.append(stringutils.bytesToString(buffer, 'GB2312'));
    // result.append(new String(buffer, StringUtils.GB2312));
  };

  /**
   * @param {BitSource} bits bits.
   * @param {StringBuffer} result string buffer.
   * @param {number} count bytes to decode.
   */
  _.decodeKanjiSegment = function(bits, result, count) {
    // Don't crash trying to read more bits than we have available.
    if (count * 13 > bits.available()) {
      throw new FormatError();
    }

    // Each character will require 2 bytes. Read the characters as 2-byte pairs
    // and decode as Shift_JIS afterwards
    var buffer = new Array(2 * count);
    var offset = 0;
    while (count > 0) {
      // Each 13 bits encodes a 2-byte character
      var twoBytes = bits.readBits(13);
      var assembledTwoBytes = ((twoBytes / 0x0C0) << 8) | (twoBytes % 0x0C0);
      if (assembledTwoBytes < 0x01F00) {
        // In the 0x8140 to 0x9FFC range
        assembledTwoBytes += 0x08140;
      } else {
        // In the 0xE040 to 0xEBBF range
        assembledTwoBytes += 0x0C140;
      }
      buffer[offset] = (assembledTwoBytes >> 8);
      buffer[offset + 1] = assembledTwoBytes;
      offset += 2;
      count--;
    }
    // Shift_JIS may not be supported in some environments:
    result.append(stringutils.bytesToString(buffer, 'SJIS'));
  };

  /**
   * @param {BitSource} bits bits.
   * @param {StringBuffer} result string buffer.
   * @param {number} count bytes to decode.
   * @param {?string} characterSetEciName character set eci name.
   * @param {Array.<number>} byteSegments raw bytes.
   */
  _.decodeByteSegment = function(bits, result, count,
                                 characterSetEciName, byteSegments) {
    // Don't crash trying to read more bits than we have available.
    if (count << 3 > bits.available()) {
      throw new FormatError();  //FormatException.getFormatInstance();
    }

    var readBytes = new Array(count);
    for (var i = 0; i < count; i++) {
      readBytes[i] = bits.readBits(8);
    }
    // var encoding = stringutils.guessEncoding(readBytes);
    // TODO: We cannot decode non-unicode strings yet.
    var encoding;
    if (!characterSetEciName) {
      // The spec isn't clear on this mode; see
      // section 6.4.5: t does not say which encoding to assuming
      // upon decoding. I have seen ISO-8859-1 used as well as
      // Shift_JIS -- without anything like an ECI designator to
      // give a hint.
      encoding = stringutils.guessEncoding(readBytes);
    } else {
      encoding = characterSetEciName;
    }
    result.append(stringutils.bytesToString(readBytes, encoding));
    byteSegments.push(readBytes);
  };

  /**
   * @param {number} value character.
   * @return {string} char.
   */
  _.toAlphaNumericChar = function(value) {
    if (value >= _.ALPHANUMERIC_CHARS.length) {
      throw new FormatError();  // FormatException.getFormatInstance();
    }
    return _.ALPHANUMERIC_CHARS[Math.floor(value)];
  };

  /**
   * @param {BitSource} bits bits.
   * @param {StringBuffer} result string buffer.
   * @param {number} count bytes to decode.
   * @param {boolean} fc1InEffect flag.
   */
  _.decodeAlphanumericSegment = function(bits, result, count, fc1InEffect) {
    // Read two characters at a time
    var start = result.getLength();
    while (count > 1) {
      if (bits.available() < 11) {
        throw new FormatError();  // throw FormatException.getFormatInstance();
      }
      var nextTwoCharsBits = bits.readBits(11);
      result.append(_.toAlphaNumericChar(nextTwoCharsBits / 45));
      result.append(_.toAlphaNumericChar(nextTwoCharsBits % 45));
      count -= 2;
    }
    if (count == 1) {
      // special case: one character left
      if (bits.available() < 6) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      result.append(_.toAlphaNumericChar(bits.readBits(6)));
    }
    // See section 6.4.8.1, 6.4.8.2
    // if (fc1InEffect) {
    //   // We need to massage the result a bit if in an FNC1 mode:
    //   // TODO: subclass stringbuffer and add required methods.
    //   for (var i = start; i < result.getLength(); i++) {
    //     if (result.charAt(i) == '%') {
    //       if (i < result.length() - 1 && result.charAt(i + 1) == '%') {
    //         // %% is rendered as %
    //         result.deleteCharAt(i + 1);
    //       } else {
    //         // In alpha mode, % should be converted to FNC1 separator 0x1D
    //         result.setCharAt(i, 0x1D);
    //       }
    //     }
    //   }
    // }
  };

  /**
   * @param {BitSource} bits bits.
   * @param {StringBuffer} result string buffer.
   * @param {number} count bytes to decode.
   */
  _.decodeNumericSegment = function(bits, result, count) {
    // Read three digits at a time
    while (count >= 3) {
      // Each 10 bits encodes three digits
      if (bits.available() < 10) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      var threeDigitsBits = bits.readBits(10);
      if (threeDigitsBits >= 1000) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      result.append(_.toAlphaNumericChar(threeDigitsBits / 100));
      result.append(_.toAlphaNumericChar((threeDigitsBits / 10) % 10));
      result.append(_.toAlphaNumericChar(threeDigitsBits % 10));
      count -= 3;
    }
    if (count == 2) {
      // Two digits left over to read, encoded in 7 bits
      if (bits.available() < 7) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      var twoDigitsBits = bits.readBits(7);
      if (twoDigitsBits >= 100) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      result.append(_.toAlphaNumericChar(twoDigitsBits / 10));
      result.append(_.toAlphaNumericChar(twoDigitsBits % 10));
    } else if (count == 1) {
      // One digit left over to read
      if (bits.available() < 4) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      var digitBits = bits.readBits(4);
      if (digitBits >= 10) {
        throw new FormatError();  // FormatException.getFormatInstance();
      }
      result.append(_.toAlphaNumericChar(digitBits));
    }
  };

  _.parseECIValue = function(bits) {
    var firstByte = bits.readBits(8);
    if ((firstByte & 0x80) == 0) {
      // just one byte
      return firstByte & 0x7F;
    }
    if ((firstByte & 0xC0) == 0x80) {
      // two bytes
      var secondByte = bits.readBits(8);
      return ((firstByte & 0x3F) << 8) | secondByte;
    }
    if ((firstByte & 0xE0) == 0xC0) {
      // three bytes
      var secondThirdBytes = bits.readBits(16);
      return ((firstByte & 0x1F) << 16) | secondThirdBytes;
    }
    throw new FormatError();  // FormatException.getFormatInstance();
  };

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.GF256Poly');
goog.require('goog.asserts');

/**
 * <p>Represents a polynomial whose coefficients are elements of a GF.
 * Instances of this class are immutable.</p>
 *
 * <p>Much credit is due to William Rucklidge since portions of this code
 * are an indirect port of his C++ Reed-Solomon implementation.</p>
 *
 * @author Sean Owen
 */


goog.scope(function() {

  /**
   * GF256Polys do not have same GF256 field.
   * @param {string=} opt_message Additional message.
   * @constructor
   * @extends {Error}
   */
  w69b.qr.WrongFieldError = function(opt_message) {
    goog.base(this, opt_message);
  };
  goog.inherits(w69b.qr.WrongFieldError, Error);
  var WrongFieldError = w69b.qr.WrongFieldError;



  /**
   * @param {!w69b.qr.GF256} field field.
   * @param {Array} coefficients coefficients.
   * @constructor
   */
  w69b.qr.GF256Poly = function(field, coefficients) {
    goog.asserts.assert(coefficients != null && coefficients.length != 0);
    this.field = field;
    var coefficientsLength = coefficients.length;
    if (coefficientsLength > 1 && coefficients[0] == 0) {
      // Leading term must be non-zero for anything except the constant
      // polynomial "0"
      var firstNonZero = 1;
      while (firstNonZero < coefficientsLength &&
        coefficients[firstNonZero] == 0) {
        firstNonZero++;
      }
      if (firstNonZero == coefficientsLength) {
        this.coefficients = field.zero.coefficients;
      } else {
        this.coefficients = new Array(coefficientsLength - firstNonZero);
        for (var i = 0; i < this.coefficients.length; i++)this.coefficients[i] =
          0;
        for (var ci = 0; ci <
          this.coefficients.length; ci++)this.coefficients[ci] =
          coefficients[firstNonZero + ci];
      }
    } else {
      this.coefficients = coefficients;
    }
  };
  var GF256Poly = w69b.qr.GF256Poly;
  var pro = GF256Poly.prototype;


  /**
   * Calculates a ^ b.
   * @param {number} a number.
   * @param {number} b number.
   * @return {number} result.
   */
  GF256Poly.addOrSubtractScalar = function(a, b) {
    return a ^ b;
  };

  pro.isZero = function() {
    return this.coefficients[0] == 0;
  };

  pro.getDegree = function() {
    return this.coefficients.length - 1;
  };

  pro.getCoefficient = function(degree) {
    return this.coefficients[this.coefficients.length - 1 - degree];
  };

  pro.evaluateAt = function(a) {
    if (a == 0) {
      // Just return the x^0 coefficient
      return this.getCoefficient(0);
    }
    var size = this.coefficients.length;
    if (a == 1) {
      // Just the sum of the coefficients
      var result = 0;
      for (var i = 0; i < size; i++) {
        result = GF256Poly.addOrSubtractScalar(result, this.coefficients[i]);
      }
      return result;
    }
    var result2 = this.coefficients[0];
    for (var i = 1; i < size; i++) {
      result2 = GF256Poly.addOrSubtractScalar(this.field.multiply(a, result2),
        this.coefficients[i]);
    }
    return result2;
  };

  /**
   * Add or substract other  poly.
   * @param {!w69b.qr.GF256Poly} other other poly.
   * @return {!w69b.qr.GF256Poly} result.
   */
  pro.addOrSubtract = function(other) {
    if (this.field != other.field) {
      throw new WrongFieldError();
    }
    if (this.isZero()) {
      return other;
    }
    if (other.isZero()) {
      return this;
    }

    var smallerCoefficients = this.coefficients;
    var largerCoefficients = other.coefficients;
    if (smallerCoefficients.length > largerCoefficients.length) {
      var temp = smallerCoefficients;
      smallerCoefficients = largerCoefficients;
      largerCoefficients = temp;
    }
    var sumDiff = new Array(largerCoefficients.length);
    var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
    // Copy high-order terms only found in higher-degree polynomial's
    // coefficients
    for (var ci = 0; ci < lengthDiff; ci++)sumDiff[ci] =
      largerCoefficients[ci];

    for (var i = lengthDiff; i < largerCoefficients.length; i++) {
      sumDiff[i] = GF256Poly.addOrSubtractScalar(
        smallerCoefficients[i - lengthDiff],
        largerCoefficients[i]);
    }

    return new GF256Poly(this.field, sumDiff);
  };

  /**
   * Multiply with other poly.
   * @param {!w69b.qr.GF256Poly} other other poly.
   * @return {w69b.qr.GF256Poly} result.
   */
  pro.multiply1 = function(other) {
    if (this.field != other.field) {
      throw new WrongFieldError();
    }
    if (this.isZero() || other.isZero()) {
      return this.field.zero;
    }
    var aCoefficients = this.coefficients;
    var aLength = aCoefficients.length;
    var bCoefficients = other.coefficients;
    var bLength = bCoefficients.length;
    var product = new Array(aLength + bLength - 1);
    for (var i = 0; i < aLength; i++) {
      var aCoeff = aCoefficients[i];
      for (var j = 0; j < bLength; j++) {
        product[i + j] = GF256Poly.addOrSubtractScalar(product[i + j],
          this.field.multiply(aCoeff, bCoefficients[j]));
      }
    }
    return new GF256Poly(this.field, product);
  };

  /**
   * Multiply with scalar.
   * @param {!number} scalar other poly.
   * @return {w69b.qr.GF256Poly} result.
   */
  pro.multiply2 = function(scalar) {
    if (scalar == 0) {
      return this.field.zero;
    }
    if (scalar == 1) {
      return this;
    }
    var size = this.coefficients.length;
    var product = new Array(size);
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], scalar);
    }
    return new GF256Poly(this.field, product);
  };
  /**
   * TODO.
   * @return {!w69b.qr.GF256Poly} result.
   */
  pro.multiplyByMonomial = function(degree, coefficient) {
    goog.asserts.assert(degree >= 0);
    if (coefficient == 0) {
      return this.field.zero;
    }
    var size = this.coefficients.length;
    var product = new Array(size + degree);
    for (var i = 0; i < product.length; i++) {
      product[i] = 0;
    }
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], coefficient);
    }
    return new GF256Poly(this.field, product);
  };

  /**
   * Divide by other poly.
   * @param {!w69b.qr.GF256Poly} other other poly.
   * @return {Array.<w69b.qr.GF256Poly>} result (quotient, remainder).
   */
  pro.divide = function(other) {
    if (this.field != other.field) {
      throw new WrongFieldError();
    }
    goog.asserts.assert(!other.isZero());

    var quotient = this.field.zero;
    var remainder = this;

    var denominatorLeadingTerm = other.getCoefficient(other.getDegree());
    var inverseDenominatorLeadingTerm = this.field.inverse(
      denominatorLeadingTerm);

    while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
      var degreeDifference = remainder.getDegree() - other.getDegree();
      var scale = this.field.multiply(
        remainder.getCoefficient(remainder.getDegree()),
        inverseDenominatorLeadingTerm);
      var term = other.multiplyByMonomial(degreeDifference, scale);
      var iterationQuotient = this.field.buildMonomial(degreeDifference,
        scale);
      quotient = quotient.addOrSubtract(iterationQuotient);
      remainder = remainder.addOrSubtract(term);
    }

    return new Array(quotient, remainder);
  };

  pro.toString = function() {
    var result = [];
    for (var degree = this.getDegree(); degree >= 0; degree--) {
      var coefficient = this.getCoefficient(degree);
      if (coefficient != 0) {
        if (coefficient < 0) {
          result.push(' - ');
          coefficient = -coefficient;
        } else {
          if (result.length > 0) {
            result.push(' + ');
          }
        }
        if (degree == 0 || coefficient != 1) {
          var alphaPower = this.field.log(coefficient);
          if (alphaPower == 0) {
            result.push('1');
          } else if (alphaPower == 1) {
            result.push('a');
          } else {
            result.push('a^');
            result.push(alphaPower);
          }
        }
        if (degree != 0) {
          if (degree == 1) {
            result.push('x');
          } else {
            result.push('x^');
            result.push(degree);
          }
        }
      }
    }
    return result.join('');
  };


});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.GF256');
goog.require('w69b.qr.GF256Poly');

goog.scope(function() {
  var GF256Poly = w69b.qr.GF256Poly;

  /**
   * @param {number} primitive number.
   * @constructor
   */
  w69b.qr.GF256 = function(primitive) {
    this.expTable = new Array(256);
    this.logTable = new Array(256);
    var x = 1;
    for (var i = 0; i < 256; i++) {
      this.expTable[i] = x;
      x <<= 1; // x = x * 2; we're assuming the generator alpha is 2
      if (x >= 0x100) {
        x ^= primitive;
      }
    }
    for (var i = 0; i < 255; i++) {
      this.logTable[this.expTable[i]] = i;
    }
    // logTable[0] == 0 but this should never be used
    var at0 = new Array(1);
    at0[0] = 0;
    this.zero = new GF256Poly(this, new Array(at0));
    var at1 = new Array(1);
    at1[0] = 1;
    this.one = new GF256Poly(this, new Array(at1));
  };
  var GF256 = w69b.qr.GF256;
  var pro = GF256.prototype;

  /**
   * @return {!GF256Poly} poly.
   */
  pro.buildMonomial = function(degree, coefficient) {
    if (degree < 0) {
      throw Error();
    }
    if (coefficient == 0) {
      return this.zero;
    }
    var coefficients = new Array(degree + 1);
    for (var i = 0; i < coefficients.length; i++)coefficients[i] = 0;
    coefficients[0] = coefficient;
    return new GF256Poly(this, coefficients);
  };
  pro.exp = function(a) {
    return this.expTable[a];
  };
  pro.log = function(a) {
    if (a == 0) {
      throw Error();
    }
    return this.logTable[a];
  };
  pro.inverse = function(a) {
    if (a == 0) {
      throw Error();
    }
    return this.expTable[255 - this.logTable[a]];
  };
  pro.multiply = function(a, b) {
    if (a == 0 || b == 0) {
      return 0;
    }
    if (a == 1) {
      return b;
    }
    if (b == 1) {
      return a;
    }
    return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
  };

  GF256.QR_CODE_FIELD = new GF256(0x011D);
  GF256.DATA_MATRIX_FIELD = new GF256(0x012D);

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.ReedSolomonDecoder');
goog.require('w69b.qr.GF256Poly');
goog.require('w69b.qr.ReaderError');

/**
 * <p>Implements Reed-Solomon decoding, as the name implies.</p>
 *
 * <p>The algorithm will not be explained here, but the following references
 * were helpful
 * in creating this implementation:</p>
 *
 * <ul>
 * <li>Bruce Maggs.
 * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld
 * /www/rs_decode.ps">
 * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
 * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
 * "Chapter 5. Generalized Reed-Solomon Codes"</a>
 * (see discussion of Euclidean algorithm)</li>
 * </ul>
 *
 * <p>Much credit is due to William Rucklidge since portions of this code are
 * an indirect port of his C++ Reed-Solomon implementation.</p>
 *
 * @author Sean Owen
 * @author William Rucklidge
 * @author sanfordsquires
 */


goog.scope(function() {
  var GF256Poly = w69b.qr.GF256Poly;

  /**
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {w69b.qr.ReaderError}
   */
  w69b.qr.ReedSolomonError = function(opt_msg) {
    goog.base(this, opt_msg);
  };
  goog.inherits(w69b.qr.ReedSolomonError, w69b.qr.ReaderError);
  var ReedSolomonError = w69b.qr.ReedSolomonError;
  /**
   * @constructor
   * @param {!w69b.qr.GF256} field field.
   */
  w69b.qr.ReedSolomonDecoder = function(field) {
    this.field = field;
  };
  var ReedSolomonDecoder = w69b.qr.ReedSolomonDecoder;
  var pro = ReedSolomonDecoder.prototype;

  /**
   * <p>Decodes given set of received codewords, which include both data and
   * error-correction codewords.
   * Really, this means it uses Reed-Solomon to detect and correct  errors,
   * in-place, in the input.</p>
   *
   * @param {Array.<number>} received data and error-correction codewords.
   * @param {number} twoS number of error-correction codewords available.
   */
  pro.decode = function(received, twoS) {
    var poly = new GF256Poly(this.field, received);
    var syndromeCoefficients = new Array(twoS);
    for (var i = 0; i <
      syndromeCoefficients.length; i++)syndromeCoefficients[i] = 0;
    var dataMatrix = false;//this.field.Equals(GF256.DATA_MATRIX_FIELD);
    var noError = true;
    for (var i = 0; i < twoS; i++) {
      // Thanks to sanfordsquires for this fix:
      var val = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));
      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = val;
      if (val != 0) {
        noError = false;
      }
    }
    if (noError) {
      return;
    }
    var syndrome = new GF256Poly(this.field, syndromeCoefficients);
    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS,
      1), syndrome, twoS);
    var sigma = sigmaOmega[0];
    var omega = sigmaOmega[1];
    var errorLocations = this.findErrorLocations(sigma);
    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations,
      dataMatrix);
    for (var i = 0; i < errorLocations.length; i++) {
      var position = received.length - 1 - this.field.log(errorLocations[i]);
      if (position < 0) {
        throw new ReedSolomonError('bad error location');
      }
      received[position] = GF256Poly.addOrSubtractScalar(received[position],
        errorMagnitudes[i]);
    }
  };

  pro.runEuclideanAlgorithm = function(a, b, R) {
    // Assume a's degree is >= b's
    if (a.getDegree() < b.getDegree()) {
      var temp = a;
      a = b;
      b = temp;
    }

    var rLast = a;
    var r = b;
    var sLast = this.field.one;
    var s = this.field.zero;
    var tLast = this.field.zero;
    var t = this.field.one;

    // Run Euclidean algorithm until r's degree is less than R/2
    while (r.getDegree() >= Math.floor(R / 2)) {
      var rLastLast = rLast;
      var sLastLast = sLast;
      var tLastLast = tLast;
      rLast = r;
      sLast = s;
      tLast = t;

      // Divide rLastLast by rLast, with quotient in q and remainder in r
      if (rLast.isZero()) {
        // Oops, Euclidean algorithm already terminated?
        throw new ReedSolomonError('r_{i-1} was zero');
      }
      r = rLastLast;
      var q = this.field.zero;
      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
      var dltInverse = this.field.inverse(denominatorLeadingTerm);
      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
        var degreeDiff = r.getDegree() - rLast.getDegree();
        var scale = this.field.multiply(r.getCoefficient(r.getDegree()),
          dltInverse);
        q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));
        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
        //r.EXE();
      }

      s = q.multiply1(sLast).addOrSubtract(sLastLast);
      t = q.multiply1(tLast).addOrSubtract(tLastLast);
    }

    var sigmaTildeAtZero = t.getCoefficient(0);
    if (sigmaTildeAtZero == 0) {
      throw new ReedSolomonError('sigmaTilde(0) was zero');
    }

    var inverse = this.field.inverse(sigmaTildeAtZero);
    var sigma = t.multiply2(inverse);
    var omega = r.multiply2(inverse);
    return new Array(sigma, omega);
  };
  pro.findErrorLocations = function(errorLocator) {
    // This is a direct application of Chien's search
    var numErrors = errorLocator.getDegree();
    if (numErrors == 1) {
      // shortcut
      return [errorLocator.getCoefficient(1)];
    }
    var result = new Array(numErrors);
    var e = 0;
    for (var i = 1; i < 256 && e < numErrors; i++) {
      if (errorLocator.evaluateAt(i) == 0) {
        result[e] = this.field.inverse(i);
        e++;
      }
    }
    if (e != numErrors) {
      throw new ReedSolomonError('locator degree does not match ' +
        'number of roots');
    }
    return result;
  };
  pro.findErrorMagnitudes =
    function(errorEvaluator, errorLocations, dataMatrix) {
      // This is directly applying Forney's Formula
      var s = errorLocations.length;
      var result = new Array(s);
      for (var i = 0; i < s; i++) {
        var xiInverse = this.field.inverse(errorLocations[i]);
        var denominator = 1;
        for (var j = 0; j < s; j++) {
          if (i != j) {
            denominator =
              this.field.multiply(denominator, GF256Poly.addOrSubtractScalar(1,
                this.field.multiply(errorLocations[j], xiInverse)));
          }
        }
        result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse),
          this.field.inverse(denominator));
        // Thanks to sanfordsquires for this fix:
        if (dataMatrix) {
          result[i] = this.field.multiply(result[i], xiInverse);
        }
      }
      return result;
    };
});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 Ported to JavaScript by Lazar Laszlo 2011

 lazarsoft@gmail.com, www.lazarsoft.info

 */

/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.decoder');
goog.require('w69b.qr.BitMatrixParser');
goog.require('w69b.qr.DataBlock');
goog.require('w69b.qr.DecodedBitStreamParser');
goog.require('w69b.qr.GF256');
goog.require('w69b.qr.ReedSolomonDecoder');

goog.scope(function() {
  var GF256 = w69b.qr.GF256;
  var DataBlock = w69b.qr.DataBlock;

  var _ = w69b.qr.decoder;
  _.rsDecoder = new w69b.qr.ReedSolomonDecoder(GF256.QR_CODE_FIELD);

  _.correctErrors = function(codewordBytes, numDataCodewords) {
    var numCodewords = codewordBytes.length;
    // First read into an array of ints
    var codewordsInts = new Array(numCodewords);
    for (var i = 0; i < numCodewords; i++) {
      codewordsInts[i] = codewordBytes[i] & 0xFF;
    }
    var numECCodewords = codewordBytes.length - numDataCodewords;
    _.rsDecoder.decode(codewordsInts, numECCodewords);
      //var corrector = new ReedSolomon(codewordsInts, numECCodewords);
      //corrector.correct();
    // Copy back into array of bytes -- only need to worry about the bytes that
    // were data We don't care about errors in the error-correction codewords
    for (var i = 0; i < numDataCodewords; i++) {
      codewordBytes[i] = codewordsInts[i];
    }
  };

  /**
   * @param {w69b.qr.BitMatrix} bits matrix.
   * @return {string} reader instnance.
   */
  _.decode = function(bits) {
    var parser = new w69b.qr.BitMatrixParser(bits);
    var version = parser.readVersion();
    var ecLevel = parser.readFormatInformation().errorCorrectionLevel;

    // Read codewords
    var codewords = parser.readCodewords();

    // Separate into data blocks
    var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);

    // Count total number of data bytes
    var totalBytes = 0;
    for (var i = 0; i < dataBlocks.length; i++) {
      totalBytes += dataBlocks[i].numDataCodewords;
    }
    var resultBytes = new Array(totalBytes);
    var resultOffset = 0;

    // Error-correct and copy data blocks together into a stream of bytes
    for (var j = 0; j < dataBlocks.length; j++) {
      var dataBlock = dataBlocks[j];
      var codewordBytes = dataBlock.codewords;
      var numDataCodewords = dataBlock.numDataCodewords;
      _.correctErrors(codewordBytes, numDataCodewords);
      for (var i = 0; i < numDataCodewords; i++) {
        resultBytes[resultOffset++] = codewordBytes[i];
      }
    }

    // Decode the contents of that stream of bytes
    return w69b.qr.DecodedBitStreamParser.decode(resultBytes,
      version, ecLevel.bits);
    //return DecodedBitStreamParserOld.decode(resultBytes, version, ecLevel);
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.BitArray');

goog.scope(function() {
/**
   * <p>A simple, fast array of bits, represented compactly by an array of ints
   * internally.</p>
   * @param {number=} opt_size size, defaults to 0.
   * @constructor
   * @author Sean Owen
   */
  w69b.qr.BitArray = function(opt_size) {
    /**
     * @private
     * @type {number}
     */
    this.size_ = opt_size || 0;
    /**
     * @type {Int32Array} bits.
     * @private
     */
    this.bits_ = w69b.qr.BitArray.makeArray(this.size_);
  };
  var _ = w69b.qr.BitArray;
  var pro = _.prototype;

  _.numberOfTrailingZeros = function(i) {
    // HD, Figure 5-14
    var y;
    if (i == 0) return 32;
    var n = 31;
    y = i << 16; if (y != 0) { n = n - 16; i = y; }
    y = i << 8; if (y != 0) { n = n - 8; i = y; }
    y = i << 4; if (y != 0) { n = n - 4; i = y; }
    y = i << 2; if (y != 0) { n = n - 2; i = y; }
    return n - ((i << 1) >>> 31);
  };

  pro.getSize = function() {
    return this.size_;
  };

  pro.getSizeInBytes = function() {
    return (this.size_ + 7) >> 3;
  };

  pro.ensureCapacity = function(size) {
    if (size > this.bits_.length << 5) {
      var newBits = _.makeArray(size);
      newBits.set(this.bits_, 0);
      this.bits_ = newBits;
    }
  };

  /**
   * @param {number} i bit to get.
   * @return {boolean} true iff bit i is set.
   */
  pro.get = function(i) {
    return (this.bits_[i >> 5] & (1 << (i & 0x1F))) != 0;
  };

  /**
   * Sets bit i.
   * @param {number} i bit to set.
   */
  pro.set = function(i) {
    this.bits_[i >> 5] |= 1 << (i & 0x1F);
  };

  /**
   * Flips bit i.
   *
   * @param {number} i bit to set.
   */
  pro.flip = function(i) {
    this.bits_[i >> 5] ^= 1 << (i & 0x1F);
  };

  /**
   * @param {number} from first bit to check.
   * @return {number} index of first bit that is set, starting from the given
   * index, or size if none are set at or beyond this given index.
   * @see #getNextUnset(int)
   */
  pro.getNextSet = function(from) {
    var size = this.size_;
    if (from >= size) {
      return size;
    }
    var bitsOffset = from >> 5;
    var currentBits = this.bits_[bitsOffset];
    // mask off lesser bits first
    currentBits &= ~((1 << (from & 0x1F)) - 1);
    while (currentBits == 0) {
      if (++bitsOffset == this.bits_.length) {
        return size;
      }
      currentBits = this.bits_[bitsOffset];
    }
    var result = (bitsOffset << 5) + _.numberOfTrailingZeros(currentBits);
    return result > size ? size : result;
  };

  /**
   * @see #getNextSet(int)
   */
  pro.getNextUnset = function(from) {
    var size = this.size_;
    if (from >= size) {
      return size;
    }
    var bitsOffset = from >> 5;
    var currentBits = ~this.bits_[bitsOffset];
    // mask off lesser bits first
    currentBits &= ~((1 << (from & 0x1F)) - 1);
    while (currentBits == 0) {
      if (++bitsOffset == this.bits_.length) {
        return size;
      }
      currentBits = ~this.bits_[bitsOffset];
    }
    var result = (bitsOffset << 5) + _.numberOfTrailingZeros(currentBits);
    return result > size ? size : result;
  };

  /**
   * Sets a block of 32 bits, starting at bit i.
   *
   * @param {number} i first bit to set.
   * @param {number} newBits the new value of the next 32 bits. Note again that
   * the least-significant bit corresponds to bit i, the next-least-significant
   * to i+1, and so on.
   */
  pro.setBulk = function(i, newBits) {
    this.bits_[i >> 5] = newBits;
  };

  /**
   * Sets a range of bits.
   *
   * @param {number} start start of range, inclusive.
   * @param {number} end end of range, exclusive.
   */
  pro.setRange = function(start, end) {
    if (end < start) {
      throw new Error();
    }
    if (end == start) {
      return;
    }
    // will be easier to treat this as the last actually set bit -- inclusive
    end--;
    var firstInt = start >> 5;
    var lastInt = end >> 5;
    for (var i = firstInt; i <= lastInt; i++) {
      var firstBit = i > firstInt ? 0 : start & 0x1F;
      var lastBit = i < lastInt ? 31 : end & 0x1F;
      var mask;
      if (firstBit == 0 && lastBit == 31) {
        mask = -1;
      } else {
        mask = 0;
        for (var j = firstBit; j <= lastBit; j++) {
          mask |= 1 << j;
        }
      }
      this.bits_[i] |= mask;
    }
  };

  /**
   * Clears all bits (sets to false).
   */
  pro.clear = function() {
    var max = this.bits_.length;
    for (var i = 0; i < max; i++) {
      this.bits_[i] = 0;
    }
  };

  /**
   * Efficient method to check if a range of bits is set, or not set.
   *
   * @param {number} start start of range, inclusive.
   * @param {number} end end of range, exclusive.
   * @param {boolean} value if true, checks that bits in range are set,
   * otherwise checks that they are not set.
   * @return {boolean} true iff all bits are set or not set in range, according
   * to value argument.
   */
  pro.isRange = function(start, end, value) {
    if (end < start) {
      throw new Error();
    }
    if (end == start) {
      return true; // empty range matches
    }
    // will be easier to treat this as the last actually set bit -- inclusive
    end--;
    var firstInt = start >> 5;
    var lastInt = end >> 5;
    for (var i = firstInt; i <= lastInt; i++) {
      var firstBit = i > firstInt ? 0 : start & 0x1F;
      var lastBit = i < lastInt ? 31 : end & 0x1F;
      var mask;
      if (firstBit == 0 && lastBit == 31) {
        mask = -1;
      } else {
        mask = 0;
        for (var j = firstBit; j <= lastBit; j++) {
          mask |= 1 << j;
        }
      }

      // Return false if we're looking for 1s and the masked bits[i] isn't all
      // 1s (that is, equals the mask, or we're looking for 0s and the masked
      // portion is not all 0s
      if ((this.bits_[i] & mask) != (value ? mask : 0)) {
        return false;
      }
    }
    return true;
  };

  pro.appendBit = function(bit) {
    this.ensureCapacity(this.size_ + 1);
    if (bit) {
      this.bits_[this.size_ >> 5] |= 1 << (this.size_ & 0x1F);
    }
    this.size_++;
  };

  /**
   * Appends the least-significant this.bits_, from value, in order from
   * most-significant to least-significant. For example, appending 6 this.bits_
   * from 0x000001E will append the this.bits_ 0, 1, 1, 1, 1, 0 in that order.
   */
  pro.appendBits = function(value, numBits) {
    if (numBits < 0 || numBits > 32) {
      throw new Error();
    }
    this.ensureCapacity(this.size_ + numBits);
    for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
      this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) == 1);
    }
  };

  pro.appendBitArray = function(other) {
    var otherSize = other.size_;
    this.ensureCapacity(this.size_ + otherSize);
    for (var i = 0; i < otherSize; i++) {
      this.appendBit(other.get(i));
    }
  };

  /**
   * @param {w69b.qr.BitArray} other other.
   */
  pro.xor = function(other) {
    if (this.bits_.length != other.bits_.length) {
      throw new Error();
    }
    for (var i = 0; i < this.bits_.length; i++) {
      // The last byte could be incomplete (i.e. not have 8 this.bits_ in
      // it) but there is no problem since 0 XOR 0 == 0.
      this.bits_[i] ^= other.bits_[i];
    }
  };

  /**
   *
   * @param {number} bitOffset first bit to start writing.
   * @param {Array} array array to write varo. Bytes are written
   * most-significant byte first. This is the opposite of the varernal
   * representation, which is * exposed by {@link #getBitArray()}.
   * @param {number} offset position in array to start writing.
   * @param {number} numBytes how many bytes to write.
   */
  pro.toBytes = function(bitOffset, array, offset, numBytes) {
    for (var i = 0; i < numBytes; i++) {
      var theByte = 0;
      for (var j = 0; j < 8; j++) {
        if (this.get(bitOffset)) {
          theByte |= 1 << (7 - j);
        }
        bitOffset++;
      }
      array[offset + i] = theByte;
    }
  };

  /**
   * @return {Int32Array} array of vars. The first element holds the first 32
   * bits, and the least significant bit is bit 0.
   */
  pro.getBitArray = function() {
    return this.bits_;
  };

  /**
   * Reverses all bits in the array.
   */
  pro.reverse = function() {
    var newBits = new Int32Array(this.bits_.length);
    var size = this.size_;
    for (var i = 0; i < size; i++) {
      if (this.get(size - i - 1)) {
        newBits[i >> 5] |= 1 << (i & 0x1F);
      }
    }
    this.bits_ = newBits;
  };

  _.makeArray = function(size) {
    return new Int32Array((size + 31) >> 5);
  };

  pro.toString = function() {
    var result = [];
    for (var i = 0; i < this.size_; i++) {
      if ((i & 0x07) == 0) {
        result.push(' ');
      }
      result.push(this.get(i) ? 'X' : '.');
    }
    return result.join('');
  };

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 *
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('w69b.qr.EncodeHintType');

/**
 * Encode hint key constants.
 * @enum {number}
 */
w69b.qr.EncodeHintType = {
  CHARACTER_SET: 1,
  FORCE_ADD_ECI: 2
};

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.ReedSolomonEncoder');
goog.require('w69b.qr.GF256');
goog.require('w69b.qr.GF256Poly');

goog.scope(function() {
  var GF256 = w69b.qr.GF256;
  var GF256Poly = w69b.qr.GF256Poly;

  /**
   * <p>Implements Reed-Solomon enbcoding, as the name implies.</p>
   *
   * @author Sean Owen
   * @author William Rucklidge
   * @author mb@w69b.com (Mahuel Braun) ported to js.
   */

  /**
   *
   * @param {!GF256} field to use.
   * @constructor
   */
  w69b.qr.ReedSolomonEncoder = function(field) {
    /**
     * @private
     * @type {!GF256}
     */
    this.field_ = field;
    /**
     * @private
     * @type {Array.<!GF256Poly>}
     */
    this.cachedGenerators_ = [new GF256Poly(field, [1])];
  };
  var pro = w69b.qr.ReedSolomonEncoder.prototype;

  /**
   * @param {number} degree degree.
   * @return {!GF256Poly} generator.
   */
  pro.buildGenerator = function(degree) {
    var cachedGenerators = this.cachedGenerators_;
    if (degree >= cachedGenerators.length) {
      var lastGenerator = cachedGenerators[cachedGenerators.length - 1];
      for (var d = cachedGenerators.length; d <= degree; d++) {
        var nextGenerator = lastGenerator.multiply1(
          new GF256Poly(this.field_, [1, this.field_.exp(d - 1)]));
        cachedGenerators.push(nextGenerator);
        lastGenerator = nextGenerator;
      }
    }
    return cachedGenerators[degree];
  };

  /**
   * @param {Array.<number>} toEncode data to encode, including pre-allocated
   * space for ecc bytes.
   * @param {number} ecBytes number of ec bytes.
   */
  pro.encode = function(toEncode, ecBytes) {
    if (ecBytes == 0) {
      throw new Error('No error correction bytes');
    }
    var dataBytes = toEncode.length - ecBytes;
    if (dataBytes <= 0) {
      throw new Error('No data bytes provided');
    }
    var generator = this.buildGenerator(ecBytes);
    var infoCoefficients = toEncode.slice(0, dataBytes);
    var info = new GF256Poly(this.field_, infoCoefficients);
    info = info.multiplyByMonomial(ecBytes, 1);
    var remainder = info.divide(generator)[1];
    var coefficients = remainder.coefficients;
    var numZeroCoefficients = ecBytes - coefficients.length;
    var i;
    for (i = 0; i < numZeroCoefficients; i++) {
      toEncode[dataBytes + i] = 0;
    }
    for (i = 0; i < coefficients.length; ++i) {
      toEncode[dataBytes + numZeroCoefficients + i] = coefficients[i];
    }
    // System.arraycopy(coefficients, 0, toEncode,
    //   dataBytes + numZeroCoefficients, coefficients.length);
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.BlockPair');

goog.scope(function() {
  /**
   * @constructor
   */
  w69b.qr.encoder.BlockPair = function(data, errorCorrection) {
    this.dataBytes = data;
    this.errorCorrectionBytes = errorCorrection;
  };
  var pro = w69b.qr.encoder.BlockPair.prototype;

  pro.getDataBytes = function() {
    return this.dataBytes;
  };

  pro.getErrorCorrectionBytes = function() {
    return this.errorCorrectionBytes;
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.ByteMatrix');

/**
 * A class which wraps a 2D array of bytes. The default usage is signed.
 * If you want to use it as a
 * unsigned container, it's up to you to do byteValue & 0xff at each location.
 *
 * JAVAPORT: The original code was a 2D array of ints, but since it only ever
 * gets assigned
 * -1, 0, and 1, I'm going to use less memory and go with bytes.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author mb@w69b.com (Manuel Braun) - ported to js.
 */
goog.scope(function() {

  /**
   * Row (y) first byte matrix.
   * @param {number} width with.
   * @param {number} height height.
   * @constructor
   */
  w69b.qr.encoder.ByteMatrix = function(width, height) {
    /**
     * @type {number}
     * @private
     */
    this.width_ = width;
    /**
     * @type {number}
     * @private
     */
    this.height_ = height;
    this.bytes_ = new Int8Array(width * height);
  };
  var pro = w69b.qr.encoder.ByteMatrix.prototype;

  pro.getBytes = function() {
    return this.bytes_;
  };

  pro.getHeight = function() {
    return this.height_;
  };

  pro.getWidth = function() {
    return this.width_;
  };

  pro.get = function(x, y) {
    return this.bytes_[this.width_ * y + x];
  };

  pro.set = function(x, y, value) {
    this.bytes_[this.width_ * y + x] = value;
  };

  pro.clear = function(value) {
    for (var i = 0; i < this.bytes_.length; ++i)
      this.bytes_[i] = value;
  };

  pro.toString = function() {
    var result = [];
    for (var y = 0; y < this.height_; ++y) {
      for (var x = 0; x < this.width_; ++x) {
        switch (this.get(x, y)) {
          case 0:
            result.push(' 0');
            break;
          case 1:
            result.push(' 1');
            break;
          default:
            result.push('  ');
            break;
        }
      }
      result.push('\n');
    }
    return result.join('');
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.MaskUtil');
goog.require('w69b.qr.encoder.ByteMatrix');

goog.scope(function() {
  var ByteMatrix = w69b.qr.encoder.ByteMatrix;

/**
 * @author Satoru Takabayashi
 * @author Daniel Switkin
 * @author Sean Owen
 * @author mb@69b.com (Manuel Braun) ported to js
 */
var _ = w69b.qr.encoder.MaskUtil;

  // Penalty weights from section 6.8.2.1
  _.N1 = 3;
  _.N2 = 3;
  _.N3 = 40;
  _.N4 = 10;

  /**
   * Apply mask penalty rule 1 and return the penalty.
   * Find repetitive cells with the same color and
   * give penalty to them. Example: 00000 or 11111.
   * @param {ByteMatrix} matrix working matrix.
   * @return {number} result.
   */
  _.applyMaskPenaltyRule1 = function(matrix) {
    return _.applyMaskPenaltyRule1Internal(matrix, true) +
      _.applyMaskPenaltyRule1Internal(matrix, false);
  };

  /**
   * Apply mask penalty rule 2 and return the penalty.
   * Find 2x2 blocks with the same color and give
   * penalty to them. This is actually equivalent to the spec's rule,
   * which is to find MxN blocks and give a
   * penalty proportional to (M-1)x(N-1), because this is the number of
   * 2x2 blocks inside such a block.
   * @param {ByteMatrix} matrix working matrix.
   * @return {number} result.
   */
  _.applyMaskPenaltyRule2 = function(matrix) {
    var penalty = 0;
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    for (var y = 0; y < height - 1; y++) {
      for (var x = 0; x < width - 1; x++) {
        var value = matrix.get(x, y);
        if (value == matrix.get(x + 1, y) && value == matrix.get(x, y + 1) &&
          value == matrix.get(x + 1, y + 1)) {
          penalty++;
        }
      }
    }
    return _.N2 * penalty;
  };

  /**
   * Apply mask penalty rule 3 and return the penalty. Find consecutive
   * cells of 00001011101 or
   * 10111010000, and give penalty to them.
   * If we find patterns like 000010111010000, we give
   * penalties twice (i.e. 40 * 2).
   * @param {ByteMatrix} matrix working matrix.
   * @return {number} result.
   */
  _.applyMaskPenaltyRule3 = function(matrix) {
    var penalty = 0;
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    var bytes = matrix.getBytes();
    for (var y = 0; y < height; y++) {
      var yOffset = width * y;
      for (var x = 0; x < width; x++) {
        // Tried to simplify following conditions but failed.
        if (x + 6 < width &&
            bytes[yOffset + x] == 1 &&
            bytes[yOffset + x + 1] == 0 &&
            bytes[yOffset + x + 2] == 1 &&
            bytes[yOffset + x + 3] == 1 &&
            bytes[yOffset + x + 4] == 1 &&
            bytes[yOffset + x + 5] == 0 &&
            bytes[yOffset + x + 6] == 1 &&
            ((x + 10 < width &&
                bytes[yOffset + x + 7] == 0 &&
                bytes[yOffset + x + 8] == 0 &&
                bytes[yOffset + x + 9] == 0 &&
                bytes[yOffset + x + 10] == 0) ||
             (x - 4 >= 0 &&
                bytes[yOffset + x - 1] == 0 &&
                bytes[yOffset + x - 2] == 0 &&
                bytes[yOffset + x - 3] == 0 &&
                bytes[yOffset + x - 4] == 0))) {
          penalty += _.N3;
        }
        if (y + 6 < height &&
            matrix.get(x, y) == 1 &&
            matrix.get(x, y + 1) == 0 &&
            matrix.get(x, y + 2) == 1 &&
            matrix.get(x, y + 3) == 1 &&
            matrix.get(x, y + 4) == 1 &&
            matrix.get(x, y + 5) == 0 &&
            matrix.get(x, y + 6) == 1 &&
            ((y + 10 < height &&
                matrix.get(x, y + 7) == 0 &&
                matrix.get(x, y + 8) == 0 &&
                matrix.get(x, y + 9) == 0 &&
                matrix.get(x, y + 10) == 0) ||
             (y - 4 >= 0 &&
                matrix.get(x, y - 1) == 0 &&
                matrix.get(x, y - 2) == 0 &&
                matrix.get(x, y - 3) == 0 &&
                matrix.get(x, y - 4) == 0))) {
          penalty += _.N3;
        }
      }
    }
    return penalty;
  };

  /** Apply mask penalty rule 4 and return the penalty. Calculate the ratio of
   * dark cells and give penalty if the ratio is far from 50%. It gives 10
   * penalty for 5% distance.
   * @param {ByteMatrix} matrix working matrix.
   * @return {number} result.
   */
  _.applyMaskPenaltyRule4 = function(matrix) {
    var numDarkCells = 0;
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        if (matrix.get(x, y) == 1) {
          numDarkCells++;
        }
      }
    }
    var numTotalCells = matrix.getHeight() * matrix.getWidth();
    var darkRatio = numDarkCells / numTotalCells;
    // * 100.0 / 5.0
    var fivePercentVariances = Math.floor(Math.abs(darkRatio - 0.5) * 20.0);
    return fivePercentVariances * _.N4;
  };

  /**
   * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of
   * JISX0510:2004 for mask
   * pattern conditions.
   * @param {number} maskPattern pattern.
   * @param {number} x pos.
   * @param {number} y pos.
   */
  _.getDataMaskBit = function(maskPattern, x, y) {
    var intermediate;
    var temp;
    switch (maskPattern) {
      case 0:
        intermediate = (y + x) & 0x1;
        break;
      case 1:
        intermediate = y & 0x1;
        break;
      case 2:
        intermediate = x % 3;
        break;
      case 3:
        intermediate = (y + x) % 3;
        break;
      case 4:
        intermediate = ((y >>> 1) + (x / 3)) & 0x1;
        break;
      case 5:
        temp = y * x;
        intermediate = (temp & 0x1) + (temp % 3);
        break;
      case 6:
        temp = y * x;
        intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;
        break;
      case 7:
        temp = y * x;
        intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;
        break;
      default:
        throw new Error('Invalid mask pattern: ' + maskPattern);
    }
    return intermediate == 0;
  };

  /**
   * Helper function for applyMaskPenaltyRule1. We need this for doing this
   * calculation in both vertical and horizontal orders respectively.
   * @param {ByteMatrix} matrix working matrix.
   * @param {boolean} isHorizontal horizontal switch.
   * @return {number} penalty.
   */
  _.applyMaskPenaltyRule1Internal = function(matrix, isHorizontal) {
    var penalty = 0;
    var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
    var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
    for (var i = 0; i < iLimit; i++) {
      var numSameBitCells = 0;
      var prevBit = -1;
      for (var j = 0; j < jLimit; j++) {
        var bit = isHorizontal ? matrix.get(j, i) : matrix.get(i, j);
        if (bit == prevBit) {
          numSameBitCells++;
        } else {
          if (numSameBitCells >= 5) {
            penalty += _.N1 + (numSameBitCells - 5);
          }
          numSameBitCells = 1;  // Include the cell itself.
          prevBit = bit;
        }
      }
      if (numSameBitCells > 5) {
        penalty += _.N1 + (numSameBitCells - 5);
      }
    }
    return penalty;
  };

});

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.WriterError');
goog.require('goog.debug.Error');

goog.scope(function() {
  /**
   * @constructor
   * @param {string=} opt_msg message.
   * @extends {goog.debug.Error}
   */
  w69b.qr.WriterError = function(opt_msg) {
    goog.base(this, opt_msg);
  };
  goog.inherits(w69b.qr.WriterError, goog.debug.Error);

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.QRCode');
goog.require('w69b.qr.ErrorCorrectionLevel');
goog.require('w69b.qr.Mode');
goog.require('w69b.qr.Version');
goog.require('w69b.qr.encoder.ByteMatrix');

goog.scope(function() {

  var ErrorCorrectionLevel = w69b.qr.ErrorCorrectionLevel;
  var Mode = w69b.qr.Mode;
  var Version = w69b.qr.Version;
  var ByteMatrix = w69b.qr.encoder.ByteMatrix;

  /**
   * @constructor
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C++
   * @author mb@w69b.com (Manuel Braun) - ported to js.
   */
  w69b.qr.encoder.QRCode = function() {
  };
  var _ = w69b.qr.encoder.QRCode;
  var pro = _.prototype;
  /**
   * @type {Mode}
   * @private
   */
  pro.mode_ = null;
  /**
   *
   * @type {ErrorCorrectionLevel}
   * @private
   */
  pro.ecLevel_ = null;
  /**
   *
   * @type {Version}
   * @private
   */
  pro.version_ = null;
  /**
   *
   * @type {number}
   * @private
   */
  pro.maskPattern_ = -1;
  /**
   *
   * @type {ByteMatrix}
   * @private
   */
  pro.matrix_ = null;

  /**
   * @type {number}
   */
  _.NUM_MASK_PATTERNS = 8;


  /**
   * @return {Mode} mode.
   */
  pro.getMode = function() {
    return this.mode_;
  };

  /**
   * @return {ErrorCorrectionLevel} ec level.
   */
  pro.getECLevel = function() {
    return this.ecLevel_;
  };

  /**
   * @return {Version} version.
   */
  pro.getVersion = function() {
    return this.version_;
  };

  /**
   * @return {number} mask pattern.
   */
  pro.getMaskPattern = function() {
    return this.maskPattern_;
  };

  /**
   * @return {ByteMatrix} matrix.
   */
  pro.getMatrix = function() {
    return this.matrix_;
  };


  /**
   * @return {string} debug string.
   */
  pro.toString = function() {
    var result = [];
    result.push('<<\n');
    result.push(' mode: ');
    result.push(this.mode_.toString());
    result.push('\n ecLevel: ');
    result.push(this.ecLevel_.toString());
    result.push('\n version: ');
    result.push(this.version_.toString());
    result.push('\n maskPattern: ');
    result.push(this.maskPattern_);
    if (this.matrix_ == null) {
      result.push('\n matrix: null\n');
    } else {
      result.push('\n matrix:\n');
      result.push(this.matrix_.toString());
    }
    result.push('>>\n');
    return result.join('');
  };

  /**
   * @param {Mode} value mode.
   */
  pro.setMode = function(value) {
    this.mode_ = value;
  };

  /**
   * @param {ErrorCorrectionLevel} value ec level.
   */
  pro.setECLevel = function(value) {
    this.ecLevel_ = value;
  };

  /**
   * @param {Version} version version.
   */
  pro.setVersion = function(version) {
    this.version_ = version;
  };

  /**
   * @param {number} value pattern.
   */
  pro.setMaskPattern = function(value) {
    this.maskPattern_ = value;
  };

  /**
   * @param {ByteMatrix} value matrix.
   */
  pro.setMatrix = function(value) {
    this.matrix_ = value;
  };

  /**
   * @param {number} maskPattern pattern.
   * @return {boolean} weather it is valid.
   */
  _.isValidMaskPattern = function(maskPattern) {
    return maskPattern >= 0 && maskPattern < _.NUM_MASK_PATTERNS;
  };

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.MatrixUtil');
goog.require('w69b.qr.BitArray');
goog.require('w69b.qr.ErrorCorrectionLevel');
goog.require('w69b.qr.Version');
goog.require('w69b.qr.WriterError');
goog.require('w69b.qr.encoder.ByteMatrix');
goog.require('w69b.qr.encoder.MaskUtil');
goog.require('w69b.qr.encoder.QRCode');

goog.scope(function() {
  var ErrorCorrectionLevel = w69b.qr.ErrorCorrectionLevel;
  var BitArray = w69b.qr.BitArray;
  var ByteMatrix = w69b.qr.encoder.ByteMatrix;
  var Version = w69b.qr.Version;
  var WriterError = w69b.qr.WriterError;
  var QRCode = w69b.qr.encoder.QRCode;
  var MaskUtil = w69b.qr.encoder.MaskUtil;


  /**
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C++
   * @author mb@w69b.com (Manuel Braun) - ported to js.
   */
  var _ = w69b.qr.encoder.MatrixUtil;

  _.POSITION_DETECTION_PATTERN = [
    [1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1]
  ];

  _.POSITION_ADJUSTMENT_PATTERN = [
    [1, 1, 1, 1, 1],
    [1, 0, 0, 0, 1],
    [1, 0, 1, 0, 1],
    [1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1]
  ];

  // From Appendix E. Table 1, JIS0510X:2004 (p 71). The table was
  // double-checked by komatsu.
  _.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = [
    [-1, -1, -1, -1, -1, -1, -1],  // Version 1
    [6, 18, -1, -1, -1, -1, -1],  // Version 2
    [6, 22, -1, -1, -1, -1, -1],  // Version 3
    [6, 26, -1, -1, -1, -1, -1],  // Version 4
    [6, 30, -1, -1, -1, -1, -1],  // Version 5
    [6, 34, -1, -1, -1, -1, -1],  // Version 6
    [6, 22, 38, -1, -1, -1, -1],  // Version 7
    [6, 24, 42, -1, -1, -1, -1],  // Version 8
    [6, 26, 46, -1, -1, -1, -1],  // Version 9
    [6, 28, 50, -1, -1, -1, -1],  // Version 10
    [6, 30, 54, -1, -1, -1, -1],  // Version 11
    [6, 32, 58, -1, -1, -1, -1],  // Version 12
    [6, 34, 62, -1, -1, -1, -1],  // Version 13
    [6, 26, 46, 66, -1, -1, -1],  // Version 14
    [6, 26, 48, 70, -1, -1, -1],  // Version 15
    [6, 26, 50, 74, -1, -1, -1],  // Version 16
    [6, 30, 54, 78, -1, -1, -1],  // Version 17
    [6, 30, 56, 82, -1, -1, -1],  // Version 18
    [6, 30, 58, 86, -1, -1, -1],  // Version 19
    [6, 34, 62, 90, -1, -1, -1],  // Version 20
    [6, 28, 50, 72, 94, -1, -1],  // Version 21
    [6, 26, 50, 74, 98, -1, -1],  // Version 22
    [6, 30, 54, 78, 102, -1, -1],  // Version 23
    [6, 28, 54, 80, 106, -1, -1],  // Version 24
    [6, 32, 58, 84, 110, -1, -1],  // Version 25
    [6, 30, 58, 86, 114, -1, -1],  // Version 26
    [6, 34, 62, 90, 118, -1, -1],  // Version 27
    [6, 26, 50, 74, 98, 122, -1],  // Version 28
    [6, 30, 54, 78, 102, 126, -1],  // Version 29
    [6, 26, 52, 78, 104, 130, -1],  // Version 30
    [6, 30, 56, 82, 108, 134, -1],  // Version 31
    [6, 34, 60, 86, 112, 138, -1],  // Version 32
    [6, 30, 58, 86, 114, 142, -1],  // Version 33
    [6, 34, 62, 90, 118, 146, -1],  // Version 34
    [6, 30, 54, 78, 102, 126, 150],  // Version 35
    [6, 24, 50, 76, 102, 128, 154],  // Version 36
    [6, 28, 54, 80, 106, 132, 158],  // Version 37
    [6, 32, 58, 84, 110, 136, 162],  // Version 38
    [6, 26, 54, 82, 110, 138, 166],  // Version 39
    [6, 30, 58, 86, 114, 142, 170]  // Version 40
  ];

  // Type info cells at the left top corner.
  _.TYPE_INFO_COORDINATES = [
    [8, 0],
    [8, 1],
    [8, 2],
    [8, 3],
    [8, 4],
    [8, 5],
    [8, 7],
    [8, 8],
    [7, 8],
    [5, 8],
    [4, 8],
    [3, 8],
    [2, 8],
    [1, 8],
    [0, 8]
  ];

  // From Appendix D in JISX0510:2004 (p. 67)
  _.VERSION_INFO_POLY = 0x1f25;  // 1 1111 0010 0101

  // From Appendix C in JISX0510:2004 (p.65).
  _.TYPE_INFO_POLY = 0x537;
  _.TYPE_INFO_MASK_PATTERN = 0x5412;

  // Set all cells to -1.  -1 means that the cell is empty (not set yet).
  //
  // JAVAPORT: We shouldn't need to do this at all. The code should be
  // rewritten to begin encoding with the ByteMatrix initialized all to zero.
  /**
   * @param {ByteMatrix} matrix matrix.
   */
  _.clearMatrix = function(matrix) {
    matrix.clear(-1);
  };

  /**
   * Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and
   * "getMaskPattern". On success, store the result in "matrix" .
   * @param {BitArray} dataBits bits.
   * @param {ErrorCorrectionLevel} ecLevel error correction leval.
   * @param {Version} version version.
   * @param {number} maskPattern mask.
   * @param {ByteMatrix} matrix result matrix.
   */
  _.buildMatrix = function(dataBits, ecLevel, version, maskPattern, matrix) {
    _.clearMatrix(matrix);
    _.embedBasicPatterns(version, matrix);
    // Type information appear with any version.
    _.embedTypeInfo(ecLevel, maskPattern, matrix);
    // Version info appear if version >= 7.
    _.maybeEmbedVersionInfo(version, matrix);
    // Data should be embedded at end.
    _.embedDataBits(dataBits, maskPattern, matrix);
  };

  /**
   *
   * Embed basic patterns. On success, modify the matrix and return true.
   * The basic patterns are:
   * - Position detection patterns
   * - Timing patterns
   * - Dark dot at the left bottom corner
   * - Position adjustment patterns, if needed
   * @param {Version} version version.
   * @param {ByteMatrix} matrix result.
   */
  _.embedBasicPatterns = function(version, matrix) {
    // Let's get started with embedding big squares at corners.
    _.embedPositionDetectionPatternsAndSeparators(matrix);
    // Then, embed the dark dot at the left bottom corner.
    _.embedDarkDotAtLeftBottomCorner(matrix);

    // Position adjustment patterns appear if version >= 2.
    _.maybeEmbedPositionAdjustmentPatterns(version, matrix);
    // Timing patterns should be embedded after position adj. patterns.
    _.embedTimingPatterns(matrix);
  };

  /**
   * Embed type information. On success, modify the matrix.
   * @param {ErrorCorrectionLevel} ecLevel error correciton level.
   * @param {number} maskPattern pattern.
   * @param {ByteMatrix} matrix result.
   */
  _.embedTypeInfo = function(ecLevel, maskPattern, matrix) {
    var typeInfoBits = new BitArray();
    _.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);

    for (var i = 0; i < typeInfoBits.getSize(); ++i) {
      // Place bits in LSB to MSB order.  LSB (least significant bit) is the
      // last value in "typeInfoBits".
      var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);

      // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).
      var x1 = _.TYPE_INFO_COORDINATES[i][0];
      var y1 = _.TYPE_INFO_COORDINATES[i][1];
      matrix.set(x1, y1, bit);

      if (i < 8) {
        // Right top corner.
        var x2 = matrix.getWidth() - i - 1;
        var y2 = 8;
        matrix.set(x2, y2, bit);
      } else {
        // Left bottom corner.
        var x2 = 8;
        var y2 = matrix.getHeight() - 7 + (i - 8);
        matrix.set(x2, y2, bit);
      }
    }
  };

  /**
   * Embed version information if need be. On success, modify the matrix.
   * See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
   * @param {Version} version version.
   * @param {ByteMatrix} matrix result.
   */
  _.maybeEmbedVersionInfo = function(version, matrix) {
    // Version info is necessary if version >= 7.
    if (version.getVersionNumber() < 7) {
      return;  // Don't need version info.
    }
    var versionInfoBits = new BitArray();
    _.makeVersionInfoBits(version, versionInfoBits);

    var bitIndex = 6 * 3 - 1;  // It will decrease from 17 to 0.
    for (var i = 0; i < 6; ++i) {
      for (var j = 0; j < 3; ++j) {
        // Place bits in LSB (least significant bit) to MSB order.
        var bit = versionInfoBits.get(bitIndex);
        bitIndex--;
        // Left bottom corner.
        matrix.set(i, matrix.getHeight() - 11 + j, bit);
        // Right bottom corner.
        matrix.set(matrix.getHeight() - 11 + j, i, bit);
      }
    }
  };

  /**
   * Embed "dataBits" using "getMaskPattern". On success, modify the matrix and
   * return true.  For debugging purposes, it skips masking process if
   * "getMaskPattern" is -1.  See 8.7 of JISX0510:2004 (p.38) for how to embed
   * data bits.
   * @param {BitArray} dataBits bits.
   * @param {number} maskPattern mask.
   * @param {ByteMatrix} matrix result..
   */
  _.embedDataBits = function(dataBits, maskPattern, matrix) {
    var bitIndex = 0;
    var direction = -1;
    // Start from the right bottom cell.
    var x = matrix.getWidth() - 1;
    var y = matrix.getHeight() - 1;
    while (x > 0) {
      // Skip the vertical timing pattern.
      if (x == 6) {
        x -= 1;
      }
      while (y >= 0 && y < matrix.getHeight()) {
        for (var i = 0; i < 2; ++i) {
          var xx = x - i;
          // Skip the cell if it's not empty.
          if (!_.isEmpty(matrix.get(xx, y))) {
            continue;
          }
          var bit;
          if (bitIndex < dataBits.getSize()) {
            bit = dataBits.get(bitIndex);
            ++bitIndex;
          } else {
            // Padding bit. If there is no bit left, we'll fill the left cells
            // with 0, as described in 8.4.9 of JISX0510:2004 (p. 24).
            bit = false;
          }

          // Skip masking if mask_pattern is -1.
          if (maskPattern != -1 && MaskUtil.getDataMaskBit(maskPattern, xx,
            y)) {
            bit = !bit;
          }
          matrix.set(xx, y, bit);
        }
        y += direction;
      }
      direction = -direction;  // Reverse the direction.
      y += direction;
      x -= 2;  // Move to the left.
    }
    // All bits should be consumed.
    if (bitIndex != dataBits.getSize()) {
      throw new WriterError('Not all bits consumed: ' +
        bitIndex + '/' + dataBits.getSize());
    }
  };

  /**
   *
   * Return the position of the most significant bit set (to one) in the
   * "value". The most significant bit is position 32. If there is no bit set,
   * return 0. Examples:
   * - findMSBSet(0) => 0
   * - findMSBSet(1) => 1
   * - findMSBSet(255) => 8
   */
  _.findMSBSet = function(value) {
    var numDigits = 0;
    while (value != 0) {
      value >>>= 1;
      ++numDigits;
    }
    return numDigits;
  };

  /**
   *
   * Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using
   * polynomial "poly". The BCH
   * code is used for encoding type information and version information.
   * Example: Calculation of version information of 7.
   * f(x) is created from 7.
   *   - 7 = 000111 in 6 bits
   *   - f(x) = x^2 + x^1 + x^0
   * g(x) is given by the standard (p. 67)
   *   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
   * Multiply f(x) by x^(18 - 6)
   *   - f'(x) = f(x) * x^(18 - 6)
   *   - f'(x) = x^14 + x^13 + x^12
   * Calculate the remainder of f'(x) / g(x)
   *         x^2
   *         __________________________________________________
   *   g(x) )x^14 + x^13 + x^12
   *         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
   *         --------------------------------------------------
   *                              x^11 + x^10 + x^7 + x^4 + x^2
   *
   * The remainder is x^11 + x^10 + x^7 + x^4 + x^2
   * Encode it in binary: 110010010100
   * The return value is 0xc94 (1100 1001 0100)
   *
   * Since all coefficients in the polynomials are 1 or 0, we can do the
   * calculation by bit
   * operations. We don't care if cofficients are positive or negative.
   * @param {number} value see above.
   * @param {number} poly see above.
   * @return {number} see above.
   */
  _.calculateBCHCode = function(value, poly) {
    // If poly is "1 1111 0010 0101" (version info poly), msbSetInPoly is 13.
    // We'll subtract 1 from 13 to make it 12.
    var msbSetInPoly = _.findMSBSet(poly);
    value <<= msbSetInPoly - 1;
    // Do the division business using exclusive-or operations.
    while (_.findMSBSet(value) >= msbSetInPoly) {
      value ^= poly << (_.findMSBSet(value) - msbSetInPoly);
    }
    // Now the "value" is the remainder (i.e. the BCH code)
    return value;
  };

  /**
   * Make bit vector of type information. On success, store the result in
   * "bits" and return true.  Encode error correction level and mask pattern.
   * See 8.9 of JISX0510:2004 (p.45) for details.
   * @param {ErrorCorrectionLevel} ecLevel error correction level.
   * @param {number} maskPattern pattern.
   * @param {BitArray} bits result array.
   */
  _.makeTypeInfoBits = function(ecLevel, maskPattern, bits) {
    if (!QRCode.isValidMaskPattern(maskPattern)) {
      throw new WriterError('Invalid mask pattern');
    }
    var typeInfo = (ecLevel.getBits() << 3) | maskPattern;
    bits.appendBits(typeInfo, 5);

    var bchCode = _.calculateBCHCode(typeInfo, _.TYPE_INFO_POLY);
    bits.appendBits(bchCode, 10);

    var maskBits = new BitArray();
    maskBits.appendBits(_.TYPE_INFO_MASK_PATTERN, 15);
    bits.xor(maskBits);

    if (bits.getSize() != 15) {  // Just in case.
      throw new WriterError('should not happen but we got: ' +
        bits.getSize());
    }
  };

  /**
   * Make bit vector of version information. On success, store the result in
   * "bits" and return true.  See 8.10 of JISX0510:2004 (p.45) for details.
   * @param {Version} version version.
   * @param {BitArray} bits result array.
   */
  _.makeVersionInfoBits = function(version, bits) {
    bits.appendBits(version.getVersionNumber(), 6);
    var bchCode = _.calculateBCHCode(version.getVersionNumber(),
      _.VERSION_INFO_POLY);
    bits.appendBits(bchCode, 12);

    if (bits.getSize() != 18) {  // Just in case.
      throw new WriterError('should not happen but we got: ' +
        bits.getSize());
    }
  };

  /**
   * @return {boolean} if value is empty.
   */
  _.isEmpty = function(value) {
    return value == -1;
  };

  /**
   * @param {ByteMatrix} matrix matrix to add timing patterns to.
   */
  _.embedTimingPatterns = function(matrix) {
    // -8 is for skipping position detection patterns (size 7), and two
    // horizontal/vertical separation patterns (size 1). Thus, 8 = 7 + 1.
    for (var i = 8; i < matrix.getWidth() - 8; ++i) {
      var bit = (i + 1) % 2;
      // Horizontal line.
      if (_.isEmpty(matrix.get(i, 6))) {
        matrix.set(i, 6, bit);
      }
      // Vertical line.
      if (_.isEmpty(matrix.get(6, i))) {
        matrix.set(6, i, bit);
      }
    }
  };

  /**
   * Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
   * @param {ByteMatrix} matrix the matrix.
   */
  _.embedDarkDotAtLeftBottomCorner = function(matrix) {
    if (matrix.get(8, matrix.getHeight() - 8) == 0) {
      throw new WriterError();
    }
    matrix.set(8, matrix.getHeight() - 8, 1);
  };

  _.embedHorizontalSeparationPattern = function(xStart, yStart, matrix) {
    for (var x = 0; x < 8; ++x) {
      if (!_.isEmpty(matrix.get(xStart + x, yStart))) {
        throw new WriterError();
      }
      matrix.set(xStart + x, yStart, 0);
    }
  };

  _.embedVerticalSeparationPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 7; ++y) {
      if (!_.isEmpty(matrix.get(xStart, yStart + y))) {
        throw new WriterError();
      }
      matrix.set(xStart, yStart + y, 0);
    }
  };

  _.embedPositionAdjustmentPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 5; ++y) {
      for (var x = 0; x < 5; ++x) {
        matrix.set(xStart + x, yStart + y,
          _.POSITION_ADJUSTMENT_PATTERN[y][x]);
      }
    }
  };

  _.embedPositionDetectionPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 7; ++y) {
      for (var x = 0; x < 7; ++x) {
        matrix.set(xStart + x, yStart + y, _.POSITION_DETECTION_PATTERN[y][x]);
      }
    }
  };

  /**
   * Embed position detection patterns and surrounding vertical/horizontal
   * separators.
   * @param {ByteMatrix} matrix working matrix.
   */
  _.embedPositionDetectionPatternsAndSeparators = function(matrix) {
    // Embed three big squares at corners.
    var pdpWidth = _.POSITION_DETECTION_PATTERN[0].length;
    // Left top corner.
    _.embedPositionDetectionPattern(0, 0, matrix);
    // Right top corner.
    _.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
    // Left bottom corner.
    _.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);

    // Embed horizontal separation patterns around the squares.
    var hspWidth = 8;
    // Left top corner.
    _.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
    // Right top corner.
    _.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth,
      hspWidth - 1, matrix);
    // Left bottom corner.
    _.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth,
      matrix);

    // Embed vertical separation patterns around the squares.
    var vspSize = 7;
    // Left top corner.
    _.embedVerticalSeparationPattern(vspSize, 0, matrix);
    // Right top corner.
    _.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0,
      matrix);
    // Left bottom corner.
    _.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize,
      matrix);
  };

  /**
   * Embed position adjustment patterns if needed.
   */
  _.maybeEmbedPositionAdjustmentPatterns = function(version, matrix) {
    // The patterns appear if version >= 2
    if (version.getVersionNumber() < 2) {
      return;
    }
    var index = version.getVersionNumber() - 1;
    var coordinates = _.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
    var numCoordinates =
      _.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index].length;
    for (var i = 0; i < numCoordinates; ++i) {
      for (var j = 0; j < numCoordinates; ++j) {
        var y = coordinates[i];
        var x = coordinates[j];
        if (x == -1 || y == -1) {
          continue;
        }
        // If the cell is unset, we embed the position adjustment pattern here.
        if (_.isEmpty(matrix.get(x, y))) {
          // -2 is necessary since the x/y coordinates point to the center of
          // the pattern, not the
          // left top corner.
          _.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
        }
      }
    }
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.encoder.Encoder');
goog.require('w69b.qr.BitArray');
goog.require('w69b.qr.CharacterSetECI');
goog.require('w69b.qr.EncodeHintType');
goog.require('w69b.qr.ErrorCorrectionLevel');
goog.require('w69b.qr.GF256');
goog.require('w69b.qr.Mode');
goog.require('w69b.qr.ModeEnum');
goog.require('w69b.qr.ReedSolomonEncoder');
goog.require('w69b.qr.Version');
goog.require('w69b.qr.encoder.BlockPair');
goog.require('w69b.qr.encoder.MaskUtil');
goog.require('w69b.qr.encoder.MatrixUtil');
goog.require('w69b.qr.encoder.QRCode');
goog.require('w69b.qr.stringutils');

goog.scope(function() {
  var ErrorCorrectionLevel = w69b.qr.ErrorCorrectionLevel;
  var BitArray = w69b.qr.BitArray;
  var ByteMatrix = w69b.qr.encoder.ByteMatrix;
  var MatrixUtil = w69b.qr.encoder.MatrixUtil;
  var Version = w69b.qr.Version;
  var WriterError = w69b.qr.WriterError;
  var BlockPair = w69b.qr.encoder.BlockPair;
  var QRCode = w69b.qr.encoder.QRCode;
  var MaskUtil = w69b.qr.encoder.MaskUtil;
  var Mode = w69b.qr.Mode;
  var ModeEnum = w69b.qr.ModeEnum;
  var EncodeHintType = w69b.qr.EncodeHintType;
  var CharacterSetECI = w69b.qr.CharacterSetECI;
  var ReedSolomonEncoder = w69b.qr.ReedSolomonEncoder;
  var stringutils = w69b.qr.stringutils;


  /**
   * @author satorux@google.com (Satoru Takabayashi) - creator
   * @author dswitkin@google.com (Daniel Switkin) - ported from C+
   * @author mb@w69b.com (Manuel Braun) - ported to js
   */
  var _ = w69b.qr.encoder.Encoder;

  // The original table is defined in the table 5 of JISX0510:2004 (p.19).
  _.ALPHANUMERIC_TABLE = [
    // 0x00-0x0f
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    // 0x10-0x1f
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    // 0x20-0x2f
    36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
    // 0x30-0x3f
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,
    // 0x40-0x4f
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    // 0x50-0x5f
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1
  ];

  _.DEFAULT_BYTE_MODE_ENCODING = 'UTF-8';

  /** The mask penalty calculation is complicated.  See Table 21 of
   * JISX0510:2004 (p.45) for details.  Basically it applies four rules and
   * summate all penalties.
   */
  _.calculateMaskPenalty = function(matrix) {
    return MaskUtil.applyMaskPenaltyRule1(matrix) +
      MaskUtil.applyMaskPenaltyRule2(matrix) +
      MaskUtil.applyMaskPenaltyRule3(matrix) +
      MaskUtil.applyMaskPenaltyRule4(matrix);
  };

  /**
   *  Encode "bytes" with the error correction level "ecLevel". The encoding
   *  mode will be chosen internally by chooseMode(). On success, store the
   *  result in "qrCode".
   *
   * We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for
   * "getECLevel" since our primary use is to show QR code on desktop screens.
   * We don't need very strong error correction for this purpose.
   *
   * Note that there is no way to encode bytes in MODE_KANJI. We might want to
   * add EncodeWithMode() with which clients can specify the encoding mode. For
   * now, we don't need the functionality.
   *
   * @param {string} content string.
   * @param {ErrorCorrectionLevel} ecLevel error correction level.
   * @param {Object=} opt_hints encoding hints.
   *
   */

  _.encode = function(content, ecLevel, opt_hints) {

    // Determine what character encoding has been specified by the caller, if
    // any
    var encoding = opt_hints ? opt_hints[EncodeHintType.CHARACTER_SET] : null;
    var forceECI = opt_hints ? opt_hints[EncodeHintType.FORCE_ADD_ECI] : false;
    if (encoding == null) {
      encoding = _.DEFAULT_BYTE_MODE_ENCODING;
    }

    // Pick an encoding mode appropriate for the content. Note that this will
    // not attempt to use multiple modes / segments even if that were more
    // efficient. Twould be nice.
    var mode = _.chooseMode(content, encoding);

    // This will store the header information, like mode and
    // length, as well as "header" segments like an ECI segment.
    var headerBits = new BitArray();

    // Append ECI segment if applicable
    // Disabled in compat mode as some scanners seem to have problems with it.
    if (forceECI ||
      (mode == ModeEnum.BYTE && _.DEFAULT_BYTE_MODE_ENCODING != encoding)) {
      var eci = CharacterSetECI.getValue(encoding);
      if (eci) {
        _.appendECI(eci, headerBits);
      }
    }

    // (With ECI in place,) Write the mode marker
    _.appendModeInfo(mode, headerBits);

    // Collect data within the main segment, separately, to count its size if
    // needed. Don't add it to main payload yet.
    var dataBits = new BitArray();
    _.appendBytes(content, mode, dataBits, encoding);

    // Hard part: need to know version to know how many bits length takes. But
    // need to know how many bits it takes to know version. First we take a
    // guess at version by assuming version will be the minimum, 1:

    var provisionalBitsNeeded = headerBits.getSize() +
      mode.getCharacterCountBits(Version.getVersionForNumber(1)) +
      dataBits.getSize();
    var provisionalVersion = _.chooseVersion(provisionalBitsNeeded, ecLevel);

    // Use that guess to calculate the right version. I am still not sure this
    // works in 100% of cases.

    var bitsNeeded = headerBits.getSize() +
      mode.getCharacterCountBits(provisionalVersion) +
      dataBits.getSize();
    var version = _.chooseVersion(bitsNeeded, ecLevel);

    var headerAndDataBits = new BitArray();
    headerAndDataBits.appendBitArray(headerBits);
    // Find "length" of main segment and write it
    var numLetters =
      (mode == ModeEnum.BYTE ? dataBits.getSizeInBytes() : content.length);
    _.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
    // Put data together into the overall payload
    headerAndDataBits.appendBitArray(dataBits);

    var ecBlocks = version.getECBlocksForLevel(ecLevel);
    var numDataBytes = version.getTotalCodewords() -
      ecBlocks.getTotalECCodewords();

    // Terminate the bits properly.
    _.terminateBits(numDataBytes, headerAndDataBits);

    // Interleave data bits with error correction code.
    var finalBits = _.interleaveWithECBytes(headerAndDataBits,
      version.getTotalCodewords(),
      numDataBytes,
      ecBlocks.getNumBlocks());

    var qrCode = new QRCode();

    qrCode.setECLevel(ecLevel);
    qrCode.setMode(mode);
    qrCode.setVersion(version);

    //  Choose the mask pattern and set to "qrCode".
    var dimension = version.getDimensionForVersion();
    var matrix = new ByteMatrix(dimension, dimension);
    var maskPattern = _.chooseMaskPattern(finalBits, ecLevel, version, matrix);
    qrCode.setMaskPattern(maskPattern);

    // Build the matrix and set it to "qrCode".
    MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
    qrCode.setMatrix(matrix);

    return qrCode;
  };

  /**
   * @param {number} code ascii code.
   * @return {number} the code point of the table used in alphanumeric mode or
   *  -1 if there is no corresponding code in the table.
   */
  _.getAlphanumericCode = function(code) {
    code = Number(code);
    if (code < _.ALPHANUMERIC_TABLE.length) {
      return _.ALPHANUMERIC_TABLE[code];
    }
    return -1;
  };


  /**
   * Choose the best mode by examining the content. Note that 'encoding' is
   * used as a hint;
   * if it is Shift_JIS, and the input is only double-byte Kanji, then we
   * return {@link Mode#KANJI}.
   * @param {string} content to encode.
   * @param {string=} opt_encoding optional encoding..
   */
  _.chooseMode = function(content, opt_encoding) {
    if ('SHIFT_JIS' == opt_encoding) {
      // Choose Kanji mode if all input are double-byte characters
      return _.isOnlyDoubleByteKanji(content) ? ModeEnum.KANJI : ModeEnum.BYTE;
    }
    var hasNumeric = false;
    var hasAlphanumeric = false;
    var zeroChar = '0'.charCodeAt(0);
    var nineChar = '9'.charCodeAt(0);
    for (var i = 0; i < content.length; ++i) {
      var c = content.charCodeAt(i);
      if (c >= zeroChar && c <= nineChar) {
        hasNumeric = true;
      } else if (_.getAlphanumericCode(c) != -1) {
        hasAlphanumeric = true;
      } else {
        return ModeEnum.BYTE;
      }
    }
    if (hasAlphanumeric) {
      return ModeEnum.ALPHANUMERIC;
    }
    if (hasNumeric) {
      return ModeEnum.NUMERIC;
    }
    return ModeEnum.BYTE;
  };

  _.isOnlyDoubleByteKanji = function(content) {
    var bytes = [];
    try {
      bytes = stringutils.stringToBytes(content, 'SHIFT_JIS');
    } catch (uee) {
      return false;
    }
    var length = bytes.length;
    if (length % 2 != 0) {
      return false;
    }
    for (var i = 0; i < length; i += 2) {
      var byte1 = bytes[i] & 0xFF;
      if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {
        return false;
      }
    }
    return true;
  };

  _.chooseMaskPattern = function(bits, ecLevel, version, matrix) {

    var minPenalty = Number.MAX_VALUE;  // Lower penalty is better.
    var bestMaskPattern = -1;
    // We try all mask patterns to choose the best one.
    for (var maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS;
         maskPattern++) {
      MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
      var penalty = _.calculateMaskPenalty(matrix);
      if (penalty < minPenalty) {
        minPenalty = penalty;
        bestMaskPattern = maskPattern;
      }
    }
    return bestMaskPattern;
  };

  _.chooseVersion = function(numInputBits, ecLevel) {
    // In the following comments, we use numbers of Version 7-H.
    for (var versionNum = 1; versionNum <= 40; versionNum++) {
      var version = Version.getVersionForNumber(versionNum);
      // numBytes = 196
      var numBytes = version.getTotalCodewords();
      // getNumECBytes = 130
      var ecBlocks = version.getECBlocksForLevel(ecLevel);
      var numEcBytes = ecBlocks.getTotalECCodewords();
      // getNumDataBytes = 196 - 130 = 66
      var numDataBytes = numBytes - numEcBytes;
      var totalInputBytes = Math.floor((numInputBits + 7) / 8);
      if (numDataBytes >= totalInputBytes) {
        return version;
      }
    }
    throw new WriterError('Data too big');
  };

  /**
   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
   */
  _.terminateBits = function(numDataBytes, bits) {
    var i;
    var capacity = numDataBytes << 3;
    if (bits.getSize() > capacity) {
      throw new WriterError('data bits cannot fit in the QR Code' +
        bits.getSize() + ' > ' + capacity);
    }
    for (i = 0; i < 4 && bits.getSize() < capacity; ++i) {
      bits.appendBit(false);
    }
    // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.
    // If the last byte isn't 8-bit aligned, we'll add padding bits.
    var numBitsInLastByte = bits.getSize() & 0x07;
    if (numBitsInLastByte > 0) {
      for (i = numBitsInLastByte; i < 8; i++) {
        bits.appendBit(false);
      }
    }
    // If we have more space, we'll fill the space with padding patterns
    // defined in 8.4.9 (p.24).
    var numPaddingBytes = numDataBytes - bits.getSizeInBytes();
    for (i = 0; i < numPaddingBytes; ++i) {
      bits.appendBits((i & 0x01) == 0 ? 0xEC : 0x11, 8);
    }
    if (bits.getSize() != capacity) {
      throw new WriterError('Bits size does not equal capacity');
    }
  };

  /** Get number of data bytes and number of error correction bytes for block
   * id "blockID". Store the result in "numDataBytesInBlock", and
   * "numECBytesInBlock". See table 12 in 8.5.1 of JISX0510:2004 (p.30)
   */
  _.getNumDataBytesAndNumECBytesForBlockID = function(numTotalBytes,
                                                      numDataBytes,
                                                      numRSBlocks, blockID,
                                                      numDataBytesInBlock,
                                                      numECBytesInBlock) {
    if (blockID >= numRSBlocks) {
      throw new WriterError('Block ID too large');
    }
    // numRsBlocksInGroup2 = 196 % 5 = 1
    var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
    // numRsBlocksInGroup1 = 5 - 1 = 4
    var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
    // numTotalBytesInGroup1 = 196 / 5 = 39
    var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
    // numTotalBytesInGroup2 = 39 + 1 = 40
    var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
    // numDataBytesInGroup1 = 66 / 5 = 13
    var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
    // numDataBytesInGroup2 = 13 + 1 = 14
    var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
    // numEcBytesInGroup1 = 39 - 13 = 26
    var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
    // numEcBytesInGroup2 = 40 - 14 = 26
    var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
    // Sanity checks.
    // 26 = 26
    if (numEcBytesInGroup1 != numEcBytesInGroup2) {
      throw new WriterError('EC bytes mismatch');
    }
    // 5 = 4 + 1.
    if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2) {
      throw new WriterError('RS blocks mismatch');
    }
    // 196 = (13 + 26) * 4 + (14 + 26) * 1
    if (numTotalBytes !=
      ((numDataBytesInGroup1 + numEcBytesInGroup1) *
        numRsBlocksInGroup1) +
        ((numDataBytesInGroup2 + numEcBytesInGroup2) *
          numRsBlocksInGroup2)) {
      throw new WriterError('Total bytes mismatch');
    }

    if (blockID < numRsBlocksInGroup1) {
      numDataBytesInBlock[0] = numDataBytesInGroup1;
      numECBytesInBlock[0] = numEcBytesInGroup1;
    } else {
      numDataBytesInBlock[0] = numDataBytesInGroup2;
      numECBytesInBlock[0] = numEcBytesInGroup2;
    }
  };

  /**
   * Interleave "bits" with corresponding error correction bytes. On success,
   * store the result in "result". The interleave rule is complicated. See 8.6
   * of JISX0510:2004 (p.37) for details.
   */
  _.interleaveWithECBytes = function(bits, numTotalBytes, numDataBytes,
                                     numRSBlocks) {

    // "bits" must have "getNumDataBytes" bytes of data.
    if (bits.getSizeInBytes() != numDataBytes) {
      throw new WriterError('Number of bits and data bytes does not match');
    }

    // Step 1.  Divide data bytes into blocks and generate error correction
    // bytes for them. We'll store the divided data bytes blocks and error
    // correction bytes blocks into "blocks".
    var dataBytesOffset = 0;
    var maxNumDataBytes = 0;
    var maxNumEcBytes = 0;

    // Since, we know the number of reedsolmon blocks, we can initialize the
    // vector with the number.
    var blocks = [];
    var i;

    for (i = 0; i < numRSBlocks; ++i) {
      var numDataBytesInBlock = [0];
      var numEcBytesInBlock = [0];
      _.getNumDataBytesAndNumECBytesForBlockID(
        numTotalBytes, numDataBytes, numRSBlocks, i,
        numDataBytesInBlock, numEcBytesInBlock);

      var size = numDataBytesInBlock[0];
      var dataBytes = new Array(size);
      bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
      var ecBytes = _.generateECBytes(dataBytes, numEcBytesInBlock[0]);
      blocks.push(new BlockPair(dataBytes, ecBytes));

      maxNumDataBytes = Math.max(maxNumDataBytes, size);
      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
      dataBytesOffset += numDataBytesInBlock[0];
    }
    if (numDataBytes != dataBytesOffset) {
      throw new WriterError('Data bytes does not match offset');
    }

    var result = new BitArray();

    // First, place data blocks.
    for (i = 0; i < maxNumDataBytes; ++i) {
      blocks.forEach(function(block) {
        var dataBytes = block.getDataBytes();
        if (i < dataBytes.length) {
          result.appendBits(dataBytes[i], 8);
        }
      });
    }
    // Then, place error correction blocks.
    for (i = 0; i < maxNumEcBytes; ++i) {
      blocks.forEach(function(block) {
        var ecBytes = block.getErrorCorrectionBytes();
        if (i < ecBytes.length) {
          result.appendBits(ecBytes[i], 8);
        }
      });
    }
    if (numTotalBytes != result.getSizeInBytes()) {  // Should be same.
      throw new WriterError('Interleaving error: ' + numTotalBytes +
        ' and ' + result.getSizeInBytes() + ' differ.');
    }

    return result;
  };

  /**
   * @param {Array.<number>} dataBytes bytes.
   * @param {number} numEcBytesInBlock num.
   * @return {Array.<number>} bytes.
   */
  _.generateECBytes = function(dataBytes, numEcBytesInBlock) {
    var numDataBytes = dataBytes.length;
    var toEncode = new Array(numDataBytes + numEcBytesInBlock);
    var i;
    for (i = 0; i < numDataBytes; i++) {
      toEncode[i] = dataBytes[i] & 0xFF;
    }
    new ReedSolomonEncoder(w69b.qr.GF256.QR_CODE_FIELD).encode(toEncode,
      numEcBytesInBlock);

    var ecBytes = new Array(numEcBytesInBlock);
    for (i = 0; i < numEcBytesInBlock; i++) {
      ecBytes[i] = toEncode[numDataBytes + i];
    }
    return ecBytes;
  };

  /**
   * Append mode info. On success, store the result in "bits".
   */
  _.appendModeInfo = function(mode, bits) {
    bits.appendBits(mode.getBits(), 4);
  };


  /**
   * Append length info. On success, store the result in "bits".
   */
  _.appendLengthInfo = function(numLetters, version, mode, bits) {
    var numBits = mode.getCharacterCountBits(version);
    if (numLetters >= (1 << numBits)) {
      throw new WriterError(numLetters + ' is bigger than ' +
        ((1 << numBits) - 1));
    }
    bits.appendBits(numLetters, numBits);
  };

  /**
   * Append "bytes" in "mode" mode (encoding) into "bits".
   * On success, store the result in "bits".
   */
  _.appendBytes = function(content, mode, bits, encoding) {
    switch (mode) {
      case ModeEnum.NUMERIC:
        _.appendNumericBytes(content, bits);
        break;
      case ModeEnum.ALPHANUMERIC:
        _.appendAlphanumericBytes(content, bits);
        break;
      case ModeEnum.BYTE:
        _.append8BitBytes(content, bits, encoding);
        break;
      case ModeEnum.KANJI:
        _.appendKanjiBytes(content, bits);
        break;
      default:
        throw new WriterError('Invalid mode: ' + mode);
    }
  };

  _.appendNumericBytes = function(content, bits) {
    var length = content.length;
    var i = 0;
    var num2;
    var codeZero = '0'.charCodeAt(0);
    while (i < length) {
      var num1 = content.charCodeAt(i) - codeZero;
      if (i + 2 < length) {
        // Encode three numeric letters in ten bits.
        num2 = content.charCodeAt(i + 1) - codeZero;
        var num3 = content.charCodeAt(i + 2) - codeZero;
        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
        i += 3;
      } else if (i + 1 < length) {
        // Encode two numeric letters in seven bits.
        num2 = content.charCodeAt(i + 1) - codeZero;
        bits.appendBits(num1 * 10 + num2, 7);
        i += 2;
      } else {
        // Encode one numeric letter in four bits.
        bits.appendBits(num1, 4);
        i++;
      }
    }
  };

  _.appendAlphanumericBytes = function(content, bits) {
    var length = content.length;
    var i = 0;
    while (i < length) {
      var code1 = _.getAlphanumericCode(content.charCodeAt(i));
      if (code1 == -1) {
        throw new WriterError();
      }
      if (i + 1 < length) {
        var code2 = _.getAlphanumericCode(content.charCodeAt(i + 1));
        if (code2 == -1) {
          throw new WriterError();
        }
        // Encode two alphanumeric letters in 11 bits.
        bits.appendBits(code1 * 45 + code2, 11);
        i += 2;
      } else {
        // Encode one alphanumeric letter in six bits.
        bits.appendBits(code1, 6);
        i++;
      }
    }
  };

  _.append8BitBytes = function(content, bits, encoding) {
    var bytes;
    try {
      bytes = stringutils.stringToBytes(content, encoding);
    } catch (uee) {
      throw new WriterError(uee);
    }
    bytes.forEach(function(b) {
      bits.appendBits(b, 8);
    });
  };

  _.appendKanjiBytes = function(content, bits) {
    var bytes;
    try {
      bytes = stringutils.stringToBytes(content, 'Shift_JIS');
    } catch (uee) {
      throw new WriterError(uee);
    }
    var length = bytes.length;
    for (var i = 0; i < length; i += 2) {
      var byte1 = bytes[i] & 0xFF;
      var byte2 = bytes[i + 1] & 0xFF;
      var code = (byte1 << 8) | byte2;
      var subtracted = -1;
      if (code >= 0x8140 && code <= 0x9ffc) {
        subtracted = code - 0x8140;
      } else if (code >= 0xe040 && code <= 0xebbf) {
        subtracted = code - 0xc140;
      }
      if (subtracted == -1) {
        throw new WriterError('Invalid byte sequence');
      }
      var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);
      bits.appendBits(encoded, 13);
    }
  };

  _.appendECI = function(eci, bits) {
    bits.appendBits(ModeEnum.ECI.getBits(), 4);
    // This is correct for values up to 127, which is all we need now.
    bits.appendBits(eci, 8);
  };

});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

goog.provide('w69b.qr.Binarizer');

goog.scope(function() {

/**
 * This class hierarchy provides a set of methods to convert luminance data to
 * 1 bit data.  It allows the algorithm to vary polymorphically, for example
 * allowing a very expensive thresholding technique for servers and a fast one
 * for mobile. It also permits the implementation to vary, e.g. a JNI version
 * for Android and a Java fallback version for other platforms.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * Ported to js by Manuel Braun
 *
 *  @param {w69b.qr.QRImage} source gray values .
 *  @constructor
 */
w69b.qr.Binarizer = function(source) {
  /**
   * @protected
   * @type {w69b.qr.QRImage}
   */
  this.source = source;
};
  var Binarizer = w69b.qr.Binarizer;
  var pro = Binarizer.prototype;

  /**
   * @return {w69b.qr.QRImage} image.
   */
  pro.getLuminanceSource = function() {
    return this.source;
  };

  /**
   * Converts one row of luminance data to 1 bit data. May actually do the
   * conversion, or return cached data. Callers should assume this method is
   * expensive and call it as seldom as possible.  This method is intended for
   * decoding 1D barcodes and may choose to apply sharpening.  For callers
   * which only examine one row of pixels at a time, the same BitArray should
   * be reused and passed in with each call for performance. However it is
   * legal to keep more than one row at a time if needed.
   *
   * @param {number} y The row to fetch, 0 <= y < bitmap height.
   * @param {w69b.qr.BitArray} opt_row An optional preallocated array. If null
   * or too small, it will be ignored.  If used, the Binarizer will call
   * BitArray.clear(). Always use the returned object.
   * @return {!w69b.qr.BitArray} The array of bits for this row (true means
   * black).
   */
  pro.getBlackRow = function(y, opt_row) { throw Error(); };

  /**
   * Converts a 2D array of luminance data to 1 bit data. As above, assume this
   * method is expensive and do not call it repeatedly. This method is intended
   * for decoding 2D barcodes and may or may not apply sharpening. Therefore, a
   * row from this matrix may not be identical to one fetched using
   * getBlackRow(), so don't mix and match between them.
   *
   * @return {!w69b.qr.BitMatrix} The 2D array of bits for the image
   * (true means black).
   */
  pro.getBlackMatrix = function() { throw Error(); };

  /**
   * Creates a new object with the same type as this Binarizer implementation,
   * but with pristine state. This is needed because Binarizer implementations
   * may be stateful, e.g. keeping a cache of 1 bit data. See Effective Java
   * for why we can't use Java's clone() method.
   *
   * @param {w69b.qr.QRImage} source The LuminanceSource this Binarizer
   * will operate on.
   * @return {w69b.qr.Binarizer} A new concrete Binarizer implementation
   * object.
   */
  pro.createBinarizer = function(source) { throw Error(); };

  /**
   * @return {number} width.
   */
  pro.getWidth = function() {
    return this.source.width;
  };

  /**
   * @return {number} height.
   */
  pro.getHeight = function() {
    return this.source.height;
  };

});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.GlobalHistogramBinarizer');
goog.require('w69b.qr.Binarizer');
goog.require('w69b.qr.BitArray');
goog.require('w69b.qr.BitMatrix');
goog.require('w69b.qr.NotFoundError');


goog.scope(function() {
  var BitMatrix = w69b.qr.BitMatrix;
  var BitArray = w69b.qr.BitArray;
   /**
   * This Binarizer implementation uses the old ZXing global histogram
   * approach. It is suitable for low-end mobile devices which don't have
   * enough CPU or memory to use a local thresholding algorithm. However,
   * because it picks a global black point, it cannot handle difficult shadows
   * and gradients.
   *
   * Faster mobile devices and all desktop applications should probably use
   * HybridBinarizer instead.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   * @author Sean Owen
   * Ported to js by Manuel Braun
   *
    * @param {w69b.qr.QRImage} source gray values.
   * @constructor
   * @extends {w69b.qr.Binarizer}
   */
  w69b.qr.GlobalHistogramBinarizer = function(source) {
    goog.base(this, source);
    /**
     * @type {Uint8Array}
     * @private
     */
    this.luminances_ = new Uint8Array(0);
    /**
     * @type {Uint8Array}
     * @private
     */
    this.buckets_ = new Uint8Array(_.LUMINANCE_BUCKETS);
  };
  var _ = w69b.qr.GlobalHistogramBinarizer;
  goog.inherits(_, w69b.qr.Binarizer);
  var pro = _.prototype;


  _.LUMINANCE_BITS = 5;
  _.LUMINANCE_SHIFT = 8 - _.LUMINANCE_BITS;
  _.LUMINANCE_BUCKETS = 1 << _.LUMINANCE_BITS;


  /**
   * Applies simple sharpening to the row data to improve performance of the 1D
   * Readers.
   * @override
   */
    pro.getBlackRow = function(y, row) {
      var x;
      var source = this.getLuminanceSource();
      var width = source.getWidth();
      if (row == null || row.getSize() < width) {
        row = new BitArray(width);
      } else {
        row.clear();
      }

      this.initArrays(width);
      var localLuminances = source.getRow(y, this.luminances_);
      var localBuckets = this.buckets_;
      for (x = 0; x < width; x++) {
        var pixel = localLuminances[x] & 0xff;
        localBuckets[pixel >> _.LUMINANCE_SHIFT]++;
      }
      var blackPoint = _.estimateBlackPoint(localBuckets);

      var left = localLuminances[0] & 0xff;
      var center = localLuminances[1] & 0xff;
      for (x = 1; x < width - 1; x++) {
        var right = localLuminances[x + 1] & 0xff;
        // A simple -1 4 -1 box filter with a weight of 2.
        var luminance = ((center << 2) - left - right) >> 1;
        if (luminance < blackPoint) {
          row.set(x);
        }
        left = center;
        center = right;
      }
      return row;
    };

    /**
     * Does not sharpen the data, as this call is intended to only be used by
     * 2D Readers.
     * @override
     */
    pro.getBlackMatrix = function() {
      var source = this.getLuminanceSource();
      var width = source.getWidth();
      var height = source.getHeight();
      var matrix = new BitMatrix(width, height);

      // nasty js scopes.
      var localLuminances, pixel, x, y;
      // Quickly calculates the histogram by sampling four rows from the image.
      // This proved to be more robust on the blackbox tests than sampling a
      // diagonal as we used to do.
      this.initArrays(width);
      var localBuckets = this.buckets_;
      for (y = 1; y < 5; y++) {
        var row = height * y / 5;
        localLuminances = source.getRow(row, this.luminances_);
        var right = (width << 2) / 5;
        for (x = width / 5; x < right; x++) {
          pixel = localLuminances[x] & 0xff;
          localBuckets[pixel >> _.LUMINANCE_SHIFT]++;
        }
      }
      var blackPoint = _.estimateBlackPoint(localBuckets);

      // We delay reading the entire image luminance until the black point
      // estimation succeeds.  Although we end up reading four rows twice, it
      // is consistent with our motto of "fail quickly" which is necessary for
      // continuous scanning.
      localLuminances = source.getMatrix();
      for (y = 0; y < height; y++) {
        var offset = y * width;
        for (x = 0; x < width; x++) {
          pixel = localLuminances[offset + x] & 0xff;
          if (pixel < blackPoint) {
            matrix.set(x, y);
          }
        }
      }

      return matrix;
    };

  /**
   * @override
   */
    pro.createBinarizer = function(source) {
      return new _(source);
    };

    pro.initArrays = function(luminanceSize) {
      if (this.luminances_.length < luminanceSize) {
        this.luminances_ = new Uint8Array(luminanceSize);
      }
      for (var x = 0; x < _.LUMINANCE_BUCKETS; x++) {
        this.buckets_[x] = 0;
      }
    };

    _.estimateBlackPoint = function(buckets) {
      var x, score;
      // Find the tallest peak in the histogram.
      var numBuckets = buckets.length;
      var maxBucketCount = 0;
      var firstPeak = 0;
      var firstPeakSize = 0;
      for (x = 0; x < numBuckets; x++) {
        if (buckets[x] > firstPeakSize) {
          firstPeak = x;
          firstPeakSize = buckets[x];
        }
        if (buckets[x] > maxBucketCount) {
          maxBucketCount = buckets[x];
        }
      }

      // Find the second-tallest peak which is somewhat far from the tallest
      // peak.
      var secondPeak = 0;
      var secondPeakScore = 0;
      for (x = 0; x < numBuckets; x++) {
        var distanceToBiggest = x - firstPeak;
        // Encourage more distant second peaks by multiplying by square of
        // distance.
        score = buckets[x] * distanceToBiggest * distanceToBiggest;
        if (score > secondPeakScore) {
          secondPeak = x;
          secondPeakScore = score;
        }
      }

      // Make sure firstPeak corresponds to the black peak.
      if (firstPeak > secondPeak) {
        var temp = firstPeak;
        firstPeak = secondPeak;
        secondPeak = temp;
      }

      // If there is too little contrast in the image to pick a meaningful
      // black point, throw rather than waste time trying to decode the image,
      // and risk false positives.
      if (secondPeak - firstPeak <= numBuckets >> 4) {
        throw new w69b.qr.NotFoundError();
      }

      // Find a valley between them that is low and closer to the white peak.
      var bestValley = secondPeak - 1;
      var bestValleyScore = -1;
      for (x = secondPeak - 1; x > firstPeak; x--) {
        var fromFirst = x - firstPeak;
        score = fromFirst * fromFirst * (secondPeak - x) *
          (maxBucketCount - buckets[x]);
        if (score > bestValleyScore) {
          bestValley = x;
          bestValleyScore = score;
        }
      }

      return bestValley << _.LUMINANCE_SHIFT;
    };
});


// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.IntArray2D');
goog.scope(function() {
  /**
   * Provides a pre-allocated row-first 2d integer array.
   * @param {number} size1 size of first dimension.
   * @param {number} size2 size ofsecond dimension.
   * @constructor
   */
  w69b.qr.IntArray2D = function(size1, size2) {
    this.size1 = size1;
    this.size2 = size2;
    this.data = new Int32Array(size1 * size2);
  };
  var pro = w69b.qr.IntArray2D.prototype;

  /**
   * Get value.
   * @param {number} dim1 first dimension.
   * @param {number} dim2 second dimension.
   * @return {number} value at given position.
   */
  pro.getAt = function(dim1, dim2) {
    return this.data[this.size2 * dim1 + dim2];
  };
  /**
   * Set value.
   * @param {number} dim1 first dimension.
   * @param {number} dim2 second dimension.
   * @param {number} value at given position.
   */
  pro.setAt = function(dim1, dim2, value) {
    this.data[this.size2 * dim1 + dim2] = value;
  };
});

// javascript (closure) port (c) 2013 Manuel Braun (mb@w69b.com)
/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

goog.provide('w69b.qr.HybridBinarizer');
goog.require('w69b.qr.BitArray');
goog.require('w69b.qr.BitMatrix');
goog.require('w69b.qr.GlobalHistogramBinarizer');
goog.require('w69b.qr.IntArray2D');

goog.scope(function() {
  var BitMatrix = w69b.qr.BitMatrix;
  var IntArray2D = w69b.qr.IntArray2D;
  /**
   * This class implements a local thresholding algorithm, which while slower
   * than the GlobalHistogramBinarizer, is fairly efficient for what it does.
   * It is designed for high frequency images of barcodes with black data on
   * white backgrounds. For this application, it does a much better job than a
   * global blackpoint with severe shadows and gradients.  However it tends to
   * produce artifacts on lower frequency images and is therefore not a good
   * general purpose binarizer for uses outside ZXing.
   *
   * This class extends GlobalHistogramBinarizer, using the older histogram
   * approach for 1D readers, and the newer local approach for 2D readers. 1D
   * decoding using a per-row histogram is already inherently local, and only
   * fails for horizontal gradients. We can revisit that problem later, but for
   * now it was not a win to use local blocks for 1D.
   *
   * This Binarizer is the default for the unit tests and the recommended class
   * for library users.
   *
   * @author dswitkin@google.com (Daniel Switkin)
   * ported to js by Manuel Braun
   *
   * @param {w69b.qr.QRImage} source gray values.
   * @constructor
   * @extends {w69b.qr.GlobalHistogramBinarizer}
   */
  w69b.qr.HybridBinarizer = function(source) {
    goog.base(this, source);
  };
  goog.inherits(w69b.qr.HybridBinarizer, w69b.qr.GlobalHistogramBinarizer);
  var _ = w69b.qr.HybridBinarizer;
  var pro = _.prototype;

  /**
   * @private
   * @type {BitMatrix}
   */
  pro.matrix_;

  // This class uses 5x5 blocks to compute local luminance, where each block is
  // 8x8 pixels.  So this is the smallest dimension in each axis we can accept.
  _.BLOCK_SIZE_POWER = 3;
  _.BLOCK_SIZE = 1 << _.BLOCK_SIZE_POWER; // ...0100...00
  _.BLOCK_SIZE_MASK = _.BLOCK_SIZE - 1;   // ...0011...11
  _.MINIMUM_DIMENSION = _.BLOCK_SIZE * 5;
  _.MIN_DYNAMIC_RANGE = 24;


  /**
   * Calculates the final BitMatrix once for all requests. This could be called
   * once from the constructor instead, but there are some advantages to doing
   * it lazily, such as making profiling easier, and not doing heavy lifting
   * when callers don't expect it.
   * @override
   */
  pro.getBlackMatrix = function() {
    if (this.matrix_ != null) {
      return this.matrix_;
    }
    var source = this.getLuminanceSource();
    var width = source.getWidth();
    var height = source.getHeight();
    if (width >= _.MINIMUM_DIMENSION && height >= _.MINIMUM_DIMENSION) {
      var luminances = source.getMatrix();
      // dived by 8
      var subWidth = width >> _.BLOCK_SIZE_POWER;
      // only even numbers
      if ((width & _.BLOCK_SIZE_MASK) != 0) {
        subWidth++;
      }
      var subHeight = height >> _.BLOCK_SIZE_POWER;
      if ((height & _.BLOCK_SIZE_MASK) != 0) {
        subHeight++;
      }
      var blackPoints = _.calculateBlackPoints(luminances, subWidth,
        subHeight, width, height);

      var newMatrix = new BitMatrix(width, height);
      _.calculateThresholdForBlock(luminances, subWidth, subHeight,
        width, height, blackPoints, newMatrix);
      this.matrix_ = newMatrix;
    } else {
      // If the image is too small, fall back to the global histogram approach.
      this.matrix_ = goog.base(this, 'getBlackMatrix');
    }
    return this.matrix_;
  };

  /**
   * @override
   */
  pro.createBinarizer = function(source) {
    return new _(source);
  };

  /**
   * For each block in the image, calculate the average black point using a 5x5
   * grid of the blocks around it. Also handles the corner cases (fractional
   * blocks are computed based on the last pixels in the row/column which are
   * also used in the previous block).
   */
  _.calculateThresholdForBlock = function(luminances, subWidth, subHeight,
                                          width, height, blackPoints, matrix) {
    for (var y = 0; y < subHeight; y++) {
      var yoffset = y << _.BLOCK_SIZE_POWER;
      var maxYOffset = height - _.BLOCK_SIZE;
      if (yoffset > maxYOffset) {
        yoffset = maxYOffset;
      }
      for (var x = 0; x < subWidth; x++) {
        var xoffset = x << _.BLOCK_SIZE_POWER;
        var maxXOffset = width - _.BLOCK_SIZE;
        if (xoffset > maxXOffset) {
          xoffset = maxXOffset;
        }
        var left = _.cap(x, 2, subWidth - 3);
        var top = _.cap(y, 2, subHeight - 3);
        var sum = 0;
        for (var z = -2; z <= 2; z++) {
          var offset = (top + z) * blackPoints.size2;
          var raw = blackPoints.data;
          sum += raw[offset + left - 2] + raw[offset + left - 1] +
            raw[offset + left] + raw[offset + left + 1] +
            raw[offset + left + 2];
        }
        var average = sum / 25;
        _.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
      }
    }
  };

  /**
   * @param {number} value value.
   * @param {number} min min.
   * @param {number} max max.
   * @return {number} capped value.
   */
  _.cap = function(value, min, max) {
    return value < min ? min : value > max ? max : value;
  };

  /**
   * Applies a single threshold to a block of pixels.
   */
  _.thresholdBlock = function(luminances, xoffset, yoffset, threshold, stride,
                              matrix) {
    for (var y = 0, offset = yoffset * stride + xoffset; y < _.BLOCK_SIZE;
         y++, offset += stride) {
      for (var x = 0; x < _.BLOCK_SIZE; x++) {
        // Comparison needs to be <= so that black == 0 pixels are
        // black even if the threshold is 0.
        if ((luminances[offset + x] & 0xFF) <= threshold) {
          matrix.set(xoffset + x, yoffset + y);
        }
      }
    }
  };

  /**
   * Calculates a single black point for each block of pixels and saves it away.
   * See the following thread for a discussion of this algorithm:
   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
   */
  _.calculateBlackPoints = function(luminances, subWidth, subHeight, width,
                                    height) {
    var xx;
    var blackPoints = new IntArray2D(subHeight, subWidth);
    for (var y = 0; y < subHeight; y++) {
      var yoffset = y << _.BLOCK_SIZE_POWER;
      var maxYOffset = height - _.BLOCK_SIZE;
      if (yoffset > maxYOffset) {
        yoffset = maxYOffset;
      }
      for (var x = 0; x < subWidth; x++) {
        var xoffset = x << _.BLOCK_SIZE_POWER;
        var maxXOffset = width - _.BLOCK_SIZE;
        if (xoffset > maxXOffset) {
          xoffset = maxXOffset;
        }
        var sum = 0;
        var min = 0xFF;
        var max = 0;
        for (var yy = 0, offset = yoffset * width + xoffset;
             yy < _.BLOCK_SIZE; yy++, offset += width) {
          for (xx = 0; xx < _.BLOCK_SIZE; xx++) {
            var pixel = luminances[offset + xx] & 0xFF;
            sum += pixel;
            // still looking for good contrast
            if (pixel < min) {
              min = pixel;
            }
            if (pixel > max) {
              max = pixel;
            }
          }
          // short-circuit min/max tests once dynamic range is met
          if (max - min > _.MIN_DYNAMIC_RANGE) {
            // finish the rest of the rows quickly
            for (yy++, offset += width;
                 yy < _.BLOCK_SIZE; yy++, offset += width) {
              for (xx = 0; xx < _.BLOCK_SIZE; xx++) {
                sum += luminances[offset + xx] & 0xFF;
              }
            }
          }
        }

        // The default estimate is the average of the values in the block.
        var average = sum >> (_.BLOCK_SIZE_POWER * 2);
        if (max - min <= _.MIN_DYNAMIC_RANGE) {
          // If variation within the block is low, assume this is a block with
          // only light or only dark pixels. In that case we do not want to use
          // the average, as it would divide this low contrast area into black
          // and white pixels, essentially creating data out of noise.
          //
          // The default assumption is that the block is light/background.
          // Since no estimate for the level of dark pixels exists locally, use
          // half the min for the block.
          average = min >> 1;

          if (y > 0 && x > 0) {
            // Correct the "white background" assumption for blocks that have
            // neighbors by comparing the pixels in this block to the
            // previously calculated black points. This is based on the fact
            // that dark barcode symbology is always surrounded by some amount
            // of light background for which reasonable black point estimates
            // were made. The bp estimated at the boundaries is used for the
            // interior.

            // The (min < bp) is arbitrary but works better than other
            // heuristics that were tried.
            var averageNeighborBlackPoint = (blackPoints.getAt(y - 1, x) +
              (2 * blackPoints.getAt(y, x - 1)) +
              blackPoints.getAt(y - 1, x - 1)) >> 2;
            if (min < averageNeighborBlackPoint) {
              average = averageNeighborBlackPoint;
            }
          }
        }
        blackPoints.setAt(y, x, average);
      }
    }
    return blackPoints;
  };
});


// (c) 2013 Manuel Braun (mb@w69b.com)

goog.provide('w69b.qr.nativepreprocessing');
goog.require('w69b.qr.HybridBinarizer');
goog.require('w69b.qr.QRImage');

goog.scope(function() {
  var _ = w69b.qr.nativepreprocessing;
  var QRImage = w69b.qr.QRImage;

  /**
   * @param {(!ImageData|!w69b.qr.QRImage)} imageData from canvas.
   * @return {!w69b.qr.BitMatrix} binary data.
   */
  _.binarizeImageData = function(imageData) {
    var gray = _.grayscale(imageData);
    var binarizer = new w69b.qr.HybridBinarizer(gray);
    return binarizer.getBlackMatrix();
  };

  /**
   * Returns grayscale version of image.
   * @param {(!ImageData|!w69b.qr.QRImage)} imageData from canvas.
   * @return {!w69b.qr.QRImage} binary data.
   */
  _.grayscale = function(imageData) {
    var grayImg = QRImage.newEmpty(imageData.width, imageData.height);
    var grayData = grayImg.data;
    var rgbaData = imageData.data;

    for (var i = 0; i < grayData.length; ++i) {
      var rgbaPos = i * 4;
      grayData[i] = (rgbaData[rgbaPos] * 33 +
        rgbaData[rgbaPos + 1] * 34 +
        rgbaData[rgbaPos + 2] * 33) / 100;
    }
    return grayImg;
  };

});


// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.imagedecoding');
goog.require('w69b.img.RGBABitMatrix');
goog.require('w69b.img.WebGLBinarizer');
goog.require('w69b.imgtools');
goog.require('w69b.qr.DecodeResult');
goog.require('w69b.qr.Detector');
goog.require('w69b.qr.QRImage');
goog.require('w69b.qr.ReaderError');
goog.require('w69b.qr.decoder');
goog.require('w69b.qr.encoder.Encoder');
goog.require('w69b.qr.nativepreprocessing');

/**
 * Simple high-level interface to decode qr codes.
 * @author mb@w69b.com (Manuel Braun)
 */
goog.scope(function() {
  var Detector = w69b.qr.Detector;
  var RGBABitMatrix = w69b.img.RGBABitMatrix;
  var DecodeResult = w69b.qr.DecodeResult;
  var WebGLBinarizer = w69b.img.WebGLBinarizer;
  var imgtools = w69b.imgtools;
  var preprocessing = w69b.qr.nativepreprocessing;

  var _ = w69b.qr.imagedecoding;

  _.webGLBinarizer_ = null;

  _.getWebGLBinarizer_ = function() {
    if (!_.webGLBinarizer_) {
      _.webGLBinarizer_ = new WebGLBinarizer();
    }
    return _.webGLBinarizer_;
  };

  /**
   * Decode qr code in main thread.
   * @param {(Image|HTMLVideoElement)} img image or video.
   * @param {?w69b.qr.ResultPointCallback=} callback callback for patterns.
   * @param {boolean=} opt_webgl whether to use WebGl binarizer if supported.
   * @return {DecodeResult} result.
   */
  _.decode = function(img, callback, opt_webgl) {
    var imgData;
    if (opt_webgl && WebGLBinarizer.isSupported()) {
      var binarizer = _.getWebGLBinarizer_();
      binarizer.setup(img.width || img.videoHeight, img.height || img.videoHeight);
      binarizer.render(img);
      imgData = binarizer.getBitMatrix();
    } else {
      imgData = imgtools.getImageData(img, 700);
    }
    return _.decodeFromImageData(imgData, callback);
  };

  /**
   * Decode qr code from ImageData or preprocessed RGBABitMatrix.
   * @param {(!ImageData|!w69b.qr.QRImage|!RGBABitMatrix)} imgdata from canvas.
   * @param {?w69b.qr.ResultPointCallback=} opt_callback callback.
   * @return {DecodeResult} decoded qr code.
   */
  _.decodeFromImageData = function(imgdata, opt_callback) {
    var result;
    try {
      result = _.decodeFromImageDataThrowing(imgdata, opt_callback);
    } catch (err) {
      result = new DecodeResult(err);
      if (!(err instanceof w69b.qr.ReaderError))
        throw err;
    }
    return result;
  };

  /**
   * Throws ReaderError if detection fails.
   * @param {(!ImageData|!w69b.qr.QRImage|!RGBABitMatrix)} imgdata from canvas.
   * @param {?w69b.qr.ResultPointCallback=} opt_callback callback.
   * @return {DecodeResult} decoded qr code.
   */
  _.decodeFromImageDataThrowing = function(imgdata, opt_callback) {
    var bitmap;
    if (imgdata instanceof RGBABitMatrix) {
      bitmap = imgdata;
    } else {
      bitmap = preprocessing.binarizeImageData(imgdata);
    }
    var detector = new Detector(bitmap, opt_callback);

    var detectorResult = detector.detect();
    var text = w69b.qr.decoder.decode(detectorResult.bits);

    return new DecodeResult(text, detectorResult.points);
  };

});

goog.exportSymbol('w69b.qr.imagedecoding.decodeFromImageData',
  w69b.qr.imagedecoding.decodeFromImageData);

// (c) 2013 Manuel Braun (mb@w69b.com)
goog.provide('w69b.qr.DecodeWorker');
goog.require('goog.userAgent.product');
goog.require('w69b.img.RGBABitMatrix');
goog.require('w69b.qr.InvalidCharsetError');
goog.require('w69b.qr.QRImage');
goog.require('w69b.qr.ReaderError');
goog.require('w69b.qr.WorkerMessageType');
goog.require('w69b.qr.imagedecoding');

// Hack to work arround closure warnings.
var host = self;

goog.scope(function() {
  var qrcode = w69b.qr.imagedecoding;
  var ReaderError = w69b.qr.ReaderError;
  var WorkerMessageType = w69b.qr.WorkerMessageType;

  var _ = w69b.qr.DecodeWorker;
  _.iconvPath = 'iconv.js';

  /**
   * @param {string} msgType messsage type.
   * @param {*=} opt_result value.
   */
  _.send = function(msgType, opt_result) {
    host.postMessage([msgType, host['JSON'].stringify(opt_result)]);
  };

  /**
   * @param {(!w69b.qr.QRImage|!w69b.img.RGBABitMatrix)} imgdata image to
   * @param {boolean=} failOnCharset immediately fail on charset error if true,
   * do not try to load iconv.
   * decode.
   */
  _.decode = function(imgdata, failOnCharset) {
    var result;
    try {
      result = qrcode.decodeFromImageData(imgdata, _.onPatternFound);
    } catch (err) {
      if (err instanceof w69b.qr.InvalidCharsetError && !self.iconv &&
        _.iconvPath && !failOnCharset) {
        // load iconv.
        importScripts(_.iconvPath);
        // and try again.
        _.decode(imgdata, true);
        return;
      } else {
        throw err;
      }
    }
    if (result.isError()) {
      var err = result.getError();
      _.send(WorkerMessageType.NOTFOUND, err && err.message);
    } else {
      _.send(WorkerMessageType.DECODED, result);
    }
  };

  /**
   * @param {(w69b.qr.AlignmentPattern|w69b.qr.FinderPattern)} pattern found.
   */
  _.onPatternFound = function(pattern) {
    // Build plain json object.
    _.send(WorkerMessageType.PATTERN, pattern);
  };


  /**
   * Received message from host.
   */
  self.onmessage = function(event) {
    var data = event.data;
    // Message only sent for feature detection of transferable objects.
    if (data['isfeaturedetect']) {
      // do nothing.
    } else if (data['setIconvUrl']) {
      _.iconvPath = data['setIconvUrl'];
    } else {
      // decode
      var width = data['width'];
      var height = data['height'];
      var buffer = data['buffer'];
      var isBinary = data['isBinary'];
      if (!buffer.byteLength) {
        throw Error('worker commmunication failed');
      }
      var image;
      if (isBinary) {
        image = new w69b.img.RGBABitMatrix(width, height,
          new Uint8ClampedArray(buffer));
      } else {
        image = new w69b.qr.QRImage(width, height,
          new Uint8ClampedArray(buffer));
      }
      _.decode(image);
      // Hack for FF memory leak - if webgl is used, we tranfer back the
      // buffer as a workaround.
      if (goog.userAgent.product.FIREFOX) {
        host.postMessage(['ffmemoryhack', null], [buffer]);
        event.data['buffer'] = null;
        // event.data = null;
      }
    }
  };
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJhc2UuanMiLCJlcnJvci5qcyIsIm5vZGV0eXBlLmpzIiwic3RyaW5nLmpzIiwiYXNzZXJ0cy5qcyIsImFycmF5LmpzIiwidXRpbC5qcyIsIm9iamVjdC5qcyIsImJyb3dzZXIuanMiLCJwbGF0Zm9ybS5qcyIsImVuZ2luZS5qcyIsInVzZXJhZ2VudC5qcyIsInByb2R1Y3QuanMiLCJiaXRtYXRyaXhsaWtlLmpzIiwicmdiYWJpdG1hdHJpeC5qcyIsInJlYWRlcmVycm9yLmpzIiwicXJpbWFnZS5qcyIsIndvcmtlcm1lc3NhZ2V0eXBlLmpzIiwic2l6ZS5qcyIsImltYWdlZGF0YS5qcyIsIndlYmdscGFyYW1zLmpzIiwid2ViZ2xwaXBlbGluZS5qcyIsImNvbXBpbGVkLmpzIiwid2ViZ2xwcm9ncmFtLmpzIiwid2ViZ2xmaWx0ZXIuanMiLCJ3ZWJnbGJpbmFyaXplci5qcyIsImNyeXB0LmpzIiwiYmFzZTY0LmpzIiwiaW1ndG9vbHMuanMiLCJkZWNvZGVyZXN1bHQuanMiLCJyZXN1bHRwb2ludC5qcyIsImFsaWdubWVudHBhdHRlcm4uanMiLCJhbGlnbm1lbnRwYXR0ZXJuZmluZGVyLmpzIiwiYml0bWF0cml4LmpzIiwiZ3JpZHNhbXBsZXIuanMiLCJwZXJzcGVjdGl2ZXRyYW5zZm9ybS5qcyIsImRlZmF1bHRncmlkc2FtcGxlci5qcyIsImRlY29kZWhpbnR0eXBlLmpzIiwiZmluZGVycGF0dGVybi5qcyIsImZpbmRlcnBhdHRlcm5maW5kZXIuanMiLCJtYXRodXRpbHMuanMiLCJ2ZXJzaW9uLmpzIiwiZGV0ZWN0b3IuanMiLCJlcnJvcmNvcnJlY3Rpb25sZXZlbC5qcyIsImZvcm1hdGluZm9ybWF0aW9uLmpzIiwiZGF0YW1hc2suanMiLCJiaXRtYXRyaXhwYXJzZXIuanMiLCJkYXRhYmxvY2suanMiLCJzdHJpbmdidWZmZXIuanMiLCJiaXRzb3VyY2UuanMiLCJjaGFyYWN0ZXJzZXRlY2kuanMiLCJtb2RlLmpzIiwidXRmOC5qcyIsImljb252bGl0ZS5qcyIsInN0cmluZ3V0aWxzLmpzIiwiZGVjb2RlZGJpdHN0cmVhbXBhcnNlci5qcyIsImdmMjU2cG9seS5qcyIsImdmMjU2LmpzIiwicmVlZHNvbG9tb25kZWNvZGVyLmpzIiwiZGVjb2Rlci5qcyIsImJpdGFycmF5LmpzIiwiZW5jb2RlaGludHR5cGUuanMiLCJyZWVkc29sb21vbmVuY29kZXIuanMiLCJCbG9ja1BhaXIuanMiLCJCeXRlTWF0cml4LmpzIiwiTWFza1V0aWwuanMiLCJ3cml0ZXJlcnJvci5qcyIsIlFSQ29kZS5qcyIsIk1hdHJpeFV0aWwuanMiLCJFbmNvZGVyLmpzIiwiYmluYXJpemVyLmpzIiwiZ2xvYmFsaGlzdG9ncmFtYmluYXJpemVyLmpzIiwiaW50YXJyYXkyZC5qcyIsImh5YnJpZGJpbmFyaXplci5qcyIsIm5hdGl2ZXByZXByb2Nlc3NpbmcuanMiLCJpbWFnZWRlY29kaW5nLmpzIiwiZGVjb2Rld29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6aERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdG5EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2h3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Inc2OWIucXJjb2RlLmRlY29kZXdvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm9vdHN0cmFwIGZvciB0aGUgR29vZ2xlIEpTIExpYnJhcnkgKENsb3N1cmUpLlxuICpcbiAqIEluIHVuY29tcGlsZWQgbW9kZSBiYXNlLmpzIHdpbGwgd3JpdGUgb3V0IENsb3N1cmUncyBkZXBzIGZpbGUsIHVubGVzcyB0aGVcbiAqIGdsb2JhbCA8Y29kZT5DTE9TVVJFX05PX0RFUFM8L2NvZGU+IGlzIHNldCB0byB0cnVlLiAgVGhpcyBhbGxvd3MgcHJvamVjdHMgdG9cbiAqIGluY2x1ZGUgdGhlaXIgb3duIGRlcHMgZmlsZShzKSBmcm9tIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogQGF1dGhvciBhcnZAZ29vZ2xlLmNvbSAoRXJpayBBcnZpZHNzb24pXG4gKlxuICogQHByb3ZpZGVHb29nXG4gKi9cblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IE92ZXJyaWRkZW4gdG8gdHJ1ZSBieSB0aGUgY29tcGlsZXIgd2hlblxuICogICAgIC0tcHJvY2Vzc19jbG9zdXJlX3ByaW1pdGl2ZXMgaXMgc3BlY2lmaWVkLlxuICovXG52YXIgQ09NUElMRUQgPSBmYWxzZTtcblxuXG4vKipcbiAqIEJhc2UgbmFtZXNwYWNlIGZvciB0aGUgQ2xvc3VyZSBsaWJyYXJ5LiAgQ2hlY2tzIHRvIHNlZSBnb29nIGlzIGFscmVhZHlcbiAqIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgc2NvcGUgYmVmb3JlIGFzc2lnbmluZyB0byBwcmV2ZW50IGNsb2JiZXJpbmcgaWZcbiAqIGJhc2UuanMgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBjb25zdFxuICovXG52YXIgZ29vZyA9IGdvb2cgfHwge307XG5cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBjb250ZXh0LiAgSW4gbW9zdCBjYXNlcyB0aGlzIHdpbGwgYmUgJ3dpbmRvdycuXG4gKi9cbmdvb2cuZ2xvYmFsID0gdGhpcztcblxuXG4vKipcbiAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmaW5lIHZhbHVlcyBpbiB1bmNvbXBpbGVkIG1vZGUuXG4gKlxuICogSW4gdW5jb21waWxlZCBtb2RlLCB7QGNvZGUgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVN9IG1heSBiZSBkZWZpbmVkIGJlZm9yZVxuICogbG9hZGluZyBiYXNlLmpzLiAgSWYgYSBrZXkgaXMgZGVmaW5lZCBpbiB7QGNvZGUgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVN9LFxuICoge0Bjb2RlIGdvb2cuZGVmaW5lfSB3aWxsIHVzZSB0aGUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB2YWx1ZS4gIFRoaXNcbiAqIGFsbG93cyBmbGFncyB0byBiZSBvdmVyd3JpdHRlbiB3aXRob3V0IGNvbXBpbGF0aW9uICh0aGlzIGlzIG5vcm1hbGx5XG4gKiBhY2NvbXBsaXNoZWQgd2l0aCB0aGUgY29tcGlsZXIncyBcImRlZmluZVwiIGZsYWcpLlxuICpcbiAqIEV4YW1wbGU6XG4gKiA8cHJlPlxuICogICB2YXIgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgPSB7J2dvb2cuREVCVUcnOiBmYWxzZX07XG4gKiA8L3ByZT5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVM7XG5cblxuLyoqXG4gKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmluZSB2YWx1ZXMgaW4gdW5jb21waWxlZCBvciBjb21waWxlZCBtb2RlLFxuICogbGlrZSBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyBidXQgZWZmZWN0aXZlIGluIGNvbXBpbGVkIGNvZGUuICBJblxuICogdW5jb21waWxlZCBjb2RlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIHRha2VzIHByZWNlZGVuY2UuXG4gKlxuICogQWxzbyB1bmxpa2UgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgdGhlIHZhbHVlcyBtdXN0IGJlIG51bWJlciwgYm9vbGVhbiBvclxuICogc3RyaW5nIGxpdGVyYWxzIG9yIHRoZSBjb21waWxlciB3aWxsIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogV2hpbGUgYW55IEBkZWZpbmUgdmFsdWUgbWF5IGJlIHNldCwgb25seSB0aG9zZSBzZXQgd2l0aCBnb29nLmRlZmluZSB3aWxsIGJlXG4gKiBlZmZlY3RpdmUgZm9yIHVuY29tcGlsZWQgY29kZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogPHByZT5cbiAqICAgdmFyIENMT1NVUkVfREVGSU5FUyA9IHsnZ29vZy5ERUJVRyc6IGZhbHNlfSA7XG4gKiA8L3ByZT5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIFdBUk5JTkc6IERvIG5vdCB1c2UgdGhpcyB0byB0ZXN0IGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gVXNlIHRoZSBpblxuICogb3BlcmF0b3IgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5nb29nLmlzRGVmID0gZnVuY3Rpb24odmFsKSB7XG4gIC8vIHZvaWQgMCBhbHdheXMgZXZhbHVhdGVzIHRvIHVuZGVmaW5lZCBhbmQgaGVuY2Ugd2UgZG8gbm90IG5lZWQgdG8gZGVwZW5kIG9uXG4gIC8vIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUgbmFtZWQgJ3VuZGVmaW5lZCcuXG4gIHJldHVybiB2YWwgIT09IHZvaWQgMDtcbn07XG5cblxuLyoqXG4gKiBCdWlsZHMgYW4gb2JqZWN0IHN0cnVjdHVyZSBmb3IgdGhlIHByb3ZpZGVkIG5hbWVzcGFjZSBwYXRoLCBlbnN1cmluZyB0aGF0XG4gKiBuYW1lcyB0aGF0IGFscmVhZHkgZXhpc3QgYXJlIG5vdCBvdmVyd3JpdHRlbi4gRm9yIGV4YW1wbGU6XG4gKiBcImEuYi5jXCIgLT4gYSA9IHt9O2EuYj17fTthLmIuYz17fTtcbiAqIFVzZWQgYnkgZ29vZy5wcm92aWRlIGFuZCBnb29nLmV4cG9ydFN5bWJvbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG9iamVjdCB0aGF0IHRoaXMgZmlsZSBkZWZpbmVzLlxuICogQHBhcmFtIHsqPX0gb3B0X29iamVjdCB0aGUgb2JqZWN0IHRvIGV4cG9zZSBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0VG9FeHBvcnRUbyBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcGF0aCB0bzsgZGVmYXVsdFxuICogICAgIGlzIHxnb29nLmdsb2JhbHwuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmV4cG9ydFBhdGhfID0gZnVuY3Rpb24obmFtZSwgb3B0X29iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICB2YXIgY3VyID0gb3B0X29iamVjdFRvRXhwb3J0VG8gfHwgZ29vZy5nbG9iYWw7XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZXhoaWJpdHMgc3RyYW5nZSBiZWhhdmlvciB3aGVuIHRocm93aW5nIGVycm9ycyBmcm9tXG4gIC8vIG1ldGhvZHMgZXh0ZXJuZWQgaW4gdGhpcyBtYW5uZXIuICBTZWUgdGhlIHRlc3RFeHBvcnRTeW1ib2xFeGNlcHRpb25zIGluXG4gIC8vIGJhc2VfdGVzdC5odG1sIGZvciBhbiBleGFtcGxlLlxuICBpZiAoIShwYXJ0c1swXSBpbiBjdXIpICYmIGN1ci5leGVjU2NyaXB0KSB7XG4gICAgY3VyLmV4ZWNTY3JpcHQoJ3ZhciAnICsgcGFydHNbMF0pO1xuICB9XG5cbiAgLy8gQ2VydGFpbiBicm93c2VycyBjYW5ub3QgcGFyc2UgY29kZSBpbiB0aGUgZm9ybSBmb3IoKGEgaW4gYik7IGM7KTtcbiAgLy8gVGhpcyBwYXR0ZXJuIGlzIHByb2R1Y2VkIGJ5IHRoZSBKU0NvbXBpbGVyIHdoZW4gaXQgY29sbGFwc2VzIHRoZVxuICAvLyBzdGF0ZW1lbnQgYWJvdmUgaW50byB0aGUgY29uZGl0aW9uYWwgbG9vcCBiZWxvdy4gVG8gcHJldmVudCB0aGlzIGZyb21cbiAgLy8gaGFwcGVuaW5nLCB1c2UgYSBmb3ItbG9vcCBhbmQgcmVzZXJ2ZSB0aGUgaW5pdCBsb2dpYyBhcyBiZWxvdy5cblxuICAvLyBQYXJlbnRoZXNlcyBhZGRlZCB0byBlbGltaW5hdGUgc3RyaWN0IEpTIHdhcm5pbmcgaW4gRmlyZWZveC5cbiAgZm9yICh2YXIgcGFydDsgcGFydHMubGVuZ3RoICYmIChwYXJ0ID0gcGFydHMuc2hpZnQoKSk7KSB7XG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggJiYgZ29vZy5pc0RlZihvcHRfb2JqZWN0KSkge1xuICAgICAgLy8gbGFzdCBwYXJ0IGFuZCB3ZSBoYXZlIGFuIG9iamVjdDsgdXNlIGl0XG4gICAgICBjdXJbcGFydF0gPSBvcHRfb2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoY3VyW3BhcnRdKSB7XG4gICAgICBjdXIgPSBjdXJbcGFydF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1ciA9IGN1cltwYXJ0XSA9IHt9O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIERlZmluZXMgYSBuYW1lZCB2YWx1ZS4gSW4gdW5jb21waWxlZCBtb2RlLCB0aGUgdmFsdWUgaXMgcmV0cmlldmVkIGZyb21cbiAqIENMT1NVUkVfREVGSU5FUyBvciBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyBpZiB0aGUgb2JqZWN0IGlzIGRlZmluZWQgYW5kXG4gKiBoYXMgdGhlIHByb3BlcnR5IHNwZWNpZmllZCwgYW5kIG90aGVyd2lzZSB1c2VkIHRoZSBkZWZpbmVkIGRlZmF1bHRWYWx1ZS5cbiAqIFdoZW4gY29tcGlsZWQgdGhlIGRlZmF1bHQgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGNvbXBpbGVyXG4gKiBvcHRpb25zIG9yIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIENMT1NVUkVfREVGSU5FUyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGRpc3Rpbmd1aXNoZWQgbmFtZSB0byBwcm92aWRlLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IGRlZmF1bHRWYWx1ZVxuICovXG5nb29nLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICAgICAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMsIG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgICAgIGdvb2cuZ2xvYmFsLkNMT1NVUkVfREVGSU5FUywgbmFtZSkpIHtcbiAgICAgIHZhbHVlID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTW25hbWVdO1xuICAgIH1cbiAgfVxuICBnb29nLmV4cG9ydFBhdGhfKG5hbWUsIHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBERUJVRyBpcyBwcm92aWRlZCBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgZGVidWdnaW5nIGNvZGVcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBhIHByb2R1Y3Rpb24ganNfYmluYXJ5IGNhbiBiZSBlYXNpbHkgc3RyaXBwZWRcbiAqIGJ5IHNwZWNpZnlpbmcgLS1kZWZpbmUgZ29vZy5ERUJVRz1mYWxzZSB0byB0aGUgSlNDb21waWxlci4gRm9yIGV4YW1wbGUsIG1vc3RcbiAqIHRvU3RyaW5nKCkgbWV0aG9kcyBzaG91bGQgYmUgZGVjbGFyZWQgaW5zaWRlIGFuIFwiaWYgKGdvb2cuREVCVUcpXCIgY29uZGl0aW9uYWxcbiAqIGJlY2F1c2UgdGhleSBhcmUgZ2VuZXJhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBhbmQgaXQgaXMgZGlmZmljdWx0XG4gKiBmb3IgdGhlIEpTQ29tcGlsZXIgdG8gc3RhdGljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGV5IGFyZSB1c2VkLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5ERUJVRycsIHRydWUpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7c3RyaW5nfSBMT0NBTEUgZGVmaW5lcyB0aGUgbG9jYWxlIGJlaW5nIHVzZWQgZm9yIGNvbXBpbGF0aW9uLiBJdCBpc1xuICogdXNlZCB0byBzZWxlY3QgbG9jYWxlIHNwZWNpZmljIGRhdGEgdG8gYmUgY29tcGlsZWQgaW4ganMgYmluYXJ5LiBCVUlMRCBydWxlXG4gKiBjYW4gc3BlY2lmeSB0aGlzIHZhbHVlIGJ5IFwiLS1kZWZpbmUgZ29vZy5MT0NBTEU9PGxvY2FsZV9uYW1lPlwiIGFzIEpTQ29tcGlsZXJcbiAqIG9wdGlvbi5cbiAqXG4gKiBUYWtlIGludG8gYWNjb3VudCB0aGF0IHRoZSBsb2NhbGUgY29kZSBmb3JtYXQgaXMgaW1wb3J0YW50LiBZb3Ugc2hvdWxkIHVzZVxuICogdGhlIGNhbm9uaWNhbCBVbmljb2RlIGZvcm1hdCB3aXRoIGh5cGhlbiBhcyBhIGRlbGltaXRlci4gTGFuZ3VhZ2UgbXVzdCBiZVxuICogbG93ZXJjYXNlLCBMYW5ndWFnZSBTY3JpcHQgLSBDYXBpdGFsaXplZCwgUmVnaW9uIC0gVVBQRVJDQVNFLlxuICogVGhlcmUgYXJlIGZldyBleGFtcGxlczogcHQtQlIsIGVuLCBlbi1VUywgc3ItTGF0aW4tQk8sIHpoLUhhbnMtQ04uXG4gKlxuICogU2VlIG1vcmUgaW5mbyBhYm91dCBsb2NhbGUgY29kZXMgaGVyZTpcbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNVbmljb2RlX0xhbmd1YWdlX2FuZF9Mb2NhbGVfSWRlbnRpZmllcnNcbiAqXG4gKiBGb3IgbGFuZ3VhZ2UgY29kZXMgeW91IHNob3VsZCB1c2UgdmFsdWVzIGRlZmluZWQgYnkgSVNPIDY5My0xLiBTZWUgaXQgaGVyZVxuICogaHR0cDovL3d3dy53My5vcmcvV0FJL0VSL0lHL2VydC9pc282MzkuaHRtLiBUaGVyZSBpcyBvbmx5IG9uZSBleGNlcHRpb24gZnJvbVxuICogdGhpcyBydWxlOiB0aGUgSGVicmV3IGxhbmd1YWdlLiBGb3IgbGVnYWN5IHJlYXNvbnMgdGhlIG9sZCBjb2RlIChpdykgc2hvdWxkXG4gKiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIG5ldyBjb2RlIChoZSksIHNlZSBodHRwOi8vd2lraS9NYWluL0lJSVN5bm9ueW1zLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5MT0NBTEUnLCAnZW4nKTsgIC8vIGRlZmF1bHQgdG8gZW5cblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBjb2RlIGlzIHJ1bm5pbmcgb24gdHJ1c3RlZCBzaXRlcy5cbiAqXG4gKiBPbiB1bnRydXN0ZWQgc2l0ZXMsIHNldmVyYWwgbmF0aXZlIGZ1bmN0aW9ucyBjYW4gYmUgZGVmaW5lZCBvciBvdmVycmlkZGVuIGJ5XG4gKiBleHRlcm5hbCBsaWJyYXJpZXMgbGlrZSBQcm90b3R5cGUsIERhdGVqcywgYW5kIEpRdWVyeSBhbmQgc2V0dGluZyB0aGlzIGZsYWdcbiAqIHRvIGZhbHNlIGZvcmNlcyBjbG9zdXJlIHRvIHVzZSBpdHMgb3duIGltcGxlbWVudGF0aW9ucyB3aGVuIHBvc3NpYmxlLlxuICpcbiAqIElmIHlvdXIgSmF2YVNjcmlwdCBjYW4gYmUgbG9hZGVkIGJ5IGEgdGhpcmQgcGFydHkgc2l0ZSBhbmQgeW91IGFyZSB3YXJ5IGFib3V0XG4gKiByZWx5aW5nIG9uIG5vbi1zdGFuZGFyZCBpbXBsZW1lbnRhdGlvbnMsIHNwZWNpZnlcbiAqIFwiLS1kZWZpbmUgZ29vZy5UUlVTVEVEX1NJVEU9ZmFsc2VcIiB0byB0aGUgSlNDb21waWxlci5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuVFJVU1RFRF9TSVRFJywgdHJ1ZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIGEgcHJvamVjdCBpcyBleHBlY3RlZCB0byBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLlxuICpcbiAqIFRoaXMgZGVmaW5lIGNhbiBiZSB1c2VkIHRvIHRyaWdnZXIgYWx0ZXJuYXRlIGltcGxlbWVudGF0aW9ucyBjb21wYXRpYmxlIHdpdGhcbiAqIHJ1bm5pbmcgaW4gRWNtYVNjcmlwdCBTdHJpY3QgbW9kZSBvciB3YXJuIGFib3V0IHVuYXZhaWxhYmxlIGZ1bmN0aW9uYWxpdHkuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9uc19hbmRfZnVuY3Rpb25fc2NvcGUvU3RyaWN0X21vZGVcbiAqXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLlNUUklDVF9NT0RFX0NPTVBBVElCTEUnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIGNvZGUgdGhhdCBjYWxscyB7QGxpbmsgZ29vZy5zZXRUZXN0T25seX0gc2hvdWxkXG4gKiAgICAgYmUgZGlzYWxsb3dlZCBpbiB0aGUgY29tcGlsYXRpb24gdW5pdC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuRElTQUxMT1dfVEVTVF9PTkxZX0NPREUnLCBDT01QSUxFRCAmJiAhZ29vZy5ERUJVRyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIHVzZSBhIENocm9tZSBhcHAgQ1NQLWNvbXBsaWFudCBtZXRob2QgZm9yXG4gKiAgICAgbG9hZGluZyBzY3JpcHRzIHZpYSBnb29nLnJlcXVpcmUuIEBzZWUgYXBwZW5kU2NyaXB0U3JjTm9kZV8uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLkVOQUJMRV9DSFJPTUVfQVBQX1NBRkVfU0NSSVBUX0xPQURJTkcnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBEZWZpbmVzIGEgbmFtZXNwYWNlIGluIENsb3N1cmUuXG4gKlxuICogQSBuYW1lc3BhY2UgbWF5IG9ubHkgYmUgZGVmaW5lZCBvbmNlIGluIGEgY29kZWJhc2UuIEl0IG1heSBiZSBkZWZpbmVkIHVzaW5nXG4gKiBnb29nLnByb3ZpZGUoKSBvciBnb29nLm1vZHVsZSgpLlxuICpcbiAqIFRoZSBwcmVzZW5jZSBvZiBvbmUgb3IgbW9yZSBnb29nLnByb3ZpZGUoKSBjYWxscyBpbiBhIGZpbGUgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBmaWxlIGRlZmluZXMgdGhlIGdpdmVuIG9iamVjdHMvbmFtZXNwYWNlcy5cbiAqIFByb3ZpZGVkIHN5bWJvbHMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogSW4gYWRkaXRpb24sIGdvb2cucHJvdmlkZSgpIGNyZWF0ZXMgdGhlIG9iamVjdCBzdHVicyBmb3IgYSBuYW1lc3BhY2VcbiAqIChmb3IgZXhhbXBsZSwgZ29vZy5wcm92aWRlKFwiZ29vZy5mb28uYmFyXCIpIHdpbGwgY3JlYXRlIHRoZSBvYmplY3RcbiAqIGdvb2cuZm9vLmJhciBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0KS5cbiAqXG4gKiBCdWlsZCB0b29scyBhbHNvIHNjYW4gZm9yIHByb3ZpZGUvcmVxdWlyZS9tb2R1bGUgc3RhdGVtZW50c1xuICogdG8gZGlzY2VybiBkZXBlbmRlbmNpZXMsIGJ1aWxkIGRlcGVuZGVuY3kgZmlsZXMgKHNlZSBkZXBzLmpzKSwgZXRjLlxuICpcbiAqIEBzZWUgZ29vZy5yZXF1aXJlXG4gKiBAc2VlIGdvb2cubW9kdWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgcHJvdmlkZWQgYnkgdGhpcyBmaWxlIGluIHRoZSBmb3JtXG4gKiAgICAgXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICovXG5nb29nLnByb3ZpZGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2FtZSBuYW1lc3BhY2UgaXNuJ3QgcHJvdmlkZWQgdHdpY2UuXG4gICAgLy8gQSBnb29nLm1vZHVsZS9nb29nLnByb3ZpZGUgbWFwcyBhIGdvb2cucmVxdWlyZSB0byBhIHNwZWNpZmljIGZpbGVcbiAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ05hbWVzcGFjZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZGVjbGFyZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfKG5hbWUpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBwcm92aWRlZCBieSB0aGlzIGZpbGUgaW4gdGhlIGZvcm1cbiAqICAgICBcImdvb2cucGFja2FnZS5wYXJ0XCIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB0byBlbWJlZCBpbiB0aGUgbmFtZXNwYWNlLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfID0gZnVuY3Rpb24obmFtZSwgb3B0X29iaikge1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgZGVsZXRlIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXTtcblxuICAgIHZhciBuYW1lc3BhY2UgPSBuYW1lO1xuICAgIHdoaWxlICgobmFtZXNwYWNlID0gbmFtZXNwYWNlLnN1YnN0cmluZygwLCBuYW1lc3BhY2UubGFzdEluZGV4T2YoJy4nKSkpKSB7XG4gICAgICBpZiAoZ29vZy5nZXRPYmplY3RCeU5hbWUobmFtZXNwYWNlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lc3BhY2VdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBnb29nLmV4cG9ydFBhdGhfKG5hbWUsIG9wdF9vYmopO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSBpZGVudGlmaWVyIHZhbGlkYXRpb24gcmVnZXhwLlxuICogTm90ZTogVGhpcyBpcyBhIGNvbnNlcnZhdGl2ZSBjaGVjaywgaXQgaXMgdmVyeSBwb3NzaWJsZSB0byBiZSBtb3JlIGxlbmllbnQsXG4gKiAgIHRoZSBwcmltYXJ5IGV4Y2x1c2lvbiBoZXJlIGlzIFwiL1wiIGFuZCBcIlxcXCIgYW5kIGEgbGVhZGluZyBcIi5cIiwgdGhlc2VcbiAqICAgcmVzdHJpY3Rpb25zIGFyZSBpbnRlbmRlZCB0byBsZWF2ZSB0aGUgZG9vciBvcGVuIGZvciB1c2luZyBnb29nLnJlcXVpcmVcbiAqICAgd2l0aCByZWxhdGl2ZSBmaWxlIHBhdGhzIHJhdGhlciB0aGFuIG1vZHVsZSBpZGVudGlmaWVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuVkFMSURfTU9EVUxFX1JFXyA9IC9eW2EtekEtWl8kXVthLXpBLVowLTkuXyRdKiQvO1xuXG5cbi8qKlxuICogRGVmaW5lcyBhIG1vZHVsZSBpbiBDbG9zdXJlLlxuICpcbiAqIE1hcmtzIHRoYXQgdGhpcyBmaWxlIG11c3QgYmUgbG9hZGVkIGFzIGEgbW9kdWxlIGFuZCBjbGFpbXMgdGhlIG5hbWVzcGFjZS5cbiAqXG4gKiBBIG5hbWVzcGFjZSBtYXkgb25seSBiZSBkZWZpbmVkIG9uY2UgaW4gYSBjb2RlYmFzZS4gSXQgbWF5IGJlIGRlZmluZWQgdXNpbmdcbiAqIGdvb2cucHJvdmlkZSgpIG9yIGdvb2cubW9kdWxlKCkuXG4gKlxuICogZ29vZy5tb2R1bGUoKSBoYXMgdGhyZWUgcmVxdWlyZW1lbnRzOlxuICogLSBnb29nLm1vZHVsZSBtYXkgbm90IGJlIHVzZWQgaW4gdGhlIHNhbWUgZmlsZSBhcyBnb29nLnByb3ZpZGUuXG4gKiAtIGdvb2cubW9kdWxlIG11c3QgYmUgdGhlIGZpcnN0IHN0YXRlbWVudCBpbiB0aGUgZmlsZS5cbiAqIC0gb25seSBvbmUgZ29vZy5tb2R1bGUgaXMgYWxsb3dlZCBwZXIgZmlsZS5cbiAqXG4gKiBXaGVuIGEgZ29vZy5tb2R1bGUgYW5ub3RhdGVkIGZpbGUgaXMgbG9hZGVkLCBpdCBpcyBlbmNsb3NlZCBpblxuICogYSBzdHJpY3QgZnVuY3Rpb24gY2xvc3VyZS4gVGhpcyBtZWFucyB0aGF0OlxuICogLSBhbnkgdmFyaWFibGVzIGRlY2xhcmVkIGluIGEgZ29vZy5tb2R1bGUgZmlsZSBhcmUgcHJpdmF0ZSB0byB0aGUgZmlsZVxuICogKG5vdCBnbG9iYWwpLCB0aG91Z2ggdGhlIGNvbXBpbGVyIGlzIGV4cGVjdGVkIHRvIGlubGluZSB0aGUgbW9kdWxlLlxuICogLSBUaGUgY29kZSBtdXN0IG9iZXkgYWxsIHRoZSBydWxlcyBvZiBcInN0cmljdFwiIEphdmFTY3JpcHQuXG4gKiAtIHRoZSBmaWxlIHdpbGwgYmUgbWFya2VkIGFzIFwidXNlIHN0cmljdFwiXG4gKlxuICogTk9URTogdW5saWtlIGdvb2cucHJvdmlkZSwgZ29vZy5tb2R1bGUgZG9lcyBub3QgZGVjbGFyZSBhbnkgc3ltYm9scyBieVxuICogaXRzZWxmLiBJZiBkZWNsYXJlZCBzeW1ib2xzIGFyZSBkZXNpcmVkLCB1c2VcbiAqIGdvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UoKS5cbiAqXG4gKlxuICogU2VlIHRoZSBwdWJsaWMgZ29vZy5tb2R1bGUgcHJvcG9zYWw6IGh0dHA6Ly9nb28uZ2wvVmExaGluXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIHByb3ZpZGVkIGJ5IHRoaXMgZmlsZSBpbiB0aGUgZm9ybVxuICogICAgIFwiZ29vZy5wYWNrYWdlLnBhcnRcIiwgaXMgZXhwZWN0ZWQgYnV0IG5vdCByZXF1aXJlZC5cbiAqL1xuZ29vZy5tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghZ29vZy5pc1N0cmluZyhuYW1lKSB8fFxuICAgICAgIW5hbWUgfHxcbiAgICAgIG5hbWUuc2VhcmNoKGdvb2cuVkFMSURfTU9EVUxFX1JFXykgPT0gLTEpIHtcbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBtb2R1bGUgaWRlbnRpZmllcicpO1xuICB9XG4gIGlmICghZ29vZy5pc0luTW9kdWxlTG9hZGVyXygpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ01vZHVsZSAnICsgbmFtZSArICcgaGFzIGJlZW4gbG9hZGVkIGluY29ycmVjdGx5LicpO1xuICB9XG4gIGlmIChnb29nLm1vZHVsZUxvYWRlclN0YXRlXy5tb2R1bGVOYW1lKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2dvb2cubW9kdWxlIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBtb2R1bGUuJyk7XG4gIH1cblxuICAvLyBTdG9yZSB0aGUgbW9kdWxlIG5hbWUgZm9yIHRoZSBsb2FkZXIuXG4gIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWUgPSBuYW1lO1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNhbWUgbmFtZXNwYWNlIGlzbid0IHByb3ZpZGVkIHR3aWNlLlxuICAgIC8vIEEgZ29vZy5tb2R1bGUvZ29vZy5wcm92aWRlIG1hcHMgYSBnb29nLnJlcXVpcmUgdG8gYSBzcGVjaWZpYyBmaWxlXG4gICAgaWYgKGdvb2cuaXNQcm92aWRlZF8obmFtZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdOYW1lc3BhY2UgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGRlY2xhcmVkLicpO1xuICAgIH1cbiAgICBkZWxldGUgZ29vZy5pbXBsaWNpdE5hbWVzcGFjZXNfW25hbWVdO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSBpZGVudGlmaWVyLlxuICogQHJldHVybiB7P30gVGhlIG1vZHVsZSBleHBvcnRzIGZvciBhbiBhbHJlYWR5IGxvYWRlZCBtb2R1bGUgb3IgbnVsbC5cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhbiBhbHRlcm5hdGl2ZSB0byBnb29nLnJlcXVpcmUsIGl0IGRvZXMgbm90XG4gKiBpbmRpY2F0ZSBhIGhhcmQgZGVwZW5kZW5jeSwgaW5zdGVhZCBpdCBpcyB1c2VkIHRvIGluZGljYXRlXG4gKiBhbiBvcHRpb25hbCBkZXBlbmRlbmN5IG9yIHRvIGFjY2VzcyB0aGUgZXhwb3J0cyBvZiBhIG1vZHVsZVxuICogdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC5cbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3ZpZGV9XG4gKi9cbmdvb2cubW9kdWxlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIGdvb2cubW9kdWxlLmdldEludGVybmFsXyhuYW1lKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHs/fSBUaGUgbW9kdWxlIGV4cG9ydHMgZm9yIGFuIGFscmVhZHkgbG9hZGVkIG1vZHVsZSBvciBudWxsLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5tb2R1bGUuZ2V0SW50ZXJuYWxfID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgaWYgKGdvb2cuaXNQcm92aWRlZF8obmFtZSkpIHtcbiAgICAgIC8vIGdvb2cucmVxdWlyZSBvbmx5IHJldHVybiBhIHZhbHVlIHdpdGgtaW4gZ29vZy5tb2R1bGUgZmlsZXMuXG4gICAgICByZXR1cm4gbmFtZSBpbiBnb29nLmxvYWRlZE1vZHVsZXNfID9cbiAgICAgICAgICBnb29nLmxvYWRlZE1vZHVsZXNfW25hbWVdIDpcbiAgICAgICAgICBnb29nLmdldE9iamVjdEJ5TmFtZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGUgez97bW9kdWxlTmFtZTogKHN0cmluZ3x1bmRlZmluZWQpfX1cbiAqL1xuZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gPSBudWxsO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnb29nLm1vZHVsZSBpcyBjdXJyZW50bHkgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gKi9cbmdvb2cuaXNJbk1vZHVsZUxvYWRlcl8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfICE9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUHJvdmlkZSB0aGUgbW9kdWxlJ3MgZXhwb3J0cyBhcyBhIGdsb2JhbGx5IGFjY2Vzc2libGUgb2JqZWN0IHVuZGVyIHRoZVxuICogbW9kdWxlJ3MgZGVjbGFyZWQgbmFtZS4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gZWFzZSBtaWdyYXRpb24gdG8gZ29vZy5tb2R1bGVcbiAqIGZvciBmaWxlcyB0aGF0IGhhdmUgZXhpc3RpbmcgdXNhZ2VzLlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvdmlkZX1cbiAqL1xuZ29vZy5tb2R1bGUuZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIUNPTVBJTEVEICYmICFnb29nLmlzSW5Nb2R1bGVMb2FkZXJfKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgbXVzdCBiZSBjYWxsZWQgZnJvbSAnICtcbiAgICAgICAgJ3dpdGhpbiBhIGdvb2cubW9kdWxlJyk7XG4gIH1cbiAgaWYgKCFDT01QSUxFRCAmJiAhZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZSkge1xuICAgIHRocm93IEVycm9yKCdnb29nLm1vZHVsZSBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byAnICtcbiAgICAgICAgJ2dvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UuJyk7XG4gIH1cbiAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8uZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogTWFya3MgdGhhdCB0aGUgY3VycmVudCBmaWxlIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcsIGFuZCBuZXZlciBmb3JcbiAqIGxpdmUgY29kZSBpbiBwcm9kdWN0aW9uLlxuICpcbiAqIEluIHRoZSBjYXNlIG9mIHVuaXQgdGVzdHMsIHRoZSBtZXNzYWdlIG1heSBvcHRpb25hbGx5IGJlIGFuIGV4YWN0IG5hbWVzcGFjZVxuICogZm9yIHRoZSB0ZXN0IChlLmcuICdnb29nLnN0cmluZ1Rlc3QnKS4gVGhlIGxpbnRlciB3aWxsIHRoZW4gaWdub3JlIHRoZSBleHRyYVxuICogcHJvdmlkZSAoaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpbiB0aGUgY29kZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlIHRvIGFkZCB0byB0aGUgZXJyb3IgdGhhdCdzXG4gKiAgICAgcmFpc2VkIHdoZW4gdXNlZCBpbiBwcm9kdWN0aW9uIGNvZGUuXG4gKi9cbmdvb2cuc2V0VGVzdE9ubHkgPSBmdW5jdGlvbihvcHRfbWVzc2FnZSkge1xuICBpZiAoZ29vZy5ESVNBTExPV19URVNUX09OTFlfQ09ERSkge1xuICAgIG9wdF9tZXNzYWdlID0gb3B0X21lc3NhZ2UgfHwgJyc7XG4gICAgdGhyb3cgRXJyb3IoJ0ltcG9ydGluZyB0ZXN0LW9ubHkgY29kZSBpbnRvIG5vbi1kZWJ1ZyBlbnZpcm9ubWVudCcgK1xuICAgICAgICAgICAgICAgIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcuJykpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRm9yd2FyZCBkZWNsYXJlcyBhIHN5bWJvbC4gVGhpcyBpcyBhbiBpbmRpY2F0aW9uIHRvIHRoZSBjb21waWxlciB0aGF0IHRoZVxuICogc3ltYm9sIG1heSBiZSB1c2VkIGluIHRoZSBzb3VyY2UgeWV0IGlzIG5vdCByZXF1aXJlZCBhbmQgbWF5IG5vdCBiZSBwcm92aWRlZFxuICogaW4gY29tcGlsYXRpb24uXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIHVzYWdlIG9mIGZvcndhcmQgZGVjbGFyYXRpb24gaXMgY29kZSB0aGF0IHRha2VzIGEgdHlwZSBhcyBhXG4gKiBmdW5jdGlvbiBwYXJhbWV0ZXIgYnV0IGRvZXMgbm90IG5lZWQgdG8gcmVxdWlyZSBpdC4gQnkgZm9yd2FyZCBkZWNsYXJpbmdcbiAqIGluc3RlYWQgb2YgcmVxdWlyaW5nLCBubyBoYXJkIGRlcGVuZGVuY3kgaXMgbWFkZSwgYW5kIChpZiBub3QgcmVxdWlyZWRcbiAqIGVsc2V3aGVyZSkgdGhlIG5hbWVzcGFjZSBtYXkgbmV2ZXIgYmUgcmVxdWlyZWQgYW5kIHRodXMsIG5vdCBiZSBwdWxsZWRcbiAqIGludG8gdGhlIEphdmFTY3JpcHQgYmluYXJ5LiBJZiBpdCBpcyByZXF1aXJlZCBlbHNld2hlcmUsIGl0IHdpbGwgYmUgdHlwZVxuICogY2hlY2tlZCBhcyBub3JtYWwuXG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lc3BhY2UgdG8gZm9yd2FyZCBkZWNsYXJlIGluIHRoZSBmb3JtIG9mXG4gKiAgICAgXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICovXG5nb29nLmZvcndhcmREZWNsYXJlID0gZnVuY3Rpb24obmFtZSkge307XG5cblxuLyoqXG4gKiBGb3J3YXJkIGRlY2xhcmUgdHlwZSBpbmZvcm1hdGlvbi4gVXNlZCB0byBhc3NpZ24gdHlwZXMgdG8gZ29vZy5nbG9iYWxcbiAqIHJlZmVyZW5jZWQgb2JqZWN0IHRoYXQgd291bGQgb3RoZXJ3aXNlIHJlc3VsdCBpbiB1bmtub3duIHR5cGUgcmVmZXJlbmNlc1xuICogYW5kIHRodXMgYmxvY2sgcHJvcGVydHkgZGlzYW1iaWd1YXRpb24uXG4gKi9cbmdvb2cuZm9yd2FyZERlY2xhcmUoJ0RvY3VtZW50Jyk7XG5nb29nLmZvcndhcmREZWNsYXJlKCdYTUxIdHRwUmVxdWVzdCcpO1xuXG5cbmlmICghQ09NUElMRUQpIHtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIG5hbWUgaGFzIGJlZW4gZ29vZy5wcm92aWRlZC4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3JcbiAgICogbmFtZXMgdGhhdCBhcmUgYXZhaWxhYmxlIG9ubHkgYXMgaW1wbGljaXQgbmFtZXNwYWNlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgb2JqZWN0IHRvIGxvb2sgZm9yLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pc1Byb3ZpZGVkXyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgaW4gZ29vZy5sb2FkZWRNb2R1bGVzXykgfHxcbiAgICAgICAgKCFnb29nLmltcGxpY2l0TmFtZXNwYWNlc19bbmFtZV0gJiZcbiAgICAgICAgICAgIGdvb2cuaXNEZWZBbmROb3ROdWxsKGdvb2cuZ2V0T2JqZWN0QnlOYW1lKG5hbWUpKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZXMgaW1wbGljaXRseSBkZWZpbmVkIGJ5IGdvb2cucHJvdmlkZS4gRm9yIGV4YW1wbGUsXG4gICAqIGdvb2cucHJvdmlkZSgnZ29vZy5ldmVudHMuRXZlbnQnKSBpbXBsaWNpdGx5IGRlY2xhcmVzIHRoYXQgJ2dvb2cnIGFuZFxuICAgKiAnZ29vZy5ldmVudHMnIG11c3QgYmUgbmFtZXNwYWNlcy5cbiAgICpcbiAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAoYm9vbGVhbnx1bmRlZmluZWQpPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzXyA9IHsnZ29vZy5tb2R1bGUnOiB0cnVlfTtcblxuICAvLyBOT1RFOiBXZSBhZGQgZ29vZy5tb2R1bGUgYXMgYW4gaW1wbGljaXQgbmFtZXNwYWNlIGFzIGdvb2cubW9kdWxlIGlzIGRlZmluZWRcbiAgLy8gaGVyZSBhbmQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgbW9kdWxlIHBhY2thZ2UgaGFzIG5vdCBiZWVuIG1vdmVkIHlldCBvdXQgb2ZcbiAgLy8gdGhlIGdvb2cubW9kdWxlIG5hbWVzcGFjZS4gVGhpcyBzYXRpc2lmaWVzIGJvdGggdGhlIGRlYnVnIGxvYWRlciBhbmRcbiAgLy8gYWhlYWQtb2YtdGltZSBkZXBlbmRlbmN5IG1hbmFnZW1lbnQuXG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuICBUaGUgb2JqZWN0XG4gKiBpcyBub3QgZm91bmQgaWYgbnVsbCBvciB1bmRlZmluZWQuICBJZiB5b3UgYXJlIHVzaW5nIGEgY29tcGlsYXRpb24gcGFzcyB0aGF0XG4gKiByZW5hbWVzIHByb3BlcnR5IG5hbWVzIGJld2FyZSB0aGF0IHVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgZmluZCByZW5hbWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gKiAgICAgfGdvb2cuZ2xvYmFsfC5cbiAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgbnVsbC5cbiAqL1xuZ29vZy5nZXRPYmplY3RCeU5hbWUgPSBmdW5jdGlvbihuYW1lLCBvcHRfb2JqKSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgdmFyIGN1ciA9IG9wdF9vYmogfHwgZ29vZy5nbG9iYWw7XG4gIGZvciAodmFyIHBhcnQ7IHBhcnQgPSBwYXJ0cy5zaGlmdCgpOyApIHtcbiAgICBpZiAoZ29vZy5pc0RlZkFuZE5vdE51bGwoY3VyW3BhcnRdKSkge1xuICAgICAgY3VyID0gY3VyW3BhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cjtcbn07XG5cblxuLyoqXG4gKiBHbG9iYWxpemVzIGEgd2hvbGUgbmFtZXNwYWNlLCBzdWNoIGFzIGdvb2cgb3IgZ29vZy5sYW5nLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIFRoZSBuYW1lc3BhY2UgdG8gZ2xvYmFsaXplLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZ2xvYmFsIFRoZSBvYmplY3QgdG8gYWRkIHRoZSBwcm9wZXJ0aWVzIHRvLlxuICogQGRlcHJlY2F0ZWQgUHJvcGVydGllcyBtYXkgYmUgZXhwbGljaXRseSBleHBvcnRlZCB0byB0aGUgZ2xvYmFsIHNjb3BlLCBidXRcbiAqICAgICB0aGlzIHNob3VsZCBubyBsb25nZXIgYmUgZG9uZSBpbiBidWxrLlxuICovXG5nb29nLmdsb2JhbGl6ZSA9IGZ1bmN0aW9uKG9iaiwgb3B0X2dsb2JhbCkge1xuICB2YXIgZ2xvYmFsID0gb3B0X2dsb2JhbCB8fCBnb29nLmdsb2JhbDtcbiAgZm9yICh2YXIgeCBpbiBvYmopIHtcbiAgICBnbG9iYWxbeF0gPSBvYmpbeF07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgZGVwZW5kZW5jeSBmcm9tIGEgZmlsZSB0byB0aGUgZmlsZXMgaXQgcmVxdWlyZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsUGF0aCBUaGUgcGF0aCB0byB0aGUganMgZmlsZS5cbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHByb3ZpZGVzIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aFxuICogICAgIHRoZSBuYW1lcyBvZiB0aGUgb2JqZWN0cyB0aGlzIGZpbGUgcHJvdmlkZXMuXG4gKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSByZXF1aXJlcyBBbiBhcnJheSBvZiBzdHJpbmdzIHdpdGhcbiAqICAgICB0aGUgbmFtZXMgb2YgdGhlIG9iamVjdHMgdGhpcyBmaWxlIHJlcXVpcmVzLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzTW9kdWxlIFdoZXRoZXIgdGhpcyBkZXBlbmRlbmN5IG11c3QgYmUgbG9hZGVkIGFzXG4gKiAgICAgYSBtb2R1bGUgYXMgZGVjbGFyZWQgYnkgZ29vZy5tb2R1bGUuXG4gKi9cbmdvb2cuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHJlbFBhdGgsIHByb3ZpZGVzLCByZXF1aXJlcywgb3B0X2lzTW9kdWxlKSB7XG4gIGlmIChnb29nLkRFUEVOREVOQ0lFU19FTkFCTEVEKSB7XG4gICAgdmFyIHByb3ZpZGUsIHJlcXVpcmU7XG4gICAgdmFyIHBhdGggPSByZWxQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICB2YXIgZGVwcyA9IGdvb2cuZGVwZW5kZW5jaWVzXztcbiAgICBmb3IgKHZhciBpID0gMDsgcHJvdmlkZSA9IHByb3ZpZGVzW2ldOyBpKyspIHtcbiAgICAgIGRlcHMubmFtZVRvUGF0aFtwcm92aWRlXSA9IHBhdGg7XG4gICAgICBkZXBzLnBhdGhJc01vZHVsZVtwYXRoXSA9ICEhb3B0X2lzTW9kdWxlO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgcmVxdWlyZSA9IHJlcXVpcmVzW2pdOyBqKyspIHtcbiAgICAgIGlmICghKHBhdGggaW4gZGVwcy5yZXF1aXJlcykpIHtcbiAgICAgICAgZGVwcy5yZXF1aXJlc1twYXRoXSA9IHt9O1xuICAgICAgfVxuICAgICAgZGVwcy5yZXF1aXJlc1twYXRoXVtyZXF1aXJlXSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG4vLyBOT1RFKG5uYXplKTogVGhlIGRlYnVnIERPTSBsb2FkZXIgd2FzIGluY2x1ZGVkIGluIGJhc2UuanMgYXMgYW4gb3JpZ2luYWwgd2F5XG4vLyB0byBkbyBcImRlYnVnLW1vZGVcIiBkZXZlbG9wbWVudC4gIFRoZSBkZXBlbmRlbmN5IHN5c3RlbSBjYW4gc29tZXRpbWVzIGJlXG4vLyBjb25mdXNpbmcsIGFzIGNhbiB0aGUgZGVidWcgRE9NIGxvYWRlcidzIGFzeW5jaHJvbm91cyBuYXR1cmUuXG4vL1xuLy8gV2l0aCB0aGUgRE9NIGxvYWRlciwgYSBjYWxsIHRvIGdvb2cucmVxdWlyZSgpIGlzIG5vdCBibG9ja2luZyAtLSB0aGUgc2NyaXB0XG4vLyB3aWxsIG5vdCBsb2FkIHVudGlsIHNvbWUgcG9pbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0LiAgSWYgYSBuYW1lc3BhY2UgaXNcbi8vIG5lZWRlZCBhdCBydW50aW1lLCBpdCBuZWVkcyB0byBiZSBkZWZpbmVkIGluIGEgcHJldmlvdXMgc2NyaXB0LCBvciBsb2FkZWQgdmlhXG4vLyByZXF1aXJlKCkgd2l0aCBpdHMgcmVnaXN0ZXJlZCBkZXBlbmRlbmNpZXMuXG4vLyBVc2VyLWRlZmluZWQgbmFtZXNwYWNlcyBtYXkgbmVlZCB0aGVpciBvd24gZGVwcyBmaWxlLiAgU2VlIGh0dHA6Ly9nby9qc19kZXBzLFxuLy8gaHR0cDovL2dvL2dlbmpzZGVwcywgb3IsIGV4dGVybmFsbHksIERlcHNXcml0ZXIuXG4vLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jbG9zdXJlL2xpYnJhcnkvZG9jcy9kZXBzd3JpdGVyXG4vL1xuLy8gQmVjYXVzZSBvZiBsZWdhY3kgY2xpZW50cywgdGhlIERPTSBsb2FkZXIgY2FuJ3QgYmUgZWFzaWx5IHJlbW92ZWQgZnJvbVxuLy8gYmFzZS5qcy4gIFdvcmsgaXMgYmVpbmcgZG9uZSB0byBtYWtlIGl0IGRpc2FibGVhYmxlIG9yIHJlcGxhY2VhYmxlIGZvclxuLy8gZGlmZmVyZW50IGVudmlyb25tZW50cyAoRE9NLWxlc3MgSmF2YVNjcmlwdCBpbnRlcnByZXRlcnMgbGlrZSBSaGlubyBvciBWOCxcbi8vIGZvciBleGFtcGxlKS4gU2VlIGJvb3RzdHJhcC8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgZGVidWcgbG9hZGVyLlxuICpcbiAqIElmIGVuYWJsZWQsIGEgY2FsbCB0byBnb29nLnJlcXVpcmUoKSB3aWxsIGF0dGVtcHQgdG8gbG9hZCB0aGUgbmFtZXNwYWNlIGJ5XG4gKiBhcHBlbmRpbmcgYSBzY3JpcHQgdGFnIHRvIHRoZSBET00gKGlmIHRoZSBuYW1lc3BhY2UgaGFzIGJlZW4gcmVnaXN0ZXJlZCkuXG4gKlxuICogSWYgZGlzYWJsZWQsIGdvb2cucmVxdWlyZSgpIHdpbGwgc2ltcGx5IGFzc2VydCB0aGF0IHRoZSBuYW1lc3BhY2UgaGFzIGJlZW5cbiAqIHByb3ZpZGVkIChhbmQgZGVwZW5kIG9uIHRoZSBmYWN0IHRoYXQgc29tZSBvdXRzaWRlIHRvb2wgY29ycmVjdGx5IG9yZGVyZWRcbiAqIHRoZSBzY3JpcHQpLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSJywgdHJ1ZSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxvZ1RvQ29uc29sZV8gPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKGdvb2cuZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBnb29nLmdsb2JhbC5jb25zb2xlWydlcnJvciddKG1zZyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgc3lzdGVtIGZvciB0aGUgZHluYW1pYyByZXNvbHV0aW9uIG9mIGRlcGVuZGVuY2llcyB0aGF0IHdvcmtzIGluXG4gKiBwYXJhbGxlbCB3aXRoIHRoZSBCVUlMRCBzeXN0ZW0uIE5vdGUgdGhhdCBhbGwgY2FsbHMgdG8gZ29vZy5yZXF1aXJlIHdpbGwgYmVcbiAqIHN0cmlwcGVkIGJ5IHRoZSBKU0NvbXBpbGVyIHdoZW4gdGhlIC0tcHJvY2Vzc19jbG9zdXJlX3ByaW1pdGl2ZXMgb3B0aW9uIGlzXG4gKiB1c2VkLlxuICogQHNlZSBnb29nLnByb3ZpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSB0byBpbmNsdWRlIChhcyB3YXMgZ2l2ZW4gaW4gZ29vZy5wcm92aWRlKCkpIGluXG4gKiAgICAgdGhlIGZvcm0gXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICogQHJldHVybiB7P30gSWYgY2FsbGVkIHdpdGhpbiBhIGdvb2cubW9kdWxlIGZpbGUsIHRoZSBhc3NvY2lhdGVkIG5hbWVzcGFjZSBvclxuICogICAgIG1vZHVsZSBvdGhlcndpc2UgbnVsbC5cbiAqL1xuZ29vZy5yZXF1aXJlID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBJZiB0aGUgb2JqZWN0IGFscmVhZHkgZXhpc3RzIHdlIGRvIG5vdCBuZWVkIGRvIGRvIGFueXRoaW5nLlxuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgaWYgKGdvb2cuRU5BQkxFX0RFQlVHX0xPQURFUiAmJiBnb29nLklTX09MRF9JRV8pIHtcbiAgICAgIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWREZXBfKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChnb29nLmlzUHJvdmlkZWRfKG5hbWUpKSB7XG4gICAgICBpZiAoZ29vZy5pc0luTW9kdWxlTG9hZGVyXygpKSB7XG4gICAgICAgIHJldHVybiBnb29nLm1vZHVsZS5nZXRJbnRlcm5hbF8obmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSKSB7XG4gICAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGdvb2cud3JpdGVTY3JpcHRzXyhwYXRoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVycm9yTWVzc2FnZSA9ICdnb29nLnJlcXVpcmUgY291bGQgbm90IGZpbmQ6ICcgKyBuYW1lO1xuICAgIGdvb2cubG9nVG9Db25zb2xlXyhlcnJvck1lc3NhZ2UpO1xuXG4gICAgdGhyb3cgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhdGggZm9yIGluY2x1ZGVkIHNjcmlwdHMuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5nb29nLmJhc2VQYXRoID0gJyc7XG5cblxuLyoqXG4gKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIGJhc2UgcGF0aC5cbiAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5nb29nLmdsb2JhbC5DTE9TVVJFX0JBU0VfUEFUSDtcblxuXG4vKipcbiAqIFdoZXRoZXIgdG8gd3JpdGUgb3V0IENsb3N1cmUncyBkZXBzIGZpbGUuIEJ5IGRlZmF1bHQsIHRoZSBkZXBzIGFyZSB3cml0dGVuLlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5nb29nLmdsb2JhbC5DTE9TVVJFX05PX0RFUFM7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGltcG9ydCBhIHNpbmdsZSBzY3JpcHQuIFRoaXMgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiB3aGVuXG4gKiBDbG9zdXJlIGlzIGJlaW5nIHJ1biBpbiBub24tSFRNTCBjb250ZXh0cywgc3VjaCBhcyB3ZWIgd29ya2Vycy4gSXQncyBkZWZpbmVkXG4gKiBpbiB0aGUgZ2xvYmFsIHNjb3BlIHNvIHRoYXQgaXQgY2FuIGJlIHNldCBiZWZvcmUgYmFzZS5qcyBpcyBsb2FkZWQsIHdoaWNoXG4gKiBhbGxvd3MgZGVwcy5qcyB0byBiZSBpbXBvcnRlZCBwcm9wZXJseS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzY3JpcHQgc291cmNlLCB3aGljaCBpcyBhIHJlbGF0aXZlIFVSSS4gSXQgc2hvdWxkXG4gKiByZXR1cm4gdHJ1ZSBpZiB0aGUgc2NyaXB0IHdhcyBpbXBvcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHR5cGUgeyhmdW5jdGlvbihzdHJpbmcpOiBib29sZWFuKXx1bmRlZmluZWR9XG4gKi9cbmdvb2cuZ2xvYmFsLkNMT1NVUkVfSU1QT1JUX1NDUklQVDtcblxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5nb29nLm51bGxGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBnb29nLmFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIE5vdGU6IFRoaXMgZG9lcyBub3QgdGFrZSB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gb3ZlcnJpZGUgYXMgYW4gYXJndW1lbnRcbiAqIGJlY2F1c2UgdGhhdCB3b3VsZCBtYWtlIGl0IG1vcmUgZGlmZmljdWx0IHRvIG9iZnVzY2F0ZSBvdXIgSmF2YVNjcmlwdCBjb2RlLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmdvb2cuYWJzdHJhY3RNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIHtAY29kZSBnZXRJbnN0YW5jZX0gc3RhdGljIG1ldGhvZCB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lXG4gKiBpbnN0YW5jZSBvYmplY3QuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY3RvciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBjbGFzcyB0byBhZGQgdGhlIHN0YXRpY1xuICogICAgIG1ldGhvZCB0by5cbiAqL1xuZ29vZy5hZGRTaW5nbGV0b25HZXR0ZXIgPSBmdW5jdGlvbihjdG9yKSB7XG4gIGN0b3IuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoY3Rvci5pbnN0YW5jZV8pIHtcbiAgICAgIHJldHVybiBjdG9yLmluc3RhbmNlXztcbiAgICB9XG4gICAgaWYgKGdvb2cuREVCVUcpIHtcbiAgICAgIC8vIE5PVEU6IEpTQ29tcGlsZXIgY2FuJ3Qgb3B0aW1pemUgYXdheSBBcnJheSNwdXNoLlxuICAgICAgZ29vZy5pbnN0YW50aWF0ZWRTaW5nbGV0b25zX1tnb29nLmluc3RhbnRpYXRlZFNpbmdsZXRvbnNfLmxlbmd0aF0gPSBjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gY3Rvci5pbnN0YW5jZV8gPSBuZXcgY3RvcjtcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBBbGwgc2luZ2xldG9uIGNsYXNzZXMgdGhhdCBoYXZlIGJlZW4gaW5zdGFudGlhdGVkLCBmb3IgdGVzdGluZy4gRG9uJ3QgcmVhZFxuICogaXQgZGlyZWN0bHksIHVzZSB0aGUge0Bjb2RlIGdvb2cudGVzdGluZy5zaW5nbGV0b259IG1vZHVsZS4gVGhlIGNvbXBpbGVyXG4gKiByZW1vdmVzIHRoaXMgdmFyaWFibGUgaWYgdW51c2VkLlxuICogQHR5cGUgeyFBcnJheTwhRnVuY3Rpb24+fVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pbnN0YW50aWF0ZWRTaW5nbGV0b25zXyA9IFtdO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byBsb2FkIGdvb2cubW9kdWxlcyB1c2luZyB7QGNvZGUgZXZhbH0gd2hlbiB1c2luZ1xuICogdGhlIGRlYnVnIGxvYWRlci4gIFRoaXMgcHJvdmlkZXMgYSBiZXR0ZXIgZGVidWdnaW5nIGV4cGVyaWVuY2UgYXMgdGhlXG4gKiBzb3VyY2UgaXMgdW5tb2RpZmllZCBhbmQgY2FuIGJlIGVkaXRlZCB1c2luZyBDaHJvbWUgV29ya3NwYWNlcyBvciBzaW1pbGFyLlxuICogSG93ZXZlciBpbiBzb21lIGVudmlyb25tZW50cyB0aGUgdXNlIG9mIHtAY29kZSBldmFsfSBpcyBiYW5uZWRcbiAqIHNvIHdlIHByb3ZpZGUgYW4gYWx0ZXJuYXRpdmUuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLkxPQURfTU9EVUxFX1VTSU5HX0VWQUwnLCB0cnVlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV4cG9ydHMgb2YgZ29vZy5tb2R1bGVzIHNob3VsZCBiZSBzZWFsZWQgd2hlblxuICogcG9zc2libGUuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLlNFQUxfTU9EVUxFX0VYUE9SVFMnLCBnb29nLkRFQlVHKTtcblxuXG4vKipcbiAqIFRoZSByZWdpc3RyeSBvZiBpbml0aWFsaXplZCBtb2R1bGVzOlxuICogdGhlIG1vZHVsZSBpZGVudGlmaWVyIHRvIG1vZHVsZSBleHBvcnRzIG1hcC5cbiAqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsID8+fVxuICovXG5nb29nLmxvYWRlZE1vZHVsZXNfID0ge307XG5cblxuLyoqXG4gKiBUcnVlIGlmIGdvb2cuZGVwZW5kZW5jaWVzXyBpcyBhdmFpbGFibGUuXG4gKiBAY29uc3Qge2Jvb2xlYW59XG4gKi9cbmdvb2cuREVQRU5ERU5DSUVTX0VOQUJMRUQgPSAhQ09NUElMRUQgJiYgZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSO1xuXG5cbmlmIChnb29nLkRFUEVOREVOQ0lFU19FTkFCTEVEKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBkZXBlbmRlbmNpZXMgYW5kIG90aGVyIGRhdGEgdGhhdCBpc1xuICAgKiB1c2VkIGZvciBsb2FkaW5nIHNjcmlwdHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHt7XG4gICAqICAgcGF0aElzTW9kdWxlOiAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4sXG4gICAqICAgbmFtZVRvUGF0aDogIU9iamVjdDxzdHJpbmcsIHN0cmluZz4sXG4gICAqICAgcmVxdWlyZXM6ICFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+LFxuICAgKiAgIHZpc2l0ZWQ6ICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPixcbiAgICogICB3cml0dGVuOiAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4sXG4gICAqICAgZGVmZXJyZWQ6ICFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+XG4gICAqIH19XG4gICAqL1xuICBnb29nLmRlcGVuZGVuY2llc18gPSB7XG4gICAgcGF0aElzTW9kdWxlOiB7fSwgLy8gMSB0byAxXG5cbiAgICBuYW1lVG9QYXRoOiB7fSwgLy8gMSB0byAxXG5cbiAgICByZXF1aXJlczoge30sIC8vIDEgdG8gbWFueVxuXG4gICAgLy8gVXNlZCB3aGVuIHJlc29sdmluZyBkZXBlbmRlbmNpZXMgdG8gcHJldmVudCB1cyBmcm9tIHZpc2l0aW5nIGZpbGUgdHdpY2UuXG4gICAgdmlzaXRlZDoge30sXG5cbiAgICB3cml0dGVuOiB7fSwgLy8gVXNlZCB0byBrZWVwIHRyYWNrIG9mIHNjcmlwdCBmaWxlcyB3ZSBoYXZlIHdyaXR0ZW4uXG5cbiAgICBkZWZlcnJlZDoge30gLy8gVXNlZCB0byB0cmFjayBkZWZlcnJlZCBtb2R1bGUgZXZhbHVhdGlvbnMgaW4gb2xkIElFc1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIGRldGVjdCB3aGV0aGVyIGlzIGluIHRoZSBjb250ZXh0IG9mIGFuIEhUTUwgZG9jdW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaXQgbG9va3MgbGlrZSBIVE1MIGRvY3VtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pbkh0bWxEb2N1bWVudF8gPSBmdW5jdGlvbigpIHtcbiAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICByZXR1cm4gdHlwZW9mIGRvYyAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAnd3JpdGUnIGluIGRvYzsgIC8vIFhVTERvY3VtZW50IG1pc3NlcyB3cml0ZS5cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBkZXRlY3QgdGhlIGJhc2UgcGF0aCBvZiBiYXNlLmpzIHNjcmlwdCB0aGF0IGJvb3RzdHJhcHMgQ2xvc3VyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuZmluZEJhc2VQYXRoXyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChnb29nLmlzRGVmKGdvb2cuZ2xvYmFsLkNMT1NVUkVfQkFTRV9QQVRIKSkge1xuICAgICAgZ29vZy5iYXNlUGF0aCA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfQkFTRV9QQVRIO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIWdvb2cuaW5IdG1sRG9jdW1lbnRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNjcmlwdHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NDUklQVCcpO1xuICAgIC8vIFNlYXJjaCBiYWNrd2FyZHMgc2luY2UgdGhlIGN1cnJlbnQgc2NyaXB0IGlzIGluIGFsbW9zdCBhbGwgY2FzZXMgdGhlIG9uZVxuICAgIC8vIHRoYXQgaGFzIGJhc2UuanMuXG4gICAgZm9yICh2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzY3JpcHQgPSAvKiogQHR5cGUgeyFIVE1MU2NyaXB0RWxlbWVudH0gKi8gKHNjcmlwdHNbaV0pO1xuICAgICAgdmFyIHNyYyA9IHNjcmlwdC5zcmM7XG4gICAgICB2YXIgcW1hcmsgPSBzcmMubGFzdEluZGV4T2YoJz8nKTtcbiAgICAgIHZhciBsID0gcW1hcmsgPT0gLTEgPyBzcmMubGVuZ3RoIDogcW1hcms7XG4gICAgICBpZiAoc3JjLnN1YnN0cihsIC0gNywgNykgPT0gJ2Jhc2UuanMnKSB7XG4gICAgICAgIGdvb2cuYmFzZVBhdGggPSBzcmMuc3Vic3RyKDAsIGwgLSA3KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBJbXBvcnRzIGEgc2NyaXB0IGlmLCBhbmQgb25seSBpZiwgdGhhdCBzY3JpcHQgaGFzbid0IGFscmVhZHkgYmVlbiBpbXBvcnRlZC5cbiAgICogKE11c3QgYmUgY2FsbGVkIGF0IGV4ZWN1dGlvbiB0aW1lKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNjcmlwdCBzb3VyY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3NvdXJjZVRleHQgVGhlIG9wdGlvbmFsbHkgc291cmNlIHRleHQgdG8gZXZhbHVhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaW1wb3J0U2NyaXB0XyA9IGZ1bmN0aW9uKHNyYywgb3B0X3NvdXJjZVRleHQpIHtcbiAgICB2YXIgaW1wb3J0U2NyaXB0ID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9JTVBPUlRfU0NSSVBUIHx8XG4gICAgICAgIGdvb2cud3JpdGVTY3JpcHRUYWdfO1xuICAgIGlmIChpbXBvcnRTY3JpcHQoc3JjLCBvcHRfc291cmNlVGV4dCkpIHtcbiAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy53cml0dGVuW3NyY10gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKiBAY29uc3QgQHByaXZhdGUge2Jvb2xlYW59ICovXG4gIGdvb2cuSVNfT0xEX0lFXyA9ICEhKCFnb29nLmdsb2JhbC5hdG9iICYmIGdvb2cuZ2xvYmFsLmRvY3VtZW50ICYmXG4gICAgICBnb29nLmdsb2JhbC5kb2N1bWVudC5hbGwpO1xuXG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgVVJMIGluaXRpYXRlIHJldHJpZXZhbCBhbmQgZXhlY3V0aW9uIG9mIHRoZSBtb2R1bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZSBVUkwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmltcG9ydE1vZHVsZV8gPSBmdW5jdGlvbihzcmMpIHtcbiAgICAvLyBJbiBhbiBhdHRlbXB0IHRvIGtlZXAgYnJvd3NlcnMgZnJvbSB0aW1pbmcgb3V0IGxvYWRpbmcgc2NyaXB0cyB1c2luZ1xuICAgIC8vIHN5bmNocm9ub3VzIFhIUnMsIHB1dCBlYWNoIGxvYWQgaW4gaXRzIG93biBzY3JpcHQgYmxvY2suXG4gICAgdmFyIGJvb3RzdHJhcCA9ICdnb29nLnJldHJpZXZlQW5kRXhlY01vZHVsZV8oXCInICsgc3JjICsgJ1wiKTsnO1xuXG4gICAgaWYgKGdvb2cuaW1wb3J0U2NyaXB0XygnJywgYm9vdHN0cmFwKSkge1xuICAgICAgZ29vZy5kZXBlbmRlbmNpZXNfLndyaXR0ZW5bc3JjXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqIEBwcml2YXRlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgZ29vZy5xdWV1ZWRNb2R1bGVzXyA9IFtdO1xuXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcHByb3ByaWF0ZSBtb2R1bGUgdGV4dC4gU3VpdGFibGUgdG8gaW5zZXJ0IGludG9cbiAgICogYSBzY3JpcHQgdGFnICh0aGF0IGlzIHVuZXNjYXBlZCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNVcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy53cmFwTW9kdWxlXyA9IGZ1bmN0aW9uKHNyY1VybCwgc2NyaXB0VGV4dCkge1xuICAgIGlmICghZ29vZy5MT0FEX01PRFVMRV9VU0lOR19FVkFMIHx8ICFnb29nLmlzRGVmKGdvb2cuZ2xvYmFsLkpTT04pKSB7XG4gICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICdnb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykgeycgK1xuICAgICAgICAgICdcInVzZSBzdHJpY3RcIjsnICtcbiAgICAgICAgICBzY3JpcHRUZXh0ICtcbiAgICAgICAgICAnXFxuJyArIC8vIHRlcm1pbmF0ZSBhbnkgdHJhaWxpbmcgc2luZ2xlIGxpbmUgY29tbWVudC5cbiAgICAgICAgICAnO3JldHVybiBleHBvcnRzJyArXG4gICAgICAgICAgJ30pOycgK1xuICAgICAgICAgICdcXG4vLyMgc291cmNlVVJMPScgKyBzcmNVcmwgKyAnXFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnICtcbiAgICAgICAgICAnZ29vZy5sb2FkTW9kdWxlKCcgK1xuICAgICAgICAgIGdvb2cuZ2xvYmFsLkpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBzY3JpcHRUZXh0ICsgJ1xcbi8vIyBzb3VyY2VVUkw9JyArIHNyY1VybCArICdcXG4nKSArXG4gICAgICAgICAgJyk7JztcbiAgICB9XG4gIH07XG5cbiAgLy8gT24gSUU5IGFuZCBlYXJsaWVyLCBpdCBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlXG4gIC8vIGRlZmVycmVkIG1vZHVsZSBsb2Fkcy4gSW4gbGF0ZXIgYnJvd3NlcnMsIHRoZVxuICAvLyBjb2RlIHRvIGJlIGV2YWx1YXRlZCBpcyBzaW1wbHkgaW5zZXJ0ZWQgYXMgYSBzY3JpcHRcbiAgLy8gYmxvY2sgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFRvIGV2YWwgZGVmZXJyZWRcbiAgLy8gY29kZSBhdCB0aGUgcmlnaHQgdGltZSwgd2UgcGlnZ3kgYmFjayBvbiBnb29nLnJlcXVpcmUgdG8gY2FsbFxuICAvLyBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkRGVwXy5cbiAgLy9cbiAgLy8gVGhlIGdvb2cucmVxdWlyZXMgYXJlIHVzZWQgYm90aCB0byBib290c3RyYXBcbiAgLy8gdGhlIGxvYWRpbmcgcHJvY2VzcyAod2hlbiBubyBkZXBzIGFyZSBhdmFpbGFibGUpIGFuZFxuICAvLyBkZWNsYXJlIHRoYXQgdGhleSBzaG91bGQgYmUgYXZhaWxhYmxlLlxuICAvL1xuICAvLyBIZXJlIHdlIGV2YWwgdGhlIHNvdXJjZXMsIGlmIGFsbCB0aGUgZGVwcyBhcmUgYXZhaWxhYmxlXG4gIC8vIGVpdGhlciBhbHJlYWR5IGV2YWwnZCBvciBnb29nLnJlcXVpcmUnZC4gIFRoaXMgd2lsbFxuICAvLyBiZSB0aGUgY2FzZSB3aGVuIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGhhdmUgYWxyZWFkeVxuICAvLyBiZWVuIGxvYWRlZCwgYW5kIHRoZSBkZXBlbmRlbnQgbW9kdWxlIGlzIGxvYWRlZC5cbiAgLy9cbiAgLy8gQnV0IHRoaXMgYWxvbmUgaXNuJ3Qgc3VmZmljaWVudCBiZWNhdXNlIGl0IGlzIGFsc29cbiAgLy8gbmVjZXNzYXJ5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBubyByb290XG4gIC8vIHRoYXQgaXMgbm90IGRlZmVycmVkLiAgRm9yIHRoYXQgdGhlcmUgd2UgcmVnaXN0ZXIgZm9yIGFuIGV2ZW50XG4gIC8vIGFuZCB0cmlnZ2VyIGdvb2cubG9hZFF1ZXVlZE1vZHVsZXNfIGhhbmRsZSBhbnkgcmVtYWluaW5nIGRlZmVycmVkXG4gIC8vIGV2YWx1YXRpb25zLlxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW55IHJlbWFpbmluZyBkZWZlcnJlZCBnb29nLm1vZHVsZSBldmFscy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubG9hZFF1ZXVlZE1vZHVsZXNfID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gZ29vZy5xdWV1ZWRNb2R1bGVzXy5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgdmFyIHF1ZXVlID0gZ29vZy5xdWV1ZWRNb2R1bGVzXztcbiAgICAgIGdvb2cucXVldWVkTW9kdWxlc18gPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXVlW2ldO1xuICAgICAgICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkUGF0aF8ocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEV2YWwgdGhlIG5hbWVkIG1vZHVsZSBpZiBpdHMgZGVwZW5kZW5jaWVzIGFyZVxuICAgKiBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgdG8gbG9hZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWREZXBfID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChnb29nLmlzRGVmZXJyZWRNb2R1bGVfKG5hbWUpICYmXG4gICAgICAgIGdvb2cuYWxsRGVwc0FyZUF2YWlsYWJsZV8obmFtZSkpIHtcbiAgICAgIHZhciBwYXRoID0gZ29vZy5nZXRQYXRoRnJvbURlcHNfKG5hbWUpO1xuICAgICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZFBhdGhfKGdvb2cuYmFzZVBhdGggKyBwYXRoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgcmVwcmVzZW50cyBhXG4gICAqICAgICBtb2R1bGUgd2hvc2UgZXZhbHVhdGlvbiBoYXMgYmVlbiBkZWZlcnJlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaXNEZWZlcnJlZE1vZHVsZV8gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHBhdGggPSBnb29nLmdldFBhdGhGcm9tRGVwc18obmFtZSk7XG4gICAgaWYgKHBhdGggJiYgZ29vZy5kZXBlbmRlbmNpZXNfLnBhdGhJc01vZHVsZVtwYXRoXSkge1xuICAgICAgdmFyIGFic3BhdGggPSBnb29nLmJhc2VQYXRoICsgcGF0aDtcbiAgICAgIHJldHVybiAoYWJzcGF0aCkgaW4gZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgcmVwcmVzZW50cyBhXG4gICAqICAgICBtb2R1bGUgd2hvc2UgZGVjbGFyZWQgZGVwZW5kZW5jaWVzIGhhdmUgYWxsIGJlZW4gbG9hZGVkXG4gICAqICAgICAoZXZhbCdkIG9yIGEgZGVmZXJyZWQgbW9kdWxlIGxvYWQpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmFsbERlcHNBcmVBdmFpbGFibGVfID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBwYXRoID0gZ29vZy5nZXRQYXRoRnJvbURlcHNfKG5hbWUpO1xuICAgIGlmIChwYXRoICYmIChwYXRoIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5yZXF1aXJlcykpIHtcbiAgICAgIGZvciAodmFyIHJlcXVpcmVOYW1lIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5yZXF1aXJlc1twYXRoXSkge1xuICAgICAgICBpZiAoIWdvb2cuaXNQcm92aWRlZF8ocmVxdWlyZU5hbWUpICYmXG4gICAgICAgICAgICAhZ29vZy5pc0RlZmVycmVkTW9kdWxlXyhyZXF1aXJlTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFic3BhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWRQYXRoXyA9IGZ1bmN0aW9uKGFic3BhdGgpIHtcbiAgICBpZiAoYWJzcGF0aCBpbiBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWQpIHtcbiAgICAgIHZhciBzcmMgPSBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWRbYWJzcGF0aF07XG4gICAgICBkZWxldGUgZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkW2Fic3BhdGhdO1xuICAgICAgZ29vZy5nbG9iYWxFdmFsKHNyYyk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6P3xzdHJpbmd9IG1vZHVsZURlZiBUaGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAqL1xuICBnb29nLmxvYWRNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGVEZWYpIHtcbiAgICAvLyBOT1RFOiB3ZSBhbGxvdyBmdW5jdGlvbiBkZWZpbml0aW9ucyB0byBiZSBlaXRoZXIgaW4gdGhlIGZyb21cbiAgICAvLyBvZiBhIHN0cmluZyB0byBldmFsICh3aGljaCBrZWVwcyB0aGUgb3JpZ2luYWwgc291cmNlIGludGFjdCkgb3JcbiAgICAvLyBpbiBhIGV2YWwgZm9yYmlkZGVuIGVudmlyb25tZW50IChDU1ApIHdlIGFsbG93IGEgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIC8vIHdoaWNoIGluIGl0cyBib2R5IG11c3QgY2FsbCB7QGNvZGUgZ29vZy5tb2R1bGV9LCBhbmQgcmV0dXJuIHRoZSBleHBvcnRzXG4gICAgLy8gb2YgdGhlIG1vZHVsZS5cbiAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfO1xuICAgIHRyeSB7XG4gICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IHttb2R1bGVOYW1lOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV4cG9ydHM7XG4gICAgICBpZiAoZ29vZy5pc0Z1bmN0aW9uKG1vZHVsZURlZikpIHtcbiAgICAgICAgZXhwb3J0cyA9IG1vZHVsZURlZi5jYWxsKGdvb2cuZ2xvYmFsLCB7fSk7XG4gICAgICB9IGVsc2UgaWYgKGdvb2cuaXNTdHJpbmcobW9kdWxlRGVmKSkge1xuICAgICAgICBleHBvcnRzID0gZ29vZy5sb2FkTW9kdWxlRnJvbVNvdXJjZV8uY2FsbChnb29nLmdsb2JhbCwgbW9kdWxlRGVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG1vZHVsZSBkZWZpbml0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2R1bGVOYW1lID0gZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZTtcbiAgICAgIGlmICghZ29vZy5pc1N0cmluZyhtb2R1bGVOYW1lKSB8fCAhbW9kdWxlTmFtZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBtb2R1bGUgbmFtZSBcXFwiJyArIG1vZHVsZU5hbWUgKyAnXFxcIicpO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBzZWFsIGxlZ2FjeSBuYW1lc3BhY2VzIGFzIHRoZXkgbWF5IGJlIHVzZXMgYXMgYSBwYXJlbnQgb2ZcbiAgICAgIC8vIGFub3RoZXIgbmFtZXNwYWNlXG4gICAgICBpZiAoZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8uZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSkge1xuICAgICAgICBnb29nLmNvbnN0cnVjdE5hbWVzcGFjZV8obW9kdWxlTmFtZSwgZXhwb3J0cyk7XG4gICAgICB9IGVsc2UgaWYgKGdvb2cuU0VBTF9NT0RVTEVfRVhQT1JUUyAmJiBPYmplY3Quc2VhbCkge1xuICAgICAgICBPYmplY3Quc2VhbChleHBvcnRzKTtcbiAgICAgIH1cblxuICAgICAgZ29vZy5sb2FkZWRNb2R1bGVzX1ttb2R1bGVOYW1lXSA9IGV4cG9ydHM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gcHJldmlvdXNTdGF0ZTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQHByaXZhdGUgQGNvbnN0IHtmdW5jdGlvbihzdHJpbmcpOj99XG4gICAqIEBzdXBwcmVzcyB7bmV3Q2hlY2tUeXBlc31cbiAgICovXG4gIGdvb2cubG9hZE1vZHVsZUZyb21Tb3VyY2VfID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gTk9URTogd2UgYXZvaWQgZGVjbGFyaW5nIHBhcmFtZXRlcnMgb3IgbG9jYWwgdmFyaWFibGVzIGhlcmUgdG8gYXZvaWRcbiAgICAvLyBtYXNraW5nIGdsb2JhbHMgb3IgbGVha2luZyB2YWx1ZXMgaW50byB0aGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgZXZhbChhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIG5ldyBzY3JpcHQgcG9pbnRpbmcgdG8ge0Bjb2RlIHNyY30gZGlyZWN0bHkgaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgQ1NQLWNvbXBsaWFudC4gQHNlZSBnb29nLmFwcGVuZFNjcmlwdFNyY05vZGVfIGZvclxuICAgKiB0aGUgZmFsbGJhY2sgbWVjaGFuaXNtLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzY3JpcHQgVVJMLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy53cml0ZVNjcmlwdFNyY05vZGVfID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgZ29vZy5nbG9iYWwuZG9jdW1lbnQud3JpdGUoXG4gICAgICAgICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCInICsgc3JjICsgJ1wiPjwvJyArICdzY3JpcHQ+Jyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyBzY3JpcHQgbm9kZSB0byB0aGUgRE9NIHVzaW5nIGEgQ1NQLWNvbXBsaWFudCBtZWNoYW5pc20uIFRoaXNcbiAgICogbWV0aG9kIGV4aXN0cyBhcyBhIGZhbGxiYWNrIGZvciBkb2N1bWVudC53cml0ZSAod2hpY2ggaXMgbm90IGFsbG93ZWQgaW4gYVxuICAgKiBzdHJpY3QgQ1NQIGNvbnRleHQsIGUuZy4sIENocm9tZSBhcHBzKS5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGFuYWxvZ291cyB0byB1c2luZyBkb2N1bWVudC53cml0ZSB0byBpbnNlcnQgYVxuICAgKiA8c2NyaXB0PiB0YWc7IHNwZWNpZmljYWxseSwgdGhlIHVzZXIgYWdlbnQgd2lsbCBleGVjdXRlIGEgc2NyaXB0IGFkZGVkIGJ5XG4gICAqIGRvY3VtZW50LndyaXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50IHNjcmlwdCBibG9jayBmaW5pc2hlc1xuICAgKiBleGVjdXRpbmcsIHdoZXJlYXMgdGhlIERPTS1hcHBlbmRlZCBzY3JpcHQgbm9kZSB3aWxsIG5vdCBiZSBleGVjdXRlZCB1bnRpbFxuICAgKiB0aGUgZW50aXJlIGRvY3VtZW50IGlzIHBhcnNlZCBhbmQgZXhlY3V0ZWQuIFRoYXQgaXMgdG8gc2F5LCB0aGlzIHNjcmlwdCBpc1xuICAgKiBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBzY3JpcHQgZXhlY3V0aW9uIHF1ZXVlLlxuICAgKlxuICAgKiBUaGUgcGFnZSBtdXN0IG5vdCBhdHRlbXB0IHRvIGNhbGwgZ29vZy5yZXF1aXJlZCBlbnRpdGllcyB1bnRpbCBhZnRlciB0aGVcbiAgICogZG9jdW1lbnQgaGFzIGxvYWRlZCwgZS5nLiwgaW4gb3IgYWZ0ZXIgdGhlIHdpbmRvdy5vbmxvYWQgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIHNjcmlwdCBVUkwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmFwcGVuZFNjcmlwdFNyY05vZGVfID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNjcmlwdEVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdEVsLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHRFbC5zcmMgPSBzcmM7XG4gICAgc2NyaXB0RWwuZGVmZXIgPSBmYWxzZTtcbiAgICBzY3JpcHRFbC5hc3luYyA9IGZhbHNlO1xuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgaW1wb3J0IGZ1bmN0aW9uLiBXcml0ZXMgYSBzY3JpcHQgdGFnIHRvXG4gICAqIGltcG9ydCB0aGUgc2NyaXB0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzY3JpcHQgdXJsLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zb3VyY2VUZXh0IFRoZSBvcHRpb25hbGx5IHNvdXJjZSB0ZXh0IHRvIGV2YWx1YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNjcmlwdCB3YXMgaW1wb3J0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cud3JpdGVTY3JpcHRUYWdfID0gZnVuY3Rpb24oc3JjLCBvcHRfc291cmNlVGV4dCkge1xuICAgIGlmIChnb29nLmluSHRtbERvY3VtZW50XygpKSB7XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuXG4gICAgICAvLyBJZiB0aGUgdXNlciB0cmllcyB0byByZXF1aXJlIGEgbmV3IHN5bWJvbCBhZnRlciBkb2N1bWVudCBsb2FkLFxuICAgICAgLy8gc29tZXRoaW5nIGhhcyBnb25lIHRlcnJpYmx5IHdyb25nLiBEb2luZyBhIGRvY3VtZW50LndyaXRlIHdvdWxkXG4gICAgICAvLyB3aXBlIG91dCB0aGUgcGFnZS4gVGhpcyBkb2VzIG5vdCBhcHBseSB0byB0aGUgQ1NQLWNvbXBsaWFudCBtZXRob2RcbiAgICAgIC8vIG9mIHdyaXRpbmcgc2NyaXB0IHRhZ3MuXG4gICAgICBpZiAoIWdvb2cuRU5BQkxFX0NIUk9NRV9BUFBfU0FGRV9TQ1JJUFRfTE9BRElORyAmJlxuICAgICAgICAgIGRvYy5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgLy8gQ2VydGFpbiB0ZXN0IGZyYW1ld29ya3MgbG9hZCBiYXNlLmpzIG11bHRpcGxlIHRpbWVzLCB3aGljaCB0cmllc1xuICAgICAgICAvLyB0byB3cml0ZSBkZXBzLmpzIGVhY2ggdGltZS4gSWYgdGhhdCBoYXBwZW5zLCBqdXN0IGZhaWwgc2lsZW50bHkuXG4gICAgICAgIC8vIFRoZXNlIGZyYW1ld29ya3Mgd2lwZSB0aGUgcGFnZSBiZXR3ZWVuIGVhY2ggbG9hZCBvZiBiYXNlLmpzLCBzbyB0aGlzXG4gICAgICAgIC8vIGlzIE9LLlxuICAgICAgICB2YXIgaXNEZXBzID0gL1xcYmRlcHMuanMkLy50ZXN0KHNyYyk7XG4gICAgICAgIGlmIChpc0RlcHMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBcIicgKyBzcmMgKyAnXCIgYWZ0ZXIgZG9jdW1lbnQgbG9hZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc09sZElFID0gZ29vZy5JU19PTERfSUVfO1xuXG4gICAgICBpZiAob3B0X3NvdXJjZVRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzT2xkSUUpIHtcbiAgICAgICAgICBpZiAoZ29vZy5FTkFCTEVfQ0hST01FX0FQUF9TQUZFX1NDUklQVF9MT0FESU5HKSB7XG4gICAgICAgICAgICBnb29nLmFwcGVuZFNjcmlwdFNyY05vZGVfKHNyYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdvb2cud3JpdGVTY3JpcHRTcmNOb2RlXyhzcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBcIiBvbnJlYWR5c3RhdGVjaGFuZ2U9J2dvb2cub25TY3JpcHRMb2FkXyh0aGlzLCBcIiArXG4gICAgICAgICAgICAgICsrZ29vZy5sYXN0Tm9uTW9kdWxlU2NyaXB0SW5kZXhfICsgXCIpJyBcIjtcbiAgICAgICAgICBkb2Mud3JpdGUoXG4gICAgICAgICAgICAgICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCInICtcbiAgICAgICAgICAgICAgICAgIHNyYyArICdcIicgKyBzdGF0ZSArICc+PC8nICsgJ3NjcmlwdD4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLndyaXRlKFxuICAgICAgICAgICAgJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPicgK1xuICAgICAgICAgICAgb3B0X3NvdXJjZVRleHQgK1xuICAgICAgICAgICAgJzwvJyArICdzY3JpcHQ+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPSAwO1xuXG5cbiAgLyoqXG4gICAqIEEgcmVhZHlzdGF0ZWNoYW5nZSBoYW5kbGVyIGZvciBsZWdhY3kgSUVcbiAgICogQHBhcmFtIHshSFRNTFNjcmlwdEVsZW1lbnR9IHNjcmlwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NyaXB0SW5kZXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cub25TY3JpcHRMb2FkXyA9IGZ1bmN0aW9uKHNjcmlwdCwgc2NyaXB0SW5kZXgpIHtcbiAgICAvLyBmb3Igbm93IGxvYWQgdGhlIG1vZHVsZXMgd2hlbiB3ZSByZWFjaCB0aGUgbGFzdCBzY3JpcHQsXG4gICAgLy8gbGF0ZXIgYWxsb3cgbW9yZSBpbnRlci1taW5nbGluZy5cbiAgICBpZiAoc2NyaXB0LnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPT0gc2NyaXB0SW5kZXgpIHtcbiAgICAgIGdvb2cubG9hZFF1ZXVlZE1vZHVsZXNfKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBkZXBlbmRlbmNpZXMgYmFzZWQgb24gdGhlIGRlcGVuZGVuY2llcyBhZGRlZCB1c2luZyBhZGREZXBlbmRlbmN5XG4gICAqIGFuZCBjYWxscyBpbXBvcnRTY3JpcHRfIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFRvTG9hZCBUaGUgcGF0aCBmcm9tIHdoaWNoIHRvIHN0YXJ0IGRpc2NvdmVyaW5nXG4gICAqICAgICBkZXBlbmRlbmNpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLndyaXRlU2NyaXB0c18gPSBmdW5jdGlvbihwYXRoVG9Mb2FkKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gVGhlIHNjcmlwdHMgd2UgbmVlZCB0byB3cml0ZSB0aGlzIHRpbWUuICovXG4gICAgdmFyIHNjcmlwdHMgPSBbXTtcbiAgICB2YXIgc2VlblNjcmlwdCA9IHt9O1xuICAgIHZhciBkZXBzID0gZ29vZy5kZXBlbmRlbmNpZXNfO1xuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICovXG4gICAgZnVuY3Rpb24gdmlzaXROb2RlKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoIGluIGRlcHMud3JpdHRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgb25lLiBXZSBjYW4gZ2V0IGhlcmUgaWYgd2UgaGF2ZSBjeWNsaWNcbiAgICAgIC8vIGRlcGVuZGVuY2llcy5cbiAgICAgIGlmIChwYXRoIGluIGRlcHMudmlzaXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlcHMudmlzaXRlZFtwYXRoXSA9IHRydWU7XG5cbiAgICAgIGlmIChwYXRoIGluIGRlcHMucmVxdWlyZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcmVxdWlyZU5hbWUgaW4gZGVwcy5yZXF1aXJlc1twYXRoXSkge1xuICAgICAgICAgIC8vIElmIHRoZSByZXF1aXJlZCBuYW1lIGlzIGRlZmluZWQsIHdlIGFzc3VtZSB0aGF0IGl0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gYm9vdHN0cmFwcGVkIGJ5IG90aGVyIG1lYW5zLlxuICAgICAgICAgIGlmICghZ29vZy5pc1Byb3ZpZGVkXyhyZXF1aXJlTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlTmFtZSBpbiBkZXBzLm5hbWVUb1BhdGgpIHtcbiAgICAgICAgICAgICAgdmlzaXROb2RlKGRlcHMubmFtZVRvUGF0aFtyZXF1aXJlTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuZGVmaW5lZCBuYW1lVG9QYXRoIGZvciAnICsgcmVxdWlyZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIShwYXRoIGluIHNlZW5TY3JpcHQpKSB7XG4gICAgICAgIHNlZW5TY3JpcHRbcGF0aF0gPSB0cnVlO1xuICAgICAgICBzY3JpcHRzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXROb2RlKHBhdGhUb0xvYWQpO1xuXG4gICAgLy8gcmVjb3JkIHRoYXQgd2UgYXJlIGdvaW5nIHRvIGxvYWQgYWxsIHRoZXNlIHNjcmlwdHMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGF0aCA9IHNjcmlwdHNbaV07XG4gICAgICBnb29nLmRlcGVuZGVuY2llc18ud3JpdHRlbltwYXRoXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBtb2R1bGUgaXMgbG9hZGVkIHN5bmNocm9ub3VzbHkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgLy8gY2xlYXIgdGhlIGN1cnJlbnQgaW5Nb2R1bGVMb2FkZXIgdmFsdWUsIGFuZCByZXN0b3JlIGl0IHdoZW4gd2UgYXJlXG4gICAgLy8gZG9uZSBsb2FkaW5nIHRoZSBjdXJyZW50IFwicmVxdWlyZXNcIi5cbiAgICB2YXIgbW9kdWxlU3RhdGUgPSBnb29nLm1vZHVsZUxvYWRlclN0YXRlXztcbiAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXRoID0gc2NyaXB0c1tpXTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGlmICghZGVwcy5wYXRoSXNNb2R1bGVbcGF0aF0pIHtcbiAgICAgICAgICBnb29nLmltcG9ydFNjcmlwdF8oZ29vZy5iYXNlUGF0aCArIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvb2cuaW1wb3J0TW9kdWxlXyhnb29nLmJhc2VQYXRoICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gbW9kdWxlU3RhdGU7XG4gICAgICAgIHRocm93IEVycm9yKCdVbmRlZmluZWQgc2NyaXB0IGlucHV0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSB0aGUgY3VycmVudCBcIm1vZHVsZSBsb2FkaW5nIHN0YXRlXCJcbiAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG1vZHVsZVN0YXRlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIExvb2tzIGF0IHRoZSBkZXBlbmRlbmN5IHJ1bGVzIGFuZCB0cmllcyB0byBkZXRlcm1pbmUgdGhlIHNjcmlwdCBmaWxlIHRoYXRcbiAgICogZnVsZmlsbHMgYSBwYXJ0aWN1bGFyIHJ1bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIEluIHRoZSBmb3JtIGdvb2cubmFtZXNwYWNlLkNsYXNzIG9yIHByb2plY3Quc2NyaXB0LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBVcmwgY29ycmVzcG9uZGluZyB0byB0aGUgcnVsZSwgb3IgbnVsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuZ2V0UGF0aEZyb21EZXBzXyA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICBpZiAocnVsZSBpbiBnb29nLmRlcGVuZGVuY2llc18ubmFtZVRvUGF0aCkge1xuICAgICAgcmV0dXJuIGdvb2cuZGVwZW5kZW5jaWVzXy5uYW1lVG9QYXRoW3J1bGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZ29vZy5maW5kQmFzZVBhdGhfKCk7XG5cbiAgLy8gQWxsb3cgcHJvamVjdHMgdG8gbWFuYWdlIHRoZSBkZXBzIGZpbGVzIHRoZW1zZWx2ZXMuXG4gIGlmICghZ29vZy5nbG9iYWwuQ0xPU1VSRV9OT19ERVBTKSB7XG4gICAgZ29vZy5pbXBvcnRTY3JpcHRfKGdvb2cuYmFzZVBhdGggKyAnZGVwcy5qcycpO1xuICB9XG59XG5cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBmaWxlIHBhdGggYnkgcmVtb3ZpbmcgcmVkdW5kYW50IFwiLi5cIiBhbmQgZXh0cmFuZW91cyBcIi5cIiBmaWxlXG4gKiBwYXRoIGNvbXBvbmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5ub3JtYWxpemVQYXRoXyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBjb21wb25lbnRzLmxlbmd0aCkge1xuICAgIGlmIChjb21wb25lbnRzW2ldID09ICcuJykge1xuICAgICAgY29tcG9uZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChpICYmIGNvbXBvbmVudHNbaV0gPT0gJy4uJyAmJlxuICAgICAgICBjb21wb25lbnRzW2kgLSAxXSAmJiBjb21wb25lbnRzW2kgLSAxXSAhPSAnLi4nKSB7XG4gICAgICBjb21wb25lbnRzLnNwbGljZSgtLWksIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzLmpvaW4oJy8nKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkcyBmaWxlIGJ5IHN5bmNocm9ub3VzIFhIUi4gU2hvdWxkIG5vdCBiZSB1c2VkIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTb3VyY2UgVVJMLlxuICogQHJldHVybiB7c3RyaW5nfSBGaWxlIGNvbnRlbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sb2FkRmlsZVN5bmNfID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmIChnb29nLmdsb2JhbC5DTE9TVVJFX0xPQURfRklMRV9TWU5DKSB7XG4gICAgcmV0dXJuIGdvb2cuZ2xvYmFsLkNMT1NVUkVfTE9BRF9GSUxFX1NZTkMoc3JjKTtcbiAgfSBlbHNlIHtcbiAgICAvKiogQHR5cGUge1hNTEh0dHBSZXF1ZXN0fSAqL1xuICAgIHZhciB4aHIgPSBuZXcgZ29vZy5nbG9iYWxbJ1hNTEh0dHBSZXF1ZXN0J10oKTtcbiAgICB4aHIub3BlbignZ2V0Jywgc3JjLCBmYWxzZSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHJpZXZlIGFuZCBleGVjdXRlIGEgbW9kdWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTY3JpcHQgc291cmNlIFVSTC5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cucmV0cmlldmVBbmRFeGVjTW9kdWxlXyA9IGZ1bmN0aW9uKHNyYykge1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgLy8gVGhlIGZ1bGwgYnV0IG5vbi1jYW5vbmljYWxpemVkIFVSTCBmb3IgbGF0ZXIgdXNlLlxuICAgIHZhciBvcmlnaW5hbFBhdGggPSBzcmM7XG4gICAgLy8gQ2Fub25pY2FsaXplIHRoZSBwYXRoLCByZW1vdmluZyBhbnkgLy4vIG9yIC8uLi8gc2luY2UgQ2hyb21lJ3MgZGVidWdnaW5nXG4gICAgLy8gY29uc29sZSBkb2Vzbid0IGF1dG8tY2Fub25pY2FsaXplIFhIUiBsb2FkcyBhcyBpdCBkb2VzIDxzY3JpcHQ+IHNyY3MuXG4gICAgc3JjID0gZ29vZy5ub3JtYWxpemVQYXRoXyhzcmMpO1xuXG4gICAgdmFyIGltcG9ydFNjcmlwdCA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfSU1QT1JUX1NDUklQVCB8fFxuICAgICAgICBnb29nLndyaXRlU2NyaXB0VGFnXztcblxuICAgIHZhciBzY3JpcHRUZXh0ID0gZ29vZy5sb2FkRmlsZVN5bmNfKHNyYyk7XG5cbiAgICBpZiAoc2NyaXB0VGV4dCAhPSBudWxsKSB7XG4gICAgICB2YXIgZXhlY01vZHVsZVNjcmlwdCA9IGdvb2cud3JhcE1vZHVsZV8oc3JjLCBzY3JpcHRUZXh0KTtcbiAgICAgIHZhciBpc09sZElFID0gZ29vZy5JU19PTERfSUVfO1xuICAgICAgaWYgKGlzT2xkSUUpIHtcbiAgICAgICAgZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkW29yaWdpbmFsUGF0aF0gPSBleGVjTW9kdWxlU2NyaXB0O1xuICAgICAgICBnb29nLnF1ZXVlZE1vZHVsZXNfLnB1c2gob3JpZ2luYWxQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltcG9ydFNjcmlwdChzcmMsIGV4ZWNNb2R1bGVTY3JpcHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvYWQgb2YgJyArIHNyYyArICdmYWlsZWQnKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExhbmd1YWdlIEVuaGFuY2VtZW50c1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vKipcbiAqIFRoaXMgaXMgYSBcImZpeGVkXCIgdmVyc2lvbiBvZiB0aGUgdHlwZW9mIG9wZXJhdG9yLiAgSXQgZGlmZmVycyBmcm9tIHRoZSB0eXBlb2ZcbiAqIG9wZXJhdG9yIGluIHN1Y2ggYSB3YXkgdGhhdCBudWxsIHJldHVybnMgJ251bGwnIGFuZCBhcnJheXMgcmV0dXJuICdhcnJheScuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBnZXQgdGhlIHR5cGUgb2YuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICovXG5nb29nLnR5cGVPZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBzID0gdHlwZW9mIHZhbHVlO1xuICBpZiAocyA9PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgLy8gQ2hlY2sgdGhlc2UgZmlyc3QsIHNvIHdlIGNhbiBhdm9pZCBjYWxsaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgaWZcbiAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgLy9cbiAgICAgIC8vIElFIGltcHJvcGVybHkgbWFyc2hhbHMgdHllcG9mIGFjcm9zcyBleGVjdXRpb24gY29udGV4dHMsIGJ1dCBhXG4gICAgICAvLyBjcm9zcy1jb250ZXh0IG9iamVjdCB3aWxsIHN0aWxsIHJldHVybiBmYWxzZSBmb3IgXCJpbnN0YW5jZW9mIE9iamVjdFwiLlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICAvLyBIQUNLOiBJbiBvcmRlciB0byB1c2UgYW4gT2JqZWN0IHByb3RvdHlwZSBtZXRob2Qgb24gdGhlIGFyYml0cmFyeVxuICAgICAgLy8gICB2YWx1ZSwgdGhlIGNvbXBpbGVyIHJlcXVpcmVzIHRoZSB2YWx1ZSBiZSBjYXN0IHRvIHR5cGUgT2JqZWN0LFxuICAgICAgLy8gICBldmVuIHRob3VnaCB0aGUgRUNNQSBzcGVjIGV4cGxpY2l0bHkgYWxsb3dzIGl0LlxuICAgICAgdmFyIGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChcbiAgICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKHZhbHVlKSk7XG4gICAgICAvLyBJbiBGaXJlZm94IDMuNiwgYXR0ZW1wdGluZyB0byBhY2Nlc3MgaWZyYW1lIHdpbmRvdyBvYmplY3RzJyBsZW5ndGhcbiAgICAgIC8vIHByb3BlcnR5IHRocm93cyBhbiBOU19FUlJPUl9GQUlMVVJFLCBzbyB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSBpdFxuICAgICAgLy8gaGVyZS5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjYW5ub3QgYWx3YXlzIHVzZSBjb25zdHJ1Y3RvciA9PSBBcnJheSBvciBpbnN0YW5jZW9mIEFycmF5IGJlY2F1c2VcbiAgICAgIC8vIGRpZmZlcmVudCBmcmFtZXMgaGF2ZSBkaWZmZXJlbnQgQXJyYXkgb2JqZWN0cy4gSW4gSUU2LCBpZiB0aGUgaWZyYW1lXG4gICAgICAvLyB3aGVyZSB0aGUgYXJyYXkgd2FzIGNyZWF0ZWQgaXMgZGVzdHJveWVkLCB0aGUgYXJyYXkgbG9zZXMgaXRzXG4gICAgICAvLyBwcm90b3R5cGUuIFRoZW4gZGVyZWZlcmVuY2luZyB2YWwuc3BsaWNlIGhlcmUgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgc29cbiAgICAgIC8vIHdlIGNhbid0IHVzZSBnb29nLmlzRnVuY3Rpb24uIENhbGxpbmcgdHlwZW9mIGRpcmVjdGx5IHJldHVybnMgJ3Vua25vd24nXG4gICAgICAvLyBzbyB0aGF0IHdpbGwgd29yay4gSW4gdGhpcyBjYXNlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlIGFuZFxuICAgICAgLy8gbW9zdCBhcnJheSBmdW5jdGlvbnMgd2lsbCBzdGlsbCB3b3JrIGJlY2F1c2UgdGhlIGFycmF5IGlzIHN0aWxsXG4gICAgICAvLyBhcnJheS1saWtlIChzdXBwb3J0cyBsZW5ndGggYW5kIFtdKSBldmVuIHRob3VnaCBpdCBoYXMgbG9zdCBpdHNcbiAgICAgIC8vIHByb3RvdHlwZS5cbiAgICAgIC8vIE1hcmsgTWlsbGVyIG5vdGljZWQgdGhhdCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAvLyBhbGxvd3MgYWNjZXNzIHRvIHRoZSB1bmZvcmdlYWJsZSBbW0NsYXNzXV0gcHJvcGVydHkuXG4gICAgICAvLyAgMTUuMi40LjIgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoIClcbiAgICAgIC8vICBXaGVuIHRoZSB0b1N0cmluZyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgIC8vICAgICAgMS4gR2V0IHRoZSBbW0NsYXNzXV0gcHJvcGVydHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICAvLyAgICAgIDIuIENvbXB1dGUgYSBzdHJpbmcgdmFsdWUgYnkgY29uY2F0ZW5hdGluZyB0aGUgdGhyZWUgc3RyaW5nc1xuICAgICAgLy8gICAgICAgICBcIltvYmplY3QgXCIsIFJlc3VsdCgxKSwgYW5kIFwiXVwiLlxuICAgICAgLy8gICAgICAzLiBSZXR1cm4gUmVzdWx0KDIpLlxuICAgICAgLy8gYW5kIHRoaXMgYmVoYXZpb3Igc3Vydml2ZXMgdGhlIGRlc3RydWN0aW9uIG9mIHRoZSBleGVjdXRpb24gY29udGV4dC5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScgfHxcbiAgICAgICAgICAgLy8gSW4gSUUgYWxsIG5vbiB2YWx1ZSB0eXBlcyBhcmUgd3JhcHBlZCBhcyBvYmplY3RzIGFjcm9zcyB3aW5kb3dcbiAgICAgICAgICAgLy8gYm91bmRhcmllcyAobm90IGlmcmFtZSB0aG91Z2gpIHNvIHdlIGhhdmUgdG8gZG8gb2JqZWN0IGRldGVjdGlvblxuICAgICAgICAgICAvLyBmb3IgdGhpcyBlZGdlIGNhc2UuXG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgdHlwZW9mIHZhbHVlLnNwbGljZSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICB0eXBlb2YgdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIXZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdzcGxpY2UnKVxuXG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgIH1cbiAgICAgIC8vIEhBQ0s6IFRoZXJlIGlzIHN0aWxsIGFuIGFycmF5IGNhc2UgdGhhdCBmYWlscy5cbiAgICAgIC8vICAgICBmdW5jdGlvbiBBcnJheUltcG9zdG9yKCkge31cbiAgICAgIC8vICAgICBBcnJheUltcG9zdG9yLnByb3RvdHlwZSA9IFtdO1xuICAgICAgLy8gICAgIHZhciBpbXBvc3RvciA9IG5ldyBBcnJheUltcG9zdG9yO1xuICAgICAgLy8gdGhpcyBjYW4gYmUgZml4ZWQgYnkgZ2V0dGluZyByaWQgb2YgdGhlIGZhc3QgcGF0aFxuICAgICAgLy8gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIGFuZCBzb2xlbHkgcmVseWluZyBvblxuICAgICAgLy8gKHZhbHVlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcudmFsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAvLyBidXQgdGhhdCB3b3VsZCByZXF1aXJlIG1hbnkgbW9yZSBmdW5jdGlvbiBjYWxscyBhbmQgaXMgbm90IHdhcnJhbnRlZFxuICAgICAgLy8gdW5sZXNzIGNsb3N1cmUgY29kZSBpcyByZWNlaXZpbmcgb2JqZWN0cyBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzLlxuXG4gICAgICAvLyBJRSBpbiBjcm9zcy13aW5kb3cgY2FsbHMgZG9lcyBub3QgY29ycmVjdGx5IG1hcnNoYWwgdGhlIGZ1bmN0aW9uIHR5cGVcbiAgICAgIC8vIChpdCBhcHBlYXJzIGp1c3QgYXMgYW4gb2JqZWN0KSBzbyB3ZSBjYW5ub3QgdXNlIGp1c3QgdHlwZW9mIHZhbCA9PVxuICAgICAgLy8gJ2Z1bmN0aW9uJy4gSG93ZXZlciwgaWYgdGhlIG9iamVjdCBoYXMgYSBjYWxsIHByb3BlcnR5LCBpdCBpcyBhXG4gICAgICAvLyBmdW5jdGlvbi5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUuY2FsbCAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICF2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnY2FsbCcpKSkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHMgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuY2FsbCA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIFNhZmFyaSB0eXBlb2Ygbm9kZUxpc3QgcmV0dXJucyAnZnVuY3Rpb24nLCBhbmQgb24gRmlyZWZveCB0eXBlb2ZcbiAgICAvLyBiZWhhdmVzIHNpbWlsYXJseSBmb3IgSFRNTHtBcHBsZXQsRW1iZWQsT2JqZWN0fSwgRWxlbWVudHMgYW5kIFJlZ0V4cHMuIFdlXG4gICAgLy8gd291bGQgbGlrZSB0byByZXR1cm4gb2JqZWN0IGZvciB0aG9zZSBhbmQgd2UgY2FuIGRldGVjdCBhbiBpbnZhbGlkXG4gICAgLy8gZnVuY3Rpb24gYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgZnVuY3Rpb24gb2JqZWN0IGhhcyBhIGNhbGwgbWV0aG9kLlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgbnVsbC5cbiAqL1xuZ29vZy5pc051bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuICovXG5nb29nLmlzRGVmQW5kTm90TnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAvLyBOb3RlIHRoYXQgdW5kZWZpbmVkID09IG51bGwuXG4gIHJldHVybiB2YWwgIT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBhcnJheS5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIGFycmF5LlxuICovXG5nb29nLmlzQXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIGdvb2cudHlwZU9mKHZhbCkgPT0gJ2FycmF5Jztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGFuIGFycmF5LiBUbyBxdWFsaWZ5IGFzIGFycmF5IGxpa2VcbiAqIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSBlaXRoZXIgYSBOb2RlTGlzdCBvciBhbiBvYmplY3Qgd2l0aCBhIE51bWJlciBsZW5ndGhcbiAqIHByb3BlcnR5LiBBcyBhIHNwZWNpYWwgY2FzZSwgYSBmdW5jdGlvbiB2YWx1ZSBpcyBub3QgYXJyYXkgbGlrZSwgYmVjYXVzZSBpdHNcbiAqIGxlbmd0aCBwcm9wZXJ0eSBpcyBmaXhlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZXhwZWN0ZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gYXJyYXkuXG4gKi9cbmdvb2cuaXNBcnJheUxpa2UgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHR5cGUgPSBnb29nLnR5cGVPZih2YWwpO1xuICAvLyBXZSBkbyBub3QgdXNlIGdvb2cuaXNPYmplY3QgaGVyZSBpbiBvcmRlciB0byBleGNsdWRlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgcmV0dXJuIHR5cGUgPT0gJ2FycmF5JyB8fCB0eXBlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSBEYXRlLiBUbyBxdWFsaWZ5IGFzIERhdGUtbGlrZSB0aGVcbiAqIHZhbHVlIG5lZWRzIHRvIGJlIGFuIG9iamVjdCBhbmQgaGF2ZSBhIGdldEZ1bGxZZWFyKCkgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGxpa2UgYSBEYXRlLlxuICovXG5nb29nLmlzRGF0ZUxpa2UgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIGdvb2cuaXNPYmplY3QodmFsKSAmJiB0eXBlb2YgdmFsLmdldEZ1bGxZZWFyID09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIHN0cmluZy5cbiAqL1xuZ29vZy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnc3RyaW5nJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5nb29nLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnYm9vbGVhbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZ29vZy5pc051bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnbnVtYmVyJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZ29vZy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBnb29nLnR5cGVPZih2YWwpID09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiAgVGhpcyBpbmNsdWRlcyBhcnJheXMgYW5kXG4gKiBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmdvb2cuaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyAmJiB2YWwgIT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbic7XG4gIC8vIHJldHVybiBPYmplY3QodmFsKSA9PT0gdmFsIGFsc28gd29ya3MsIGJ1dCBpcyBzbG93ZXIsIGVzcGVjaWFsbHkgaWYgdmFsIGlzXG4gIC8vIG5vdCBhbiBvYmplY3QuXG59O1xuXG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFRoZSB1bmlxdWUgSUQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyB0aGUgY3VycmVudCBzZXNzaW9uIGFtb25nc3Qgb2JqZWN0cyB0aGF0IGFyZVxuICogcGFzc2VkIGludG8ge0Bjb2RlIGdldFVpZH0uIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBJRCBpcyB1bmlxdWUgb3JcbiAqIGNvbnNpc3RlbnQgYWNyb3NzIHNlc3Npb25zLiBJdCBpcyB1bnNhZmUgdG8gZ2VuZXJhdGUgdW5pcXVlIElEIGZvciBmdW5jdGlvblxuICogcHJvdG90eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZ2V0IHRoZSB1bmlxdWUgSUQgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdW5pcXVlIElEIGZvciB0aGUgb2JqZWN0LlxuICovXG5nb29nLmdldFVpZCA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBUT0RPKGFydik6IE1ha2UgdGhlIHR5cGUgc3RyaWN0ZXIsIGRvIG5vdCBhY2NlcHQgbnVsbC5cblxuICAvLyBJbiBPcGVyYSB3aW5kb3cuaGFzT3duUHJvcGVydHkgZXhpc3RzIGJ1dCBhbHdheXMgcmV0dXJucyBmYWxzZSBzbyB3ZSBhdm9pZFxuICAvLyB1c2luZyBpdC4gQXMgYSBjb25zZXF1ZW5jZSB0aGUgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgQmFzZUNsYXNzLnByb3RvdHlwZVxuICAvLyBhbmQgU3ViQ2xhc3MucHJvdG90eXBlIHdpbGwgYmUgdGhlIHNhbWUuXG4gIHJldHVybiBvYmpbZ29vZy5VSURfUFJPUEVSVFlfXSB8fFxuICAgICAgKG9ialtnb29nLlVJRF9QUk9QRVJUWV9dID0gKytnb29nLnVpZENvdW50ZXJfKTtcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBhc3NpZ25lZCBhIHVuaXF1ZSBJRC5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZXJlIGlzIGFuIGFzc2lnbmVkIHVuaXF1ZSBpZCBmb3IgdGhlIG9iamVjdC5cbiAqL1xuZ29vZy5oYXNVaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICEhb2JqW2dvb2cuVUlEX1BST1BFUlRZX107XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdW5pcXVlIElEIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgb2JqZWN0IHdhc1xuICogcHJldmlvdXNseSBtdXRhdGVkIHVzaW5nIHtAY29kZSBnb29nLmdldFVpZH0gaW4gd2hpY2ggY2FzZSB0aGUgbXV0YXRpb24gaXNcbiAqIHVuZG9uZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZW1vdmUgdGhlIHVuaXF1ZSBJRCBmaWVsZCBmcm9tLlxuICovXG5nb29nLnJlbW92ZVVpZCA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBUT0RPKGFydik6IE1ha2UgdGhlIHR5cGUgc3RyaWN0ZXIsIGRvIG5vdCBhY2NlcHQgbnVsbC5cblxuICAvLyBJbiBJRSwgRE9NIG5vZGVzIGFyZSBub3QgaW5zdGFuY2VzIG9mIE9iamVjdCBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlXG4gIC8vIHRyeSB0byBkZWxldGUuICBJbnN0ZWFkIHdlIHRyeSB0byB1c2UgcmVtb3ZlQXR0cmlidXRlLlxuICBpZiAoJ3JlbW92ZUF0dHJpYnV0ZScgaW4gb2JqKSB7XG4gICAgb2JqLnJlbW92ZUF0dHJpYnV0ZShnb29nLlVJRF9QUk9QRVJUWV8pO1xuICB9XG4gIC8qKiBAcHJlc2VydmVUcnkgKi9cbiAgdHJ5IHtcbiAgICBkZWxldGUgb2JqW2dvb2cuVUlEX1BST1BFUlRZX107XG4gIH0gY2F0Y2ggKGV4KSB7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBOYW1lIGZvciB1bmlxdWUgSUQgcHJvcGVydHkuIEluaXRpYWxpemVkIGluIGEgd2F5IHRvIGhlbHAgYXZvaWQgY29sbGlzaW9uc1xuICogd2l0aCBvdGhlciBjbG9zdXJlIEphdmFTY3JpcHQgb24gdGhlIHNhbWUgcGFnZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLlVJRF9QUk9QRVJUWV8gPSAnY2xvc3VyZV91aWRfJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXG5cbi8qKlxuICogQ291bnRlciBmb3IgVUlELlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cudWlkQ291bnRlcl8gPSAwO1xuXG5cbi8qKlxuICogQWRkcyBhIGhhc2ggY29kZSBmaWVsZCB0byBhbiBvYmplY3QuIFRoZSBoYXNoIGNvZGUgaXMgdW5pcXVlIGZvciB0aGVcbiAqIGdpdmVuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIGhhc2ggY29kZSBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoYXNoIGNvZGUgZm9yIHRoZSBvYmplY3QuXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ29vZy5nZXRVaWQgaW5zdGVhZC5cbiAqL1xuZ29vZy5nZXRIYXNoQ29kZSA9IGdvb2cuZ2V0VWlkO1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgaGFzaCBjb2RlIGZpZWxkIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJlbW92ZSB0aGUgZmllbGQgZnJvbS5cbiAqIEBkZXByZWNhdGVkIFVzZSBnb29nLnJlbW92ZVVpZCBpbnN0ZWFkLlxuICovXG5nb29nLnJlbW92ZUhhc2hDb2RlID0gZ29vZy5yZW1vdmVVaWQ7XG5cblxuLyoqXG4gKiBDbG9uZXMgYSB2YWx1ZS4gVGhlIGlucHV0IG1heSBiZSBhbiBPYmplY3QsIEFycmF5LCBvciBiYXNpYyB0eXBlLiBPYmplY3RzIGFuZFxuICogYXJyYXlzIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIFdBUk5JTkdTOlxuICogPGNvZGU+Z29vZy5jbG9uZU9iamVjdDwvY29kZT4gZG9lcyBub3QgZGV0ZWN0IHJlZmVyZW5jZSBsb29wcy4gT2JqZWN0cyB0aGF0XG4gKiByZWZlciB0byB0aGVtc2VsdmVzIHdpbGwgY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uLlxuICpcbiAqIDxjb2RlPmdvb2cuY2xvbmVPYmplY3Q8L2NvZGU+IGlzIHVuYXdhcmUgb2YgdW5pcXVlIGlkZW50aWZpZXJzLCBhbmQgY29waWVzXG4gKiBVSURzIGNyZWF0ZWQgYnkgPGNvZGU+Z2V0VWlkPC9jb2RlPiBpbnRvIGNsb25lZCByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm4geyp9IEEgY2xvbmUgb2YgdGhlIGlucHV0IHZhbHVlLlxuICogQGRlcHJlY2F0ZWQgZ29vZy5jbG9uZU9iamVjdCBpcyB1bnNhZmUuIFByZWZlciB0aGUgZ29vZy5vYmplY3QgbWV0aG9kcy5cbiAqL1xuZ29vZy5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgdHlwZSA9IGdvb2cudHlwZU9mKG9iaik7XG4gIGlmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2FycmF5Jykge1xuICAgIGlmIChvYmouY2xvbmUpIHtcbiAgICAgIHJldHVybiBvYmouY2xvbmUoKTtcbiAgICB9XG4gICAgdmFyIGNsb25lID0gdHlwZSA9PSAnYXJyYXknID8gW10gOiB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBjbG9uZVtrZXldID0gZ29vZy5jbG9uZU9iamVjdChvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8qKlxuICogQSBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgZ29vZy5iaW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IHNlbGZPYmogU3BlY2lmaWVzIHRoZSBvYmplY3Qgd2hpY2ggdGhpcyBzaG91bGRcbiAqICAgICBwb2ludCB0byB3aGVuIHRoZSBmdW5jdGlvbiBpcyBydW4uXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICogICAgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGJpbmQoKSB3YXNcbiAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7ZGVwcmVjYXRlZH0gVGhlIGNvbXBpbGVyIHRoaW5rcyB0aGF0IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGlzXG4gKiAgICAgZGVwcmVjYXRlZCBiZWNhdXNlIHNvbWUgcGVvcGxlIGhhdmUgZGVjbGFyZWQgYSBwdXJlLUpTIHZlcnNpb24uXG4gKiAgICAgT25seSB0aGUgcHVyZS1KUyB2ZXJzaW9uIGlzIHRydWx5IGRlcHJlY2F0ZWQuXG4gKi9cbmdvb2cuYmluZE5hdGl2ZV8gPSBmdW5jdGlvbihmbiwgc2VsZk9iaiwgdmFyX2FyZ3MpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyAoZm4uY2FsbC5hcHBseShmbi5iaW5kLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBBIHB1cmUtSlMgaW1wbGVtZW50YXRpb24gb2YgZ29vZy5iaW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IHNlbGZPYmogU3BlY2lmaWVzIHRoZSBvYmplY3Qgd2hpY2ggdGhpcyBzaG91bGRcbiAqICAgICBwb2ludCB0byB3aGVuIHRoZSBmdW5jdGlvbiBpcyBydW4uXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICogICAgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGJpbmQoKSB3YXNcbiAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5iaW5kSnNfID0gZnVuY3Rpb24oZm4sIHNlbGZPYmosIHZhcl9hcmdzKSB7XG4gIGlmICghZm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgIHZhciBib3VuZEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFByZXBlbmQgdGhlIGJvdW5kIGFyZ3VtZW50cyB0byB0aGUgY3VycmVudCBhcmd1bWVudHMuXG4gICAgICB2YXIgbmV3QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShuZXdBcmdzLCBib3VuZEFyZ3MpO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGZPYmosIG5ld0FyZ3MpO1xuICAgIH07XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoc2VsZk9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFydGlhbGx5IGFwcGxpZXMgdGhpcyBmdW5jdGlvbiB0byBhIHBhcnRpY3VsYXIgJ3RoaXMgb2JqZWN0JyBhbmQgemVybyBvclxuICogbW9yZSBhcmd1bWVudHMuIFRoZSByZXN1bHQgaXMgYSBuZXcgZnVuY3Rpb24gd2l0aCBzb21lIGFyZ3VtZW50cyBvZiB0aGUgZmlyc3RcbiAqIGZ1bmN0aW9uIHByZS1maWxsZWQgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzICdwcmUtc3BlY2lmaWVkJy5cbiAqXG4gKiBSZW1haW5pbmcgYXJndW1lbnRzIHNwZWNpZmllZCBhdCBjYWxsLXRpbWUgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmUtc3BlY2lmaWVkXG4gKiBvbmVzLlxuICpcbiAqIEFsc28gc2VlOiB7QGxpbmsgI3BhcnRpYWx9LlxuICpcbiAqIFVzYWdlOlxuICogPHByZT52YXIgYmFyTWV0aEJvdW5kID0gZ29vZy5iaW5kKG15RnVuY3Rpb24sIG15T2JqLCAnYXJnMScsICdhcmcyJyk7XG4gKiBiYXJNZXRoQm91bmQoJ2FyZzMnLCAnYXJnNCcpOzwvcHJlPlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VCwgLi4uKX0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gKiBAcGFyYW0ge1R9IHNlbGZPYmogU3BlY2lmaWVzIHRoZSBvYmplY3Qgd2hpY2ggdGhpcyBzaG91bGQgcG9pbnQgdG8gd2hlbiB0aGVcbiAqICAgICBmdW5jdGlvbiBpcyBydW4uXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICogICAgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGdvb2cuYmluZCgpIHdhc1xuICogICAgIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gKiBAdGVtcGxhdGUgVFxuICogQHN1cHByZXNzIHtkZXByZWNhdGVkfSBTZWUgYWJvdmUuXG4gKi9cbmdvb2cuYmluZCA9IGZ1bmN0aW9uKGZuLCBzZWxmT2JqLCB2YXJfYXJncykge1xuICAvLyBUT0RPKG5pY2tzYW50b3MpOiBuYXJyb3cgdGhlIHR5cGUgc2lnbmF0dXJlLlxuICBpZiAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiZcbiAgICAgIC8vIE5PVEUobmlja3NhbnRvcyk6IFNvbWVib2R5IHB1bGxlZCBiYXNlLmpzIGludG8gdGhlIGRlZmF1bHQgQ2hyb21lXG4gICAgICAvLyBleHRlbnNpb24gZW52aXJvbm1lbnQuIFRoaXMgbWVhbnMgdGhhdCBmb3IgQ2hyb21lIGV4dGVuc2lvbnMsIHRoZXkgZ2V0XG4gICAgICAvLyB0aGUgaW1wbGVtZW50YXRpb24gb2YgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgdGhhdCBjYWxscyBnb29nLmJpbmRcbiAgICAgIC8vIGluc3RlYWQgb2YgdGhlIG5hdGl2ZSBvbmUuIEV2ZW4gd29yc2UsIHdlIGRvbid0IHdhbnQgdG8gaW50cm9kdWNlIGFcbiAgICAgIC8vIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBnb29nLmJpbmQgYW5kIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBzb1xuICAgICAgLy8gd2UgaGF2ZSB0byBoYWNrIHRoaXMgdG8gbWFrZSBzdXJlIGl0IHdvcmtzIGNvcnJlY3RseS5cbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZignbmF0aXZlIGNvZGUnKSAhPSAtMSkge1xuICAgIGdvb2cuYmluZCA9IGdvb2cuYmluZE5hdGl2ZV87XG4gIH0gZWxzZSB7XG4gICAgZ29vZy5iaW5kID0gZ29vZy5iaW5kSnNfO1xuICB9XG4gIHJldHVybiBnb29nLmJpbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqXG4gKiBMaWtlIGdvb2cuYmluZCgpLCBleGNlcHQgdGhhdCBhICd0aGlzIG9iamVjdCcgaXMgbm90IHJlcXVpcmVkLiBVc2VmdWwgd2hlblxuICogdGhlIHRhcmdldCBmdW5jdGlvbiBpcyBhbHJlYWR5IGJvdW5kLlxuICpcbiAqIFVzYWdlOlxuICogdmFyIGcgPSBnb29nLnBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gKiBnKGFyZzMsIGFyZzQpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byBmbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBnb29nLnBhcnRpYWwoKVxuICogICAgIHdhcyBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICovXG5nb29nLnBhcnRpYWwgPSBmdW5jdGlvbihmbiwgdmFyX2FyZ3MpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5ICh3aXRoIHNsaWNlKCkpIGFuZCBhcHBlbmQgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAvLyB0byB0aGUgZXhpc3RpbmcgYXJndW1lbnRzLlxuICAgIHZhciBuZXdBcmdzID0gYXJncy5zbGljZSgpO1xuICAgIG5ld0FyZ3MucHVzaC5hcHBseShuZXdBcmdzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuIFRoaXMgbWV0aG9kXG4gKiBkb2VzIG5vdCB3b3JrIG9uIGFsbCBicm93c2VycyBmb3IgYWxsIG9iamVjdHMgdGhhdCBjb250YWluIGtleXMgc3VjaCBhc1xuICogdG9TdHJpbmcgb3IgaGFzT3duUHJvcGVydHkuIFVzZSBnb29nLm9iamVjdC5leHRlbmQgZm9yIHRoaXMgcHVycG9zZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2UuXG4gKi9cbmdvb2cubWl4aW4gPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKHZhciB4IGluIHNvdXJjZSkge1xuICAgIHRhcmdldFt4XSA9IHNvdXJjZVt4XTtcbiAgfVxuXG4gIC8vIEZvciBJRTcgb3IgbG93ZXIsIHRoZSBmb3ItaW4tbG9vcCBkb2VzIG5vdCBjb250YWluIGFueSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gIC8vIG5vdCBlbnVtZXJhYmxlIG9uIHRoZSBwcm90b3R5cGUgb2JqZWN0IChmb3IgZXhhbXBsZSwgaXNQcm90b3R5cGVPZiBmcm9tXG4gIC8vIE9iamVjdC5wcm90b3R5cGUpIGJ1dCBhbHNvIGl0IHdpbGwgbm90IGluY2x1ZGUgJ3JlcGxhY2UnIG9uIG9iamVjdHMgdGhhdFxuICAvLyBleHRlbmQgU3RyaW5nIGFuZCBjaGFuZ2UgJ3JlcGxhY2UnIChub3QgdGhhdCBpdCBpcyBjb21tb24gZm9yIGFueW9uZSB0b1xuICAvLyBleHRlbmQgYW55dGhpbmcgZXhjZXB0IE9iamVjdCkuXG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgIGJldHdlZW4gbWlkbmlnaHQsIEphbnVhcnkgMSwgMTk3MCBhbmQgdGhlIGN1cnJlbnQgdGltZS5cbiAqL1xuZ29vZy5ub3cgPSAoZ29vZy5UUlVTVEVEX1NJVEUgJiYgRGF0ZS5ub3cpIHx8IChmdW5jdGlvbigpIHtcbiAgLy8gVW5hcnkgcGx1cyBvcGVyYXRvciBjb252ZXJ0cyBpdHMgb3BlcmFuZCB0byBhIG51bWJlciB3aGljaCBpbiB0aGUgY2FzZSBvZlxuICAvLyBhIGRhdGUgaXMgZG9uZSBieSBjYWxsaW5nIGdldFRpbWUoKS5cbiAgcmV0dXJuICtuZXcgRGF0ZSgpO1xufSk7XG5cblxuLyoqXG4gKiBFdmFscyBKYXZhU2NyaXB0IGluIHRoZSBnbG9iYWwgc2NvcGUuICBJbiBJRSB0aGlzIHVzZXMgZXhlY1NjcmlwdCwgb3RoZXJcbiAqIGJyb3dzZXJzIHVzZSBnb29nLmdsb2JhbC5ldmFsLiBJZiBnb29nLmdsb2JhbC5ldmFsIGRvZXMgbm90IGV2YWx1YXRlIGluIHRoZVxuICogZ2xvYmFsIHNjb3BlIChmb3IgZXhhbXBsZSwgaW4gU2FmYXJpKSwgYXBwZW5kcyBhIHNjcmlwdCB0YWcgaW5zdGVhZC5cbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgbmVpdGhlciBleGVjU2NyaXB0IG9yIGV2YWwgaXMgZGVmaW5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKi9cbmdvb2cuZ2xvYmFsRXZhbCA9IGZ1bmN0aW9uKHNjcmlwdCkge1xuICBpZiAoZ29vZy5nbG9iYWwuZXhlY1NjcmlwdCkge1xuICAgIGdvb2cuZ2xvYmFsLmV4ZWNTY3JpcHQoc2NyaXB0LCAnSmF2YVNjcmlwdCcpO1xuICB9IGVsc2UgaWYgKGdvb2cuZ2xvYmFsLmV2YWwpIHtcbiAgICAvLyBUZXN0IHRvIHNlZSBpZiBldmFsIHdvcmtzXG4gICAgaWYgKGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPT0gbnVsbCkge1xuICAgICAgZ29vZy5nbG9iYWwuZXZhbCgndmFyIF9ldmFsVGVzdF8gPSAxOycpO1xuICAgICAgaWYgKHR5cGVvZiBnb29nLmdsb2JhbFsnX2V2YWxUZXN0XyddICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVsZXRlIGdvb2cuZ2xvYmFsWydfZXZhbFRlc3RfJ107XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgIC8vIE1pY3Jvc29mdCBlZGdlIGZhaWxzIHRoZSBkZWxldGlvbiBhYm92ZSBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgfVxuICAgICAgICBnb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXykge1xuICAgICAgZ29vZy5nbG9iYWwuZXZhbChzY3JpcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuICAgICAgdmFyIHNjcmlwdEVsdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtcbiAgICAgIHNjcmlwdEVsdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICBzY3JpcHRFbHQuZGVmZXIgPSBmYWxzZTtcbiAgICAgIC8vIE5vdGUodXNlcik6IGNhbid0IHVzZSAuaW5uZXJIVE1MIHNpbmNlIFwidCgnPHRlc3Q+JylcIiB3aWxsIGZhaWwgYW5kXG4gICAgICAvLyAudGV4dCBkb2Vzbid0IHdvcmsgaW4gU2FmYXJpIDIuICBUaGVyZWZvcmUgd2UgYXBwZW5kIGEgdGV4dCBub2RlLlxuICAgICAgc2NyaXB0RWx0LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShzY3JpcHQpKTtcbiAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdEVsdCk7XG4gICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChzY3JpcHRFbHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignZ29vZy5nbG9iYWxFdmFsIG5vdCBhdmFpbGFibGUnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gY2FsbCAnZXZhbCcgZGlyZWN0bHkgdG8gZXZhbCBjb2RlIGluIHRoZVxuICogZ2xvYmFsIHNjb3BlLiBTZXQgdG8gYSBCb29sZWFuIGJ5IHRoZSBmaXJzdCBjYWxsIHRvIGdvb2cuZ2xvYmFsRXZhbCAod2hpY2hcbiAqIGVtcGlyaWNhbGx5IHRlc3RzIHdoZXRoZXIgZXZhbCB3b3JrcyBmb3IgZ2xvYmFscykuIEBzZWUgZ29vZy5nbG9iYWxFdmFsXG4gKiBAdHlwZSB7P2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfID0gbnVsbDtcblxuXG4vKipcbiAqIE9wdGlvbmFsIG1hcCBvZiBDU1MgY2xhc3MgbmFtZXMgdG8gb2JmdXNjYXRlZCBuYW1lcyB1c2VkIHdpdGhcbiAqIGdvb2cuZ2V0Q3NzTmFtZSgpLlxuICogQHByaXZhdGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fHVuZGVmaW5lZH1cbiAqIEBzZWUgZ29vZy5zZXRDc3NOYW1lTWFwcGluZ1xuICovXG5nb29nLmNzc05hbWVNYXBwaW5nXztcblxuXG4vKipcbiAqIE9wdGlvbmFsIG9iZnVzY2F0aW9uIHN0eWxlIGZvciBDU1MgY2xhc3MgbmFtZXMuIFNob3VsZCBiZSBzZXQgdG8gZWl0aGVyXG4gKiAnQllfV0hPTEUnIG9yICdCWV9QQVJUJyBpZiBkZWZpbmVkLlxuICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICogQHNlZSBnb29nLnNldENzc05hbWVNYXBwaW5nXG4gKi9cbmdvb2cuY3NzTmFtZU1hcHBpbmdTdHlsZV87XG5cblxuLyoqXG4gKiBIYW5kbGVzIHN0cmluZ3MgdGhhdCBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBDU1MgY2xhc3MgbmFtZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b3JrcyBpbiB0YW5kZW0gd2l0aCBAc2VlIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcuXG4gKlxuICogV2l0aG91dCBhbnkgbWFwcGluZyBzZXQsIHRoZSBhcmd1bWVudHMgYXJlIHNpbXBsZSBqb2luZWQgd2l0aCBhIGh5cGhlbiBhbmRcbiAqIHBhc3NlZCB0aHJvdWdoIHVuYWx0ZXJlZC5cbiAqXG4gKiBXaGVuIHRoZXJlIGlzIGEgbWFwcGluZywgdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzdHlsZXMgaW4gd2hpY2ggdGhlc2VcbiAqIG1hcHBpbmdzIGFyZSB1c2VkLiBJbiB0aGUgQllfUEFSVCBzdHlsZSwgZWFjaCBwYXJ0IChpLmUuIGluIGJldHdlZW4gaHlwaGVucylcbiAqIG9mIHRoZSBwYXNzZWQgaW4gY3NzIG5hbWUgaXMgcmV3cml0dGVuIGFjY29yZGluZyB0byB0aGUgbWFwLiBJbiB0aGUgQllfV0hPTEVcbiAqIHN0eWxlLCB0aGUgZnVsbCBjc3MgbmFtZSBpcyBsb29rZWQgdXAgaW4gdGhlIG1hcCBkaXJlY3RseS4gSWYgYSByZXdyaXRlIGlzXG4gKiBub3Qgc3BlY2lmaWVkIGJ5IHRoZSBtYXAsIHRoZSBjb21waWxlciB3aWxsIG91dHB1dCBhIHdhcm5pbmcuXG4gKlxuICogV2hlbiB0aGUgbWFwcGluZyBpcyBwYXNzZWQgdG8gdGhlIGNvbXBpbGVyLCBpdCB3aWxsIHJlcGxhY2UgY2FsbHMgdG9cbiAqIGdvb2cuZ2V0Q3NzTmFtZSB3aXRoIHRoZSBzdHJpbmdzIGZyb20gdGhlIG1hcHBpbmcsIGUuZy5cbiAqICAgICB2YXIgeCA9IGdvb2cuZ2V0Q3NzTmFtZSgnZm9vJyk7XG4gKiAgICAgdmFyIHkgPSBnb29nLmdldENzc05hbWUodGhpcy5iYXNlQ2xhc3MsICdhY3RpdmUnKTtcbiAqICBiZWNvbWVzOlxuICogICAgIHZhciB4PSAnZm9vJztcbiAqICAgICB2YXIgeSA9IHRoaXMuYmFzZUNsYXNzICsgJy1hY3RpdmUnO1xuICpcbiAqIElmIG9uZSBhcmd1bWVudCBpcyBwYXNzZWQgaXQgd2lsbCBiZSBwcm9jZXNzZWQsIGlmIHR3byBhcmUgcGFzc2VkIG9ubHkgdGhlXG4gKiBtb2RpZmllciB3aWxsIGJlIHByb2Nlc3NlZCwgYXMgaXQgaXMgYXNzdW1lZCB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGdlbmVyYXRlZFxuICogYXMgYSByZXN1bHQgb2YgY2FsbGluZyBnb29nLmdldENzc05hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21vZGlmaWVyIEEgbW9kaWZpZXIgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGNsYXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjbGFzcyBuYW1lIG9yIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBjbGFzcyBuYW1lIGFuZFxuICogICAgIHRoZSBtb2RpZmllci5cbiAqL1xuZ29vZy5nZXRDc3NOYW1lID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvcHRfbW9kaWZpZXIpIHtcbiAgdmFyIGdldE1hcHBpbmcgPSBmdW5jdGlvbihjc3NOYW1lKSB7XG4gICAgcmV0dXJuIGdvb2cuY3NzTmFtZU1hcHBpbmdfW2Nzc05hbWVdIHx8IGNzc05hbWU7XG4gIH07XG5cbiAgdmFyIHJlbmFtZUJ5UGFydHMgPSBmdW5jdGlvbihjc3NOYW1lKSB7XG4gICAgLy8gUmVtYXAgYWxsIHRoZSBwYXJ0cyBpbmRpdmlkdWFsbHkuXG4gICAgdmFyIHBhcnRzID0gY3NzTmFtZS5zcGxpdCgnLScpO1xuICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBwZWQucHVzaChnZXRNYXBwaW5nKHBhcnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQuam9pbignLScpO1xuICB9O1xuXG4gIHZhciByZW5hbWU7XG4gIGlmIChnb29nLmNzc05hbWVNYXBwaW5nXykge1xuICAgIHJlbmFtZSA9IGdvb2cuY3NzTmFtZU1hcHBpbmdTdHlsZV8gPT0gJ0JZX1dIT0xFJyA/XG4gICAgICAgIGdldE1hcHBpbmcgOiByZW5hbWVCeVBhcnRzO1xuICB9IGVsc2Uge1xuICAgIHJlbmFtZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH07XG4gIH1cblxuICBpZiAob3B0X21vZGlmaWVyKSB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZSArICctJyArIHJlbmFtZShvcHRfbW9kaWZpZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZW5hbWUoY2xhc3NOYW1lKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCB0byBjaGVjayB3aGVuIHJldHVybmluZyBhIHZhbHVlIGZyb20gZ29vZy5nZXRDc3NOYW1lKCkuIEV4YW1wbGU6XG4gKiA8cHJlPlxuICogZ29vZy5zZXRDc3NOYW1lTWFwcGluZyh7XG4gKiAgIFwiZ29vZ1wiOiBcImFcIixcbiAqICAgXCJkaXNhYmxlZFwiOiBcImJcIixcbiAqIH0pO1xuICpcbiAqIHZhciB4ID0gZ29vZy5nZXRDc3NOYW1lKCdnb29nJyk7XG4gKiAvLyBUaGUgZm9sbG93aW5nIGV2YWx1YXRlcyB0bzogXCJhIGEtYlwiLlxuICogZ29vZy5nZXRDc3NOYW1lKCdnb29nJykgKyAnICcgKyBnb29nLmdldENzc05hbWUoeCwgJ2Rpc2FibGVkJylcbiAqIDwvcHJlPlxuICogV2hlbiBkZWNsYXJlZCBhcyBhIG1hcCBvZiBzdHJpbmcgbGl0ZXJhbHMgdG8gc3RyaW5nIGxpdGVyYWxzLCB0aGUgSlNDb21waWxlclxuICogd2lsbCByZXBsYWNlIGFsbCBjYWxscyB0byBnb29nLmdldENzc05hbWUoKSB1c2luZyB0aGUgc3VwcGxpZWQgbWFwIGlmIHRoZVxuICogLS1wcm9jZXNzX2Nsb3N1cmVfcHJpbWl0aXZlcyBmbGFnIGlzIHNldC5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IG1hcHBpbmcgQSBtYXAgb2Ygc3RyaW5ncyB0byBzdHJpbmdzIHdoZXJlIGtleXMgYXJlIHBvc3NpYmxlXG4gKiAgICAgYXJndW1lbnRzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpIGFuZCB2YWx1ZXMgYXJlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICogICAgIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc3R5bGUgVGhlIHN0eWxlIG9mIGNzcyBuYW1lIG1hcHBpbmcuIFRoZXJlIGFyZSB0d28gdmFsaWRcbiAqICAgICBvcHRpb25zOiAnQllfUEFSVCcsIGFuZCAnQllfV0hPTEUnLlxuICogQHNlZSBnb29nLmdldENzc05hbWUgZm9yIGEgZGVzY3JpcHRpb24uXG4gKi9cbmdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcgPSBmdW5jdGlvbihtYXBwaW5nLCBvcHRfc3R5bGUpIHtcbiAgZ29vZy5jc3NOYW1lTWFwcGluZ18gPSBtYXBwaW5nO1xuICBnb29nLmNzc05hbWVNYXBwaW5nU3R5bGVfID0gb3B0X3N0eWxlO1xufTtcblxuXG4vKipcbiAqIFRvIHVzZSBDU1MgcmVuYW1pbmcgaW4gY29tcGlsZWQgbW9kZSwgb25lIG9mIHRoZSBpbnB1dCBmaWxlcyBzaG91bGQgaGF2ZSBhXG4gKiBjYWxsIHRvIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcoKSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsIHRoYXQgdGhlIEpTQ29tcGlsZXJcbiAqIGNhbiBleHRyYWN0IGFuZCB1c2UgdG8gcmVwbGFjZSBhbGwgY2FsbHMgdG8gZ29vZy5nZXRDc3NOYW1lKCkuIEluIHVuY29tcGlsZWRcbiAqIG1vZGUsIEphdmFTY3JpcHQgY29kZSBzaG91bGQgYmUgbG9hZGVkIGJlZm9yZSB0aGlzIGJhc2UuanMgZmlsZSB0aGF0IGRlY2xhcmVzXG4gKiBhIGdsb2JhbCB2YXJpYWJsZSwgQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HLCB3aGljaCBpcyB1c2VkIGJlbG93LiBUaGlzIGlzXG4gKiB0byBlbnN1cmUgdGhhdCB0aGUgbWFwcGluZyBpcyBsb2FkZWQgYmVmb3JlIGFueSBjYWxscyB0byBnb29nLmdldENzc05hbWUoKVxuICogYXJlIG1hZGUgaW4gdW5jb21waWxlZCBtb2RlLlxuICpcbiAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgQ1NTIG5hbWUgbWFwcGluZy5cbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPnx1bmRlZmluZWR9XG4gKi9cbmdvb2cuZ2xvYmFsLkNMT1NVUkVfQ1NTX05BTUVfTUFQUElORztcblxuXG5pZiAoIUNPTVBJTEVEICYmIGdvb2cuZ2xvYmFsLkNMT1NVUkVfQ1NTX05BTUVfTUFQUElORykge1xuICAvLyBUaGlzIGRvZXMgbm90IGNhbGwgZ29vZy5zZXRDc3NOYW1lTWFwcGluZygpIGJlY2F1c2UgdGhlIEpTQ29tcGlsZXJcbiAgLy8gcmVxdWlyZXMgdGhhdCBnb29nLnNldENzc05hbWVNYXBwaW5nKCkgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuXG4gIGdvb2cuY3NzTmFtZU1hcHBpbmdfID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HO1xufVxuXG5cbi8qKlxuICogR2V0cyBhIGxvY2FsaXplZCBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb21waWxlciBwcmltaXRpdmUuIElmIHlvdSBnaXZlIHRoZSBjb21waWxlciBhIGxvY2FsaXplZFxuICogbWVzc2FnZSBidW5kbGUsIGl0IHdpbGwgcmVwbGFjZSB0aGUgc3RyaW5nIGF0IGNvbXBpbGUtdGltZSB3aXRoIGEgbG9jYWxpemVkXG4gKiB2ZXJzaW9uLCBhbmQgZXhwYW5kIGdvb2cuZ2V0TXNnIGNhbGwgdG8gYSBjb25jYXRlbmF0ZWQgc3RyaW5nLlxuICpcbiAqIE1lc3NhZ2VzIG11c3QgYmUgaW5pdGlhbGl6ZWQgaW4gdGhlIGZvcm06XG4gKiA8Y29kZT5cbiAqIHZhciBNU0dfTkFNRSA9IGdvb2cuZ2V0TXNnKCdIZWxsbyB7JHBsYWNlaG9sZGVyfScsIHsncGxhY2Vob2xkZXInOiAnd29ybGQnfSk7XG4gKiA8L2NvZGU+XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUcmFuc2xhdGFibGUgc3RyaW5nLCBwbGFjZXMgaG9sZGVycyBpbiB0aGUgZm9ybSB7JGZvb30uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz49fSBvcHRfdmFsdWVzIE1hcHMgcGxhY2UgaG9sZGVyIG5hbWUgdG8gdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IG1lc3NhZ2Ugd2l0aCBwbGFjZWhvbGRlcnMgZmlsbGVkLlxuICovXG5nb29nLmdldE1zZyA9IGZ1bmN0aW9uKHN0ciwgb3B0X3ZhbHVlcykge1xuICBpZiAob3B0X3ZhbHVlcykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHtcXCQoW159XSspfS9nLCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICByZXR1cm4ga2V5IGluIG9wdF92YWx1ZXMgPyBvcHRfdmFsdWVzW2tleV0gOiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIEdldHMgYSBsb2NhbGl6ZWQgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgZG9lcyBub3QgaGF2ZSBhIHRyYW5zbGF0aW9uLCBnaXZlcyBhXG4gKiBmYWxsYmFjayBtZXNzYWdlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gaW50cm9kdWNpbmcgYSBuZXcgbWVzc2FnZSB0aGF0IGhhcyBub3QgeWV0IGJlZW5cbiAqIHRyYW5zbGF0ZWQgaW50byBhbGwgbGFuZ3VhZ2VzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb21waWxlciBwcmltaXRpdmUuIE11c3QgYmUgdXNlZCBpbiB0aGUgZm9ybTpcbiAqIDxjb2RlPnZhciB4ID0gZ29vZy5nZXRNc2dXaXRoRmFsbGJhY2soTVNHX0EsIE1TR19CKTs8L2NvZGU+XG4gKiB3aGVyZSBNU0dfQSBhbmQgTVNHX0Igd2VyZSBpbml0aWFsaXplZCB3aXRoIGdvb2cuZ2V0TXNnLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhIFRoZSBwcmVmZXJyZWQgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiIFRoZSBmYWxsYmFjayBtZXNzYWdlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmVzdCB0cmFuc2xhdGVkIG1lc3NhZ2UuXG4gKi9cbmdvb2cuZ2V0TXNnV2l0aEZhbGxiYWNrID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYTtcbn07XG5cblxuLyoqXG4gKiBFeHBvc2VzIGFuIHVub2JmdXNjYXRlZCBnbG9iYWwgbmFtZXNwYWNlIHBhdGggZm9yIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBOb3RlIHRoYXQgZmllbGRzIG9mIHRoZSBleHBvcnRlZCBvYmplY3QgKndpbGwqIGJlIG9iZnVzY2F0ZWQsIHVubGVzcyB0aGV5IGFyZVxuICogZXhwb3J0ZWQgaW4gdHVybiB2aWEgdGhpcyBmdW5jdGlvbiBvciBnb29nLmV4cG9ydFByb3BlcnR5LlxuICpcbiAqIEFsc28gaGFuZHkgZm9yIG1ha2luZyBwdWJsaWMgaXRlbXMgdGhhdCBhcmUgZGVmaW5lZCBpbiBhbm9ueW1vdXMgY2xvc3VyZXMuXG4gKlxuICogZXguIGdvb2cuZXhwb3J0U3ltYm9sKCdwdWJsaWMucGF0aC5Gb28nLCBGb28pO1xuICpcbiAqIGV4LiBnb29nLmV4cG9ydFN5bWJvbCgncHVibGljLnBhdGguRm9vLnN0YXRpY0Z1bmN0aW9uJywgRm9vLnN0YXRpY0Z1bmN0aW9uKTtcbiAqICAgICBwdWJsaWMucGF0aC5Gb28uc3RhdGljRnVuY3Rpb24oKTtcbiAqXG4gKiBleC4gZ29vZy5leHBvcnRTeW1ib2woJ3B1YmxpYy5wYXRoLkZvby5wcm90b3R5cGUubXlNZXRob2QnLFxuICogICAgICAgICAgICAgICAgICAgICAgIEZvby5wcm90b3R5cGUubXlNZXRob2QpO1xuICogICAgIG5ldyBwdWJsaWMucGF0aC5Gb28oKS5teU1ldGhvZCgpO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNQYXRoIFVub2JmdXNjYXRlZCBuYW1lIHRvIGV4cG9ydC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IE9iamVjdCB0aGUgbmFtZSBzaG91bGQgcG9pbnQgdG8uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3RUb0V4cG9ydFRvIFRoZSBvYmplY3QgdG8gYWRkIHRoZSBwYXRoIHRvOyBkZWZhdWx0XG4gKiAgICAgaXMgZ29vZy5nbG9iYWwuXG4gKi9cbmdvb2cuZXhwb3J0U3ltYm9sID0gZnVuY3Rpb24ocHVibGljUGF0aCwgb2JqZWN0LCBvcHRfb2JqZWN0VG9FeHBvcnRUbykge1xuICBnb29nLmV4cG9ydFBhdGhfKHB1YmxpY1BhdGgsIG9iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pO1xufTtcblxuXG4vKipcbiAqIEV4cG9ydHMgYSBwcm9wZXJ0eSB1bm9iZnVzY2F0ZWQgaW50byB0aGUgb2JqZWN0J3MgbmFtZXNwYWNlLlxuICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLCAnc3RhdGljRnVuY3Rpb24nLCBGb28uc3RhdGljRnVuY3Rpb24pO1xuICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLnByb3RvdHlwZSwgJ215TWV0aG9kJywgRm9vLnByb3RvdHlwZS5teU1ldGhvZCk7XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB3aG9zZSBzdGF0aWMgcHJvcGVydHkgaXMgYmVpbmcgZXhwb3J0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljTmFtZSBVbm9iZnVzY2F0ZWQgbmFtZSB0byBleHBvcnQuXG4gKiBAcGFyYW0geyp9IHN5bWJvbCBPYmplY3QgdGhlIG5hbWUgc2hvdWxkIHBvaW50IHRvLlxuICovXG5nb29nLmV4cG9ydFByb3BlcnR5ID0gZnVuY3Rpb24ob2JqZWN0LCBwdWJsaWNOYW1lLCBzeW1ib2wpIHtcbiAgb2JqZWN0W3B1YmxpY05hbWVdID0gc3ltYm9sO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBVc2FnZTpcbiAqIDxwcmU+XG4gKiBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqIFBhcmVudENsYXNzLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbihhKSB7IH07XG4gKlxuICogZnVuY3Rpb24gQ2hpbGRDbGFzcyhhLCBiLCBjKSB7XG4gKiAgIENoaWxkQ2xhc3MuYmFzZSh0aGlzLCAnY29uc3RydWN0b3InLCBhLCBiKTtcbiAqIH1cbiAqIGdvb2cuaW5oZXJpdHMoQ2hpbGRDbGFzcywgUGFyZW50Q2xhc3MpO1xuICpcbiAqIHZhciBjaGlsZCA9IG5ldyBDaGlsZENsYXNzKCdhJywgJ2InLCAnc2VlJyk7XG4gKiBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjaGlsZEN0b3IgQ2hpbGQgY2xhc3MuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gcGFyZW50Q3RvciBQYXJlbnQgY2xhc3MuXG4gKi9cbmdvb2cuaW5oZXJpdHMgPSBmdW5jdGlvbihjaGlsZEN0b3IsIHBhcmVudEN0b3IpIHtcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiB0ZW1wQ3RvcigpIHt9O1xuICB0ZW1wQ3Rvci5wcm90b3R5cGUgPSBwYXJlbnRDdG9yLnByb3RvdHlwZTtcbiAgY2hpbGRDdG9yLnN1cGVyQ2xhc3NfID0gcGFyZW50Q3Rvci5wcm90b3R5cGU7XG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUgPSBuZXcgdGVtcEN0b3IoKTtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBjaGlsZEN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGRDdG9yO1xuXG4gIC8qKlxuICAgKiBDYWxscyBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yL21ldGhvZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBpZiB5b3UgdXNlIGdvb2cuaW5oZXJpdHMgdG9cbiAgICogZXhwcmVzcyBpbmhlcml0YW5jZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gY2xhc3Nlcy5cbiAgICpcbiAgICogTk9URTogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBnb29nLmJhc2UgYW5kIGZvciBzdXBlckNsYXNzX1xuICAgKiBwcm9wZXJ0eSBkZWZpbmVkIGluIGNoaWxkQ3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHshT2JqZWN0fSBtZSBTaG91bGQgYWx3YXlzIGJlIFwidGhpc1wiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbWV0aG9kIG5hbWUgdG8gY2FsbC4gQ2FsbGluZ1xuICAgKiAgICAgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciBjYW4gYmUgZG9uZSB3aXRoIHRoZSBzcGVjaWFsIHN0cmluZ1xuICAgKiAgICAgJ2NvbnN0cnVjdG9yJy5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gc3VwZXJjbGFzc1xuICAgKiAgICAgbWV0aG9kL2NvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBzdXBlcmNsYXNzIG1ldGhvZC9jb25zdHJ1Y3Rvci5cbiAgICovXG4gIGNoaWxkQ3Rvci5iYXNlID0gZnVuY3Rpb24obWUsIG1ldGhvZE5hbWUsIHZhcl9hcmdzKSB7XG4gICAgLy8gQ29weWluZyB1c2luZyBsb29wIHRvIGF2b2lkIGRlb3AgZHVlIHRvIHBhc3NpbmcgYXJndW1lbnRzIG9iamVjdCB0b1xuICAgIC8vIGZ1bmN0aW9uLiBUaGlzIGlzIGZhc3RlciBpbiBtYW55IEpTIGVuZ2luZXMgYXMgb2YgbGF0ZSAyMDE0LlxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpIC0gMl0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gIH07XG59O1xuXG5cbi8qKlxuICogQ2FsbCB1cCB0byB0aGUgc3VwZXJjbGFzcy5cbiAqXG4gKiBJZiB0aGlzIGlzIGNhbGxlZCBmcm9tIGEgY29uc3RydWN0b3IsIHRoZW4gdGhpcyBjYWxscyB0aGUgc3VwZXJjbGFzc1xuICogY29uc3RydWN0b3Igd2l0aCBhcmd1bWVudHMgMS1OLlxuICpcbiAqIElmIHRoaXMgaXMgY2FsbGVkIGZyb20gYSBwcm90b3R5cGUgbWV0aG9kLCB0aGVuIHlvdSBtdXN0IHBhc3MgdGhlIG5hbWUgb2YgdGhlXG4gKiBtZXRob2QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uLiBJZiB5b3UgZG8gbm90LCB5b3Ugd2lsbCBnZXQgYVxuICogcnVudGltZSBlcnJvci4gVGhpcyBjYWxscyB0aGUgc3VwZXJjbGFzcycgbWV0aG9kIHdpdGggYXJndW1lbnRzIDItTi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3MgaWYgeW91IHVzZSBnb29nLmluaGVyaXRzIHRvIGV4cHJlc3MgaW5oZXJpdGFuY2VcbiAqIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiB5b3VyIGNsYXNzZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIGNvbXBpbGVyIHByaW1pdGl2ZS4gQXQgY29tcGlsZS10aW1lLCB0aGUgY29tcGlsZXIgd2lsbCBkb1xuICogbWFjcm8gZXhwYW5zaW9uIHRvIHJlbW92ZSBhIGxvdCBvZiB0aGUgZXh0cmEgb3ZlcmhlYWQgdGhhdCB0aGlzIGZ1bmN0aW9uXG4gKiBpbnRyb2R1Y2VzLiBUaGUgY29tcGlsZXIgd2lsbCBhbHNvIGVuZm9yY2UgYSBsb3Qgb2YgdGhlIGFzc3VtcHRpb25zIHRoYXQgdGhpc1xuICogZnVuY3Rpb24gbWFrZXMsIGFuZCB0cmVhdCBpdCBhcyBhIGNvbXBpbGVyIGVycm9yIGlmIHlvdSBicmVhayB0aGVtLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gbWUgU2hvdWxkIGFsd2F5cyBiZSBcInRoaXNcIi5cbiAqIEBwYXJhbSB7Kj19IG9wdF9tZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSBpZiBjYWxsaW5nIGEgc3VwZXIgbWV0aG9kLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgcmVzdCBvZiB0aGUgYXJndW1lbnRzLlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gKiBAc3VwcHJlc3Mge2VzNVN0cmljdH0gVGhpcyBtZXRob2QgY2FuIG5vdCBiZSB1c2VkIGluIHN0cmljdCBtb2RlLCBidXRcbiAqICAgICBhbGwgQ2xvc3VyZSBMaWJyYXJ5IGNvbnN1bWVycyBtdXN0IGRlcGVuZCBvbiB0aGlzIGZpbGUuXG4gKi9cbmdvb2cuYmFzZSA9IGZ1bmN0aW9uKG1lLCBvcHRfbWV0aG9kTmFtZSwgdmFyX2FyZ3MpIHtcbiAgdmFyIGNhbGxlciA9IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyO1xuXG4gIGlmIChnb29nLlNUUklDVF9NT0RFX0NPTVBBVElCTEUgfHwgKGdvb2cuREVCVUcgJiYgIWNhbGxlcikpIHtcbiAgICB0aHJvdyBFcnJvcignYXJndW1lbnRzLmNhbGxlciBub3QgZGVmaW5lZC4gIGdvb2cuYmFzZSgpIGNhbm5vdCBiZSB1c2VkICcgK1xuICAgICAgICAgICAgICAgICd3aXRoIHN0cmljdCBtb2RlIGNvZGUuIFNlZSAnICtcbiAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLUMnKTtcbiAgfVxuXG4gIGlmIChjYWxsZXIuc3VwZXJDbGFzc18pIHtcbiAgICAvLyBDb3B5aW5nIHVzaW5nIGxvb3AgdG8gYXZvaWQgZGVvcCBkdWUgdG8gcGFzc2luZyBhcmd1bWVudHMgb2JqZWN0IHRvXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgaXMgZmFzdGVyIGluIG1hbnkgSlMgZW5naW5lcyBhcyBvZiBsYXRlIDIwMTQuXG4gICAgdmFyIGN0b3JBcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY3RvckFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgY29uc3RydWN0b3IuIENhbGwgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuXG4gICAgcmV0dXJuIGNhbGxlci5zdXBlckNsYXNzXy5jb25zdHJ1Y3Rvci5hcHBseShtZSwgY3RvckFyZ3MpO1xuICB9XG5cbiAgLy8gQ29weWluZyB1c2luZyBsb29wIHRvIGF2b2lkIGRlb3AgZHVlIHRvIHBhc3NpbmcgYXJndW1lbnRzIG9iamVjdCB0b1xuICAvLyBmdW5jdGlvbi4gVGhpcyBpcyBmYXN0ZXIgaW4gbWFueSBKUyBlbmdpbmVzIGFzIG9mIGxhdGUgMjAxNC5cbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaSAtIDJdID0gYXJndW1lbnRzW2ldO1xuICB9XG4gIHZhciBmb3VuZENhbGxlciA9IGZhbHNlO1xuICBmb3IgKHZhciBjdG9yID0gbWUuY29uc3RydWN0b3I7XG4gICAgICAgY3RvcjsgY3RvciA9IGN0b3Iuc3VwZXJDbGFzc18gJiYgY3Rvci5zdXBlckNsYXNzXy5jb25zdHJ1Y3Rvcikge1xuICAgIGlmIChjdG9yLnByb3RvdHlwZVtvcHRfbWV0aG9kTmFtZV0gPT09IGNhbGxlcikge1xuICAgICAgZm91bmRDYWxsZXIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZm91bmRDYWxsZXIpIHtcbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZVtvcHRfbWV0aG9kTmFtZV0uYXBwbHkobWUsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGRpZCBub3QgZmluZCB0aGUgY2FsbGVyIGluIHRoZSBwcm90b3R5cGUgY2hhaW4sIHRoZW4gb25lIG9mIHR3b1xuICAvLyB0aGluZ3MgaGFwcGVuZWQ6XG4gIC8vIDEpIFRoZSBjYWxsZXIgaXMgYW4gaW5zdGFuY2UgbWV0aG9kLlxuICAvLyAyKSBUaGlzIG1ldGhvZCB3YXMgbm90IGNhbGxlZCBieSB0aGUgcmlnaHQgY2FsbGVyLlxuICBpZiAobWVbb3B0X21ldGhvZE5hbWVdID09PSBjYWxsZXIpIHtcbiAgICByZXR1cm4gbWUuY29uc3RydWN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdnb29nLmJhc2UgY2FsbGVkIGZyb20gYSBtZXRob2Qgb2Ygb25lIG5hbWUgJyArXG4gICAgICAgICd0byBhIG1ldGhvZCBvZiBhIGRpZmZlcmVudCBuYW1lJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBbGxvdyBmb3IgYWxpYXNpbmcgd2l0aGluIHNjb3BlIGZ1bmN0aW9ucy4gIFRoaXMgZnVuY3Rpb24gZXhpc3RzIGZvclxuICogdW5jb21waWxlZCBjb2RlIC0gaW4gY29tcGlsZWQgY29kZSB0aGUgY2FsbHMgd2lsbCBiZSBpbmxpbmVkIGFuZCB0aGUgYWxpYXNlc1xuICogYXBwbGllZC4gIEluIHVuY29tcGlsZWQgY29kZSB0aGUgZnVuY3Rpb24gaXMgc2ltcGx5IHJ1biBzaW5jZSB0aGUgYWxpYXNlcyBhc1xuICogd3JpdHRlbiBhcmUgdmFsaWQgSmF2YVNjcmlwdC5cbiAqXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBGdW5jdGlvbiB0byBjYWxsLiAgVGhpcyBmdW5jdGlvbiBjYW4gY29udGFpbiBhbGlhc2VzXG4gKiAgICAgdG8gbmFtZXNwYWNlcyAoZS5nLiBcInZhciBkb20gPSBnb29nLmRvbVwiKSBvciBjbGFzc2VzXG4gKiAgICAgKGUuZy4gXCJ2YXIgVGltZXIgPSBnb29nLlRpbWVyXCIpLlxuICovXG5nb29nLnNjb3BlID0gZnVuY3Rpb24oZm4pIHtcbiAgZm4uY2FsbChnb29nLmdsb2JhbCk7XG59O1xuXG5cbi8qXG4gKiBUbyBzdXBwb3J0IHVuY29tcGlsZWQsIHN0cmljdCBtb2RlIGJ1bmRsZXMgdGhhdCB1c2UgZXZhbCB0byBkaXZpZGUgc291cmNlXG4gKiBsaWtlIHNvOlxuICogICAgZXZhbCgnc29tZVNvdXJjZTsvLyMgc291cmNlVXJsIHNvdXJjZWZpbGUuanMnKTtcbiAqIFdlIG5lZWQgdG8gZXhwb3J0IHRoZSBnbG9iYWxseSBkZWZpbmVkIHN5bWJvbHMgXCJnb29nXCIgYW5kIFwiQ09NUElMRURcIi5cbiAqIEV4cG9ydGluZyBcImdvb2dcIiBicmVha3MgdGhlIGNvbXBpbGVyIG9wdGltaXphdGlvbnMsIHNvIHdlIHJlcXVpcmVkIHRoYXRcbiAqIGJlIGRlZmluZWQgZXh0ZXJuYWxseS5cbiAqIE5PVEU6IFdlIGRvbid0IHVzZSBnb29nLmV4cG9ydFN5bWJvbCBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyXG4gKiBleHRlcm4gZ2VuZXJhdGlvbiB3aGVuIHRoYXQgY29tcGlsZXIgb3B0aW9uIGlzIGVuYWJsZWQuXG4gKi9cbmlmICghQ09NUElMRUQpIHtcbiAgZ29vZy5nbG9iYWxbJ0NPTVBJTEVEJ10gPSBDT01QSUxFRDtcbn1cblxuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBnb29nLmRlZmluZUNsYXNzIGltcGxlbWVudGF0aW9uXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlc3RyaWN0ZWQgZm9ybSBvZiBhIENsb3N1cmUgXCJjbGFzc1wiOlxuICogICAtIGZyb20gdGhlIGNvbXBpbGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBpbnN0YW5jZSByZXR1cm5lZCBmcm9tIHRoZVxuICogICAgIGNvbnN0cnVjdG9yIGlzIHNlYWxlZCAobm8gbmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkKS4gIFRoaXMgZW5hYmxlc1xuICogICAgIGJldHRlciBjaGVja3MuXG4gKiAgIC0gdGhlIGNvbXBpbGVyIHdpbGwgcmV3cml0ZSB0aGlzIGRlZmluaXRpb24gdG8gYSBmb3JtIHRoYXQgaXMgb3B0aW1hbFxuICogICAgIGZvciB0eXBlIGNoZWNraW5nIGFuZCBvcHRpbWl6YXRpb24gKGluaXRpYWxseSB0aGlzIHdpbGwgYmUgYSBtb3JlXG4gKiAgICAgdHJhZGl0aW9uYWwgZm9ybSkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyBUaGUgc3VwZXJjbGFzcywgT2JqZWN0IG9yIG51bGwuXG4gKiBAcGFyYW0ge2dvb2cuZGVmaW5lQ2xhc3MuQ2xhc3NEZXNjcmlwdG9yfSBkZWZcbiAqICAgICBBbiBvYmplY3QgbGl0ZXJhbCBkZXNjcmliaW5nXG4gKiAgICAgdGhlIGNsYXNzLiAgSXQgbWF5IGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAgIFwiY29uc3RydWN0b3JcIjogdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiAgICAgXCJzdGF0aWNzXCI6IGFuIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgbWV0aG9kcyB0byBhZGQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gKiAgICAgICAgYXMgXCJzdGF0aWNcIiBtZXRob2RzIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGNvbnN0cnVjdG9yXG4gKiAgICAgICAgZnVuY3Rpb24gYXMgaXRzIG9ubHkgcGFyYW1ldGVyIHRvIHdoaWNoIHN0YXRpYyBwcm9wZXJ0aWVzIGNhblxuICogICAgICAgIGJlIGFkZGVkLlxuICogICAgIGFsbCBvdGhlciBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byB0aGUgcHJvdG90eXBlLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBUaGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKi9cbmdvb2cuZGVmaW5lQ2xhc3MgPSBmdW5jdGlvbihzdXBlckNsYXNzLCBkZWYpIHtcbiAgLy8gVE9ETyhqb2hubGVueik6IGNvbnNpZGVyIG1ha2luZyB0aGUgc3VwZXJDbGFzcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuXG4gIHZhciBjb25zdHJ1Y3RvciA9IGRlZi5jb25zdHJ1Y3RvcjtcbiAgdmFyIHN0YXRpY3MgPSBkZWYuc3RhdGljcztcbiAgLy8gV3JhcCB0aGUgY29uc3RydWN0b3IgcHJpb3IgdG8gc2V0dGluZyB1cCB0aGUgcHJvdG90eXBlIGFuZCBzdGF0aWMgbWV0aG9kcy5cbiAgaWYgKCFjb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvciA9PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IEVycm9yKCdjYW5ub3QgaW5zdGFudGlhdGUgYW4gaW50ZXJmYWNlIChubyBjb25zdHJ1Y3RvciBkZWZpbmVkKS4nKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNscyA9IGdvb2cuZGVmaW5lQ2xhc3MuY3JlYXRlU2VhbGluZ0NvbnN0cnVjdG9yXyhjb25zdHJ1Y3Rvciwgc3VwZXJDbGFzcyk7XG4gIGlmIChzdXBlckNsYXNzKSB7XG4gICAgZ29vZy5pbmhlcml0cyhjbHMsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3QgYmUgY29waWVkIHRvIHRoZSBwcm90b3R5cGUuXG4gIGRlbGV0ZSBkZWYuY29uc3RydWN0b3I7XG4gIGRlbGV0ZSBkZWYuc3RhdGljcztcblxuICBnb29nLmRlZmluZUNsYXNzLmFwcGx5UHJvcGVydGllc18oY2xzLnByb3RvdHlwZSwgZGVmKTtcbiAgaWYgKHN0YXRpY3MgIT0gbnVsbCkge1xuICAgIGlmIChzdGF0aWNzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHN0YXRpY3MoY2xzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ29vZy5kZWZpbmVDbGFzcy5hcHBseVByb3BlcnRpZXNfKGNscywgc3RhdGljcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNscztcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7XG4gKiAgICAgIU9iamVjdHxcbiAqICAgICB7Y29uc3RydWN0b3I6IUZ1bmN0aW9ufXxcbiAqICAgICB7Y29uc3RydWN0b3I6IUZ1bmN0aW9uLCBzdGF0aWNzOihPYmplY3R8ZnVuY3Rpb24oRnVuY3Rpb24pOnZvaWQpfX1cbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3ZpZGV9XG4gKi9cbmdvb2cuZGVmaW5lQ2xhc3MuQ2xhc3NEZXNjcmlwdG9yO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaW5zdGFuY2VzIHJldHVybmVkIGJ5XG4gKiBnb29nLmRlZmluZUNsYXNzIHNob3VsZCBiZSBzZWFsZWQgd2hlbiBwb3NzaWJsZS5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuZGVmaW5lQ2xhc3MuU0VBTF9DTEFTU19JTlNUQU5DRVMnLCBnb29nLkRFQlVHKTtcblxuXG4vKipcbiAqIElmIGdvb2cuZGVmaW5lQ2xhc3MuU0VBTF9DTEFTU19JTlNUQU5DRVMgaXMgZW5hYmxlZCBhbmQgT2JqZWN0LnNlYWwgaXNcbiAqIGRlZmluZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCB3cmFwIHRoZSBjb25zdHJ1Y3RvciBpbiBhIGZ1bmN0aW9uIHRoYXQgc2VhbHMgdGhlXG4gKiByZXN1bHRzIG9mIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY3RyIFRoZSBjb25zdHJ1Y3RvciB3aG9zZSByZXN1bHRzIG1heWJlIGJlIHNlYWxlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ2xhc3MgVGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJuIHshRnVuY3Rpb259IFRoZSByZXBsYWNlbWVudCBjb25zdHJ1Y3Rvci5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuZGVmaW5lQ2xhc3MuY3JlYXRlU2VhbGluZ0NvbnN0cnVjdG9yXyA9IGZ1bmN0aW9uKGN0ciwgc3VwZXJDbGFzcykge1xuICBpZiAoZ29vZy5kZWZpbmVDbGFzcy5TRUFMX0NMQVNTX0lOU1RBTkNFUyAmJlxuICAgICAgT2JqZWN0LnNlYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIC8vIERvbid0IHNlYWwgc3ViY2xhc3NlcyBvZiB1bnNlYWxhYmxlLXRhZ2dlZCBsZWdhY3kgY2xhc3Nlcy5cbiAgICBpZiAoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICBzdXBlckNsYXNzLnByb3RvdHlwZVtnb29nLlVOU0VBTEFCTEVfQ09OU1RSVUNUT1JfUFJPUEVSVFlfXSkge1xuICAgICAgcmV0dXJuIGN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRoaXMge09iamVjdH1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVkQ3RyID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEb24ndCBzZWFsIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgd2hlbiBpdCBjYWxscyB0aGUgY29uc3RydWN0b3Igb2ZcbiAgICAgIC8vIGl0cyBzdXBlciBjbGFzcyBhcyB0aGVyZSBpcyBtb3N0IGxpa2VseSBzdGlsbCBzZXR1cCB0byBkby5cbiAgICAgIHZhciBpbnN0YW5jZSA9IGN0ci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBpbnN0YW5jZVtnb29nLlVJRF9QUk9QRVJUWV9dID0gaW5zdGFuY2VbZ29vZy5VSURfUFJPUEVSVFlfXTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSB3cmFwcGVkQ3RyKSB7XG4gICAgICAgIE9iamVjdC5zZWFsKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICAgIHJldHVybiB3cmFwcGVkQ3RyO1xuICB9XG4gIHJldHVybiBjdHI7XG59O1xuXG5cbi8vIFRPRE8oam9obmxlbnopOiBzaGFyZSB0aGVzZSB2YWx1ZXMgd2l0aCB0aGUgZ29vZy5vYmplY3Rcbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBmaWVsZHMgdGhhdCBhcmUgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqIEBjb25zdFxuICovXG5nb29nLmRlZmluZUNsYXNzLk9CSkVDVF9QUk9UT1RZUEVfRklFTERTXyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLy8gVE9ETyhqb2hubGVueik6IHNoYXJlIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgZ29vZy5vYmplY3Rcbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBhZGQgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7IU9iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmRlZmluZUNsYXNzLmFwcGx5UHJvcGVydGllc18gPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBUT0RPKGpvaG5sZW56KTogdXBkYXRlIHRoaXMgdG8gc3VwcG9ydCBFUzUgZ2V0dGVycy9zZXR0ZXJzXG5cbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yIElFIHRoZSBmb3ItaW4tbG9vcCBkb2VzIG5vdCBjb250YWluIGFueSBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdFxuICAvLyBlbnVtZXJhYmxlIG9uIHRoZSBwcm90b3R5cGUgb2JqZWN0IChmb3IgZXhhbXBsZSBpc1Byb3RvdHlwZU9mIGZyb21cbiAgLy8gT2JqZWN0LnByb3RvdHlwZSkgYW5kIGl0IHdpbGwgYWxzbyBub3QgaW5jbHVkZSAncmVwbGFjZScgb24gb2JqZWN0cyB0aGF0XG4gIC8vIGV4dGVuZCBTdHJpbmcgYW5kIGNoYW5nZSAncmVwbGFjZScgKG5vdCB0aGF0IGl0IGlzIGNvbW1vbiBmb3IgYW55b25lIHRvXG4gIC8vIGV4dGVuZCBhbnl0aGluZyBleGNlcHQgT2JqZWN0KS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnb29nLmRlZmluZUNsYXNzLk9CSkVDVF9QUk9UT1RZUEVfRklFTERTXy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGdvb2cuZGVmaW5lQ2xhc3MuT0JKRUNUX1BST1RPVFlQRV9GSUVMRFNfW2ldO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNlYWxpbmcgY2xhc3NlcyBicmVha3MgdGhlIG9sZGVyIGlkaW9tIG9mIGFzc2lnbmluZyBwcm9wZXJ0aWVzIG9uIHRoZVxuICogcHJvdG90eXBlIHJhdGhlciB0aGFuIGluIHRoZSBjb25zdHJ1Y3Rvci4gIEFzIHN1Y2gsIGdvb2cuZGVmaW5lQ2xhc3NcbiAqIG11c3Qgbm90IHNlYWwgc3ViY2xhc3NlcyBvZiB0aGVzZSBvbGQtc3R5bGUgY2xhc3NlcyB1bnRpbCB0aGV5IGFyZSBmaXhlZC5cbiAqIFVudGlsIHRoZW4sIHRoaXMgbWFya3MgYSBjbGFzcyBhcyBcImJyb2tlblwiLCBpbnN0cnVjdGluZyBkZWZpbmVDbGFzc1xuICogbm90IHRvIHNlYWwgc3ViY2xhc3Nlcy5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjdHIgVGhlIGxlZ2FjeSBjb25zdHJ1Y3RvciB0byB0YWcgYXMgdW5zZWFsYWJsZS5cbiAqL1xuZ29vZy50YWdVbnNlYWxhYmxlQ2xhc3MgPSBmdW5jdGlvbihjdHIpIHtcbiAgaWYgKCFDT01QSUxFRCAmJiBnb29nLmRlZmluZUNsYXNzLlNFQUxfQ0xBU1NfSU5TVEFOQ0VTKSB7XG4gICAgY3RyLnByb3RvdHlwZVtnb29nLlVOU0VBTEFCTEVfQ09OU1RSVUNUT1JfUFJPUEVSVFlfXSA9IHRydWU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBOYW1lIGZvciB1bnNlYWxhYmxlIHRhZyBwcm9wZXJ0eS5cbiAqIEBjb25zdCBAcHJpdmF0ZSB7c3RyaW5nfVxuICovXG5nb29nLlVOU0VBTEFCTEVfQ09OU1RSVUNUT1JfUFJPUEVSVFlfID0gJ2dvb2dfZGVmaW5lQ2xhc3NfbGVnYWN5X3Vuc2VhbGFibGUnO1xuIiwiLy8gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBQcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIGN1c3RvbSBFcnJvciBvYmplY3RzIHN1Y2ggdGhhdCB0aGVcbiAqIHN0YWNrIGlzIGNvcnJlY3RseSBtYWludGFpbmVkLlxuICpcbiAqIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byB0aHJvdyBnb29nLmRlYnVnLkVycm9yKG1zZykgZGlyZWN0bHksIEVycm9yKG1zZykgaXNcbiAqIHN1ZmZpY2llbnQuXG4gKlxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5kZWJ1Zy5FcnJvcicpO1xuXG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjdXN0b20gZXJyb3Igb2JqZWN0cy5cbiAqIEBwYXJhbSB7Kj19IG9wdF9tc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5nb29nLmRlYnVnLkVycm9yID0gZnVuY3Rpb24ob3B0X21zZykge1xuXG4gIC8vIEF0dGVtcHQgdG8gZW5zdXJlIHRoZXJlIGlzIGEgc3RhY2sgdHJhY2UuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdvb2cuZGVidWcuRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIGlmIChzdGFjaykge1xuICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRfbXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gU3RyaW5nKG9wdF9tc2cpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVwb3J0IHRoaXMgZXJyb3IgdG8gdGhlIHNlcnZlci4gU2V0dGluZyB0aGlzIHRvIGZhbHNlIHdpbGxcbiAgICogY2F1c2UgdGhlIGVycm9yIHJlcG9ydGVyIHRvIG5vdCByZXBvcnQgdGhlIGVycm9yIGJhY2sgdG8gdGhlIHNlcnZlcixcbiAgICogd2hpY2ggY2FuIGJlIHVzZWZ1bCBpZiB0aGUgY2xpZW50IGtub3dzIHRoYXQgdGhlIGVycm9yIGhhcyBhbHJlYWR5IGJlZW5cbiAgICogbG9nZ2VkIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5yZXBvcnRFcnJvclRvU2VydmVyID0gdHJ1ZTtcbn07XG5nb29nLmluaGVyaXRzKGdvb2cuZGVidWcuRXJyb3IsIEVycm9yKTtcblxuXG4vKiogQG92ZXJyaWRlICovXG5nb29nLmRlYnVnLkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0N1c3RvbUVycm9yJztcbiIsIi8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5pdGlvbiBvZiBnb29nLmRvbS5Ob2RlVHlwZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ2dvb2cuZG9tLk5vZGVUeXBlJyk7XG5cblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIHRoZSBub2RlVHlwZSBhdHRyaWJ1dGUgaW4gdGhlIE5vZGUgaW50ZXJmYWNlLlxuICpcbiAqIFRoZXNlIGNvbnN0YW50cyBtYXRjaCB0aG9zZSBzcGVjaWZpZWQgaW4gdGhlIE5vZGUgaW50ZXJmYWNlLiBUaGVzZSBhcmVcbiAqIHVzdWFsbHkgcHJlc2VudCBvbiB0aGUgTm9kZSBvYmplY3QgaW4gcmVjZW50IGJyb3dzZXJzLCBidXQgbm90IGluIG9sZGVyXG4gKiBicm93c2VycyAoc3BlY2lmaWNhbGx5LCBlYXJseSBJRXMpIGFuZCB0aHVzIGFyZSBnaXZlbiBoZXJlLlxuICpcbiAqIEluIHNvbWUgYnJvd3NlcnMgKGVhcmx5IElFcyksIHRoZXNlIGFyZSBub3QgZGVmaW5lZCBvbiB0aGUgTm9kZSBvYmplY3QsXG4gKiBzbyB0aGV5IGFyZSBwcm92aWRlZCBoZXJlLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlL2NvcmUuaHRtbCNJRC0xOTUwNjQxMjQ3XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5nb29nLmRvbS5Ob2RlVHlwZSA9IHtcbiAgRUxFTUVOVDogMSxcbiAgQVRUUklCVVRFOiAyLFxuICBURVhUOiAzLFxuICBDREFUQV9TRUNUSU9OOiA0LFxuICBFTlRJVFlfUkVGRVJFTkNFOiA1LFxuICBFTlRJVFk6IDYsXG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT046IDcsXG4gIENPTU1FTlQ6IDgsXG4gIERPQ1VNRU5UOiA5LFxuICBET0NVTUVOVF9UWVBFOiAxMCxcbiAgRE9DVU1FTlRfRlJBR01FTlQ6IDExLFxuICBOT1RBVElPTjogMTJcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAwNiBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdGllcyBmb3Igc3RyaW5nIG1hbmlwdWxhdGlvbi5cbiAqIEBhdXRob3IgYXJ2QGdvb2dsZS5jb20gKEVyaWsgQXJ2aWRzc29uKVxuICovXG5cblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIHN0cmluZyB1dGlsaXRpZXNcbiAqL1xuZ29vZy5wcm92aWRlKCdnb29nLnN0cmluZycpO1xuZ29vZy5wcm92aWRlKCdnb29nLnN0cmluZy5Vbmljb2RlJyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBFbmFibGVzIEhUTUwgZXNjYXBpbmcgb2YgbG93ZXJjYXNlIGxldHRlciBcImVcIiB3aGljaCBoZWxwc1xuICogd2l0aCBkZXRlY3Rpb24gb2YgZG91YmxlLWVzY2FwaW5nIGFzIHRoaXMgbGV0dGVyIGlzIGZyZXF1ZW50bHkgdXNlZC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIGZvcmNlIG5vbi1kb20gaHRtbCB1bmVzY2FwaW5nLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5zdHJpbmcuRk9SQ0VfTk9OX0RPTV9IVE1MX1VORVNDQVBJTkcnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBDb21tb24gVW5pY29kZSBzdHJpbmcgY2hhcmFjdGVycy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmdvb2cuc3RyaW5nLlVuaWNvZGUgPSB7XG4gIE5CU1A6ICdcXHhhMCdcbn07XG5cblxuLyoqXG4gKiBGYXN0IHByZWZpeC1jaGVja2VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBBIHN0cmluZyB0byBsb29rIGZvciBhdCB0aGUgc3RhcnQgb2Yge0Bjb2RlIHN0cn0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHtAY29kZSBzdHJ9IGJlZ2lucyB3aXRoIHtAY29kZSBwcmVmaXh9LlxuICovXG5nb29nLnN0cmluZy5zdGFydHNXaXRoID0gZnVuY3Rpb24oc3RyLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHN0ci5sYXN0SW5kZXhPZihwcmVmaXgsIDApID09IDA7XG59O1xuXG5cbi8qKlxuICogRmFzdCBzdWZmaXgtY2hlY2tlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXggQSBzdHJpbmcgdG8gbG9vayBmb3IgYXQgdGhlIGVuZCBvZiB7QGNvZGUgc3RyfS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYge0Bjb2RlIHN0cn0gZW5kcyB3aXRoIHtAY29kZSBzdWZmaXh9LlxuICovXG5nb29nLnN0cmluZy5lbmRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgc3VmZml4KSB7XG4gIHZhciBsID0gc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGg7XG4gIHJldHVybiBsID49IDAgJiYgc3RyLmluZGV4T2Yoc3VmZml4LCBsKSA9PSBsO1xufTtcblxuXG4vKipcbiAqIENhc2UtaW5zZW5zaXRpdmUgcHJlZml4LWNoZWNrZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4ICBBIHN0cmluZyB0byBsb29rIGZvciBhdCB0aGUgZW5kIG9mIHtAY29kZSBzdHJ9LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB7QGNvZGUgc3RyfSBiZWdpbnMgd2l0aCB7QGNvZGUgcHJlZml4fSAoaWdub3JpbmdcbiAqICAgICBjYXNlKS5cbiAqL1xuZ29vZy5zdHJpbmcuY2FzZUluc2Vuc2l0aXZlU3RhcnRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgcHJlZml4KSB7XG4gIHJldHVybiBnb29nLnN0cmluZy5jYXNlSW5zZW5zaXRpdmVDb21wYXJlKFxuICAgICAgcHJlZml4LCBzdHIuc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpKSA9PSAwO1xufTtcblxuXG4vKipcbiAqIENhc2UtaW5zZW5zaXRpdmUgc3VmZml4LWNoZWNrZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gc3VmZml4IEEgc3RyaW5nIHRvIGxvb2sgZm9yIGF0IHRoZSBlbmQgb2Yge0Bjb2RlIHN0cn0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHtAY29kZSBzdHJ9IGVuZHMgd2l0aCB7QGNvZGUgc3VmZml4fSAoaWdub3JpbmdcbiAqICAgICBjYXNlKS5cbiAqL1xuZ29vZy5zdHJpbmcuY2FzZUluc2Vuc2l0aXZlRW5kc1dpdGggPSBmdW5jdGlvbihzdHIsIHN1ZmZpeCkge1xuICByZXR1cm4gZ29vZy5zdHJpbmcuY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShcbiAgICAgIHN1ZmZpeCwgc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCwgc3VmZml4Lmxlbmd0aCkpID09IDA7XG59O1xuXG5cbi8qKlxuICogQ2FzZS1pbnNlbnNpdGl2ZSBlcXVhbGl0eSBjaGVja2VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjEgRmlyc3Qgc3RyaW5nIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjIgU2Vjb25kIHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYge0Bjb2RlIHN0cjF9IGFuZCB7QGNvZGUgc3RyMn0gYXJlIHRoZSBzYW1lIHN0cmluZyxcbiAqICAgICBpZ25vcmluZyBjYXNlLlxuICovXG5nb29nLnN0cmluZy5jYXNlSW5zZW5zaXRpdmVFcXVhbHMgPSBmdW5jdGlvbihzdHIxLCBzdHIyKSB7XG4gIHJldHVybiBzdHIxLnRvTG93ZXJDYXNlKCkgPT0gc3RyMi50b0xvd2VyQ2FzZSgpO1xufTtcblxuXG4vKipcbiAqIERvZXMgc2ltcGxlIHB5dGhvbi1zdHlsZSBzdHJpbmcgc3Vic3RpdHV0aW9uLlxuICogc3VicyhcImZvbyVzIGhvdCVzXCIsIFwiYmFyXCIsIFwiZG9nXCIpIGJlY29tZXMgXCJmb29iYXIgaG90ZG9nXCIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgcGF0dGVybi5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgcGF0dGVybi5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBjb3B5IG9mIHtAY29kZSBzdHJ9IGluIHdoaWNoIGVhY2ggb2NjdXJyZW5jZSBvZlxuICogICAgIHtAY29kZSAlc30gaGFzIGJlZW4gcmVwbGFjZWQgYW4gYXJndW1lbnQgZnJvbSB7QGNvZGUgdmFyX2FyZ3N9LlxuICovXG5nb29nLnN0cmluZy5zdWJzID0gZnVuY3Rpb24oc3RyLCB2YXJfYXJncykge1xuICB2YXIgc3BsaXRQYXJ0cyA9IHN0ci5zcGxpdCgnJXMnKTtcbiAgdmFyIHJldHVyblN0cmluZyA9ICcnO1xuXG4gIHZhciBzdWJzQXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHN1YnNBcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAvLyBSZXBsYWNlIHVwIHRvIHRoZSBsYXN0IHNwbGl0IHBhcnQuIFdlIGFyZSBpbnNlcnRpbmcgaW4gdGhlXG4gICAgICAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBzcGxpdCBwYXJ0cy5cbiAgICAgICAgIHNwbGl0UGFydHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVyblN0cmluZyArPSBzcGxpdFBhcnRzLnNoaWZ0KCkgKyBzdWJzQXJndW1lbnRzLnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuU3RyaW5nICsgc3BsaXRQYXJ0cy5qb2luKCclcycpOyAvLyBKb2luIHVudXNlZCAnJXMnXG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgbXVsdGlwbGUgd2hpdGVzcGFjZSBjaGFycyAoc3BhY2VzLCBub24tYnJlYWtpbmctc3BhY2VzLCBuZXcgbGluZXNcbiAqIGFuZCB0YWJzKSB0byBhIHNpbmdsZSBzcGFjZSwgYW5kIHN0cmlwcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBJbnB1dCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgY29weSBvZiB7QGNvZGUgc3RyfSB3aXRoIGNvbGxhcHNlZCB3aGl0ZXNwYWNlLlxuICovXG5nb29nLnN0cmluZy5jb2xsYXBzZVdoaXRlc3BhY2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgLy8gU2luY2UgSUUgZG9lc24ndCBpbmNsdWRlIG5vbi1icmVha2luZy1zcGFjZSAoMHhhMCkgaW4gdGhlaXIgXFxzIGNoYXJhY3RlclxuICAvLyBjbGFzcyAoYXMgcmVxdWlyZWQgYnkgc2VjdGlvbiA3LjIgb2YgdGhlIEVDTUFTY3JpcHQgc3BlYyksIHdlIGV4cGxpY2l0bHlcbiAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgcmVnZXhwIHRvIGVuZm9yY2UgY29uc2lzdGVudCBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHNcXHhhMF0rL2csICcgJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB7QGNvZGUgc3RyfSBpcyBlbXB0eSBvciB3aGl0ZXNwYWNlIG9ubHkuXG4gKi9cbmdvb2cuc3RyaW5nLmlzRW1wdHlPcldoaXRlc3BhY2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgLy8gdGVzdGluZyBsZW5ndGggPT0gMCBmaXJzdCBpcyBhY3R1YWxseSBzbG93ZXIgaW4gYWxsIGJyb3dzZXJzIChhYm91dCB0aGVcbiAgLy8gc2FtZSBpbiBPcGVyYSkuXG4gIC8vIFNpbmNlIElFIGRvZXNuJ3QgaW5jbHVkZSBub24tYnJlYWtpbmctc3BhY2UgKDB4YTApIGluIHRoZWlyIFxccyBjaGFyYWN0ZXJcbiAgLy8gY2xhc3MgKGFzIHJlcXVpcmVkIGJ5IHNlY3Rpb24gNy4yIG9mIHRoZSBFQ01BU2NyaXB0IHNwZWMpLCB3ZSBleHBsaWNpdGx5XG4gIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHJlZ2V4cCB0byBlbmZvcmNlIGNvbnNpc3RlbnQgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgcmV0dXJuIC9eW1xcc1xceGEwXSokLy50ZXN0KHN0cik7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGVtcHR5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB7QGNvZGUgc3RyfSBpcyBlbXB0eS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA9PSAwO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLlxuICpcbiAqIFRPRE8odXNlcik6IERlcHJlY2F0ZSB0aGlzIHdoZW4gY2xpZW50cyBoYXZlIGJlZW4gc3dpdGNoZWQgb3ZlciB0b1xuICogZ29vZy5zdHJpbmcuaXNFbXB0eU9yV2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHtAY29kZSBzdHJ9IGlzIGVtcHR5IG9yIHdoaXRlc3BhY2Ugb25seS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNFbXB0eSA9IGdvb2cuc3RyaW5nLmlzRW1wdHlPcldoaXRlc3BhY2U7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgbnVsbCwgdW5kZWZpbmVkLCBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLlxuICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIge0Bjb2RlIHN0cn0gaXMgbnVsbCwgdW5kZWZpbmVkLCBlbXB0eSwgb3JcbiAqICAgICB3aGl0ZXNwYWNlIG9ubHkuXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ29vZy5zdHJpbmcuaXNFbXB0eU9yV2hpdGVzcGFjZShnb29nLnN0cmluZy5tYWtlU2FmZShzdHIpKVxuICogICAgIGluc3RlYWQuXG4gKi9cbmdvb2cuc3RyaW5nLmlzRW1wdHlPcldoaXRlc3BhY2VTYWZlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBnb29nLnN0cmluZy5pc0VtcHR5T3JXaGl0ZXNwYWNlKGdvb2cuc3RyaW5nLm1ha2VTYWZlKHN0cikpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBudWxsLCB1bmRlZmluZWQsIGVtcHR5IG9yIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZXMuXG4gKlxuICogVE9ETyh1c2VyKTogRGVwcmVjYXRlIHRoaXMgd2hlbiBjbGllbnRzIGhhdmUgYmVlbiBzd2l0Y2hlZCBvdmVyIHRvXG4gKiBnb29nLnN0cmluZy5pc0VtcHR5T3JXaGl0ZXNwYWNlU2FmZS5cbiAqXG4gKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB7QGNvZGUgc3RyfSBpcyBudWxsLCB1bmRlZmluZWQsIGVtcHR5LCBvclxuICogICAgIHdoaXRlc3BhY2Ugb25seS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNFbXB0eVNhZmUgPSBnb29nLnN0cmluZy5pc0VtcHR5T3JXaGl0ZXNwYWNlU2FmZTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhbGwgYnJlYWtpbmcgd2hpdGVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN0cmluZyBpcyBhbGwgYnJlYWtpbmcgd2hpdGVzcGFjZS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNCcmVha2luZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuICEvW15cXHRcXG5cXHIgXS8udGVzdChzdHIpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBjb250YWlucyBhbGwgbGV0dGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB7QGNvZGUgc3RyfSBjb25zaXN0cyBlbnRpcmVseSBvZiBsZXR0ZXJzLlxuICovXG5nb29nLnN0cmluZy5pc0FscGhhID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAhL1teYS16QS1aXS8udGVzdChzdHIpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBjb250YWlucyBvbmx5IG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IHN0ciBzdHJpbmcgdG8gY2hlY2suIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZVxuICogICAgIGNhc3RlZCB0byBvbmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHtAY29kZSBzdHJ9IGlzIG51bWVyaWMuXG4gKi9cbmdvb2cuc3RyaW5nLmlzTnVtZXJpYyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gIS9bXjAtOV0vLnRlc3Qoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgY29udGFpbnMgb25seSBudW1iZXJzIG9yIGxldHRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYge0Bjb2RlIHN0cn0gaXMgYWxwaGFudW1lcmljLlxuICovXG5nb29nLnN0cmluZy5pc0FscGhhTnVtZXJpYyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gIS9bXmEtekEtWjAtOV0vLnRlc3Qoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaXMgYSBzcGFjZSBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2ggQ2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB7QGNvZGUgY2h9IGlzIGEgc3BhY2UuXG4gKi9cbmdvb2cuc3RyaW5nLmlzU3BhY2UgPSBmdW5jdGlvbihjaCkge1xuICByZXR1cm4gY2ggPT0gJyAnO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNoYXJhY3RlciBpcyBhIHZhbGlkIHVuaWNvZGUgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoIENoYXJhY3RlciB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYge0Bjb2RlIGNofSBpcyBhIHZhbGlkIHVuaWNvZGUgY2hhcmFjdGVyLlxuICovXG5nb29nLnN0cmluZy5pc1VuaWNvZGVDaGFyID0gZnVuY3Rpb24oY2gpIHtcbiAgcmV0dXJuIGNoLmxlbmd0aCA9PSAxICYmIGNoID49ICcgJyAmJiBjaCA8PSAnficgfHxcbiAgICAgICAgIGNoID49ICdcXHUwMDgwJyAmJiBjaCA8PSAnXFx1RkZGRCc7XG59O1xuXG5cbi8qKlxuICogVGFrZXMgYSBzdHJpbmcgYW5kIHJlcGxhY2VzIG5ld2xpbmVzIHdpdGggYSBzcGFjZS4gTXVsdGlwbGUgbGluZXMgYXJlXG4gKiByZXBsYWNlZCB3aXRoIGEgc2luZ2xlIHNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIGZyb20gd2hpY2ggdG8gc3RyaXAgbmV3bGluZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgY29weSBvZiB7QGNvZGUgc3RyfSBzdHJpcHBlZCBvZiBuZXdsaW5lcy5cbiAqL1xuZ29vZy5zdHJpbmcuc3RyaXBOZXdsaW5lcyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhcXHJcXG58XFxyfFxcbikrL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogUmVwbGFjZXMgV2luZG93cyBhbmQgTWFjIG5ldyBsaW5lcyB3aXRoIHVuaXggc3R5bGU6IFxcciBvciBcXHJcXG4gd2l0aCBcXG4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gaW4gd2hpY2ggdG8gY2Fub25pY2FsaXplIG5ld2xpbmVzLlxuICogQHJldHVybiB7c3RyaW5nfSB7QGNvZGUgc3RyfSBBIGNvcHkgb2Yge0Bjb2RlfSB3aXRoIGNhbm9uaWNhbGl6ZWQgbmV3bGluZXMuXG4gKi9cbmdvb2cuc3RyaW5nLmNhbm9uaWNhbGl6ZU5ld2xpbmVzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKS9nLCAnXFxuJyk7XG59O1xuXG5cbi8qKlxuICogTm9ybWFsaXplcyB3aGl0ZXNwYWNlIGluIGEgc3RyaW5nLCByZXBsYWNpbmcgYWxsIHdoaXRlc3BhY2UgY2hhcnMgd2l0aFxuICogYSBzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBpbiB3aGljaCB0byBub3JtYWxpemUgd2hpdGVzcGFjZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBjb3B5IG9mIHtAY29kZSBzdHJ9IHdpdGggYWxsIHdoaXRlc3BhY2Ugbm9ybWFsaXplZC5cbiAqL1xuZ29vZy5zdHJpbmcubm9ybWFsaXplV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xceGEwfFxccy9nLCAnICcpO1xufTtcblxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgc3BhY2VzIGluIGEgc3RyaW5nLCByZXBsYWNpbmcgYWxsIGNvbnNlY3V0aXZlIHNwYWNlcyBhbmQgdGFic1xuICogd2l0aCBhIHNpbmdsZSBzcGFjZS4gUmVwbGFjZXMgbm9uLWJyZWFraW5nIHNwYWNlIHdpdGggYSBzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBpbiB3aGljaCB0byBub3JtYWxpemUgc3BhY2VzLlxuICogQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN0cn0gd2l0aCBhbGwgY29uc2VjdXRpdmUgc3BhY2VzIGFuZCB0YWJzXG4gKiAgICByZXBsYWNlZCB3aXRoIGEgc2luZ2xlIHNwYWNlLlxuICovXG5nb29nLnN0cmluZy5ub3JtYWxpemVTcGFjZXMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHhhMHxbIFxcdF0rL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gKi9cbmdvb2cuc3RyaW5nLmNvbGxhcHNlQnJlYWtpbmdTcGFjZXMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZShcbiAgICAgIC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG59O1xuXG5cbi8qKlxuICogVHJpbXMgd2hpdGUgc3BhY2VzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHRyaW1tZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAqL1xuZ29vZy5zdHJpbmcudHJpbSA9IChnb29nLlRSVVNURURfU0lURSAmJiBTdHJpbmcucHJvdG90eXBlLnRyaW0pID9cbiAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKHN0cikge1xuICAgICAgLy8gU2luY2UgSUUgZG9lc24ndCBpbmNsdWRlIG5vbi1icmVha2luZy1zcGFjZSAoMHhhMCkgaW4gdGhlaXIgXFxzXG4gICAgICAvLyBjaGFyYWN0ZXIgY2xhc3MgKGFzIHJlcXVpcmVkIGJ5IHNlY3Rpb24gNy4yIG9mIHRoZSBFQ01BU2NyaXB0IHNwZWMpLFxuICAgICAgLy8gd2UgZXhwbGljaXRseSBpbmNsdWRlIGl0IGluIHRoZSByZWdleHAgdG8gZW5mb3JjZSBjb25zaXN0ZW50XG4gICAgICAvLyBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csICcnKTtcbiAgICB9O1xuXG5cbi8qKlxuICogVHJpbXMgd2hpdGVzcGFjZXMgYXQgdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxlZnQgdHJpbS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSB0cmltbWVkIGNvcHkgb2Yge0Bjb2RlIHN0cn0uXG4gKi9cbmdvb2cuc3RyaW5nLnRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIFNpbmNlIElFIGRvZXNuJ3QgaW5jbHVkZSBub24tYnJlYWtpbmctc3BhY2UgKDB4YTApIGluIHRoZWlyIFxccyBjaGFyYWN0ZXJcbiAgLy8gY2xhc3MgKGFzIHJlcXVpcmVkIGJ5IHNlY3Rpb24gNy4yIG9mIHRoZSBFQ01BU2NyaXB0IHNwZWMpLCB3ZSBleHBsaWNpdGx5XG4gIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHJlZ2V4cCB0byBlbmZvcmNlIGNvbnNpc3RlbnQgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xceGEwXSsvLCAnJyk7XG59O1xuXG5cbi8qKlxuICogVHJpbXMgd2hpdGVzcGFjZXMgYXQgdGhlIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byByaWdodCB0cmltLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHRyaW1tZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAqL1xuZ29vZy5zdHJpbmcudHJpbVJpZ2h0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIFNpbmNlIElFIGRvZXNuJ3QgaW5jbHVkZSBub24tYnJlYWtpbmctc3BhY2UgKDB4YTApIGluIHRoZWlyIFxccyBjaGFyYWN0ZXJcbiAgLy8gY2xhc3MgKGFzIHJlcXVpcmVkIGJ5IHNlY3Rpb24gNy4yIG9mIHRoZSBFQ01BU2NyaXB0IHNwZWMpLCB3ZSBleHBsaWNpdGx5XG4gIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHJlZ2V4cCB0byBlbmZvcmNlIGNvbnNpc3RlbnQgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzXFx4YTBdKyQvLCAnJyk7XG59O1xuXG5cbi8qKlxuICogQSBzdHJpbmcgY29tcGFyYXRvciB0aGF0IGlnbm9yZXMgY2FzZS5cbiAqIC0xID0gc3RyMSBsZXNzIHRoYW4gc3RyMlxuICogIDAgPSBzdHIxIGVxdWFscyBzdHIyXG4gKiAgMSA9IHN0cjEgZ3JlYXRlciB0aGFuIHN0cjJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUge0Bjb2RlIHN0cjF9IHRvLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29tcGFyYXRvciByZXN1bHQsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqL1xuZ29vZy5zdHJpbmcuY2FzZUluc2Vuc2l0aXZlQ29tcGFyZSA9IGZ1bmN0aW9uKHN0cjEsIHN0cjIpIHtcbiAgdmFyIHRlc3QxID0gU3RyaW5nKHN0cjEpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICh0ZXN0MSA8IHRlc3QyKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHRlc3QxID09IHRlc3QyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBmb3Igc3BsaXR0aW5nIGEgc3RyaW5nIGludG8gc3Vic3RyaW5ncyBvZiBmcmFjdGlvbmFsXG4gKiBudW1iZXJzLCBpbnRlZ2VycywgYW5kIG5vbi1udW1lcmljIGNoYXJhY3RlcnMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcubnVtZXJhdGVDb21wYXJlUmVnRXhwXyA9IC8oXFwuXFxkKyl8KFxcZCspfChcXEQrKS9nO1xuXG5cbi8qKlxuICogU3RyaW5nIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdCBoYW5kbGVzIG51bWJlcnMgaW4gYSB3YXkgaHVtYW5zIG1pZ2h0IGV4cGVjdC5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSBzdHJpbmcgXCJGaWxlIDIuanBnXCIgc29ydHMgYmVmb3JlIFwiRmlsZSAxMC5qcGdcIi4gVGhlXG4gKiBjb21wYXJpc29uIGlzIG1vc3RseSBjYXNlLWluc2Vuc2l0aXZlLCB0aG91Z2ggc3RyaW5ncyB0aGF0IGFyZSBpZGVudGljYWxcbiAqIGV4Y2VwdCBmb3IgY2FzZSBhcmUgc29ydGVkIHdpdGggdGhlIHVwcGVyLWNhc2Ugc3RyaW5ncyBiZWZvcmUgbG93ZXItY2FzZS5cbiAqXG4gKiBUaGlzIGNvbXBhcmlzb24gZnVuY3Rpb24gaXMgc2lnbmlmaWNhbnRseSBzbG93ZXIgKGFib3V0IDUwMHgpIHRoYW4gZWl0aGVyXG4gKiB0aGUgZGVmYXVsdCBvciB0aGUgY2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJlLiBJdCBzaG91bGQgbm90IGJlIHVzZWQgaW5cbiAqIHRpbWUtY3JpdGljYWwgY29kZSwgYnV0IHNob3VsZCBiZSBmYXN0IGVub3VnaCB0byBzb3J0IHNldmVyYWwgaHVuZHJlZCBzaG9ydFxuICogc3RyaW5ncyAobGlrZSBmaWxlbmFtZXMpIHdpdGggYSByZWFzb25hYmxlIGRlbGF5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIxIFRoZSBzdHJpbmcgdG8gY29tcGFyZSBpbiBhIG51bWVyaWNhbGx5IHNlbnNpdGl2ZSB3YXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMiBUaGUgc3RyaW5nIHRvIGNvbXBhcmUge0Bjb2RlIHN0cjF9IHRvLlxuICogQHJldHVybiB7bnVtYmVyfSBsZXNzIHRoYW4gMCBpZiBzdHIxIDwgc3RyMiwgMCBpZiBzdHIxID09IHN0cjIsIGdyZWF0ZXIgdGhhblxuICogICAgIDAgaWYgc3RyMSA+IHN0cjIuXG4gKi9cbmdvb2cuc3RyaW5nLm51bWVyYXRlQ29tcGFyZSA9IGZ1bmN0aW9uKHN0cjEsIHN0cjIpIHtcbiAgaWYgKHN0cjEgPT0gc3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICghc3RyMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoIXN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIFVzaW5nIG1hdGNoIHRvIHNwbGl0IHRoZSBlbnRpcmUgc3RyaW5nIGFoZWFkIG9mIHRpbWUgdHVybnMgb3V0IHRvIGJlIGZhc3RlclxuICAvLyBmb3IgbW9zdCBpbnB1dHMgdGhhbiB1c2luZyBSZWdFeHAuZXhlYyBvciBpdGVyYXRpbmcgb3ZlciBlYWNoIGNoYXJhY3Rlci5cbiAgdmFyIHRva2VuczEgPSBzdHIxLnRvTG93ZXJDYXNlKCkubWF0Y2goZ29vZy5zdHJpbmcubnVtZXJhdGVDb21wYXJlUmVnRXhwXyk7XG4gIHZhciB0b2tlbnMyID0gc3RyMi50b0xvd2VyQ2FzZSgpLm1hdGNoKGdvb2cuc3RyaW5nLm51bWVyYXRlQ29tcGFyZVJlZ0V4cF8pO1xuXG4gIHZhciBjb3VudCA9IE1hdGgubWluKHRva2VuczEubGVuZ3RoLCB0b2tlbnMyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0b2tlbnMxW2ldO1xuICAgIHZhciBiID0gdG9rZW5zMltpXTtcblxuICAgIC8vIENvbXBhcmUgcGFpcnMgb2YgdG9rZW5zLCByZXR1cm5pbmcgaWYgb25lIHRva2VuIHNvcnRzIGJlZm9yZSB0aGUgb3RoZXIuXG4gICAgaWYgKGEgIT0gYikge1xuXG4gICAgICAvLyBPbmx5IGlmIGJvdGggdG9rZW5zIGFyZSBpbnRlZ2VycyBpcyBhIHNwZWNpYWwgY29tcGFyaXNvbiByZXF1aXJlZC5cbiAgICAgIC8vIERlY2ltYWwgbnVtYmVycyBhcmUgc29ydGVkIGFzIHN0cmluZ3MgKGUuZy4sICcuMDknIDwgJy4xJykuXG4gICAgICB2YXIgbnVtMSA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICAgIGlmICghaXNOYU4obnVtMSkpIHtcbiAgICAgICAgdmFyIG51bTIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4obnVtMikgJiYgbnVtMSAtIG51bTIpIHtcbiAgICAgICAgICByZXR1cm4gbnVtMSAtIG51bTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBvbmUgc3RyaW5nIGlzIGEgc3Vic3RyaW5nIG9mIHRoZSBvdGhlciwgdGhlIHNob3J0ZXIgc3RyaW5nIHNvcnRzIGZpcnN0LlxuICBpZiAodG9rZW5zMS5sZW5ndGggIT0gdG9rZW5zMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gdG9rZW5zMS5sZW5ndGggLSB0b2tlbnMyLmxlbmd0aDtcbiAgfVxuXG4gIC8vIFRoZSB0d28gc3RyaW5ncyBtdXN0IGJlIGVxdWl2YWxlbnQgZXhjZXB0IGZvciBjYXNlIChwZXJmZWN0IGVxdWFsaXR5IGlzXG4gIC8vIHRlc3RlZCBhdCB0aGUgaGVhZCBvZiB0aGUgZnVuY3Rpb24uKSBSZXZlcnQgdG8gZGVmYXVsdCBBU0NJSS1iZXRpY2FsIHN0cmluZ1xuICAvLyBjb21wYXJpc29uIHRvIHN0YWJsaXplIHRoZSBzb3J0LlxuICByZXR1cm4gc3RyMSA8IHN0cjIgPyAtMSA6IDE7XG59O1xuXG5cbi8qKlxuICogVVJMLWVuY29kZXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gdXJsLWVuY29kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZW5jb2RlZCBjb3B5IG9mIHtAY29kZSBzdHJ9IHRoYXQgaXMgc2FmZSBmb3IgdXJscy5cbiAqICAgICBOb3RlIHRoYXQgJyMnLCAnOicsIGFuZCBvdGhlciBjaGFyYWN0ZXJzIHVzZWQgdG8gZGVsaW1pdCBwb3J0aW9uc1xuICogICAgIG9mIFVSTHMgKndpbGwqIGJlIGVuY29kZWQuXG4gKi9cbmdvb2cuc3RyaW5nLnVybEVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzdHIpKTtcbn07XG5cblxuLyoqXG4gKiBVUkwtZGVjb2RlcyB0aGUgc3RyaW5nLiBXZSBuZWVkIHRvIHNwZWNpYWxseSBoYW5kbGUgJysncyBiZWNhdXNlXG4gKiB0aGUgamF2YXNjcmlwdCBsaWJyYXJ5IGRvZXNuJ3QgY29udmVydCB0aGVtIHRvIHNwYWNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1cmwgZGVjb2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCB7QGNvZGUgc3RyfS5cbiAqL1xuZ29vZy5zdHJpbmcudXJsRGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBcXG4gdG8gPGJyPnMgb3IgPGJyIC8+cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBpbiB3aGljaCB0byBjb252ZXJ0IG5ld2xpbmVzLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3htbCBXaGV0aGVyIHRvIHVzZSBYTUwgY29tcGF0aWJsZSB0YWdzLlxuICogQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN0cn0gd2l0aCBjb252ZXJ0ZWQgbmV3bGluZXMuXG4gKi9cbmdvb2cuc3RyaW5nLm5ld0xpbmVUb0JyID0gZnVuY3Rpb24oc3RyLCBvcHRfeG1sKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFxcclxcbnxcXHJ8XFxuKS9nLCBvcHRfeG1sID8gJzxiciAvPicgOiAnPGJyPicpO1xufTtcblxuXG4vKipcbiAqIEVzY2FwZXMgZG91YmxlIHF1b3RlICdcIicgYW5kIHNpbmdsZSBxdW90ZSAnXFwnJyBjaGFyYWN0ZXJzIGluIGFkZGl0aW9uIHRvXG4gKiAnJicsICc8JywgYW5kICc+JyBzbyB0aGF0IGEgc3RyaW5nIGNhbiBiZSBpbmNsdWRlZCBpbiBhbiBIVE1MIHRhZyBhdHRyaWJ1dGVcbiAqIHZhbHVlIHdpdGhpbiBkb3VibGUgb3Igc2luZ2xlIHF1b3Rlcy5cbiAqXG4gKiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCA+IGRvZXNuJ3QgbmVlZCB0byBiZSBlc2NhcGVkIGZvciB0aGUgSFRNTCBvciBYTUwgdG9cbiAqIGJlIHZhbGlkLCBidXQgaXQgaGFzIGJlZW4gZGVjaWRlZCB0byBlc2NhcGUgaXQgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXJcbiAqIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBXaXRoIGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcsIHRoaXMgZnVuY3Rpb24gZXNjYXBlcyBhbHNvIHRoZVxuICogbG93ZXJjYXNlIGxldHRlciBcImVcIi5cbiAqXG4gKiBOT1RFKHVzZXIpOlxuICogSHRtbEVzY2FwZSBpcyBvZnRlbiBjYWxsZWQgZHVyaW5nIHRoZSBnZW5lcmF0aW9uIG9mIGxhcmdlIGJsb2NrcyBvZiBIVE1MLlxuICogVXNpbmcgc3RhdGljcyBmb3IgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIHN0cmluZ3MgaXMgYW4gb3B0aW1pemF0aW9uXG4gKiB0aGF0IGNhbiBtb3JlIHRoYW4gaGFsZiB0aGUgYW1vdW50IG9mIHRpbWUgSUUgc3BlbmRzIGluIHRoaXMgZnVuY3Rpb24gZm9yXG4gKiBsYXJnZSBhcHBzLCBzaW5jZSBzdHJpbmdzIGFuZCByZWdleGVzIGJvdGggY29udHJpYnV0ZSB0byBHQyBhbGxvY2F0aW9ucy5cbiAqXG4gKiBUZXN0aW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjaGFyYWN0ZXIgYmVmb3JlIGVzY2FwaW5nIGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gKiBvZiBmdW5jdGlvbiBjYWxscywgYnV0IGFjdHVhbGx5IHByb3ZpZGVzIGEgc3BlZWQgaW5jcmVhc2UgZm9yIHRoZSBhdmVyYWdlXG4gKiBjYXNlIC0tIHNpbmNlIHRoZSBhdmVyYWdlIGNhc2Ugb2Z0ZW4gZG9lc24ndCByZXF1aXJlIHRoZSBlc2NhcGluZyBvZiBhbGwgNFxuICogY2hhcmFjdGVycyBhbmQgaW5kZXhPZigpIGlzIG11Y2ggY2hlYXBlciB0aGFuIHJlcGxhY2UoKS5cbiAqIFRoZSB3b3JzdCBjYXNlIGRvZXMgc3VmZmVyIHNsaWdodGx5IGZyb20gdGhlIGFkZGl0aW9uYWwgY2FsbHMsIHRoZXJlZm9yZSB0aGVcbiAqIG9wdF9pc0xpa2VseVRvQ29udGFpbkh0bWxDaGFycyBvcHRpb24gaGFzIGJlZW4gaW5jbHVkZWQgZm9yIHNpdHVhdGlvbnNcbiAqIHdoZXJlIGFsbCA0IEhUTUwgZW50aXRpZXMgYXJlIHZlcnkgbGlrZWx5IHRvIGJlIHByZXNlbnQgYW5kIG5lZWQgZXNjYXBpbmcuXG4gKlxuICogU29tZSBiZW5jaG1hcmtzICh0aW1lcyB0ZW5kZWQgdG8gZmx1Y3R1YXRlICstMC4wNW1zKTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVGb3ggICAgICAgICAgICAgICAgICAgICBJRTZcbiAqIChubyBjaGFycyAvIGF2ZXJhZ2UgKG1peCBvZiBjYXNlcykgLyBhbGwgNCBjaGFycylcbiAqIG5vIGNoZWNrcyAgICAgICAgICAgICAgICAgICAgIDAuMTMgLyAwLjIyIC8gMC4yMiAgICAgICAgIDAuMjMgLyAwLjUzIC8gMC44MFxuICogaW5kZXhPZiAgICAgICAgICAgICAgICAgICAgICAgMC4wOCAvIDAuMTcgLyAwLjI2ICAgICAgICAgMC4yMiAvIDAuNTQgLyAwLjg0XG4gKiBpbmRleE9mICsgcmUgdGVzdCAgICAgICAgICAgICAwLjA3IC8gMC4xNyAvIDAuMjggICAgICAgICAwLjE5IC8gMC41MCAvIDAuODVcbiAqXG4gKiBBbiBhZGRpdGlvbmFsIGFkdmFudGFnZSBvZiBjaGVja2luZyBpZiByZXBsYWNlIGFjdHVhbGx5IG5lZWRzIHRvIGJlIGNhbGxlZFxuICogaXMgYSByZWR1Y3Rpb24gaW4gdGhlIG51bWJlciBvZiBvYmplY3QgYWxsb2NhdGlvbnMsIHNvIGFzIHRoZSBzaXplIG9mIHRoZVxuICogYXBwbGljYXRpb24gZ3Jvd3MgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdmFyaW91cyBtZXRob2RzIHdvdWxkIGluY3JlYXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGJlIGVzY2FwZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMgRG9uJ3QgcGVyZm9ybSBhIGNoZWNrIHRvIHNlZVxuICogICAgIGlmIHRoZSBjaGFyYWN0ZXIgbmVlZHMgcmVwbGFjaW5nIC0gdXNlIHRoaXMgb3B0aW9uIGlmIHlvdSBleHBlY3QgZWFjaCBvZlxuICogICAgIHRoZSBjaGFyYWN0ZXJzIHRvIGFwcGVhciBvZnRlbi4gTGVhdmUgZmFsc2UgaWYgeW91IGV4cGVjdCBmZXcgaHRtbFxuICogICAgIGNoYXJhY3RlcnMgdG8gb2NjdXIgaW4geW91ciBzdHJpbmdzLCBzdWNoIGFzIGlmIHlvdSBhcmUgZXNjYXBpbmcgSFRNTC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLnN0cmluZy5odG1sRXNjYXBlID0gZnVuY3Rpb24oc3RyLCBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMpIHtcblxuICBpZiAob3B0X2lzTGlrZWx5VG9Db250YWluSHRtbENoYXJzKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuQU1QX1JFXywgJyZhbXA7JylcbiAgICAgICAgICAucmVwbGFjZShnb29nLnN0cmluZy5MVF9SRV8sICcmbHQ7JylcbiAgICAgICAgICAucmVwbGFjZShnb29nLnN0cmluZy5HVF9SRV8sICcmZ3Q7JylcbiAgICAgICAgICAucmVwbGFjZShnb29nLnN0cmluZy5RVU9UX1JFXywgJyZxdW90OycpXG4gICAgICAgICAgLnJlcGxhY2UoZ29vZy5zdHJpbmcuU0lOR0xFX1FVT1RFX1JFXywgJyYjMzk7JylcbiAgICAgICAgICAucmVwbGFjZShnb29nLnN0cmluZy5OVUxMX1JFXywgJyYjMDsnKTtcbiAgICBpZiAoZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORykge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuRV9SRV8sICcmIzEwMTsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcblxuICB9IGVsc2Uge1xuICAgIC8vIHF1aWNrIHRlc3QgaGVscHMgaW4gdGhlIGNhc2Ugd2hlbiB0aGVyZSBhcmUgbm8gY2hhcnMgdG8gcmVwbGFjZSwgaW5cbiAgICAvLyB3b3JzdCBjYXNlIHRoaXMgbWFrZXMgYmFyZWx5IGEgZGlmZmVyZW5jZSB0byB0aGUgdGltZSB0YWtlblxuICAgIGlmICghZ29vZy5zdHJpbmcuQUxMX1JFXy50ZXN0KHN0cikpIHJldHVybiBzdHI7XG5cbiAgICAvLyBzdHIuaW5kZXhPZiBpcyBmYXN0ZXIgdGhhbiByZWdleC50ZXN0IGluIHRoaXMgY2FzZVxuICAgIGlmIChzdHIuaW5kZXhPZignJicpICE9IC0xKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5BTVBfUkVfLCAnJmFtcDsnKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCc8JykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkxUX1JFXywgJyZsdDsnKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCc+JykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkdUX1JFXywgJyZndDsnKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCdcIicpICE9IC0xKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5RVU9UX1JFXywgJyZxdW90OycpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoJ1xcJycpICE9IC0xKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5TSU5HTEVfUVVPVEVfUkVfLCAnJiMzOTsnKTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKCdcXHgwMCcpICE9IC0xKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5OVUxMX1JFXywgJyYjMDsnKTtcbiAgICB9XG4gICAgaWYgKGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcgJiYgc3RyLmluZGV4T2YoJ2UnKSAhPSAtMSkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuRV9SRV8sICcmIzEwMTsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gYW1wZXJzYW5kLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICogQGNvbnN0IHshUmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcuQU1QX1JFXyA9IC8mL2c7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgbGVzcyB0aGFuIHNpZ24sIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5MVF9SRV8gPSAvPC9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIGdyZWF0ZXIgdGhhbiBzaWduLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICogQGNvbnN0IHshUmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcuR1RfUkVfID0gLz4vZztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBkb3VibGUgcXVvdGUsIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5RVU9UX1JFXyA9IC9cIi9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIHNpbmdsZSBxdW90ZSwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8gPSAvJy9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBudWxsIGNoYXJhY3RlciwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLk5VTExfUkVfID0gL1xceDAwL2c7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgbG93ZXJjYXNlIGxldHRlciBcImVcIiwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLkVfUkVfID0gL2UvZztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW55IGNoYXJhY3RlciB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWQuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5BTExfUkVfID0gKGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcgP1xuICAgIC9bXFx4MDAmPD5cIidlXS8gOlxuICAgIC9bXFx4MDAmPD5cIiddLyk7XG5cblxuLyoqXG4gKiBVbmVzY2FwZXMgYW4gSFRNTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiB1bmVzY2FwZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAqL1xuZ29vZy5zdHJpbmcudW5lc2NhcGVFbnRpdGllcyA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoZ29vZy5zdHJpbmcuY29udGFpbnMoc3RyLCAnJicpKSB7XG4gICAgLy8gV2UgYXJlIGNhcmVmdWwgbm90IHRvIHVzZSBhIERPTSBpZiB3ZSBkbyBub3QgaGF2ZSBvbmUgb3Igd2UgZXhwbGljaXRseVxuICAgIC8vIHJlcXVlc3RlZCBub24tRE9NIGh0bWwgdW5lc2NhcGluZy5cbiAgICBpZiAoIWdvb2cuc3RyaW5nLkZPUkNFX05PTl9ET01fSFRNTF9VTkVTQ0FQSU5HICYmXG4gICAgICAgICdkb2N1bWVudCcgaW4gZ29vZy5nbG9iYWwpIHtcbiAgICAgIHJldHVybiBnb29nLnN0cmluZy51bmVzY2FwZUVudGl0aWVzVXNpbmdEb21fKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGwgYmFjayBvbiBwdXJlIFhNTCBlbnRpdGllc1xuICAgICAgcmV0dXJuIGdvb2cuc3RyaW5nLnVuZXNjYXBlUHVyZVhtbEVudGl0aWVzXyhzdHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIFVuZXNjYXBlcyBhIEhUTUwgc3RyaW5nIHVzaW5nIHRoZSBwcm92aWRlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnQgQSBkb2N1bWVudCB0byB1c2UgaW4gZXNjYXBpbmcgdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gdW5lc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN0cn0uXG4gKi9cbmdvb2cuc3RyaW5nLnVuZXNjYXBlRW50aXRpZXNXaXRoRG9jdW1lbnQgPSBmdW5jdGlvbihzdHIsIGRvY3VtZW50KSB7XG4gIGlmIChnb29nLnN0cmluZy5jb250YWlucyhzdHIsICcmJykpIHtcbiAgICByZXR1cm4gZ29vZy5zdHJpbmcudW5lc2NhcGVFbnRpdGllc1VzaW5nRG9tXyhzdHIsIGRvY3VtZW50KTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIFVuZXNjYXBlcyBhbiBIVE1MIHN0cmluZyB1c2luZyBhIERPTSB0byByZXNvbHZlIG5vbi1YTUwsIG5vbi1udW1lcmljXG4gKiBlbnRpdGllcy4gVGhpcyBmdW5jdGlvbiBpcyBYU1Mtc2FmZSBhbmQgd2hpdGVzcGFjZS1wcmVzZXJ2aW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAqIEBwYXJhbSB7RG9jdW1lbnQ9fSBvcHRfZG9jdW1lbnQgQW4gb3B0aW9uYWwgZG9jdW1lbnQgdG8gdXNlIGZvciBjcmVhdGluZ1xuICogICAgIGVsZW1lbnRzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgdGhlbiB0aGUgZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcbiAqICAgICB3aWxsIGJlIHVzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1bmVzY2FwZWQge0Bjb2RlIHN0cn0gc3RyaW5nLlxuICovXG5nb29nLnN0cmluZy51bmVzY2FwZUVudGl0aWVzVXNpbmdEb21fID0gZnVuY3Rpb24oc3RyLCBvcHRfZG9jdW1lbnQpIHtcbiAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgdmFyIHNlZW4gPSB7JyZhbXA7JzogJyYnLCAnJmx0Oyc6ICc8JywgJyZndDsnOiAnPicsICcmcXVvdDsnOiAnXCInfTtcbiAgdmFyIGRpdjtcbiAgaWYgKG9wdF9kb2N1bWVudCkge1xuICAgIGRpdiA9IG9wdF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfSBlbHNlIHtcbiAgICBkaXYgPSBnb29nLmdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuICAvLyBNYXRjaCBhcyBtYW55IHZhbGlkIGVudGl0eSBjaGFyYWN0ZXJzIGFzIHBvc3NpYmxlLiBJZiB0aGUgYWN0dWFsIGVudGl0eVxuICAvLyBoYXBwZW5zIHRvIGJlIHNob3J0ZXIsIGl0IHdpbGwgc3RpbGwgd29yayBhcyBpbm5lckhUTUwgd2lsbCByZXR1cm4gdGhlXG4gIC8vIHRyYWlsaW5nIGNoYXJhY3RlcnMgdW5jaGFuZ2VkLiBTaW5jZSB0aGUgZW50aXR5IGNoYXJhY3RlcnMgZG8gbm90IGluY2x1ZGVcbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0LCB0aGVyZSBpcyBubyBjaGFuY2Ugb2YgWFNTIGZyb20gdGhlIGlubmVySFRNTCB1c2UuXG4gIC8vIFNpbmNlIG5vIHdoaXRlc3BhY2UgaXMgcGFzc2VkIHRvIGlubmVySFRNTCwgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWQuXG4gIHJldHVybiBzdHIucmVwbGFjZShnb29nLnN0cmluZy5IVE1MX0VOVElUWV9QQVRURVJOXywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBlbnRpdHkuXG4gICAgdmFyIHZhbHVlID0gc2VlbltzXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIG51bWVyaWMgZW50aXR5LlxuICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09ICcjJykge1xuICAgICAgLy8gUHJlZml4IHdpdGggMCBzbyB0aGF0IGhleCBlbnRpdGllcyAoZS5nLiAmI3gxMCkgcGFyc2UgYXMgaGV4IG51bWJlcnMuXG4gICAgICB2YXIgbiA9IE51bWJlcignMCcgKyBlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgIGlmICghaXNOYU4obikpIHtcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gaW5uZXJIVE1MIG90aGVyd2lzZS5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBBcHBlbmQgYSBub24tZW50aXR5IGNoYXJhY3RlciB0byBhdm9pZCBhIGJ1ZyBpbiBXZWJraXQgdGhhdCBwYXJzZXNcbiAgICAgIC8vIGFuIGludmFsaWQgZW50aXR5IGF0IHRoZSBlbmQgb2YgaW5uZXJIVE1MIHRleHQgYXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSBzICsgJyAnO1xuICAgICAgLy8gVGhlbiByZW1vdmUgdGhlIHRyYWlsaW5nIGNoYXJhY3RlciBmcm9tIHRoZSByZXN1bHQuXG4gICAgICB2YWx1ZSA9IGRpdi5maXJzdENoaWxkLm5vZGVWYWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8vIENhY2hlIGFuZCByZXR1cm4uXG4gICAgcmV0dXJuIHNlZW5bc10gPSB2YWx1ZTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVW5lc2NhcGVzIFhNTCBlbnRpdGllcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIHVuZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLnN0cmluZy51bmVzY2FwZVB1cmVYbWxFbnRpdGllc18gPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKFteO10rKTsvZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgc3dpdGNoIChlbnRpdHkpIHtcbiAgICAgIGNhc2UgJ2FtcCc6XG4gICAgICAgIHJldHVybiAnJic7XG4gICAgICBjYXNlICdsdCc6XG4gICAgICAgIHJldHVybiAnPCc7XG4gICAgICBjYXNlICdndCc6XG4gICAgICAgIHJldHVybiAnPic7XG4gICAgICBjYXNlICdxdW90JzpcbiAgICAgICAgcmV0dXJuICdcIic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PSAnIycpIHtcbiAgICAgICAgICAvLyBQcmVmaXggd2l0aCAwIHNvIHRoYXQgaGV4IGVudGl0aWVzIChlLmcuICYjeDEwKSBwYXJzZSBhcyBoZXguXG4gICAgICAgICAgdmFyIG4gPSBOdW1iZXIoJzAnICsgZW50aXR5LnN1YnN0cigxKSk7XG4gICAgICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBpbnZhbGlkIGVudGl0aWVzIHdlIGp1c3QgcmV0dXJuIHRoZSBlbnRpdHlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIEhUTUwgZW50aXR5LlxuICogU2VlIGFsc28gSFRNTDU6IFRva2VuaXphdGlvbiAvIFRva2VuaXppbmcgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgeyFSZWdFeHB9XG4gKi9cbmdvb2cuc3RyaW5nLkhUTUxfRU5USVRZX1BBVFRFUk5fID0gLyYoW147XFxzPCZdKyk7Py9nO1xuXG5cbi8qKlxuICogRG8gZXNjYXBpbmcgb2Ygd2hpdGVzcGFjZSB0byBwcmVzZXJ2ZSBzcGF0aWFsIGZvcm1hdHRpbmcuIFdlIHVzZSBjaGFyYWN0ZXJcbiAqIGVudGl0eSAjMTYwIHRvIG1ha2UgaXQgc2FmZXIgZm9yIHhtbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBpbiB3aGljaCB0byBlc2NhcGUgd2hpdGVzcGFjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF94bWwgV2hldGhlciB0byB1c2UgWE1MIGNvbXBhdGlibGUgdGFncy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLnN0cmluZy53aGl0ZXNwYWNlRXNjYXBlID0gZnVuY3Rpb24oc3RyLCBvcHRfeG1sKSB7XG4gIC8vIFRoaXMgZG9lc24ndCB1c2UgZ29vZy5zdHJpbmcucHJlc2VydmVTcGFjZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICByZXR1cm4gZ29vZy5zdHJpbmcubmV3TGluZVRvQnIoc3RyLnJlcGxhY2UoLyAgL2csICcgJiMxNjA7JyksIG9wdF94bWwpO1xufTtcblxuXG4vKipcbiAqIFByZXNlcnZlIHNwYWNlcyB0aGF0IHdvdWxkIGJlIG90aGVyd2lzZSBjb2xsYXBzZWQgaW4gSFRNTCBieSByZXBsYWNpbmcgdGhlbVxuICogd2l0aCBub24tYnJlYWtpbmcgc3BhY2UgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIGluIHdoaWNoIHRvIHByZXNlcnZlIHdoaXRlc3BhY2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgY29weSBvZiB7QGNvZGUgc3RyfSB3aXRoIHByZXNlcnZlZCB3aGl0ZXNwYWNlLlxuICovXG5nb29nLnN0cmluZy5wcmVzZXJ2ZVNwYWNlcyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhefFtcXG4gXSkgL2csICckMScgKyBnb29nLnN0cmluZy5Vbmljb2RlLk5CU1ApO1xufTtcblxuXG4vKipcbiAqIFN0cmlwIHF1b3RlIGNoYXJhY3RlcnMgYXJvdW5kIGEgc3RyaW5nLiAgVGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIHN0cmluZyBvZlxuICogY2hhcmFjdGVycyB0byB0cmVhdCBhcyBxdW90ZXMuICBUaGlzIGNhbiBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIgb3IgYSBzdHJpbmcgb2ZcbiAqIG11bHRpcGxlIGNoYXJhY3RlciBhbmQgaW4gdGhhdCBjYXNlIGVhY2ggb2YgdGhvc2UgYXJlIHRyZWF0ZWQgYXMgcG9zc2libGVcbiAqIHF1b3RlIGNoYXJhY3RlcnMuIEZvciBleGFtcGxlOlxuICpcbiAqIDxwcmU+XG4gKiBnb29nLnN0cmluZy5zdHJpcFF1b3RlcygnXCJhYmNcIicsICdcImAnKSAtLT4gJ2FiYydcbiAqIGdvb2cuc3RyaW5nLnN0cmlwUXVvdGVzKCdgYWJjYCcsICdcImAnKSAtLT4gJ2FiYydcbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBzdHJpcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdW90ZUNoYXJzIFRoZSBxdW90ZSBjaGFyYWN0ZXJzIHRvIHN0cmlwLlxuICogQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN0cn0gd2l0aG91dCB0aGUgcXVvdGVzLlxuICovXG5nb29nLnN0cmluZy5zdHJpcFF1b3RlcyA9IGZ1bmN0aW9uKHN0ciwgcXVvdGVDaGFycykge1xuICB2YXIgbGVuZ3RoID0gcXVvdGVDaGFycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gbGVuZ3RoID09IDEgPyBxdW90ZUNoYXJzIDogcXVvdGVDaGFycy5jaGFyQXQoaSk7XG4gICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gcXVvdGVDaGFyICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09IHF1b3RlQ2hhcikge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIFRydW5jYXRlcyBhIHN0cmluZyB0byBhIGNlcnRhaW4gbGVuZ3RoIGFuZCBhZGRzICcuLi4nIGlmIG5lY2Vzc2FyeS4gIFRoZVxuICogbGVuZ3RoIGFsc28gYWNjb3VudHMgZm9yIHRoZSBlbGxpcHNpcywgc28gYSBtYXhpbXVtIGxlbmd0aCBvZiAxMCBhbmQgYSBzdHJpbmdcbiAqICdIZWxsbyBXb3JsZCEnIHByb2R1Y2VzICdIZWxsbyBXLi4uJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFycyBNYXggbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcHJvdGVjdEVzY2FwZWRDaGFyYWN0ZXJzIFdoZXRoZXIgdG8gcHJvdGVjdCBlc2NhcGVkXG4gKiAgICAgY2hhcmFjdGVycyBmcm9tIGJlaW5nIGN1dCBvZmYgaW4gdGhlIG1pZGRsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRydW5jYXRlZCB7QGNvZGUgc3RyfSBzdHJpbmcuXG4gKi9cbmdvb2cuc3RyaW5nLnRydW5jYXRlID0gZnVuY3Rpb24oc3RyLCBjaGFycywgb3B0X3Byb3RlY3RFc2NhcGVkQ2hhcmFjdGVycykge1xuICBpZiAob3B0X3Byb3RlY3RFc2NhcGVkQ2hhcmFjdGVycykge1xuICAgIHN0ciA9IGdvb2cuc3RyaW5nLnVuZXNjYXBlRW50aXRpZXMoc3RyKTtcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gY2hhcnMpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGNoYXJzIC0gMykgKyAnLi4uJztcbiAgfVxuXG4gIGlmIChvcHRfcHJvdGVjdEVzY2FwZWRDaGFyYWN0ZXJzKSB7XG4gICAgc3RyID0gZ29vZy5zdHJpbmcuaHRtbEVzY2FwZShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBUcnVuY2F0ZSBhIHN0cmluZyBpbiB0aGUgbWlkZGxlLCBhZGRpbmcgXCIuLi5cIiBpZiBuZWNlc3NhcnksXG4gKiBhbmQgZmF2b3JpbmcgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRydW5jYXRlIHRoZSBtaWRkbGUgb2YuXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhcnMgTWF4IG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3Byb3RlY3RFc2NhcGVkQ2hhcmFjdGVycyBXaGV0aGVyIHRvIHByb3RlY3QgZXNjYXBlZFxuICogICAgIGNoYXJhY3RlcnMgZnJvbSBiZWluZyBjdXRvZmYgaW4gdGhlIG1pZGRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RyYWlsaW5nQ2hhcnMgT3B0aW9uYWwgbnVtYmVyIG9mIHRyYWlsaW5nIGNoYXJhY3RlcnMgdG9cbiAqICAgICBsZWF2ZSBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIGluc3RlYWQgb2YgdHJ1bmNhdGluZyBhcyBjbG9zZSB0byB0aGVcbiAqICAgICBtaWRkbGUgYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgdHJ1bmNhdGVkIGNvcHkgb2Yge0Bjb2RlIHN0cn0uXG4gKi9cbmdvb2cuc3RyaW5nLnRydW5jYXRlTWlkZGxlID0gZnVuY3Rpb24oc3RyLCBjaGFycyxcbiAgICBvcHRfcHJvdGVjdEVzY2FwZWRDaGFyYWN0ZXJzLCBvcHRfdHJhaWxpbmdDaGFycykge1xuICBpZiAob3B0X3Byb3RlY3RFc2NhcGVkQ2hhcmFjdGVycykge1xuICAgIHN0ciA9IGdvb2cuc3RyaW5nLnVuZXNjYXBlRW50aXRpZXMoc3RyKTtcbiAgfVxuXG4gIGlmIChvcHRfdHJhaWxpbmdDaGFycyAmJiBzdHIubGVuZ3RoID4gY2hhcnMpIHtcbiAgICBpZiAob3B0X3RyYWlsaW5nQ2hhcnMgPiBjaGFycykge1xuICAgICAgb3B0X3RyYWlsaW5nQ2hhcnMgPSBjaGFycztcbiAgICB9XG4gICAgdmFyIGVuZFBvaW50ID0gc3RyLmxlbmd0aCAtIG9wdF90cmFpbGluZ0NoYXJzO1xuICAgIHZhciBzdGFydFBvaW50ID0gY2hhcnMgLSBvcHRfdHJhaWxpbmdDaGFycztcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0UG9pbnQpICsgJy4uLicgKyBzdHIuc3Vic3RyaW5nKGVuZFBvaW50KTtcbiAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID4gY2hhcnMpIHtcbiAgICAvLyBGYXZvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmc6XG4gICAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKGNoYXJzIC8gMik7XG4gICAgdmFyIGVuZFBvcyA9IHN0ci5sZW5ndGggLSBoYWxmO1xuICAgIGhhbGYgKz0gY2hhcnMgJSAyO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaGFsZikgKyAnLi4uJyArIHN0ci5zdWJzdHJpbmcoZW5kUG9zKTtcbiAgfVxuXG4gIGlmIChvcHRfcHJvdGVjdEVzY2FwZWRDaGFyYWN0ZXJzKSB7XG4gICAgc3RyID0gZ29vZy5zdHJpbmcuaHRtbEVzY2FwZShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBTcGVjaWFsIGNoYXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGZvciBnb29nLnN0cmluZy5xdW90ZS5cbiAqIEBwcml2YXRlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZ29vZy5zdHJpbmcuc3BlY2lhbEVzY2FwZUNoYXJzXyA9IHtcbiAgJ1xcMCc6ICdcXFxcMCcsXG4gICdcXGInOiAnXFxcXGInLFxuICAnXFxmJzogJ1xcXFxmJyxcbiAgJ1xcbic6ICdcXFxcbicsXG4gICdcXHInOiAnXFxcXHInLFxuICAnXFx0JzogJ1xcXFx0JyxcbiAgJ1xceDBCJzogJ1xcXFx4MEInLCAvLyAnXFx2JyBpcyBub3Qgc3VwcG9ydGVkIGluIEpTY3JpcHRcbiAgJ1wiJzogJ1xcXFxcIicsXG4gICdcXFxcJzogJ1xcXFxcXFxcJ1xufTtcblxuXG4vKipcbiAqIENoYXJhY3RlciBtYXBwaW5ncyB1c2VkIGludGVybmFsbHkgZm9yIGdvb2cuc3RyaW5nLmVzY2FwZUNoYXIuXG4gKiBAcHJpdmF0ZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmdvb2cuc3RyaW5nLmpzRXNjYXBlQ2FjaGVfID0ge1xuICAnXFwnJzogJ1xcXFxcXCcnXG59O1xuXG5cbi8qKlxuICogRW5jbG9zZXMgYSBzdHJpbmcgaW4gZG91YmxlIHF1b3RlcyBhbmQgZXNjYXBlcyBjaGFyYWN0ZXJzIHNvIHRoYXQgdGhlXG4gKiBzdHJpbmcgaXMgYSB2YWxpZCBKUyBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBUaGUgc3RyaW5nIHRvIHF1b3RlLlxuICogQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN9IHN1cnJvdW5kZWQgYnkgZG91YmxlIHF1b3Rlcy5cbiAqL1xuZ29vZy5zdHJpbmcucXVvdGUgPSBmdW5jdGlvbihzKSB7XG4gIHMgPSBTdHJpbmcocyk7XG4gIGlmIChzLnF1b3RlKSB7XG4gICAgcmV0dXJuIHMucXVvdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2IgPSBbJ1wiJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2ggPSBzLmNoYXJBdChpKTtcbiAgICAgIHZhciBjYyA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICBzYltpICsgMV0gPSBnb29nLnN0cmluZy5zcGVjaWFsRXNjYXBlQ2hhcnNfW2NoXSB8fFxuICAgICAgICAgICgoY2MgPiAzMSAmJiBjYyA8IDEyNykgPyBjaCA6IGdvb2cuc3RyaW5nLmVzY2FwZUNoYXIoY2gpKTtcbiAgICB9XG4gICAgc2IucHVzaCgnXCInKTtcbiAgICByZXR1cm4gc2Iuam9pbignJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcgZm9yIHRoYXQgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLnN0cmluZy5lc2NhcGVTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHNiID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgc2JbaV0gPSBnb29nLnN0cmluZy5lc2NhcGVDaGFyKHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzYi5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBUYWtlcyBhIGNoYXJhY3RlciBhbmQgcmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcgZm9yIHRoYXQgY2hhcmFjdGVyLiBGb3JcbiAqIGV4YW1wbGUgZXNjYXBlQ2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKDE1KSkgLT4gXCJcXFxceDBFXCIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBUaGUgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHtAY29kZSBjfS5cbiAqL1xuZ29vZy5zdHJpbmcuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYgKGMgaW4gZ29vZy5zdHJpbmcuanNFc2NhcGVDYWNoZV8pIHtcbiAgICByZXR1cm4gZ29vZy5zdHJpbmcuanNFc2NhcGVDYWNoZV9bY107XG4gIH1cblxuICBpZiAoYyBpbiBnb29nLnN0cmluZy5zcGVjaWFsRXNjYXBlQ2hhcnNfKSB7XG4gICAgcmV0dXJuIGdvb2cuc3RyaW5nLmpzRXNjYXBlQ2FjaGVfW2NdID0gZ29vZy5zdHJpbmcuc3BlY2lhbEVzY2FwZUNoYXJzX1tjXTtcbiAgfVxuXG4gIHZhciBydiA9IGM7XG4gIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgaWYgKGNjID4gMzEgJiYgY2MgPCAxMjcpIHtcbiAgICBydiA9IGM7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGFiIGlzIDkgYnV0IGhhbmRsZWQgYWJvdmVcbiAgICBpZiAoY2MgPCAyNTYpIHtcbiAgICAgIHJ2ID0gJ1xcXFx4JztcbiAgICAgIGlmIChjYyA8IDE2IHx8IGNjID4gMjU2KSB7XG4gICAgICAgIHJ2ICs9ICcwJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcnYgPSAnXFxcXHUnO1xuICAgICAgaWYgKGNjIDwgNDA5NikgeyAvLyBcXHUxMDAwXG4gICAgICAgIHJ2ICs9ICcwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcnYgKz0gY2MudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gZ29vZy5zdHJpbmcuanNFc2NhcGVDYWNoZV9bY10gPSBydjtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgY29udGFpbnMgYSBzdWJzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IHN1YlN0cmluZyBUaGUgc3Vic3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHtAY29kZSBzdHJ9IGNvbnRhaW5zIHtAY29kZSBzdWJTdHJpbmd9LlxuICovXG5nb29nLnN0cmluZy5jb250YWlucyA9IGZ1bmN0aW9uKHN0ciwgc3ViU3RyaW5nKSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZihzdWJTdHJpbmcpICE9IC0xO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBhIHN1YnN0cmluZywgaWdub3JpbmcgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ViU3RyaW5nIFRoZSBzdWJzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIge0Bjb2RlIHN0cn0gY29udGFpbnMge0Bjb2RlIHN1YlN0cmluZ30uXG4gKi9cbmdvb2cuc3RyaW5nLmNhc2VJbnNlbnNpdGl2ZUNvbnRhaW5zID0gZnVuY3Rpb24oc3RyLCBzdWJTdHJpbmcpIHtcbiAgcmV0dXJuIGdvb2cuc3RyaW5nLmNvbnRhaW5zKHN0ci50b0xvd2VyQ2FzZSgpLCBzdWJTdHJpbmcudG9Mb3dlckNhc2UoKSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2VzIG9mIHNzIGluIHMuXG4gKiBJZiBlaXRoZXIgcyBvciBzcyBldmFsdXRlcyB0byBmYWxzZSwgdGhlbiByZXR1cm5zIHplcm8uXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBUaGUgc3RyaW5nIHRvIGxvb2sgaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3MgVGhlIHN0cmluZyB0byBsb29rIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHNzIGluIHMuXG4gKi9cbmdvb2cuc3RyaW5nLmNvdW50T2YgPSBmdW5jdGlvbihzLCBzcykge1xuICByZXR1cm4gcyAmJiBzcyA/IHMuc3BsaXQoc3MpLmxlbmd0aCAtIDEgOiAwO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBzdWJzdHJpbmcgb2YgYSBzcGVjaWZpZWQgbGVuZ3RoIGF0IGEgc3BlY2lmaWNcbiAqIGluZGV4IGluIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHMgVGhlIGJhc2Ugc3RyaW5nIGZyb20gd2hpY2ggdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byByZW1vdmUgdGhlIHN1YnN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpbmdMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgc3Vic3RyaW5nIHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBjb3B5IG9mIHtAY29kZSBzfSB3aXRoIHRoZSBzdWJzdHJpbmcgcmVtb3ZlZCBvciB0aGUgZnVsbFxuICogICAgIHN0cmluZyBpZiBub3RoaW5nIGlzIHJlbW92ZWQgb3IgdGhlIGlucHV0IGlzIGludmFsaWQuXG4gKi9cbmdvb2cuc3RyaW5nLnJlbW92ZUF0ID0gZnVuY3Rpb24ocywgaW5kZXgsIHN0cmluZ0xlbmd0aCkge1xuICB2YXIgcmVzdWx0U3RyID0gcztcbiAgLy8gSWYgdGhlIGluZGV4IGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMCB0aGVuIHJlbW92ZSBzdWJzdHJpbmdcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzLmxlbmd0aCAmJiBzdHJpbmdMZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0U3RyID0gcy5zdWJzdHIoMCwgaW5kZXgpICtcbiAgICAgICAgcy5zdWJzdHIoaW5kZXggKyBzdHJpbmdMZW5ndGgsIHMubGVuZ3RoIC0gaW5kZXggLSBzdHJpbmdMZW5ndGgpO1xuICB9XG4gIHJldHVybiByZXN1bHRTdHI7XG59O1xuXG5cbi8qKlxuICogIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzdWJzdHJpbmcgZnJvbSBhIHN0cmluZy5cbiAqICBAcGFyYW0ge3N0cmluZ30gcyBUaGUgYmFzZSBzdHJpbmcgZnJvbSB3aGljaCB0byByZW1vdmUuXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNzIFRoZSBzdHJpbmcgdG8gcmVtb3ZlLlxuICogIEByZXR1cm4ge3N0cmluZ30gQSBjb3B5IG9mIHtAY29kZSBzfSB3aXRoIHtAY29kZSBzc30gcmVtb3ZlZCBvciB0aGUgZnVsbFxuICogICAgICBzdHJpbmcgaWYgbm90aGluZyBpcyByZW1vdmVkLlxuICovXG5nb29nLnN0cmluZy5yZW1vdmUgPSBmdW5jdGlvbihzLCBzcykge1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKGdvb2cuc3RyaW5nLnJlZ0V4cEVzY2FwZShzcyksICcnKTtcbiAgcmV0dXJuIHMucmVwbGFjZShyZSwgJycpO1xufTtcblxuXG4vKipcbiAqICBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBhIHN1YnN0cmluZyBmcm9tIGEgc3RyaW5nLlxuICogIEBwYXJhbSB7c3RyaW5nfSBzIFRoZSBiYXNlIHN0cmluZyBmcm9tIHdoaWNoIHRvIHJlbW92ZS5cbiAqICBAcGFyYW0ge3N0cmluZ30gc3MgVGhlIHN0cmluZyB0byByZW1vdmUuXG4gKiAgQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN9IHdpdGgge0Bjb2RlIHNzfSByZW1vdmVkIG9yIHRoZSBmdWxsXG4gKiAgICAgIHN0cmluZyBpZiBub3RoaW5nIGlzIHJlbW92ZWQuXG4gKi9cbmdvb2cuc3RyaW5nLnJlbW92ZUFsbCA9IGZ1bmN0aW9uKHMsIHNzKSB7XG4gIHZhciByZSA9IG5ldyBSZWdFeHAoZ29vZy5zdHJpbmcucmVnRXhwRXNjYXBlKHNzKSwgJ2cnKTtcbiAgcmV0dXJuIHMucmVwbGFjZShyZSwgJycpO1xufTtcblxuXG4vKipcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cbiAqIEBwYXJhbSB7Kn0gcyBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICogICAgIHRvIG9uZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAqL1xuZ29vZy5zdHJpbmcucmVnRXhwRXNjYXBlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykuXG4gICAgICByZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xufTtcblxuXG4vKipcbiAqIFJlcGVhdHMgYSBzdHJpbmcgbiB0aW1lcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0LlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBjb250YWluaW5nIHtAY29kZSBsZW5ndGh9IHJlcGV0aXRpb25zIG9mXG4gKiAgICAge0Bjb2RlIHN0cmluZ30uXG4gKi9cbmdvb2cuc3RyaW5nLnJlcGVhdCA9IChTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkgP1xuICAgIGZ1bmN0aW9uKHN0cmluZywgbGVuZ3RoKSB7XG4gICAgICAvLyBUaGUgbmF0aXZlIG1ldGhvZCBpcyBvdmVyIDEwMCB0aW1lcyBmYXN0ZXIgdGhhbiB0aGUgYWx0ZXJuYXRpdmUuXG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGVhdChsZW5ndGgpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKHN0cmluZywgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5KGxlbmd0aCArIDEpLmpvaW4oc3RyaW5nKTtcbiAgICB9O1xuXG5cbi8qKlxuICogUGFkcyBudW1iZXIgdG8gZ2l2ZW4gbGVuZ3RoIGFuZCBvcHRpb25hbGx5IHJvdW5kcyBpdCB0byBhIGdpdmVuIHByZWNpc2lvbi5cbiAqIEZvciBleGFtcGxlOlxuICogPHByZT5wYWROdW1iZXIoMS4yNSwgMiwgMykgLT4gJzAxLjI1MCdcbiAqIHBhZE51bWJlcigxLjI1LCAyKSAtPiAnMDEuMjUnXG4gKiBwYWROdW1iZXIoMS4yNSwgMiwgMSkgLT4gJzAxLjMnXG4gKiBwYWROdW1iZXIoMS4yNSwgMCkgLT4gJzEuMjUnPC9wcmU+XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIHBhZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGRlc2lyZWQgbGVuZ3RoLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcHJlY2lzaW9uIFRoZSBkZXNpcmVkIHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge3N0cmluZ30ge0Bjb2RlIG51bX0gYXMgYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqL1xuZ29vZy5zdHJpbmcucGFkTnVtYmVyID0gZnVuY3Rpb24obnVtLCBsZW5ndGgsIG9wdF9wcmVjaXNpb24pIHtcbiAgdmFyIHMgPSBnb29nLmlzRGVmKG9wdF9wcmVjaXNpb24pID8gbnVtLnRvRml4ZWQob3B0X3ByZWNpc2lvbikgOiBTdHJpbmcobnVtKTtcbiAgdmFyIGluZGV4ID0gcy5pbmRleE9mKCcuJyk7XG4gIGlmIChpbmRleCA9PSAtMSkge1xuICAgIGluZGV4ID0gcy5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGdvb2cuc3RyaW5nLnJlcGVhdCgnMCcsIE1hdGgubWF4KDAsIGxlbmd0aCAtIGluZGV4KSkgKyBzO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIG9iamVjdCwgd2l0aFxuICogbnVsbCBhbmQgdW5kZWZpbmVkIGJlaW5nIHJldHVybmVkIGFzIHRoZSBlbXB0eSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUge0Bjb2RlIG9ian0uXG4gKi9cbmdvb2cuc3RyaW5nLm1ha2VTYWZlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT0gbnVsbCA/ICcnIDogU3RyaW5nKG9iaik7XG59O1xuXG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHN0cmluZyBleHByZXNzaW9ucy4gVGhpcyBpcyB1c2VmdWxcbiAqIHNpbmNlIHNvbWUgYnJvd3NlcnMgYXJlIHZlcnkgaW5lZmZpY2llbnQgd2hlbiBpdCBjb21lcyB0byB1c2luZyBwbHVzIHRvXG4gKiBjb25jYXQgc3RyaW5ncy4gQmUgY2FyZWZ1bCB3aGVuIHVzaW5nIG51bGwgYW5kIHVuZGVmaW5lZCBoZXJlIHNpbmNlXG4gKiB0aGVzZSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBJZiB5b3UgbmVlZCB0byByZXByZXNlbnQgdGhlc2VcbiAqIGJlIHN1cmUgdG8gY2FzdCB0aGUgYXJndW1lbnQgdG8gYSBTdHJpbmcgZmlyc3QuXG4gKiBGb3IgZXhhbXBsZTpcbiAqIDxwcmU+YnVpbGRTdHJpbmcoJ2EnLCAnYicsICdjJywgJ2QnKSAtPiAnYWJjZCdcbiAqIGJ1aWxkU3RyaW5nKG51bGwsIHVuZGVmaW5lZCkgLT4gJydcbiAqIDwvcHJlPlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBIGxpc3Qgb2Ygc3RyaW5ncyB0byBjb25jYXRlbmF0ZS4gSWYgbm90IGEgc3RyaW5nLFxuICogICAgIGl0IHdpbGwgYmUgY2FzdGVkIHRvIG9uZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbmNhdGVuYXRpb24gb2Yge0Bjb2RlIHZhcl9hcmdzfS5cbiAqL1xuZ29vZy5zdHJpbmcuYnVpbGRTdHJpbmcgPSBmdW5jdGlvbih2YXJfYXJncykge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICpcbiAqIERvZXNuJ3QgdHJ1c3QgSmF2YXNjcmlwdCdzIHJhbmRvbSBmdW5jdGlvbiBlbnRpcmVseS4gVXNlcyBhIGNvbWJpbmF0aW9uIG9mXG4gKiByYW5kb20gYW5kIGN1cnJlbnQgdGltZXN0YW1wLCBhbmQgdGhlbiBlbmNvZGVzIHRoZSBzdHJpbmcgaW4gYmFzZS0zNiB0b1xuICogbWFrZSBpdCBzaG9ydGVyLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cbiAqL1xuZ29vZy5zdHJpbmcuZ2V0UmFuZG9tU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gMjE0NzQ4MzY0ODtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArXG4gICAgICAgICBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIGdvb2cubm93KCkpLnRvU3RyaW5nKDM2KTtcbn07XG5cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gdmVyc2lvbiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmVyc2lvbjEgVmVyc2lvbiBvZiBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2ZXJzaW9uMiBWZXJzaW9uIG9mIHNlY29uZCBpdGVtLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gIDEgaWYge0Bjb2RlIHZlcnNpb24xfSBpcyBoaWdoZXIuXG4gKiAgICAgICAgICAgICAgICAgICAwIGlmIGFyZ3VtZW50cyBhcmUgZXF1YWwuXG4gKiAgICAgICAgICAgICAgICAgIC0xIGlmIHtAY29kZSB2ZXJzaW9uMn0gaXMgaGlnaGVyLlxuICovXG5nb29nLnN0cmluZy5jb21wYXJlVmVyc2lvbnMgPSBmdW5jdGlvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgdmFyIG9yZGVyID0gMDtcbiAgLy8gVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIGFuZCBzcGxpdCB0aGUgdmVyc2lvbnMgaW50b1xuICAvLyBzdWJ2ZXJzaW9ucy5cbiAgdmFyIHYxU3VicyA9IGdvb2cuc3RyaW5nLnRyaW0oU3RyaW5nKHZlcnNpb24xKSkuc3BsaXQoJy4nKTtcbiAgdmFyIHYyU3VicyA9IGdvb2cuc3RyaW5nLnRyaW0oU3RyaW5nKHZlcnNpb24yKSkuc3BsaXQoJy4nKTtcbiAgdmFyIHN1YkNvdW50ID0gTWF0aC5tYXgodjFTdWJzLmxlbmd0aCwgdjJTdWJzLmxlbmd0aCk7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBzdWJ2ZXJzaW9ucywgYXMgbG9uZyBhcyB0aGV5IGFwcGVhciB0byBiZSBlcXVpdmFsZW50LlxuICBmb3IgKHZhciBzdWJJZHggPSAwOyBvcmRlciA9PSAwICYmIHN1YklkeCA8IHN1YkNvdW50OyBzdWJJZHgrKykge1xuICAgIHZhciB2MVN1YiA9IHYxU3Vic1tzdWJJZHhdIHx8ICcnO1xuICAgIHZhciB2MlN1YiA9IHYyU3Vic1tzdWJJZHhdIHx8ICcnO1xuXG4gICAgLy8gU3BsaXQgdGhlIHN1YnZlcnNpb25zIGludG8gcGFpcnMgb2YgbnVtYmVycyBhbmQgcXVhbGlmaWVycyAobGlrZSAnYicpLlxuICAgIC8vIFR3byBkaWZmZXJlbnQgUmVnRXhwIG9iamVjdHMgYXJlIG5lZWRlZCBiZWNhdXNlIHRoZXkgYXJlIGJvdGggdXNpbmdcbiAgICAvLyB0aGUgJ2cnIGZsYWcuXG4gICAgdmFyIHYxQ29tcFBhcnNlciA9IG5ldyBSZWdFeHAoJyhcXFxcZCopKFxcXFxEKiknLCAnZycpO1xuICAgIHZhciB2MkNvbXBQYXJzZXIgPSBuZXcgUmVnRXhwKCcoXFxcXGQqKShcXFxcRCopJywgJ2cnKTtcbiAgICBkbyB7XG4gICAgICB2YXIgdjFDb21wID0gdjFDb21wUGFyc2VyLmV4ZWModjFTdWIpIHx8IFsnJywgJycsICcnXTtcbiAgICAgIHZhciB2MkNvbXAgPSB2MkNvbXBQYXJzZXIuZXhlYyh2MlN1YikgfHwgWycnLCAnJywgJyddO1xuICAgICAgLy8gQnJlYWsgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbiAgICAgIGlmICh2MUNvbXBbMF0ubGVuZ3RoID09IDAgJiYgdjJDb21wWzBdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSB0aGUgbnVtZXJpYyBwYXJ0IG9mIHRoZSBzdWJ2ZXJzaW9uLiBBIG1pc3NpbmcgbnVtYmVyIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIDAuXG4gICAgICB2YXIgdjFDb21wTnVtID0gdjFDb21wWzFdLmxlbmd0aCA9PSAwID8gMCA6IHBhcnNlSW50KHYxQ29tcFsxXSwgMTApO1xuICAgICAgdmFyIHYyQ29tcE51bSA9IHYyQ29tcFsxXS5sZW5ndGggPT0gMCA/IDAgOiBwYXJzZUludCh2MkNvbXBbMV0sIDEwKTtcblxuICAgICAgLy8gQ29tcGFyZSB0aGUgc3VidmVyc2lvbiBjb21wb25lbnRzLiBUaGUgbnVtYmVyIGhhcyB0aGUgaGlnaGVzdFxuICAgICAgLy8gcHJlY2VkZW5jZS4gTmV4dCwgaWYgdGhlIG51bWJlcnMgYXJlIGVxdWFsLCBhIHN1YnZlcnNpb24gd2l0aG91dCBhbnlcbiAgICAgIC8vIHF1YWxpZmllciBpcyBhbHdheXMgaGlnaGVyIHRoYW4gYSBzdWJ2ZXJzaW9uIHdpdGggYW55IHF1YWxpZmllci4gTmV4dCxcbiAgICAgIC8vIHRoZSBxdWFsaWZpZXJzIGFyZSBjb21wYXJlZCBhcyBzdHJpbmdzLlxuICAgICAgb3JkZXIgPSBnb29nLnN0cmluZy5jb21wYXJlRWxlbWVudHNfKHYxQ29tcE51bSwgdjJDb21wTnVtKSB8fFxuICAgICAgICAgIGdvb2cuc3RyaW5nLmNvbXBhcmVFbGVtZW50c18odjFDb21wWzJdLmxlbmd0aCA9PSAwLFxuICAgICAgICAgICAgICB2MkNvbXBbMl0ubGVuZ3RoID09IDApIHx8XG4gICAgICAgICAgZ29vZy5zdHJpbmcuY29tcGFyZUVsZW1lbnRzXyh2MUNvbXBbMl0sIHYyQ29tcFsyXSk7XG4gICAgICAvLyBTdG9wIGFzIHNvb24gYXMgYW4gaW5lcXVhbGl0eSBpcyBkaXNjb3ZlcmVkLlxuICAgIH0gd2hpbGUgKG9yZGVyID09IDApO1xuICB9XG5cbiAgcmV0dXJuIG9yZGVyO1xufTtcblxuXG4vKipcbiAqIENvbXBhcmVzIGVsZW1lbnRzIG9mIGEgdmVyc2lvbiBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IGxlZnQgQW4gZWxlbWVudCBmcm9tIGEgdmVyc2lvbiBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gcmlnaHQgQW4gZWxlbWVudCBmcm9tIGEgdmVyc2lvbiBudW1iZXIuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSAgMSBpZiB7QGNvZGUgbGVmdH0gaXMgaGlnaGVyLlxuICogICAgICAgICAgICAgICAgICAgMCBpZiBhcmd1bWVudHMgYXJlIGVxdWFsLlxuICogICAgICAgICAgICAgICAgICAtMSBpZiB7QGNvZGUgcmlnaHR9IGlzIGhpZ2hlci5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLmNvbXBhcmVFbGVtZW50c18gPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGxlZnQgPiByaWdodCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuXG4vKipcbiAqIFN0cmluZyBoYXNoIGZ1bmN0aW9uIHNpbWlsYXIgdG8gamF2YS5sYW5nLlN0cmluZy5oYXNoQ29kZSgpLlxuICogVGhlIGhhc2ggY29kZSBmb3IgYSBzdHJpbmcgaXMgY29tcHV0ZWQgYXNcbiAqIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gKiB3aGVyZSBzW2ldIGlzIHRoZSBpdGggY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgYW5kIG4gaXMgdGhlIGxlbmd0aCBvZlxuICogdGhlIHN0cmluZy4gV2UgbW9kIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzJcbiAqIChleGNsdXNpdmUpLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaCB2YWx1ZSBmb3Ige0Bjb2RlIHN0cn0sIGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMlxuICogIChleGNsdXNpdmUpLiBUaGUgZW1wdHkgc3RyaW5nIHJldHVybnMgMC5cbiAqL1xuZ29vZy5zdHJpbmcuaGFzaENvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9ybWFsaXplIHRvIDQgYnl0ZSByYW5nZSwgMCAuLi4gMl4zMi5cbiAgICByZXN1bHQgPSAoMzEgKiByZXN1bHQgKyBzdHIuY2hhckNvZGVBdChpKSkgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBUaGUgbW9zdCByZWNlbnQgdW5pcXVlIElELiB8MCBpcyBlcXVpdmFsZW50IHRvIE1hdGguZmxvb3IgaW4gdGhpcyBjYXNlLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLnVuaXF1ZVN0cmluZ0NvdW50ZXJfID0gTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwMDAgfCAwO1xuXG5cbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdoaWNoIGlzIHVuaXF1ZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAqIFRoaXMgaXMgdXNlZnVsLCBmb3IgZXhhbXBsZSwgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIERPTSBlbGVtZW50cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKi9cbmdvb2cuc3RyaW5nLmNyZWF0ZVVuaXF1ZVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ2dvb2dfJyArIGdvb2cuc3RyaW5nLnVuaXF1ZVN0cmluZ0NvdW50ZXJfKys7XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgdGhlIHN1cHBsaWVkIHN0cmluZyB0byBhIG51bWJlciwgd2hpY2ggbWF5IGJlIEluZmluaXR5IG9yIE5hTi5cbiAqIFRoaXMgZnVuY3Rpb24gc3RyaXBzIHdoaXRlc3BhY2U6ICh0b051bWJlcignIDEyMycpID09PSAxMjMpXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgc2NpZW50aWZpYyBub3RhdGlvbjogKHRvTnVtYmVyKCcxZTEnKSA9PT0gMTApXG4gKlxuICogVGhpcyBpcyBiZXR0ZXIgdGhhbiBKYXZhc2NyaXB0J3MgYnVpbHQtaW4gY29udmVyc2lvbnMgYmVjYXVzZSwgc2FkbHk6XG4gKiAgICAgKE51bWJlcignICcpID09PSAwKSBhbmQgKHBhcnNlRmxvYXQoJzEyM2EnKSA9PT0gMTIzKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIHRoZSBzdXBwbGllZCBzdHJpbmcgcmVwcmVzZW50cywgb3IgTmFOLlxuICovXG5nb29nLnN0cmluZy50b051bWJlciA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgbnVtID0gTnVtYmVyKHN0cik7XG4gIGlmIChudW0gPT0gMCAmJiBnb29nLnN0cmluZy5pc0VtcHR5T3JXaGl0ZXNwYWNlKHN0cikpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBudW07XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaXMgbG93ZXIgY2FtZWwgY2FzZSAoZS5nLiBcImlzRm9vQmFyXCIpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGFzc3VtZXMgdGhlIHN0cmluZyBpcyBlbnRpcmVseSBsZXR0ZXJzLlxuICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSNWYXJpYXRpb25zX2FuZF9zeW5vbnltc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgaXMgbG93ZXIgY2FtZWwgY2FzZS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNMb3dlckNhbWVsQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gL15bYS16XSsoW0EtWl1bYS16XSopKiQvLnRlc3Qoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBpcyB1cHBlciBjYW1lbCBjYXNlIChlLmcuIFwiRm9vQmFyQmF6XCIpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGFzc3VtZXMgdGhlIHN0cmluZyBpcyBlbnRpcmVseSBsZXR0ZXJzLlxuICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSNWYXJpYXRpb25zX2FuZF9zeW5vbnltc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgaXMgdXBwZXIgY2FtZWwgY2FzZS5cbiAqL1xuZ29vZy5zdHJpbmcuaXNVcHBlckNhbWVsQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gL14oW0EtWl1bYS16XSopKyQvLnRlc3Qoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBmcm9tIHNlbGVjdG9yLWNhc2UgdG8gY2FtZWxDYXNlIChlLmcuIGZyb21cbiAqIFwibXVsdGktcGFydC1zdHJpbmdcIiB0byBcIm11bHRpUGFydFN0cmluZ1wiKSwgdXNlZnVsIGZvciBjb252ZXJ0aW5nXG4gKiBDU1Mgc2VsZWN0b3JzIGFuZCBIVE1MIGRhdGFzZXQga2V5cyB0byB0aGVpciBlcXVpdmFsZW50IEpTIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgaW4gc2VsZWN0b3ItY2FzZSBmb3JtLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGluIGNhbWVsQ2FzZSBmb3JtLlxuICovXG5nb29nLnN0cmluZy50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvXFwtKFthLXpdKS9nLCBmdW5jdGlvbihhbGwsIG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGZyb20gY2FtZWxDYXNlIHRvIHNlbGVjdG9yLWNhc2UgKGUuZy4gZnJvbVxuICogXCJtdWx0aVBhcnRTdHJpbmdcIiB0byBcIm11bHRpLXBhcnQtc3RyaW5nXCIpLCB1c2VmdWwgZm9yIGNvbnZlcnRpbmcgSlNcbiAqIHN0eWxlIGFuZCBkYXRhc2V0IHByb3BlcnRpZXMgdG8gZXF1aXZhbGVudCBDU1Mgc2VsZWN0b3JzIGFuZCBIVE1MIGtleXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgaW4gY2FtZWxDYXNlIGZvcm0uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgaW4gc2VsZWN0b3ItY2FzZSBmb3JtLlxuICovXG5nb29nLnN0cmluZy50b1NlbGVjdG9yQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIFRpdGxlQ2FzZS4gRmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgaXMgYWx3YXlzXG4gKiBjYXBpdGFsaXplZCBpbiBhZGRpdGlvbiB0byB0aGUgZmlyc3QgbGV0dGVyIG9mIGV2ZXJ5IHN1YnNlcXVlbnQgd29yZC5cbiAqIFdvcmRzIGFyZSBkZWxpbWl0ZWQgYnkgb25lIG9yIG1vcmUgd2hpdGVzcGFjZXMgYnkgZGVmYXVsdC4gQ3VzdG9tIGRlbGltaXRlcnNcbiAqIGNhbiBvcHRpb25hbGx5IGJlIHNwZWNpZmllZCB0byByZXBsYWNlIHRoZSBkZWZhdWx0LCB3aGljaCBkb2Vzbid0IHByZXNlcnZlXG4gKiB3aGl0ZXNwYWNlIGRlbGltaXRlcnMgYW5kIGluc3RlYWQgbXVzdCBiZSBleHBsaWNpdGx5IGluY2x1ZGVkIGlmIG5lZWRlZC5cbiAqXG4gKiBEZWZhdWx0IGRlbGltaXRlciA9PiBcIiBcIjpcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmVUd29UaHJlZScpICAgID0+ICdPbmVUd29UaHJlZSdcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmUgdHdvIHRocmVlJykgID0+ICdPbmUgVHdvIFRocmVlJ1xuICogICAgZ29vZy5zdHJpbmcudG9UaXRsZUNhc2UoJyAgb25lICAgdHdvICAgJykgPT4gJyAgT25lICAgVHdvICAgJ1xuICogICAgZ29vZy5zdHJpbmcudG9UaXRsZUNhc2UoJ29uZV90d29fdGhyZWUnKSAgPT4gJ09uZV90d29fdGhyZWUnXG4gKiAgICBnb29nLnN0cmluZy50b1RpdGxlQ2FzZSgnb25lLXR3by10aHJlZScpICA9PiAnT25lLXR3by10aHJlZSdcbiAqXG4gKiBDdXN0b20gZGVsaW1pdGVyID0+IFwiXy0uXCI6XG4gKiAgICBnb29nLnN0cmluZy50b1RpdGxlQ2FzZSgnb25lVHdvVGhyZWUnLCAnXy0uJykgICAgICAgPT4gJ09uZVR3b1RocmVlJ1xuICogICAgZ29vZy5zdHJpbmcudG9UaXRsZUNhc2UoJ29uZSB0d28gdGhyZWUnLCAnXy0uJykgICAgID0+ICdPbmUgdHdvIHRocmVlJ1xuICogICAgZ29vZy5zdHJpbmcudG9UaXRsZUNhc2UoJyAgb25lICAgdHdvICAgJywgJ18tLicpICAgID0+ICcgIG9uZSAgIHR3byAgICdcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmVfdHdvX3RocmVlJywgJ18tLicpICAgICA9PiAnT25lX1R3b19UaHJlZSdcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmUtdHdvLXRocmVlJywgJ18tLicpICAgICA9PiAnT25lLVR3by1UaHJlZSdcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmUuLi50d28uLi50aHJlZScsICdfLS4nKSA9PiAnT25lLi4uVHdvLi4uVGhyZWUnXG4gKiAgICBnb29nLnN0cmluZy50b1RpdGxlQ2FzZSgnb25lLiB0d28uIHRocmVlJywgJ18tLicpICAgPT4gJ09uZS4gdHdvLiB0aHJlZSdcbiAqICAgIGdvb2cuc3RyaW5nLnRvVGl0bGVDYXNlKCdvbmUtdHdvLnRocmVlJywgJ18tLicpICAgICA9PiAnT25lLVR3by5UaHJlZSdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB2YWx1ZSBpbiBjYW1lbENhc2UgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RlbGltaXRlcnMgQ3VzdG9tIGRlbGltaXRlciBjaGFyYWN0ZXIgc2V0IHVzZWQgdG9cbiAqICAgICAgZGlzdGluZ3Vpc2ggd29yZHMgaW4gdGhlIHN0cmluZyB2YWx1ZS4gRWFjaCBjaGFyYWN0ZXIgcmVwcmVzZW50cyBhXG4gKiAgICAgIHNpbmdsZSBkZWxpbWl0ZXIuIFdoZW4gcHJvdmlkZWQsIGRlZmF1bHQgd2hpdGVzcGFjZSBkZWxpbWl0ZXIgaXNcbiAqICAgICAgb3ZlcnJpZGRlbiBhbmQgbXVzdCBiZSBleHBsaWNpdGx5IGluY2x1ZGVkIGlmIG5lZWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHZhbHVlIGluIFRpdGxlQ2FzZSBmb3JtLlxuICovXG5nb29nLnN0cmluZy50b1RpdGxlQ2FzZSA9IGZ1bmN0aW9uKHN0ciwgb3B0X2RlbGltaXRlcnMpIHtcbiAgdmFyIGRlbGltaXRlcnMgPSBnb29nLmlzU3RyaW5nKG9wdF9kZWxpbWl0ZXJzKSA/XG4gICAgICBnb29nLnN0cmluZy5yZWdFeHBFc2NhcGUob3B0X2RlbGltaXRlcnMpIDogJ1xcXFxzJztcblxuICAvLyBGb3IgSUU4LCB3ZSBuZWVkIHRvIHByZXZlbnQgdXNpbmcgYW4gZW1wdHkgY2hhcmFjdGVyIHNldC4gT3RoZXJ3aXNlLFxuICAvLyBpbmNvcnJlY3QgbWF0Y2hpbmcgd2lsbCBvY2N1ci5cbiAgZGVsaW1pdGVycyA9IGRlbGltaXRlcnMgPyAnfFsnICsgZGVsaW1pdGVycyArICddKycgOiAnJztcblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKF4nICsgZGVsaW1pdGVycyArICcpKFthLXpdKScsICdnJyk7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKGFsbCwgcDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxICsgcDIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcsIGkuZS4gY29udmVydHMgdGhlIGZpcnN0IGxldHRlciB0byB1cHBlcmNhc2VcbiAqIGFuZCBhbGwgb3RoZXIgbGV0dGVycyB0byBsb3dlcmNhc2UsIGUuZy46XG4gKlxuICogZ29vZy5zdHJpbmcuY2FwaXRhbGl6ZSgnb25lJykgICAgID0+ICdPbmUnXG4gKiBnb29nLnN0cmluZy5jYXBpdGFsaXplKCdPTkUnKSAgICAgPT4gJ09uZSdcbiAqIGdvb2cuc3RyaW5nLmNhcGl0YWxpemUoJ29uZSB0d28nKSA9PiAnT25lIHR3bydcbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0cmltIGluaXRpYWwgd2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB2YWx1ZSB0byBjYXBpdGFsaXplLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgdmFsdWUgd2l0aCBmaXJzdCBsZXR0ZXIgaW4gdXBwZXJjYXNlLlxuICovXG5nb29nLnN0cmluZy5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyLmNoYXJBdCgwKSkudG9VcHBlckNhc2UoKSArXG4gICAgICBTdHJpbmcoc3RyLnN1YnN0cigxKSkudG9Mb3dlckNhc2UoKTtcbn07XG5cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbiBkZWNpbWFsIG9yIGhleGlkZWNpbWFsICgnMHhGRkZGJykgZm9ybS5cbiAqXG4gKiBUbyBwYXJzZSBhIHBhcnRpY3VsYXIgcmFkaXgsIHBsZWFzZSB1c2UgcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkgZGlyZWN0bHkuIFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcGFyc2VJbnRcbiAqXG4gKiBUaGlzIGlzIGEgd3JhcHBlciBmb3IgdGhlIGJ1aWx0LWluIHBhcnNlSW50IGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IHBhcnNlXG4gKiBudW1iZXJzIGFzIGJhc2UgMTAgb3IgYmFzZSAxNi4gIFNvbWUgSlMgaW1wbGVtZW50YXRpb25zIGFzc3VtZSBzdHJpbmdzXG4gKiBzdGFydGluZyB3aXRoIFwiMFwiIGFyZSBpbnRlbmRlZCB0byBiZSBvY3RhbC4gRVMzIGFsbG93ZWQgYnV0IGRpc2NvdXJhZ2VkXG4gKiB0aGlzIGJlaGF2aW9yLiBFUzUgZm9yYmlkcyBpdC4gIFRoaXMgZnVuY3Rpb24gZW11bGF0ZXMgdGhlIEVTNSBiZWhhdmlvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIE1vemlsbGEgSlMgUmVmZXJlbmNlOiBodHRwOi8vZ29vLmdsLzhSaUZqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfG51bGx8dW5kZWZpbmVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyLCBwYXJzZWQuIElmIHRoZSBzdHJpbmcgZmFpbGVkIHRvIHBhcnNlLCB0aGlzXG4gKiAgICAgd2lsbCBiZSBOYU4uXG4gKi9cbmdvb2cuc3RyaW5nLnBhcnNlSW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gRm9yY2UgZmluaXRlIG51bWJlcnMgdG8gc3RyaW5ncy5cbiAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChnb29nLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggJzB4JyBvciAnLTB4JywgcGFyc2UgYXMgaGV4LlxuICAgIHJldHVybiAvXlxccyotPzB4L2kudGVzdCh2YWx1ZSkgP1xuICAgICAgICBwYXJzZUludCh2YWx1ZSwgMTYpIDogcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfVxuXG4gIHJldHVybiBOYU47XG59O1xuXG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIG9uIGEgc2VwYXJhdG9yIGEgbGltaXRlZCBudW1iZXIgb2YgdGltZXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBtb3JlIHNpbWlsYXIgdG8gUHl0aG9uIG9yIEphdmEsIHdoZXJlIHRoZSBsaW1pdFxuICogcGFyYW1ldGVyIHNwZWNpZmllcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHJhdGhlciB0aGFuIHRydW5jYXRpbmdcbiAqIHRoZSBudW1iZXIgb2YgcmVzdWx0cy5cbiAqXG4gKiBTZWUgaHR0cDovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvc3RkdHlwZXMuaHRtbCNzdHIuc3BsaXRcbiAqIFNlZSBKYXZhRG9jOiBodHRwOi8vZ29vLmdsL0YyQXNZXG4gKiBTZWUgTW96aWxsYSByZWZlcmVuY2U6IGh0dHA6Ly9nb28uZ2wvZFpkWnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbGltaXQgdG8gdGhlIG51bWJlciBvZiBzcGxpdHMuIFRoZSByZXN1bHRpbmcgYXJyYXlcbiAqICAgICB3aWxsIGhhdmUgYSBtYXhpbXVtIGxlbmd0aCBvZiBsaW1pdCsxLiAgTmVnYXRpdmUgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAqICAgICBhcyB6ZXJvLlxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IFRoZSBzdHJpbmcsIHNwbGl0LlxuICovXG5cbmdvb2cuc3RyaW5nLnNwbGl0TGltaXQgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gIHZhciByZXR1cm5WYWwgPSBbXTtcblxuICAvLyBPbmx5IGNvbnRpbnVlIGRvaW5nIHRoaXMgd2hpbGUgd2UgaGF2ZW4ndCBoaXQgdGhlIGxpbWl0IGFuZCB3ZSBoYXZlXG4gIC8vIHBhcnRzIGxlZnQuXG4gIHdoaWxlIChsaW1pdCA+IDAgJiYgcGFydHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuVmFsLnB1c2gocGFydHMuc2hpZnQoKSk7XG4gICAgbGltaXQtLTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSByZW1haW5pbmcgcGFydHMsIGFwcGVuZCB0aGVtIHRvIHRoZSBlbmQuXG4gIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm5WYWwucHVzaChwYXJ0cy5qb2luKHNlcGFyYXRvcikpO1xuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbDtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgTGV2ZW5zaHRlaW4gZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBzdHJpbmdzLlxuICovXG5nb29nLnN0cmluZy5lZGl0RGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB2MCA9IFtdO1xuICB2YXIgdjEgPSBbXTtcblxuICBpZiAoYSA9PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWEubGVuZ3RoIHx8ICFiLmxlbmd0aCkge1xuICAgIHJldHVybiBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aCArIDE7IGkrKykge1xuICAgIHYwW2ldID0gaTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHYxWzBdID0gaSArIDE7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBjb3N0ID0gYVtpXSAhPSBiW2pdO1xuICAgICAgLy8gQ29zdCBmb3IgdGhlIHN1YnN0cmluZyBpcyB0aGUgbWluaW11bSBvZiBhZGRpbmcgb25lIGNoYXJhY3RlciwgcmVtb3ZpbmdcbiAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIG9yIGEgc3dhcC5cbiAgICAgIHYxW2ogKyAxXSA9IE1hdGgubWluKHYxW2pdICsgMSwgdjBbaiArIDFdICsgMSwgdjBbal0gKyBjb3N0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHYwLmxlbmd0aDsgaisrKSB7XG4gICAgICB2MFtqXSA9IHYxW2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2MVtiLmxlbmd0aF07XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMDggVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXRpZXMgdG8gY2hlY2sgdGhlIHByZWNvbmRpdGlvbnMsIHBvc3Rjb25kaXRpb25zIGFuZFxuICogaW52YXJpYW50cyBydW50aW1lLlxuICpcbiAqIE1ldGhvZHMgaW4gdGhpcyBwYWNrYWdlIHNob3VsZCBiZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBieSB0aGUgY29tcGlsZXJcbiAqIGZvciB0eXBlLWluZmVyZW5jZS4gRm9yIGV4YW1wbGUsIDxjb2RlPmdvb2cuYXNzZXJ0cy5hc3NlcnQoZm9vKTwvY29kZT5cbiAqIHdpbGwgcmVzdHJpY3QgPGNvZGU+Zm9vPC9jb2RlPiB0byBhIHRydXRoeSB2YWx1ZS5cbiAqXG4gKiBUaGUgY29tcGlsZXIgaGFzIGFuIG9wdGlvbiB0byBkaXNhYmxlIGFzc2VydHMuIFNvIGNvZGUgbGlrZTpcbiAqIDxjb2RlPlxuICogdmFyIHggPSBnb29nLmFzc2VydHMuYXNzZXJ0KGZvbygpKTsgZ29vZy5hc3NlcnRzLmFzc2VydChiYXIoKSk7XG4gKiA8L2NvZGU+XG4gKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG86XG4gKiA8Y29kZT5cbiAqIHZhciB4ID0gZm9vKCk7XG4gKiA8L2NvZGU+XG4gKiBUaGUgY29tcGlsZXIgd2lsbCBsZWF2ZSBpbiBmb28oKSAoYmVjYXVzZSBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQpLFxuICogYnV0IGl0IHdpbGwgcmVtb3ZlIGJhcigpIGJlY2F1c2UgaXQgYXNzdW1lcyBpdCBkb2VzIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy5cbiAqXG4gKiBAYXV0aG9yIGFncmlldmVAZ29vZ2xlLmNvbSAoQW5kcmV3IEdyaWV2ZSlcbiAqL1xuXG5nb29nLnByb3ZpZGUoJ2dvb2cuYXNzZXJ0cycpO1xuZ29vZy5wcm92aWRlKCdnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3InKTtcblxuZ29vZy5yZXF1aXJlKCdnb29nLmRlYnVnLkVycm9yJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuZG9tLk5vZGVUeXBlJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuc3RyaW5nJyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIHN0cmlwIG91dCBhc3NlcnRzIG9yIHRvIGxlYXZlIHRoZW0gaW4uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMnLCBnb29nLkRFQlVHKTtcblxuXG5cbi8qKlxuICogRXJyb3Igb2JqZWN0IGZvciBmYWlsZWQgYXNzZXJ0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlUGF0dGVybiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIGZvcm0gbWVzc2FnZS5cbiAqIEBwYXJhbSB7IUFycmF5PCo+fSBtZXNzYWdlQXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBwYXR0ZXJuLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Z29vZy5kZWJ1Zy5FcnJvcn1cbiAqIEBmaW5hbFxuICovXG5nb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlUGF0dGVybiwgbWVzc2FnZUFyZ3MpIHtcbiAgbWVzc2FnZUFyZ3MudW5zaGlmdChtZXNzYWdlUGF0dGVybik7XG4gIGdvb2cuZGVidWcuRXJyb3IuY2FsbCh0aGlzLCBnb29nLnN0cmluZy5zdWJzLmFwcGx5KG51bGwsIG1lc3NhZ2VBcmdzKSk7XG4gIC8vIFJlbW92ZSB0aGUgbWVzc2FnZVBhdHRlcm4gYWZ0ZXJ3YXJkcyB0byBhdm9pZCBwZXJtYW5lbnRseSBtb2RpZnlpbmcgdGhlXG4gIC8vIHBhc3NlZCBpbiBhcnJheS5cbiAgbWVzc2FnZUFyZ3Muc2hpZnQoKTtcblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgcGF0dGVybiB1c2VkIHRvIGZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZS4gRXJyb3IgaGFuZGxlcnMgY2FuXG4gICAqIHVzZSB0aGlzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBhc3NlcnRpb24uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm1lc3NhZ2VQYXR0ZXJuID0gbWVzc2FnZVBhdHRlcm47XG59O1xuZ29vZy5pbmhlcml0cyhnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IsIGdvb2cuZGVidWcuRXJyb3IpO1xuXG5cbi8qKiBAb3ZlcnJpZGUgKi9cbmdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyLlxuICogQHBhcmFtIHshZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBlIFRoZSBleGNlcHRpb24gdG8gYmUgaGFuZGxlZC5cbiAqL1xuZ29vZy5hc3NlcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uKGUpIHsgdGhyb3cgZTsgfTtcblxuXG4vKipcbiAqIFRoZSBoYW5kbGVyIHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyBvciBsb2dnaW5nIGFzc2VydGlvbiBlcnJvcnMuXG4gKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIWdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcil9XG4gKi9cbmdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfID0gZ29vZy5hc3NlcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUjtcblxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBhbmQgXCJBc3NlcnRpb24gZmFpbGVkXCIgcHJlZml4ZWRcbiAqIG9udG8gaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gdXNlIGlmIGdpdmVuTWVzc2FnZSBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGRlZmF1bHRBcmdzIFRoZSBzdWJzdGl0dXRpb24gYXJndW1lbnRzIGZvciBkZWZhdWx0TWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZ2l2ZW5NZXNzYWdlIE1lc3NhZ2Ugc3VwcGxpZWQgYnkgdGhlIGNhbGxlci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGdpdmVuQXJncyBUaGUgc3Vic3RpdHV0aW9uIGFyZ3VtZW50cyBmb3IgZ2l2ZW5NZXNzYWdlLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXyA9XG4gICAgZnVuY3Rpb24oZGVmYXVsdE1lc3NhZ2UsIGRlZmF1bHRBcmdzLCBnaXZlbk1lc3NhZ2UsIGdpdmVuQXJncykge1xuICB2YXIgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkJztcbiAgaWYgKGdpdmVuTWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgKz0gJzogJyArIGdpdmVuTWVzc2FnZTtcbiAgICB2YXIgYXJncyA9IGdpdmVuQXJncztcbiAgfSBlbHNlIGlmIChkZWZhdWx0TWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgKz0gJzogJyArIGRlZmF1bHRNZXNzYWdlO1xuICAgIGFyZ3MgPSBkZWZhdWx0QXJncztcbiAgfVxuICAvLyBUaGUgJycgKyB3b3JrcyBhcm91bmQgYW4gT3BlcmEgMTAgYnVnIGluIHRoZSB1bml0IHRlc3RzLiBXaXRob3V0IGl0LFxuICAvLyBhIHN0YWNrIHRyYWNlIGlzIGFkZGVkIHRvIHZhciBtZXNzYWdlIGFib3ZlLiBXaXRoIHRoaXMsIGEgc3RhY2sgdHJhY2UgaXNcbiAgLy8gbm90IGFkZGVkIHVudGlsIHRoaXMgbGluZSAoaXQgY2F1c2VzIHRoZSBleHRyYSBnYXJiYWdlIHRvIGJlIGFkZGVkIGFmdGVyXG4gIC8vIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBpbnN0ZWFkIG9mIGluIHRoZSBtaWRkbGUgb2YgaXQpLlxuICB2YXIgZSA9IG5ldyBnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IoJycgKyBtZXNzYWdlLCBhcmdzIHx8IFtdKTtcbiAgZ29vZy5hc3NlcnRzLmVycm9ySGFuZGxlcl8oZSk7XG59O1xuXG5cbi8qKlxuICogU2V0cyBhIGN1c3RvbSBlcnJvciBoYW5kbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZlxuICogYXNzZXJ0aW9uIGZhaWx1cmVzLCBmb3IgZXhhbXBsZSBieSB0dXJuaW5nIGFsbCBhc3NlcnRpb24gZmFpbHVyZXMgaW50byBsb2dcbiAqIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbighZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKX0gZXJyb3JIYW5kbGVyXG4gKi9cbmdvb2cuYXNzZXJ0cy5zZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvckhhbmRsZXIpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUykge1xuICAgIGdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzXG4gKiB0cnVlLlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtUfSBUaGUgdmFsdWUgb2YgdGhlIGNvbmRpdGlvbi5cbiAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBmYWxzZS5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWNvbmRpdGlvbikge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCcnLCBudWxsLCBvcHRfbWVzc2FnZSxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIGNvbmRpdGlvbjtcbn07XG5cblxuLyoqXG4gKiBGYWlscyBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS4gVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgaW4gY2FzZVxuICogd2hlbiB3ZSB3YW50IHRvIGFkZCBhIGNoZWNrIGluIHRoZSB1bnJlYWNoYWJsZSBhcmVhIGxpa2Ugc3dpdGNoLWNhc2VcbiAqIHN0YXRlbWVudDpcbiAqXG4gKiA8cHJlPlxuICogIHN3aXRjaCh0eXBlKSB7XG4gKiAgICBjYXNlIEZPTzogZG9Tb21ldGhpbmcoKTsgYnJlYWs7XG4gKiAgICBjYXNlIEJBUjogZG9Tb21ldGhpbmdFbHNlKCk7IGJyZWFrO1xuICogICAgZGVmYXVsdDogZ29vZy5hc3NlcnQuZmFpbCgnVW5yZWNvZ25pemVkIHR5cGU6ICcgKyB0eXBlKTtcbiAqICAgICAgLy8gV2UgaGF2ZSBvbmx5IDIgdHlwZXMgLSBcImRlZmF1bHQ6XCIgc2VjdGlvbiBpcyB1bnJlYWNoYWJsZSBjb2RlLlxuICogIH1cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gRmFpbHVyZS5cbiAqL1xuZ29vZy5hc3NlcnRzLmZhaWwgPSBmdW5jdGlvbihvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUykge1xuICAgIGdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfKG5ldyBnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICdGYWlsdXJlJyArIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcnKSxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBudW1iZXIgd2hlbiBhc3NlcnRzIGVuYWJsZWQuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydE51bWJlciA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgbnVtYmVyIGJ1dCBnb3QgJXM6ICVzLicsXG4gICAgICAgIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIHN0cmluZyB3aGVuIGFzc2VydHMgZW5hYmxlZC5cbiAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLlxuICovXG5nb29nLmFzc2VydHMuYXNzZXJ0U3RyaW5nID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBzdHJpbmcgYnV0IGdvdCAlczogJXMuJyxcbiAgICAgICAgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiB3aGVuIGFzc2VydHNcbiAqICAgICBlbmFibGVkLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBmdW5jdGlvbi5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydEZ1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJ0V4cGVjdGVkIGZ1bmN0aW9uIGJ1dCBnb3QgJXM6ICVzLicsXG4gICAgICAgIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIE9iamVjdCBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHJldHVybiB7IU9iamVjdH0gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LlxuICovXG5nb29nLmFzc2VydHMuYXNzZXJ0T2JqZWN0ID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlczogJXMuJyxcbiAgICAgICAgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLFxuICAgICAgICBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIEFycmF5IGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHshQXJyYXk8Pz59IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIG5vbi1udWxsIGFycmF5LlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRBcnJheSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc0FycmF5KHZhbHVlKSkge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBhcnJheSBidXQgZ290ICVzOiAlcy4nLFxuICAgICAgICBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHshQXJyYXk8Pz59ICovICh2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIGJvb2xlYW4gd2hlbiBhc3NlcnRzIGFyZVxuICogICAgIGVuYWJsZWQuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIGJvb2xlYW4uXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRCb29sZWFuID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgYm9vbGVhbiBidXQgZ290ICVzOiAlcy4nLFxuICAgICAgICBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBET00gRWxlbWVudCBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSB2YWx1ZSwgbGlrZWx5IHRvIGJlIGEgRE9NIEVsZW1lbnQgd2hlbiBhc3NlcnRzIGFyZVxuICogICAgIGVuYWJsZWQuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhbiBFbGVtZW50LlxuICovXG5nb29nLmFzc2VydHMuYXNzZXJ0RWxlbWVudCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAoIWdvb2cuaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB2YWx1ZS5ub2RlVHlwZSAhPSBnb29nLmRvbS5Ob2RlVHlwZS5FTEVNRU5UKSkge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBFbGVtZW50IGJ1dCBnb3QgJXM6ICVzLicsXG4gICAgICAgIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHVzZXItZGVmaW5lZCB0eXBlIGlmXG4gKiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgY29tcGlsZXIgbWF5IHRpZ2h0ZW4gdGhlIHR5cGUgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OiBULCAuLi4pfSB0eXBlIEEgdXNlci1kZWZpbmVkIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gaW5zdGFuY2Ugb2ZcbiAqICAgICB0eXBlLlxuICogQHJldHVybiB7VH1cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRJbnN0YW5jZW9mID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICEodmFsdWUgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBpbnN0YW5jZW9mICVzIGJ1dCBnb3QgJXMuJyxcbiAgICAgICAgW2dvb2cuYXNzZXJ0cy5nZXRUeXBlXyh0eXBlKSwgZ29vZy5hc3NlcnRzLmdldFR5cGVfKHZhbHVlKV0sXG4gICAgICAgIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgbm8gZW51bWVyYWJsZSBrZXlzIGFyZSBwcmVzZW50IGluIE9iamVjdC5wcm90b3R5cGUuIFN1Y2gga2V5c1xuICogd291bGQgYnJlYWsgbW9zdCBjb2RlIHRoYXQgdXNlIHtAY29kZSBmb3IgKHZhciAuLi4gaW4gLi4uKX0gbG9vcHMuXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRPYmplY3RQcm90b3R5cGVJc0ludGFjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGdvb2cuYXNzZXJ0cy5mYWlsKGtleSArICcgc2hvdWxkIG5vdCBiZSBlbnVtZXJhYmxlIGluIE9iamVjdC5wcm90b3R5cGUuJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgdmFsdWUuIElmIGEgY29uc3RydWN0b3IgaXMgcGFzc2VkLCBhbmQgYSBzdWl0YWJsZVxuICogc3RyaW5nIGNhbm5vdCBiZSBmb3VuZCwgJ3Vua25vd24gdHlwZSBuYW1lJyB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBBIGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHByaW1pdGl2ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJlc3QgZGlzcGxheSBuYW1lIGZvciB0aGUgdmFsdWUsIG9yICd1bmtub3duIHR5cGUgbmFtZScuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmFzc2VydHMuZ2V0VHlwZV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lIHx8ICd1bmtub3duIHR5cGUgbmFtZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgYXJyYXlzLlxuICpcbiAqIEBhdXRob3IgYXJ2QGdvb2dsZS5jb20gKEVyaWsgQXJ2aWRzc29uKVxuICovXG5cblxuZ29vZy5wcm92aWRlKCdnb29nLmFycmF5Jyk7XG5nb29nLnByb3ZpZGUoJ2dvb2cuYXJyYXkuQXJyYXlMaWtlJyk7XG5cbmdvb2cucmVxdWlyZSgnZ29vZy5hc3NlcnRzJyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBOQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY29kZSBzaG91bGRcbiAqIHJlbHkgb24gQXJyYXkucHJvdG90eXBlIGZ1bmN0aW9ucywgaWYgYXZhaWxhYmxlLlxuICpcbiAqIFRoZSBBcnJheS5wcm90b3R5cGUgZnVuY3Rpb25zIGNhbiBiZSBkZWZpbmVkIGJ5IGV4dGVybmFsIGxpYnJhcmllcyBsaWtlXG4gKiBQcm90b3R5cGUgYW5kIHNldHRpbmcgdGhpcyBmbGFnIHRvIGZhbHNlIGZvcmNlcyBjbG9zdXJlIHRvIHVzZSBpdHMgb3duXG4gKiBnb29nLmFycmF5IGltcGxlbWVudGF0aW9uLlxuICpcbiAqIElmIHlvdXIgamF2YXNjcmlwdCBjYW4gYmUgbG9hZGVkIGJ5IGEgdGhpcmQgcGFydHkgc2l0ZSBhbmQgeW91IGFyZSB3YXJ5IGFib3V0XG4gKiByZWx5aW5nIG9uIHRoZSBwcm90b3R5cGUgZnVuY3Rpb25zLCBzcGVjaWZ5XG4gKiBcIi0tZGVmaW5lIGdvb2cuTkFUSVZFX0FSUkFZX1BST1RPVFlQRVM9ZmFsc2VcIiB0byB0aGUgSlNDb21waWxlci5cbiAqXG4gKiBTZXR0aW5nIGdvb2cuVFJVU1RFRF9TSVRFIHRvIGZhbHNlIHdpbGwgYXV0b21hdGljYWxseSBzZXRcbiAqIE5BVElWRV9BUlJBWV9QUk9UT1RZUEVTIHRvIGZhbHNlLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUycsIGdvb2cuVFJVU1RFRF9TSVRFKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IElmIHRydWUsIEpTQ29tcGlsZXIgd2lsbCB1c2UgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICogYXJyYXkgZnVuY3Rpb25zIHdoZXJlIGFwcHJvcHJpYXRlIChlLmcuLCB7QGNvZGUgQXJyYXkjZmlsdGVyfSkgYW5kIHJlbW92ZSB0aGVcbiAqIHVudXNlZCBwdXJlIEpTIGltcGxlbWVudGF0aW9uLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5hcnJheS5BU1NVTUVfTkFUSVZFX0ZVTkNUSU9OUycsIGZhbHNlKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheXxOb2RlTGlzdHxBcmd1bWVudHN8e2xlbmd0aDogbnVtYmVyfX1cbiAqL1xuZ29vZy5hcnJheS5BcnJheUxpa2U7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgaW4gYW4gYXJyYXkgd2l0aG91dCByZW1vdmluZyBpdC5cbiAqIFNhbWUgYXMgZ29vZy5hcnJheS5sYXN0LlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyYXkgVGhlIGFycmF5LlxuICogQHJldHVybiB7VH0gTGFzdCBpdGVtIGluIGFycmF5LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5wZWVrID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBpbiBhbiBhcnJheSB3aXRob3V0IHJlbW92aW5nIGl0LlxuICogU2FtZSBhcyBnb29nLmFycmF5LnBlZWsuXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnJheSBUaGUgYXJyYXkuXG4gKiBAcmV0dXJuIHtUfSBMYXN0IGl0ZW0gaW4gYXJyYXkuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5Lmxhc3QgPSBnb29nLmFycmF5LnBlZWs7XG5cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHtAY29kZSBBcnJheS5wcm90b3R5cGV9LlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfID0gQXJyYXkucHJvdG90eXBlO1xuXG5cbi8vIE5PVEUoYXJ2KTogU2luY2UgbW9zdCBvZiB0aGUgYXJyYXkgZnVuY3Rpb25zIGFyZSBnZW5lcmljIGl0IGFsbG93cyB5b3UgdG9cbi8vIHBhc3MgYW4gYXJyYXktbGlrZSBvYmplY3QuIFN0cmluZ3MgaGF2ZSBhIGxlbmd0aCBhbmQgYXJlIGNvbnNpZGVyZWQgYXJyYXktXG4vLyBsaWtlLiBIb3dldmVyLCB0aGUgJ2luJyBvcGVyYXRvciBkb2VzIG5vdCB3b3JrIG9uIHN0cmluZ3Mgc28gd2UgY2Fubm90IGp1c3Rcbi8vIHVzZSB0aGUgYXJyYXkgcGF0aCBldmVuIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGluZGV4aW5nIGludG8gc3RyaW5ncy4gV2Vcbi8vIHRoZXJlZm9yZSBlbmQgdXAgc3BsaXR0aW5nIHRoZSBzdHJpbmcuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheSB3aXRoIGEgc3BlY2lmaWVkIHZhbHVlLCBvclxuICogLTEgaWYgdGhlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cDovL3Rpbnl1cmwuY29tL2RldmVsb3Blci1tb3ppbGxhLW9yZy1hcnJheS1pbmRleG9mfVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBUaGUgYXJyYXkgdG8gYmUgc2VhcmNoZWQuXG4gKiBAcGFyYW0ge1R9IG9iaiBUaGUgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgc2VhcmNoaW5nLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLiBJZlxuICogICAgIG9taXR0ZWQgdGhlIHNlYXJjaCBzdGFydHMgYXQgaW5kZXggMC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaGluZyBhcnJheSBlbGVtZW50LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5pbmRleE9mID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgICAgKGdvb2cuYXJyYXkuQVNTVU1FX05BVElWRV9GVU5DVElPTlMgfHxcbiAgICAgICAgICAgICAgICAgICAgICBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uaW5kZXhPZikgP1xuICAgIGZ1bmN0aW9uKGFyciwgb2JqLCBvcHRfZnJvbUluZGV4KSB7XG4gICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyci5sZW5ndGggIT0gbnVsbCk7XG5cbiAgICAgIHJldHVybiBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uaW5kZXhPZi5jYWxsKGFyciwgb2JqLCBvcHRfZnJvbUluZGV4KTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbihhcnIsIG9iaiwgb3B0X2Zyb21JbmRleCkge1xuICAgICAgdmFyIGZyb21JbmRleCA9IG9wdF9mcm9tSW5kZXggPT0gbnVsbCA/XG4gICAgICAgICAgMCA6IChvcHRfZnJvbUluZGV4IDwgMCA/XG4gICAgICAgICAgICAgICBNYXRoLm1heCgwLCBhcnIubGVuZ3RoICsgb3B0X2Zyb21JbmRleCkgOiBvcHRfZnJvbUluZGV4KTtcblxuICAgICAgaWYgKGdvb2cuaXNTdHJpbmcoYXJyKSkge1xuICAgICAgICAvLyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB1c2VzID09PSBzbyBvbmx5IHN0cmluZ3Mgc2hvdWxkIGJlIGZvdW5kLlxuICAgICAgICBpZiAoIWdvb2cuaXNTdHJpbmcob2JqKSB8fCBvYmoubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKG9iaiwgZnJvbUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBhcnIgJiYgYXJyW2ldID09PSBvYmopXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkgd2l0aCBhIHNwZWNpZmllZCB2YWx1ZSwgb3JcbiAqIC0xIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly90aW55dXJsLmNvbS9kZXZlbG9wZXItbW96aWxsYS1vcmctYXJyYXktbGFzdGluZGV4b2Z9XG4gKlxuICogQHBhcmFtIHshQXJyYXk8VD58IWdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgVGhlIGFycmF5IHRvIGJlIHNlYXJjaGVkLlxuICogQHBhcmFtIHtUfSBvYmogVGhlIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHNlYXJjaGluZy5cbiAqIEBwYXJhbSB7P251bWJlcj19IG9wdF9mcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guIElmXG4gKiAgICAgb21pdHRlZCB0aGUgc2VhcmNoIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IG1hdGNoaW5nIGFycmF5IGVsZW1lbnQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5Lmxhc3RJbmRleE9mID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIChnb29nLmFycmF5LkFTU1VNRV9OQVRJVkVfRlVOQ1RJT05TIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5sYXN0SW5kZXhPZikgP1xuICAgIGZ1bmN0aW9uKGFyciwgb2JqLCBvcHRfZnJvbUluZGV4KSB7XG4gICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyci5sZW5ndGggIT0gbnVsbCk7XG5cbiAgICAgIC8vIEZpcmVmb3ggdHJlYXRzIHVuZGVmaW5lZCBhbmQgbnVsbCBhcyAwIGluIHRoZSBmcm9tSW5kZXggYXJndW1lbnQgd2hpY2hcbiAgICAgIC8vIGxlYWRzIGl0IHRvIGFsd2F5cyByZXR1cm4gLTFcbiAgICAgIHZhciBmcm9tSW5kZXggPSBvcHRfZnJvbUluZGV4ID09IG51bGwgPyBhcnIubGVuZ3RoIC0gMSA6IG9wdF9mcm9tSW5kZXg7XG4gICAgICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLmxhc3RJbmRleE9mLmNhbGwoYXJyLCBvYmosIGZyb21JbmRleCk7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oYXJyLCBvYmosIG9wdF9mcm9tSW5kZXgpIHtcbiAgICAgIHZhciBmcm9tSW5kZXggPSBvcHRfZnJvbUluZGV4ID09IG51bGwgPyBhcnIubGVuZ3RoIC0gMSA6IG9wdF9mcm9tSW5kZXg7XG5cbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IE1hdGgubWF4KDAsIGFyci5sZW5ndGggKyBmcm9tSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ29vZy5pc1N0cmluZyhhcnIpKSB7XG4gICAgICAgIC8vIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiB1c2VzID09PSBzbyBvbmx5IHN0cmluZ3Mgc2hvdWxkIGJlIGZvdW5kLlxuICAgICAgICBpZiAoIWdvb2cuaXNTdHJpbmcob2JqKSB8fCBvYmoubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5sYXN0SW5kZXhPZihvYmosIGZyb21JbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChpIGluIGFyciAmJiBhcnJbaV0gPT09IG9iailcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG5cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5LiBTa2lwcyBob2xlcyBpbiB0aGUgYXJyYXkuXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly90aW55dXJsLmNvbS9kZXZlbG9wZXItbW96aWxsYS1vcmctYXJyYXktZm9yZWFjaH1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3Qgb3ZlclxuICogICAgIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOiBTLCBULCBudW1iZXIsID8pOiA/fSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBldmVyeVxuICogICAgIGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGUgaW5kZXggYW5kIHRoZVxuICogICAgIGFycmF5KS4gVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtTPX0gb3B0X29iaiBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJyB3aXRoaW4gZi5cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZ29vZy5hcnJheS5mb3JFYWNoID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgICAgKGdvb2cuYXJyYXkuQVNTVU1FX05BVElWRV9GVU5DVElPTlMgfHxcbiAgICAgICAgICAgICAgICAgICAgICBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uZm9yRWFjaCkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChhcnIubGVuZ3RoICE9IG51bGwpO1xuXG4gICAgICBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uZm9yRWFjaC5jYWxsKGFyciwgZiwgb3B0X29iaik7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oYXJyLCBmLCBvcHRfb2JqKSB7XG4gICAgICB2YXIgbCA9IGFyci5sZW5ndGg7ICAvLyBtdXN0IGJlIGZpeGVkIGR1cmluZyBsb29wLi4uIHNlZSBkb2NzXG4gICAgICB2YXIgYXJyMiA9IGdvb2cuaXNTdHJpbmcoYXJyKSA/IGFyci5zcGxpdCgnJykgOiBhcnI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBhcnIyKSB7XG4gICAgICAgICAgZi5jYWxsKG9wdF9vYmosIGFycjJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5LCBzdGFydGluZyBmcm9tIHRoZSBsYXN0XG4gKiBlbGVtZW50IHJhdGhlciB0aGFuIHRoZSBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgb3IgYXJyYXlcbiAqICAgICBsaWtlIG9iamVjdCBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOiBTLCBULCBudW1iZXIsID8pOiA/fSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBldmVyeVxuICogICAgIGVsZW1lbnQuIFRoaXMgZnVuY3Rpb25cbiAqICAgICB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZSBpbmRleCBhbmQgdGhlIGFycmF5KS4gVGhlIHJldHVyblxuICogICAgIHZhbHVlIGlzIGlnbm9yZWQuXG4gKiBAcGFyYW0ge1M9fSBvcHRfb2JqIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnXG4gKiAgICAgd2l0aGluIGYuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmdvb2cuYXJyYXkuZm9yRWFjaFJpZ2h0ID0gZnVuY3Rpb24oYXJyLCBmLCBvcHRfb2JqKSB7XG4gIHZhciBsID0gYXJyLmxlbmd0aDsgIC8vIG11c3QgYmUgZml4ZWQgZHVyaW5nIGxvb3AuLi4gc2VlIGRvY3NcbiAgdmFyIGFycjIgPSBnb29nLmlzU3RyaW5nKGFycikgPyBhcnIuc3BsaXQoJycpIDogYXJyO1xuICBmb3IgKHZhciBpID0gbCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGkgaW4gYXJyMikge1xuICAgICAgZi5jYWxsKG9wdF9vYmosIGFycjJbaV0sIGksIGFycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5LCBhbmQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqIHRydWUgYWRkcyB0aGUgZWxlbWVudCB0byBhIG5ldyBhcnJheS5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly90aW55dXJsLmNvbS9kZXZlbG9wZXItbW96aWxsYS1vcmctYXJyYXktZmlsdGVyfVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheVxuICogICAgIGxpa2Ugb2JqZWN0IG92ZXIgd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6UywgVCwgbnVtYmVyLCA/KTpib29sZWFufSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvclxuICogICAgIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb25cbiAqICAgICB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZSBpbmRleCBhbmQgdGhlIGFycmF5KSBhbmQgbXVzdFxuICogICAgIHJldHVybiBhIEJvb2xlYW4uIElmIHRoZSByZXR1cm4gdmFsdWUgaXMgdHJ1ZSB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGVcbiAqICAgICByZXN1bHQgYXJyYXkuIElmIGl0IGlzIGZhbHNlIHRoZSBlbGVtZW50IGlzIG5vdCBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcydcbiAqICAgICB3aXRoaW4gZi5cbiAqIEByZXR1cm4geyFBcnJheTxUPn0gYSBuZXcgYXJyYXkgaW4gd2hpY2ggb25seSBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgdGVzdFxuICogICAgIGFyZSBwcmVzZW50LlxuICogQHRlbXBsYXRlIFQsU1xuICovXG5nb29nLmFycmF5LmZpbHRlciA9IGdvb2cuTkFUSVZFX0FSUkFZX1BST1RPVFlQRVMgJiZcbiAgICAgICAgICAgICAgICAgICAgKGdvb2cuYXJyYXkuQVNTVU1FX05BVElWRV9GVU5DVElPTlMgfHxcbiAgICAgICAgICAgICAgICAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5maWx0ZXIpID9cbiAgICBmdW5jdGlvbihhcnIsIGYsIG9wdF9vYmopIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXJyLmxlbmd0aCAhPSBudWxsKTtcblxuICAgICAgcmV0dXJuIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5maWx0ZXIuY2FsbChhcnIsIGYsIG9wdF9vYmopO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgdmFyIGwgPSBhcnIubGVuZ3RoOyAgLy8gbXVzdCBiZSBmaXhlZCBkdXJpbmcgbG9vcC4uLiBzZWUgZG9jc1xuICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgdmFyIHJlc0xlbmd0aCA9IDA7XG4gICAgICB2YXIgYXJyMiA9IGdvb2cuaXNTdHJpbmcoYXJyKSA/IGFyci5zcGxpdCgnJykgOiBhcnI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBhcnIyKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFycjJbaV07ICAvLyBpbiBjYXNlIGYgbXV0YXRlcyBhcnIyXG4gICAgICAgICAgaWYgKGYuY2FsbChvcHRfb2JqLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgICAgIHJlc1tyZXNMZW5ndGgrK10gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cblxuLyoqXG4gKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gYW4gYXJyYXkgYW5kIGluc2VydHMgdGhlIHJlc3VsdCBpbnRvIGFcbiAqIG5ldyBhcnJheS5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly90aW55dXJsLmNvbS9kZXZlbG9wZXItbW96aWxsYS1vcmctYXJyYXktbWFwfVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3RcbiAqICAgICBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUywgVkFMVUUsIG51bWJlciwgPyk6IFJFU1VMVH0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogICAgIGZvciBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCxcbiAqICAgICB0aGUgaW5kZXggYW5kIHRoZSBhcnJheSkgYW5kIHNob3VsZCByZXR1cm4gc29tZXRoaW5nLiBUaGUgcmVzdWx0IHdpbGwgYmVcbiAqICAgICBpbnNlcnRlZCBpbnRvIGEgbmV3IGFycmF5LlxuICogQHBhcmFtIHtUSElTPX0gb3B0X29iaiBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJyB3aXRoaW4gZi5cbiAqIEByZXR1cm4geyFBcnJheTxSRVNVTFQ+fSBhIG5ldyBhcnJheSB3aXRoIHRoZSByZXN1bHRzIGZyb20gZi5cbiAqIEB0ZW1wbGF0ZSBUSElTLCBWQUxVRSwgUkVTVUxUXG4gKi9cbmdvb2cuYXJyYXkubWFwID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAoZ29vZy5hcnJheS5BU1NVTUVfTkFUSVZFX0ZVTkNUSU9OUyB8fFxuICAgICAgICAgICAgICAgICAgZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLm1hcCkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChhcnIubGVuZ3RoICE9IG51bGwpO1xuXG4gICAgICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLm1hcC5jYWxsKGFyciwgZiwgb3B0X29iaik7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oYXJyLCBmLCBvcHRfb2JqKSB7XG4gICAgICB2YXIgbCA9IGFyci5sZW5ndGg7ICAvLyBtdXN0IGJlIGZpeGVkIGR1cmluZyBsb29wLi4uIHNlZSBkb2NzXG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGwpO1xuICAgICAgdmFyIGFycjIgPSBnb29nLmlzU3RyaW5nKGFycikgPyBhcnIuc3BsaXQoJycpIDogYXJyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gYXJyMikge1xuICAgICAgICAgIHJlc1tpXSA9IGYuY2FsbChvcHRfb2JqLCBhcnIyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cblxuLyoqXG4gKiBQYXNzZXMgZXZlcnkgZWxlbWVudCBvZiBhbiBhcnJheSBpbnRvIGEgZnVuY3Rpb24gYW5kIGFjY3VtdWxhdGVzIHRoZSByZXN1bHQuXG4gKlxuICogU2VlIHtAbGluayBodHRwOi8vdGlueXVybC5jb20vZGV2ZWxvcGVyLW1vemlsbGEtb3JnLWFycmF5LXJlZHVjZX1cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIHZhciBhID0gWzEsIDIsIDMsIDRdO1xuICogZ29vZy5hcnJheS5yZWR1Y2UoYSwgZnVuY3Rpb24ociwgdiwgaSwgYXJyKSB7cmV0dXJuIHIgKyB2O30sIDApO1xuICogcmV0dXJucyAxMFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheVxuICogICAgIGxpa2Ugb2JqZWN0IG92ZXIgd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTLCBSLCBULCBudW1iZXIsID8pIDogUn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3JcbiAqICAgICBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uXG4gKiAgICAgdGFrZXMgNCBhcmd1bWVudHMgKHRoZSBmdW5jdGlvbidzIHByZXZpb3VzIHJlc3VsdCBvciB0aGUgaW5pdGlhbCB2YWx1ZSxcbiAqICAgICB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgYXJyYXkgZWxlbWVudCwgdGhlIGN1cnJlbnQgYXJyYXkgaW5kZXgsIGFuZCB0aGVcbiAqICAgICBhcnJheSBpdHNlbGYpXG4gKiAgICAgZnVuY3Rpb24ocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICogQHBhcmFtIHs/fSB2YWwgVGhlIGluaXRpYWwgdmFsdWUgdG8gcGFzcyBpbnRvIHRoZSBmdW5jdGlvbiBvbiB0aGUgZmlyc3QgY2FsbC5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnXG4gKiAgICAgd2l0aGluIGYuXG4gKiBAcmV0dXJuIHtSfSBSZXN1bHQgb2YgZXZhbHVhdGluZyBmIHJlcGVhdGVkbHkgYWNyb3NzIHRoZSB2YWx1ZXMgb2YgdGhlIGFycmF5LlxuICogQHRlbXBsYXRlIFQsUyxSXG4gKi9cbmdvb2cuYXJyYXkucmVkdWNlID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgICAoZ29vZy5hcnJheS5BU1NVTUVfTkFUSVZFX0ZVTkNUSU9OUyB8fFxuICAgICAgICAgICAgICAgICAgICAgZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLnJlZHVjZSkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgdmFsLCBvcHRfb2JqKSB7XG4gICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyci5sZW5ndGggIT0gbnVsbCk7XG4gICAgICBpZiAob3B0X29iaikge1xuICAgICAgICBmID0gZ29vZy5iaW5kKGYsIG9wdF9vYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5yZWR1Y2UuY2FsbChhcnIsIGYsIHZhbCk7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oYXJyLCBmLCB2YWwsIG9wdF9vYmopIHtcbiAgICAgIHZhciBydmFsID0gdmFsO1xuICAgICAgZ29vZy5hcnJheS5mb3JFYWNoKGFyciwgZnVuY3Rpb24odmFsLCBpbmRleCkge1xuICAgICAgICBydmFsID0gZi5jYWxsKG9wdF9vYmosIHJ2YWwsIHZhbCwgaW5kZXgsIGFycik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydmFsO1xuICAgIH07XG5cblxuLyoqXG4gKiBQYXNzZXMgZXZlcnkgZWxlbWVudCBvZiBhbiBhcnJheSBpbnRvIGEgZnVuY3Rpb24gYW5kIGFjY3VtdWxhdGVzIHRoZSByZXN1bHQsXG4gKiBzdGFydGluZyBmcm9tIHRoZSBsYXN0IGVsZW1lbnQgYW5kIHdvcmtpbmcgdG93YXJkcyB0aGUgZmlyc3QuXG4gKlxuICogU2VlIHtAbGluayBodHRwOi8vdGlueXVybC5jb20vZGV2ZWxvcGVyLW1vemlsbGEtb3JnLWFycmF5LXJlZHVjZXJpZ2h0fVxuICpcbiAqIEZvciBleGFtcGxlOlxuICogdmFyIGEgPSBbJ2EnLCAnYicsICdjJ107XG4gKiBnb29nLmFycmF5LnJlZHVjZVJpZ2h0KGEsIGZ1bmN0aW9uKHIsIHYsIGksIGFycikge3JldHVybiByICsgdjt9LCAnJyk7XG4gKiByZXR1cm5zICdjYmEnXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIEFycmF5IG9yIGFycmF5XG4gKiAgICAgbGlrZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpTLCBSLCBULCBudW1iZXIsID8pIDogUn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3JcbiAqICAgICBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uXG4gKiAgICAgdGFrZXMgNCBhcmd1bWVudHMgKHRoZSBmdW5jdGlvbidzIHByZXZpb3VzIHJlc3VsdCBvciB0aGUgaW5pdGlhbCB2YWx1ZSxcbiAqICAgICB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgYXJyYXkgZWxlbWVudCwgdGhlIGN1cnJlbnQgYXJyYXkgaW5kZXgsIGFuZCB0aGVcbiAqICAgICBhcnJheSBpdHNlbGYpXG4gKiAgICAgZnVuY3Rpb24ocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICogQHBhcmFtIHs/fSB2YWwgVGhlIGluaXRpYWwgdmFsdWUgdG8gcGFzcyBpbnRvIHRoZSBmdW5jdGlvbiBvbiB0aGUgZmlyc3QgY2FsbC5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcydcbiAqICAgICB3aXRoaW4gZi5cbiAqIEByZXR1cm4ge1J9IE9iamVjdCByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiBldmFsdWF0aW5nIGYgcmVwZWF0ZWRseSBhY3Jvc3MgdGhlXG4gKiAgICAgdmFsdWVzIG9mIHRoZSBhcnJheS5cbiAqIEB0ZW1wbGF0ZSBULFMsUlxuICovXG5nb29nLmFycmF5LnJlZHVjZVJpZ2h0ID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIChnb29nLmFycmF5LkFTU1VNRV9OQVRJVkVfRlVOQ1RJT05TIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5yZWR1Y2VSaWdodCkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgdmFsLCBvcHRfb2JqKSB7XG4gICAgICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyci5sZW5ndGggIT0gbnVsbCk7XG4gICAgICBpZiAob3B0X29iaikge1xuICAgICAgICBmID0gZ29vZy5iaW5kKGYsIG9wdF9vYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5yZWR1Y2VSaWdodC5jYWxsKGFyciwgZiwgdmFsKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbihhcnIsIGYsIHZhbCwgb3B0X29iaikge1xuICAgICAgdmFyIHJ2YWwgPSB2YWw7XG4gICAgICBnb29nLmFycmF5LmZvckVhY2hSaWdodChhcnIsIGZ1bmN0aW9uKHZhbCwgaW5kZXgpIHtcbiAgICAgICAgcnZhbCA9IGYuY2FsbChvcHRfb2JqLCBydmFsLCB2YWwsIGluZGV4LCBhcnIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9O1xuXG5cbi8qKlxuICogQ2FsbHMgZiBmb3IgZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5LiBJZiBhbnkgY2FsbCByZXR1cm5zIHRydWUsIHNvbWUoKVxuICogcmV0dXJucyB0cnVlICh3aXRob3V0IGNoZWNraW5nIHRoZSByZW1haW5pbmcgZWxlbWVudHMpLiBJZiBhbGwgY2FsbHNcbiAqIHJldHVybiBmYWxzZSwgc29tZSgpIHJldHVybnMgZmFsc2UuXG4gKlxuICogU2VlIHtAbGluayBodHRwOi8vdGlueXVybC5jb20vZGV2ZWxvcGVyLW1vemlsbGEtb3JnLWFycmF5LXNvbWV9XG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIEFycmF5IG9yIGFycmF5XG4gKiAgICAgbGlrZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpTLCBULCBudW1iZXIsID8pIDogYm9vbGVhbn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3JcbiAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICogICAgIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnXG4gKiAgICAgd2l0aGluIGYuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgdGVzdC5cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZ29vZy5hcnJheS5zb21lID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgKGdvb2cuYXJyYXkuQVNTVU1FX05BVElWRV9GVU5DVElPTlMgfHxcbiAgICAgICAgICAgICAgICAgICBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uc29tZSkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChhcnIubGVuZ3RoICE9IG51bGwpO1xuXG4gICAgICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLnNvbWUuY2FsbChhcnIsIGYsIG9wdF9vYmopO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgdmFyIGwgPSBhcnIubGVuZ3RoOyAgLy8gbXVzdCBiZSBmaXhlZCBkdXJpbmcgbG9vcC4uLiBzZWUgZG9jc1xuICAgICAgdmFyIGFycjIgPSBnb29nLmlzU3RyaW5nKGFycikgPyBhcnIuc3BsaXQoJycpIDogYXJyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gYXJyMiAmJiBmLmNhbGwob3B0X29iaiwgYXJyMltpXSwgaSwgYXJyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuXG4vKipcbiAqIENhbGwgZiBmb3IgZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5LiBJZiBhbGwgY2FsbHMgcmV0dXJuIHRydWUsIGV2ZXJ5KClcbiAqIHJldHVybnMgdHJ1ZS4gSWYgYW55IGNhbGwgcmV0dXJucyBmYWxzZSwgZXZlcnkoKSByZXR1cm5zIGZhbHNlIGFuZFxuICogZG9lcyBub3QgY29udGludWUgdG8gY2hlY2sgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly90aW55dXJsLmNvbS9kZXZlbG9wZXItbW96aWxsYS1vcmctYXJyYXktZXZlcnl9XG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIEFycmF5IG9yIGFycmF5XG4gKiAgICAgbGlrZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpTLCBULCBudW1iZXIsID8pIDogYm9vbGVhbn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3JcbiAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICogICAgIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcydcbiAqICAgICB3aXRoaW4gZi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBlbGVtZW50IGZhaWxzIHRoZSB0ZXN0LlxuICogQHRlbXBsYXRlIFQsU1xuICovXG5nb29nLmFycmF5LmV2ZXJ5ID0gZ29vZy5OQVRJVkVfQVJSQVlfUFJPVE9UWVBFUyAmJlxuICAgICAgICAgICAgICAgICAgIChnb29nLmFycmF5LkFTU1VNRV9OQVRJVkVfRlVOQ1RJT05TIHx8XG4gICAgICAgICAgICAgICAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5ldmVyeSkgP1xuICAgIGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydChhcnIubGVuZ3RoICE9IG51bGwpO1xuXG4gICAgICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLmV2ZXJ5LmNhbGwoYXJyLCBmLCBvcHRfb2JqKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbihhcnIsIGYsIG9wdF9vYmopIHtcbiAgICAgIHZhciBsID0gYXJyLmxlbmd0aDsgIC8vIG11c3QgYmUgZml4ZWQgZHVyaW5nIGxvb3AuLi4gc2VlIGRvY3NcbiAgICAgIHZhciBhcnIyID0gZ29vZy5pc1N0cmluZyhhcnIpID8gYXJyLnNwbGl0KCcnKSA6IGFycjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIGFycjIgJiYgIWYuY2FsbChvcHRfb2JqLCBhcnIyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG5cbi8qKlxuICogQ291bnRzIHRoZSBhcnJheSBlbGVtZW50cyB0aGF0IGZ1bGZpbGwgdGhlIHByZWRpY2F0ZSwgaS5lLiBmb3Igd2hpY2ggdGhlXG4gKiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRydWUuIFNraXBzIGhvbGVzIGluIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0geyEoQXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2UpfSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3RcbiAqICAgICBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQsIG51bWJlciwgPyk6IGJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yXG4gKiAgICAgZXZlcnkgZWxlbWVudC4gVGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGUgaW5kZXggYW5kIHRoZSBhcnJheSkuXG4gKiBAcGFyYW0ge1M9fSBvcHRfb2JqIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnIHdpdGhpbiBmLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRoZSBtYXRjaGluZyBlbGVtZW50cy5cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZ29vZy5hcnJheS5jb3VudCA9IGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICB2YXIgY291bnQgPSAwO1xuICBnb29nLmFycmF5LmZvckVhY2goYXJyLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCwgYXJyKSB7XG4gICAgaWYgKGYuY2FsbChvcHRfb2JqLCBlbGVtZW50LCBpbmRleCwgYXJyKSkge1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gIH0sIG9wdF9vYmopO1xuICByZXR1cm4gY291bnQ7XG59O1xuXG5cbi8qKlxuICogU2VhcmNoIGFuIGFycmF5IGZvciB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyBhIGdpdmVuIGNvbmRpdGlvbiBhbmRcbiAqIHJldHVybiB0aGF0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgb3IgYXJyYXlcbiAqICAgICBsaWtlIG9iamVjdCBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlMsIFQsIG51bWJlciwgPykgOiBib29sZWFufSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGVcbiAqICAgICBpbmRleCBhbmQgdGhlIGFycmF5KSBhbmQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gKiBAcGFyYW0ge1M9fSBvcHRfb2JqIEFuIG9wdGlvbmFsIFwidGhpc1wiIGNvbnRleHQgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1R8bnVsbH0gVGhlIGZpcnN0IGFycmF5IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIHRlc3QsIG9yIG51bGwgaWYgbm9cbiAqICAgICBlbGVtZW50IGlzIGZvdW5kLlxuICogQHRlbXBsYXRlIFQsU1xuICovXG5nb29nLmFycmF5LmZpbmQgPSBmdW5jdGlvbihhcnIsIGYsIG9wdF9vYmopIHtcbiAgdmFyIGkgPSBnb29nLmFycmF5LmZpbmRJbmRleChhcnIsIGYsIG9wdF9vYmopO1xuICByZXR1cm4gaSA8IDAgPyBudWxsIDogZ29vZy5pc1N0cmluZyhhcnIpID8gYXJyLmNoYXJBdChpKSA6IGFycltpXTtcbn07XG5cblxuLyoqXG4gKiBTZWFyY2ggYW4gYXJyYXkgZm9yIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIGEgZ2l2ZW4gY29uZGl0aW9uIGFuZFxuICogcmV0dXJuIGl0cyBpbmRleC5cbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheVxuICogICAgIGxpa2Ugb2JqZWN0IG92ZXIgd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6UywgVCwgbnVtYmVyLCA/KSA6IGJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yXG4gKiAgICAgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGRcbiAqICAgICByZXR1cm4gYSBib29sZWFuLlxuICogQHBhcmFtIHtTPX0gb3B0X29iaiBBbiBvcHRpb25hbCBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgYXJyYXkgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgdGVzdCxcbiAqICAgICBvciAtMSBpZiBubyBlbGVtZW50IGlzIGZvdW5kLlxuICogQHRlbXBsYXRlIFQsU1xuICovXG5nb29nLmFycmF5LmZpbmRJbmRleCA9IGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICB2YXIgbCA9IGFyci5sZW5ndGg7ICAvLyBtdXN0IGJlIGZpeGVkIGR1cmluZyBsb29wLi4uIHNlZSBkb2NzXG4gIHZhciBhcnIyID0gZ29vZy5pc1N0cmluZyhhcnIpID8gYXJyLnNwbGl0KCcnKSA6IGFycjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIyICYmIGYuY2FsbChvcHRfb2JqLCBhcnIyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFNlYXJjaCBhbiBhcnJheSAoaW4gcmV2ZXJzZSBvcmRlcikgZm9yIHRoZSBsYXN0IGVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgYVxuICogZ2l2ZW4gY29uZGl0aW9uIGFuZCByZXR1cm4gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIEFycmF5IG9yIGFycmF5XG4gKiAgICAgbGlrZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpTLCBULCBudW1iZXIsID8pIDogYm9vbGVhbn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogICAgIGZvciBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uXG4gKiAgICAgdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGUgaW5kZXggYW5kIHRoZSBhcnJheSkgYW5kIHNob3VsZFxuICogICAgIHJldHVybiBhIGJvb2xlYW4uXG4gKiBAcGFyYW0ge1M9fSBvcHRfb2JqIEFuIG9wdGlvbmFsIFwidGhpc1wiIGNvbnRleHQgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1R8bnVsbH0gVGhlIGxhc3QgYXJyYXkgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgdGVzdCwgb3IgbnVsbCBpZiBub1xuICogICAgIGVsZW1lbnQgaXMgZm91bmQuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmdvb2cuYXJyYXkuZmluZFJpZ2h0ID0gZnVuY3Rpb24oYXJyLCBmLCBvcHRfb2JqKSB7XG4gIHZhciBpID0gZ29vZy5hcnJheS5maW5kSW5kZXhSaWdodChhcnIsIGYsIG9wdF9vYmopO1xuICByZXR1cm4gaSA8IDAgPyBudWxsIDogZ29vZy5pc1N0cmluZyhhcnIpID8gYXJyLmNoYXJBdChpKSA6IGFycltpXTtcbn07XG5cblxuLyoqXG4gKiBTZWFyY2ggYW4gYXJyYXkgKGluIHJldmVyc2Ugb3JkZXIpIGZvciB0aGUgbGFzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIGFcbiAqIGdpdmVuIGNvbmRpdGlvbiBhbmQgcmV0dXJuIGl0cyBpbmRleC5cbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheVxuICogICAgIGxpa2Ugb2JqZWN0IG92ZXIgd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6UywgVCwgbnVtYmVyLCA/KSA6IGJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGRcbiAqICAgICByZXR1cm4gYSBib29sZWFuLlxuICogQHBhcmFtIHtTPX0gb3B0X29iaiBBbiBvcHRpb25hbCBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgbGFzdCBhcnJheSBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LFxuICogICAgIG9yIC0xIGlmIG5vIGVsZW1lbnQgaXMgZm91bmQuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmdvb2cuYXJyYXkuZmluZEluZGV4UmlnaHQgPSBmdW5jdGlvbihhcnIsIGYsIG9wdF9vYmopIHtcbiAgdmFyIGwgPSBhcnIubGVuZ3RoOyAgLy8gbXVzdCBiZSBmaXhlZCBkdXJpbmcgbG9vcC4uLiBzZWUgZG9jc1xuICB2YXIgYXJyMiA9IGdvb2cuaXNTdHJpbmcoYXJyKSA/IGFyci5zcGxpdCgnJykgOiBhcnI7XG4gIGZvciAodmFyIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoaSBpbiBhcnIyICYmIGYuY2FsbChvcHRfb2JqLCBhcnIyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGNvbnRhaW5zIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge2dvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgVGhlIGFycmF5IHRvIHRlc3QgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGVcbiAqICAgICBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdCBmb3Igd2hpY2ggdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgb2JqIGlzIHByZXNlbnQuXG4gKi9cbmdvb2cuYXJyYXkuY29udGFpbnMgPSBmdW5jdGlvbihhcnIsIG9iaikge1xuICByZXR1cm4gZ29vZy5hcnJheS5pbmRleE9mKGFyciwgb2JqKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGlzIGVtcHR5LlxuICogQHBhcmFtIHtnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIFRoZSBhcnJheSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBlbXB0eS5cbiAqL1xuZ29vZy5hcnJheS5pc0VtcHR5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBhcnIubGVuZ3RoID09IDA7XG59O1xuXG5cbi8qKlxuICogQ2xlYXJzIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCB0byBjbGVhci5cbiAqL1xuZ29vZy5hcnJheS5jbGVhciA9IGZ1bmN0aW9uKGFycikge1xuICAvLyBGb3Igbm9uIHJlYWwgYXJyYXlzIHdlIGRvbid0IGhhdmUgdGhlIG1hZ2ljIGxlbmd0aCBzbyB3ZSBkZWxldGUgdGhlXG4gIC8vIGluZGljZXMuXG4gIGlmICghZ29vZy5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBkZWxldGUgYXJyW2ldO1xuICAgIH1cbiAgfVxuICBhcnIubGVuZ3RoID0gMDtcbn07XG5cblxuLyoqXG4gKiBQdXNoZXMgYW4gaXRlbSBpbnRvIGFuIGFycmF5LCBpZiBpdCdzIG5vdCBhbHJlYWR5IGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFyciBBcnJheSBpbnRvIHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7VH0gb2JqIFZhbHVlIHRvIGFkZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXJyYXkuaW5zZXJ0ID0gZnVuY3Rpb24oYXJyLCBvYmopIHtcbiAgaWYgKCFnb29nLmFycmF5LmNvbnRhaW5zKGFyciwgb2JqKSkge1xuICAgIGFyci5wdXNoKG9iaik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBJbnNlcnRzIGFuIG9iamVjdCBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHtnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2kgVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgb2JqZWN0LiBJZiBvbWl0dGVkLFxuICogICAgICB0cmVhdGVkIGFzIDAuIEEgbmVnYXRpdmUgaW5kZXggaXMgY291bnRlZCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICovXG5nb29nLmFycmF5Lmluc2VydEF0ID0gZnVuY3Rpb24oYXJyLCBvYmosIG9wdF9pKSB7XG4gIGdvb2cuYXJyYXkuc3BsaWNlKGFyciwgb3B0X2ksIDAsIG9iaik7XG59O1xuXG5cbi8qKlxuICogSW5zZXJ0cyBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgdGhlIGFycmF5LCBhbGwgZWxlbWVudHMgb2YgYW5vdGhlciBhcnJheS5cbiAqIEBwYXJhbSB7Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtnb29nLmFycmF5LkFycmF5TGlrZX0gZWxlbWVudHNUb0FkZCBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYWRkLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBvYmplY3QuIElmIG9taXR0ZWQsXG4gKiAgICAgIHRyZWF0ZWQgYXMgMC4gQSBuZWdhdGl2ZSBpbmRleCBpcyBjb3VudGVkIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gKi9cbmdvb2cuYXJyYXkuaW5zZXJ0QXJyYXlBdCA9IGZ1bmN0aW9uKGFyciwgZWxlbWVudHNUb0FkZCwgb3B0X2kpIHtcbiAgZ29vZy5wYXJ0aWFsKGdvb2cuYXJyYXkuc3BsaWNlLCBhcnIsIG9wdF9pLCAwKS5hcHBseShudWxsLCBlbGVtZW50c1RvQWRkKTtcbn07XG5cblxuLyoqXG4gKiBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IGJlZm9yZSBhIHNwZWNpZmllZCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7VH0gb2JqIFRoZSBvYmplY3QgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtUPX0gb3B0X29iajIgVGhlIG9iamVjdCBiZWZvcmUgd2hpY2ggb2JqIHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgb2JqMlxuICogICAgIGlzIG9taXR0ZWQgb3Igbm90IGZvdW5kLCBvYmogaXMgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5Lmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKGFyciwgb2JqLCBvcHRfb2JqMikge1xuICB2YXIgaTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMiB8fCAoaSA9IGdvb2cuYXJyYXkuaW5kZXhPZihhcnIsIG9wdF9vYmoyKSkgPCAwKSB7XG4gICAgYXJyLnB1c2gob2JqKTtcbiAgfSBlbHNlIHtcbiAgICBnb29nLmFycmF5Lmluc2VydEF0KGFyciwgb2JqLCBpKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmVcbiAqICAgICB2YWx1ZS5cbiAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5LnJlbW92ZSA9IGZ1bmN0aW9uKGFyciwgb2JqKSB7XG4gIHZhciBpID0gZ29vZy5hcnJheS5pbmRleE9mKGFyciwgb2JqKTtcbiAgdmFyIHJ2O1xuICBpZiAoKHJ2ID0gaSA+PSAwKSkge1xuICAgIGdvb2cuYXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcbiAgfVxuICByZXR1cm4gcnY7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAqIEBwYXJhbSB7Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvXG4gKiAgICAgcmVtb3ZlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAqL1xuZ29vZy5hcnJheS5yZW1vdmVBdCA9IGZ1bmN0aW9uKGFyciwgaSkge1xuICBnb29nLmFzc2VydHMuYXNzZXJ0KGFyci5sZW5ndGggIT0gbnVsbCk7XG5cbiAgLy8gdXNlIGdlbmVyaWMgZm9ybSBvZiBzcGxpY2VcbiAgLy8gc3BsaWNlIHJldHVybnMgdGhlIHJlbW92ZWQgaXRlbXMgYW5kIGlmIHN1Y2Nlc3NmdWwgdGhlIGxlbmd0aCBvZiB0aGF0XG4gIC8vIHdpbGwgYmUgMVxuICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09IDE7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBzYXRpc2ZpZXMgdGhlIGdpdmVuIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheVxuICogICAgIGxpa2Ugb2JqZWN0IG92ZXIgd2hpY2ggdG8gaXRlcmF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6UywgVCwgbnVtYmVyLCA/KSA6IGJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGRcbiAqICAgICByZXR1cm4gYSBib29sZWFuLlxuICogQHBhcmFtIHtTPX0gb3B0X29iaiBBbiBvcHRpb25hbCBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmdvb2cuYXJyYXkucmVtb3ZlSWYgPSBmdW5jdGlvbihhcnIsIGYsIG9wdF9vYmopIHtcbiAgdmFyIGkgPSBnb29nLmFycmF5LmZpbmRJbmRleChhcnIsIGYsIG9wdF9vYmopO1xuICBpZiAoaSA+PSAwKSB7XG4gICAgZ29vZy5hcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCB2YWx1ZXMgdGhhdCBzYXRpc2Z5IHRoZSBnaXZlbiBjb25kaXRpb24uXG4gKiBAcGFyYW0ge0FycmF5PFQ+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgQXJyYXkgb3IgYXJyYXlcbiAqICAgICBsaWtlIG9iamVjdCBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlMsIFQsIG51bWJlciwgPykgOiBib29sZWFufSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb25cbiAqICAgICB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZSBpbmRleCBhbmQgdGhlIGFycmF5KSBhbmQgc2hvdWxkXG4gKiAgICAgcmV0dXJuIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7Uz19IG9wdF9vYmogQW4gb3B0aW9uYWwgXCJ0aGlzXCIgY29udGV4dCBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlbW92ZWRcbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZ29vZy5hcnJheS5yZW1vdmVBbGxJZiA9IGZ1bmN0aW9uKGFyciwgZiwgb3B0X29iaikge1xuICB2YXIgcmVtb3ZlZENvdW50ID0gMDtcbiAgZ29vZy5hcnJheS5mb3JFYWNoUmlnaHQoYXJyLCBmdW5jdGlvbih2YWwsIGluZGV4KSB7XG4gICAgaWYgKGYuY2FsbChvcHRfb2JqLCB2YWwsIGluZGV4LCBhcnIpKSB7XG4gICAgICBpZiAoZ29vZy5hcnJheS5yZW1vdmVBdChhcnIsIGluZGV4KSkge1xuICAgICAgICByZW1vdmVkQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVtb3ZlZENvdW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGpvaW5pbmcgdGhlIGFyZ3VtZW50cy4gIElmIGFycmF5c1xuICogYXJlIHBhc3NlZCB0aGVuIHRoZWlyIGl0ZW1zIGFyZSBhZGRlZCwgaG93ZXZlciwgaWYgbm9uLWFycmF5cyBhcmUgcGFzc2VkIHRoZXlcbiAqIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJldHVybiBhcnJheSBhcyBpcy5cbiAqXG4gKiBOb3RlIHRoYXQgQXJyYXlMaWtlIG9iamVjdHMgd2lsbCBiZSBhZGRlZCBhcyBpcywgcmF0aGVyIHRoYW4gaGF2aW5nIHRoZWlyXG4gKiBpdGVtcyBhZGRlZC5cbiAqXG4gKiBnb29nLmFycmF5LmNvbmNhdChbMSwgMl0sIFszLCA0XSkgLT4gWzEsIDIsIDMsIDRdXG4gKiBnb29nLmFycmF5LmNvbmNhdCgwLCBbMSwgMl0pIC0+IFswLCAxLCAyXVxuICogZ29vZy5hcnJheS5jb25jYXQoWzEsIDJdLCBudWxsKSAtPiBbMSwgMiwgbnVsbF1cbiAqXG4gKiBUaGVyZSBpcyBidWcgaW4gYWxsIGN1cnJlbnQgdmVyc2lvbnMgb2YgSUUgKDYsIDcgYW5kIDgpIHdoZXJlIGFycmF5cyBjcmVhdGVkXG4gKiBpbiBhbiBpZnJhbWUgYmVjb21lIGNvcnJ1cHRlZCBzb29uIChub3QgaW1tZWRpYXRlbHkpIGFmdGVyIHRoZSBpZnJhbWUgaXNcbiAqIGRlc3Ryb3llZC4gVGhpcyBpcyBjb21tb24gaWYgbG9hZGluZyBkYXRhIHZpYSBnb29nLm5ldC5JZnJhbWVJbywgZm9yIGV4YW1wbGUuXG4gKiBUaGlzIGNvcnJ1cHRpb24gb25seSBhZmZlY3RzIHRoZSBjb25jYXQgbWV0aG9kIHdoaWNoIHdpbGwgc3RhcnQgdGhyb3dpbmdcbiAqIENhdGFzdHJvcGhpYyBFcnJvcnMgKCMtMjE0NzQxODExMykuXG4gKlxuICogU2VlIGh0dHA6Ly9lbmRvZmxvdy5jb20vc2NyYXRjaC9jb3JydXB0ZWQtYXJyYXlzLmh0bWwgZm9yIGEgdGVzdCBjYXNlLlxuICpcbiAqIEludGVybmFsbHkgZ29vZy5hcnJheSBzaG91bGQgdXNlIHRoaXMsIHNvIHRoYXQgYWxsIG1ldGhvZHMgd2lsbCBjb250aW51ZSB0b1xuICogd29yayBvbiB0aGVzZSBicm9rZW4gYXJyYXkgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEl0ZW1zIHRvIGNvbmNhdGVuYXRlLiAgQXJyYXlzIHdpbGwgaGF2ZSBlYWNoIGl0ZW1cbiAqICAgICBhZGRlZCwgd2hpbGUgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyB3aWxsIGJlIGFkZGVkIGFzIGlzLlxuICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgbmV3IHJlc3VsdGFudCBhcnJheS5cbiAqL1xuZ29vZy5hcnJheS5jb25jYXQgPSBmdW5jdGlvbih2YXJfYXJncykge1xuICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLmNvbmNhdC5hcHBseShcbiAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXywgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnRzIG9mIGFsbCB0aGUgYXJyYXlzIHBhc3NlZC5cbiAqIEBwYXJhbSB7Li4uIUFycmF5PFQ+fSB2YXJfYXJnc1xuICogQHJldHVybiB7IUFycmF5PFQ+fVxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5qb2luID0gZnVuY3Rpb24odmFyX2FyZ3MpIHtcbiAgcmV0dXJuIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5jb25jYXQuYXBwbHkoXG4gICAgICBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8sIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gb2JqZWN0ICBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYW5cbiAqICAgICBhcnJheS5cbiAqIEByZXR1cm4geyFBcnJheTxUPn0gVGhlIG9iamVjdCBjb252ZXJ0ZWQgaW50byBhbiBhcnJheS4gSWYgb2JqZWN0IGhhcyBhXG4gKiAgICAgbGVuZ3RoIHByb3BlcnR5LCBldmVyeSBwcm9wZXJ0eSBpbmRleGVkIHdpdGggYSBub24tbmVnYXRpdmUgbnVtYmVyXG4gKiAgICAgbGVzcyB0aGFuIGxlbmd0aCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuIElmIG9iamVjdCBkb2VzIG5vdFxuICogICAgIGhhdmUgYSBsZW5ndGggcHJvcGVydHksIGFuIGVtcHR5IGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5LnRvQXJyYXkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG5cbiAgLy8gSWYgbGVuZ3RoIGlzIG5vdCBhIG51bWJlciB0aGUgZm9sbG93aW5nIGl0IGZhbHNlLiBUaGlzIGNhc2UgaXMga2VwdCBmb3JcbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgc2luY2UgdGhlcmUgYXJlIGNhbGxlcnMgdGhhdCBwYXNzIG9iamVjdHMgdGhhdCBhcmVcbiAgLy8gbm90IGFycmF5IGxpa2UuXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdmFyIHJ2ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcnZbaV0gPSBvYmplY3RbaV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG5cbi8qKlxuICogRG9lcyBhIHNoYWxsb3cgY29weSBvZiBhbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciAgQXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3QgdG9cbiAqICAgICBjbG9uZS5cbiAqIEByZXR1cm4geyFBcnJheTxUPn0gQ2xvbmUgb2YgdGhlIGlucHV0IGFycmF5LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5jbG9uZSA9IGdvb2cuYXJyYXkudG9BcnJheTtcblxuXG4vKipcbiAqIEV4dGVuZHMgYW4gYXJyYXkgd2l0aCBhbm90aGVyIGFycmF5LCBlbGVtZW50LCBvciBcImFycmF5IGxpa2VcIiBvYmplY3QuXG4gKiBUaGlzIGZ1bmN0aW9uIG9wZXJhdGVzICdpbi1wbGFjZScsIGl0IGRvZXMgbm90IGNyZWF0ZSBhIG5ldyBBcnJheS5cbiAqXG4gKiBFeGFtcGxlOlxuICogdmFyIGEgPSBbXTtcbiAqIGdvb2cuYXJyYXkuZXh0ZW5kKGEsIFswLCAxXSk7XG4gKiBhOyAvLyBbMCwgMV1cbiAqIGdvb2cuYXJyYXkuZXh0ZW5kKGEsIDIpO1xuICogYTsgLy8gWzAsIDEsIDJdXG4gKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFycjEgIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0gey4uLihBcnJheTxWQUxVRT58VkFMVUUpfSB2YXJfYXJncyBUaGUgZWxlbWVudHMgb3IgYXJyYXlzIG9mIGVsZW1lbnRzXG4gKiAgICAgdG8gYWRkIHRvIGFycjEuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZ29vZy5hcnJheS5leHRlbmQgPSBmdW5jdGlvbihhcnIxLCB2YXJfYXJncykge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnIyID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChnb29nLmlzQXJyYXlMaWtlKGFycjIpKSB7XG4gICAgICB2YXIgbGVuMSA9IGFycjEubGVuZ3RoIHx8IDA7XG4gICAgICB2YXIgbGVuMiA9IGFycjIubGVuZ3RoIHx8IDA7XG4gICAgICBhcnIxLmxlbmd0aCA9IGxlbjEgKyBsZW4yO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgYXJyMVtsZW4xICsgal0gPSBhcnIyW2pdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnIxLnB1c2goYXJyMik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkuIFRoaXMgaXMgYSBnZW5lcmljIHZlcnNpb24gb2YgQXJyYXlcbiAqIHNwbGljZS4gVGhpcyBtZWFucyB0aGF0IGl0IG1pZ2h0IHdvcmsgb24gb3RoZXIgb2JqZWN0cyBzaW1pbGFyIHRvIGFycmF5cyxcbiAqIHN1Y2ggYXMgdGhlIGFyZ3VtZW50cyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGFuZ2luZyB0aGVcbiAqICAgICBhcnJheS4gSWYgbm90IGRlZmluZWQsIHRyZWF0ZWQgYXMgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBob3dNYW55IEhvdyBtYW55IGVsZW1lbnRzIHRvIHJlbW92ZSAoMCBtZWFucyBubyByZW1vdmFsLiBBXG4gKiAgICAgdmFsdWUgYmVsb3cgMCBpcyB0cmVhdGVkIGFzIHplcm8gYW5kIHNvIGlzIGFueSBvdGhlciBub24gbnVtYmVyLiBOdW1iZXJzXG4gKiAgICAgYXJlIGZsb29yZWQpLlxuICogQHBhcmFtIHsuLi5UfSB2YXJfYXJncyBPcHRpb25hbCwgYWRkaXRpb25hbCBlbGVtZW50cyB0byBpbnNlcnQgaW50byB0aGVcbiAqICAgICBhcnJheS5cbiAqIEByZXR1cm4geyFBcnJheTxUPn0gdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5LnNwbGljZSA9IGZ1bmN0aW9uKGFyciwgaW5kZXgsIGhvd01hbnksIHZhcl9hcmdzKSB7XG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXJyLmxlbmd0aCAhPSBudWxsKTtcblxuICByZXR1cm4gZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLnNwbGljZS5hcHBseShcbiAgICAgIGFyciwgZ29vZy5hcnJheS5zbGljZShhcmd1bWVudHMsIDEpKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IGZyb20gYSBzZWdtZW50IG9mIGFuIGFycmF5LiBUaGlzIGlzIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mXG4gKiBBcnJheSBzbGljZS4gVGhpcyBtZWFucyB0aGF0IGl0IG1pZ2h0IHdvcmsgb24gb3RoZXIgb2JqZWN0cyBzaW1pbGFyIHRvXG4gKiBhcnJheXMsIHN1Y2ggYXMgdGhlIGFyZ3VtZW50cyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIFRoZSBhcnJheSBmcm9tXG4gKiB3aGljaCB0byBjb3B5IGEgc2VnbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG8gY29weS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudCB0byBjb3B5LlxuICogQHJldHVybiB7IUFycmF5PFQ+fSBBIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgc2VnbWVudCBvZiB0aGVcbiAqICAgICBvcmlnaW5hbCBhcnJheS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXJyYXkuc2xpY2UgPSBmdW5jdGlvbihhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnQoYXJyLmxlbmd0aCAhPSBudWxsKTtcblxuICAvLyBwYXNzaW5nIDEgYXJnIHRvIHNsaWNlIGlzIG5vdCB0aGUgc2FtZSBhcyBwYXNzaW5nIDIgd2hlcmUgdGhlIHNlY29uZCBpc1xuICAvLyBudWxsIG9yIHVuZGVmaW5lZCAoaW4gdGhhdCBjYXNlIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdHJlYXRlZCBhcyAwKS5cbiAgLy8gd2UgY291bGQgdXNlIHNsaWNlIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0IGFuZCB0aGVuIHVzZSBhcHBseSBpbnN0ZWFkIG9mXG4gIC8vIHRlc3RpbmcgdGhlIGxlbmd0aFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgcmV0dXJuIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5zbGljZS5jYWxsKGFyciwgc3RhcnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnb29nLmFycmF5LkFSUkFZX1BST1RPVFlQRV8uc2xpY2UuY2FsbChhcnIsIHN0YXJ0LCBvcHRfZW5kKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheSAocmV0YWluaW5nIG9ubHkgdGhlIGZpcnN0XG4gKiBvY2N1cnJlbmNlIG9mIGVhY2ggYXJyYXkgZWxlbWVudCkuICBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogYXJyYXkgaW4gcGxhY2UgYW5kIGRvZXNuJ3QgY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgbm9uLWR1cGxpY2F0ZSBpdGVtcy5cbiAqXG4gKiBGb3Igb2JqZWN0cywgZHVwbGljYXRlcyBhcmUgaWRlbnRpZmllZCBhcyBoYXZpbmcgdGhlIHNhbWUgdW5pcXVlIElEIGFzXG4gKiBkZWZpbmVkIGJ5IHtAbGluayBnb29nLmdldFVpZH0uXG4gKlxuICogQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHNwZWNpZnkgYSBjdXN0b20gaGFzaCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB1bmlxdWVcbiAqIHZhbHVlIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5IGl0IHNob3VsZCBjb25zaWRlciB1bmlxdWUuXG4gKlxuICogUnVudGltZTogTixcbiAqIFdvcnN0Y2FzZSBzcGFjZTogMk4gKG5vIGR1cGVzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBUaGUgYXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmVcbiAqICAgICBkdXBsaWNhdGVzLlxuICogQHBhcmFtIHtBcnJheT19IG9wdF9ydiBBbiBvcHRpb25hbCBhcnJheSBpbiB3aGljaCB0byByZXR1cm4gdGhlIHJlc3VsdHMsXG4gKiAgICAgaW5zdGVhZCBvZiBwZXJmb3JtaW5nIHRoZSByZW1vdmFsIGlucGxhY2UuICBJZiBzcGVjaWZpZWQsIHRoZSBvcmlnaW5hbFxuICogICAgIGFycmF5IHdpbGwgcmVtYWluIHVuY2hhbmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6c3RyaW5nPX0gb3B0X2hhc2hGbiBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byB1c2UgdG9cbiAqICAgICBhcHBseSB0byBldmVyeSBpdGVtIGluIHRoZSBhcnJheS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgdW5pcXVlXG4gKiAgICAgdmFsdWUgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgaXQgc2hvdWxkIGNvbnNpZGVyIHVuaXF1ZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXJyYXkucmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uKGFyciwgb3B0X3J2LCBvcHRfaGFzaEZuKSB7XG4gIHZhciByZXR1cm5BcnJheSA9IG9wdF9ydiB8fCBhcnI7XG4gIHZhciBkZWZhdWx0SGFzaEZuID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIC8vIFByZWZpeCBlYWNoIHR5cGUgd2l0aCBhIHNpbmdsZSBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nIHRoZSB0eXBlIHRvXG4gICAgLy8gcHJldmVudCBjb25mbGljdGluZyBrZXlzIChlLmcuIHRydWUgYW5kICd0cnVlJykuXG4gICAgcmV0dXJuIGdvb2cuaXNPYmplY3QoaXRlbSkgPyAnbycgKyBnb29nLmdldFVpZChpdGVtKSA6XG4gICAgICAgICh0eXBlb2YgaXRlbSkuY2hhckF0KDApICsgaXRlbTtcbiAgfTtcbiAgdmFyIGhhc2hGbiA9IG9wdF9oYXNoRm4gfHwgZGVmYXVsdEhhc2hGbjtcblxuICB2YXIgc2VlbiA9IHt9LCBjdXJzb3JJbnNlcnQgPSAwLCBjdXJzb3JSZWFkID0gMDtcbiAgd2hpbGUgKGN1cnNvclJlYWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBhcnJbY3Vyc29yUmVhZCsrXTtcbiAgICB2YXIga2V5ID0gaGFzaEZuKGN1cnJlbnQpO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlZW4sIGtleSkpIHtcbiAgICAgIHNlZW5ba2V5XSA9IHRydWU7XG4gICAgICByZXR1cm5BcnJheVtjdXJzb3JJbnNlcnQrK10gPSBjdXJyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm5BcnJheS5sZW5ndGggPSBjdXJzb3JJbnNlcnQ7XG59O1xuXG5cbi8qKlxuICogU2VhcmNoZXMgdGhlIHNwZWNpZmllZCBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgdXNpbmcgdGhlIGJpbmFyeVxuICogc2VhcmNoIGFsZ29yaXRobS4gIElmIG5vIG9wdF9jb21wYXJlRm4gaXMgc3BlY2lmaWVkLCBlbGVtZW50cyBhcmUgY29tcGFyZWRcbiAqIHVzaW5nIDxjb2RlPmdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmU8L2NvZGU+LCB3aGljaCBjb21wYXJlcyB0aGUgZWxlbWVudHNcbiAqIHVzaW5nIHRoZSBidWlsdCBpbiA8IGFuZCA+IG9wZXJhdG9ycy4gIFRoaXMgd2lsbCBwcm9kdWNlIHRoZSBleHBlY3RlZFxuICogYmVoYXZpb3IgZm9yIGhvbW9nZW5lb3VzIGFycmF5cyBvZiBTdHJpbmcocykgYW5kIE51bWJlcihzKS4gVGhlIGFycmF5XG4gKiBzcGVjaWZpZWQgPGI+bXVzdDwvYj4gYmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciAoYXMgZGVmaW5lZCBieSB0aGVcbiAqIGNvbXBhcmlzb24gZnVuY3Rpb24pLiAgSWYgdGhlIGFycmF5IGlzIG5vdCBzb3J0ZWQsIHJlc3VsdHMgYXJlIHVuZGVmaW5lZC5cbiAqIElmIHRoZSBhcnJheSBjb250YWlucyBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHNwZWNpZmllZCB0YXJnZXQgdmFsdWUsIGFueVxuICogb2YgdGhlc2UgaW5zdGFuY2VzIG1heSBiZSBmb3VuZC5cbiAqXG4gKiBSdW50aW1lOiBPKGxvZyBuKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fGdvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIgVGhlIGFycmF5IHRvIGJlIHNlYXJjaGVkLlxuICogQHBhcmFtIHtUQVJHRVR9IHRhcmdldCBUaGUgc291Z2h0IHZhbHVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihUQVJHRVQsIFZBTFVFKTogbnVtYmVyPX0gb3B0X2NvbXBhcmVGbiBPcHRpb25hbCBjb21wYXJpc29uXG4gKiAgICAgZnVuY3Rpb24gYnkgd2hpY2ggdGhlIGFycmF5IGlzIG9yZGVyZWQuIFNob3VsZCB0YWtlIDIgYXJndW1lbnRzIHRvXG4gKiAgICAgY29tcGFyZSwgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciwgemVybywgb3IgYSBwb3NpdGl2ZSBudW1iZXJcbiAqICAgICBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuLCBlcXVhbCB0bywgb3JcbiAqICAgICBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEByZXR1cm4ge251bWJlcn0gTG93ZXN0IGluZGV4IG9mIHRoZSB0YXJnZXQgdmFsdWUgaWYgZm91bmQsIG90aGVyd2lzZVxuICogICAgICgtKGluc2VydGlvbiBwb2ludCkgLSAxKS4gVGhlIGluc2VydGlvbiBwb2ludCBpcyB3aGVyZSB0aGUgdmFsdWUgc2hvdWxkXG4gKiAgICAgYmUgaW5zZXJ0ZWQgaW50byBhcnIgdG8gcHJlc2VydmUgdGhlIHNvcnRlZCBwcm9wZXJ0eS4gIFJldHVybiB2YWx1ZSA+PSAwXG4gKiAgICAgaWZmIHRhcmdldCBpcyBmb3VuZC5cbiAqIEB0ZW1wbGF0ZSBUQVJHRVQsIFZBTFVFXG4gKi9cbmdvb2cuYXJyYXkuYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24oYXJyLCB0YXJnZXQsIG9wdF9jb21wYXJlRm4pIHtcbiAgcmV0dXJuIGdvb2cuYXJyYXkuYmluYXJ5U2VhcmNoXyhhcnIsXG4gICAgICBvcHRfY29tcGFyZUZuIHx8IGdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmUsIGZhbHNlIC8qIGlzRXZhbHVhdG9yICovLFxuICAgICAgdGFyZ2V0KTtcbn07XG5cblxuLyoqXG4gKiBTZWxlY3RzIGFuIGluZGV4IGluIHRoZSBzcGVjaWZpZWQgYXJyYXkgdXNpbmcgdGhlIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtLlxuICogVGhlIGV2YWx1YXRvciByZWNlaXZlcyBhbiBlbGVtZW50IGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRlc2lyZWQgaW5kZXhcbiAqIGlzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIGl0LiAgVGhlIGV2YWx1YXRvciBtdXN0IGJlIGNvbnNpc3RlbnQgKGZvcm1hbGx5LFxuICogZ29vZy5hcnJheS5tYXAoZ29vZy5hcnJheS5tYXAoYXJyLCBldmFsdWF0b3IsIG9wdF9vYmopLCBnb29nLm1hdGguc2lnbilcbiAqIG11c3QgYmUgbW9ub3RvbmljYWxseSBub24taW5jcmVhc2luZykuXG4gKlxuICogUnVudGltZTogTyhsb2cgbilcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyIFRoZSBhcnJheSB0byBiZSBzZWFyY2hlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTLCBWQUxVRSwgbnVtYmVyLCA/KTogbnVtYmVyfSBldmFsdWF0b3JcbiAqICAgICBFdmFsdWF0b3IgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZSBpbmRleCBhbmRcbiAqICAgICB0aGUgYXJyYXkpLiBTaG91bGQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlclxuICogICAgIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBkZXNpcmVkIGluZGV4IGlzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZVxuICogICAgIGVsZW1lbnQgcGFzc2VkIHRvIGl0LlxuICogQHBhcmFtIHtUSElTPX0gb3B0X29iaiBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJ1xuICogICAgIHdpdGhpbiBldmFsdWF0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBsZWZ0bW9zdCBlbGVtZW50IG1hdGNoZWQgYnkgdGhlIGV2YWx1YXRvciwgaWZcbiAqICAgICBzdWNoIGV4aXN0czsgb3RoZXJ3aXNlICgtKGluc2VydGlvbiBwb2ludCkgLSAxKS4gVGhlIGluc2VydGlvbiBwb2ludCBpc1xuICogICAgIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggdGhlIGV2YWx1YXRvciByZXR1cm5zIG5lZ2F0aXZlLFxuICogICAgIG9yIGFyci5sZW5ndGggaWYgbm8gc3VjaCBlbGVtZW50IGV4aXN0cy4gVGhlIHJldHVybiB2YWx1ZSBpcyBub24tbmVnYXRpdmVcbiAqICAgICBpZmYgYSBtYXRjaCBpcyBmb3VuZC5cbiAqIEB0ZW1wbGF0ZSBUSElTLCBWQUxVRVxuICovXG5nb29nLmFycmF5LmJpbmFyeVNlbGVjdCA9IGZ1bmN0aW9uKGFyciwgZXZhbHVhdG9yLCBvcHRfb2JqKSB7XG4gIHJldHVybiBnb29nLmFycmF5LmJpbmFyeVNlYXJjaF8oYXJyLCBldmFsdWF0b3IsIHRydWUgLyogaXNFdmFsdWF0b3IgKi8sXG4gICAgICB1bmRlZmluZWQgLyogb3B0X3RhcmdldCAqLywgb3B0X29iaik7XG59O1xuXG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobSB3aGljaCBrbm93cyBob3cgdG8gdXNlIGJvdGhcbiAqIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFuZCBldmFsdWF0b3JzLiBJZiBhbiBldmFsdWF0b3IgaXMgcHJvdmlkZWQsIHdpbGwgY2FsbFxuICogdGhlIGV2YWx1YXRvciB3aXRoIHRoZSBnaXZlbiBvcHRpb25hbCBkYXRhIG9iamVjdCwgY29uZm9ybWluZyB0byB0aGVcbiAqIGludGVyZmFjZSBkZWZpbmVkIGluIGJpbmFyeVNlbGVjdC4gT3RoZXJ3aXNlLCBpZiBhIGNvbXBhcmlzb24gZnVuY3Rpb24gaXNcbiAqIHByb3ZpZGVkLCB3aWxsIGNhbGwgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gYWdhaW5zdCB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBwdXJwb3NlZnVsbHkgZG9lcyBub3QgdXNlIGdvb2cuYmluZCBvciBnb29nLnBhcnRpYWwgZm9yXG4gKiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICpcbiAqIFJ1bnRpbWU6IE8obG9nIG4pXG4gKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBUaGUgYXJyYXkgdG8gYmUgc2VhcmNoZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRBUkdFVCwgVkFMVUUpOiBudW1iZXJ8XG4gKiAgICAgICAgIGZ1bmN0aW9uKHRoaXM6VEhJUywgVkFMVUUsIG51bWJlciwgPyk6IG51bWJlcn0gY29tcGFyZUZuIEVpdGhlciBhblxuICogICAgIGV2YWx1YXRvciBvciBhIGNvbXBhcmlzb24gZnVuY3Rpb24sIGFzIGRlZmluZWQgYnkgYmluYXJ5U2VhcmNoXG4gKiAgICAgYW5kIGJpbmFyeVNlbGVjdCBhYm92ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFdmFsdWF0b3IgV2hldGhlciB0aGUgZnVuY3Rpb24gaXMgYW4gZXZhbHVhdG9yIG9yIGFcbiAqICAgICBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUQVJHRVQ9fSBvcHRfdGFyZ2V0IElmIHRoZSBmdW5jdGlvbiBpcyBhIGNvbXBhcmlzb24gZnVuY3Rpb24sIHRoZW5cbiAqICAgICB0aGlzIGlzIHRoZSB0YXJnZXQgdG8gYmluYXJ5IHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfc2VsZk9iaiBJZiB0aGUgZnVuY3Rpb24gaXMgYW4gZXZhbHVhdG9yLCB0aGlzIGlzIGFuXG4gICogICAgb3B0aW9uYWwgdGhpcyBvYmplY3QgZm9yIHRoZSBldmFsdWF0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvd2VzdCBpbmRleCBvZiB0aGUgdGFyZ2V0IHZhbHVlIGlmIGZvdW5kLCBvdGhlcndpc2VcbiAqICAgICAoLShpbnNlcnRpb24gcG9pbnQpIC0gMSkuIFRoZSBpbnNlcnRpb24gcG9pbnQgaXMgd2hlcmUgdGhlIHZhbHVlIHNob3VsZFxuICogICAgIGJlIGluc2VydGVkIGludG8gYXJyIHRvIHByZXNlcnZlIHRoZSBzb3J0ZWQgcHJvcGVydHkuICBSZXR1cm4gdmFsdWUgPj0gMFxuICogICAgIGlmZiB0YXJnZXQgaXMgZm91bmQuXG4gKiBAdGVtcGxhdGUgVEhJUywgVkFMVUUsIFRBUkdFVFxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5hcnJheS5iaW5hcnlTZWFyY2hfID0gZnVuY3Rpb24oYXJyLCBjb21wYXJlRm4sIGlzRXZhbHVhdG9yLCBvcHRfdGFyZ2V0LFxuICAgIG9wdF9zZWxmT2JqKSB7XG4gIHZhciBsZWZ0ID0gMDsgIC8vIGluY2x1c2l2ZVxuICB2YXIgcmlnaHQgPSBhcnIubGVuZ3RoOyAgLy8gZXhjbHVzaXZlXG4gIHZhciBmb3VuZDtcbiAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgIHZhciBtaWRkbGUgPSAobGVmdCArIHJpZ2h0KSA+PiAxO1xuICAgIHZhciBjb21wYXJlUmVzdWx0O1xuICAgIGlmIChpc0V2YWx1YXRvcikge1xuICAgICAgY29tcGFyZVJlc3VsdCA9IGNvbXBhcmVGbi5jYWxsKG9wdF9zZWxmT2JqLCBhcnJbbWlkZGxlXSwgbWlkZGxlLCBhcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wYXJlUmVzdWx0ID0gY29tcGFyZUZuKG9wdF90YXJnZXQsIGFyclttaWRkbGVdKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPiAwKSB7XG4gICAgICBsZWZ0ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgICAvLyBXZSBhcmUgbG9va2luZyBmb3IgdGhlIGxvd2VzdCBpbmRleCBzbyB3ZSBjYW4ndCByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICBmb3VuZCA9ICFjb21wYXJlUmVzdWx0O1xuICAgIH1cbiAgfVxuICAvLyBsZWZ0IGlzIHRoZSBpbmRleCBpZiBmb3VuZCwgb3IgdGhlIGluc2VydGlvbiBwb2ludCBvdGhlcndpc2UuXG4gIC8vIH5sZWZ0IGlzIGEgc2hvcnRoYW5kIGZvciAtbGVmdCAtIDEuXG4gIHJldHVybiBmb3VuZCA/IGxlZnQgOiB+bGVmdDtcbn07XG5cblxuLyoqXG4gKiBTb3J0cyB0aGUgc3BlY2lmaWVkIGFycmF5IGludG8gYXNjZW5kaW5nIG9yZGVyLiAgSWYgbm8gb3B0X2NvbXBhcmVGbiBpc1xuICogc3BlY2lmaWVkLCBlbGVtZW50cyBhcmUgY29tcGFyZWQgdXNpbmdcbiAqIDxjb2RlPmdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmU8L2NvZGU+LCB3aGljaCBjb21wYXJlcyB0aGUgZWxlbWVudHMgdXNpbmdcbiAqIHRoZSBidWlsdCBpbiA8IGFuZCA+IG9wZXJhdG9ycy4gIFRoaXMgd2lsbCBwcm9kdWNlIHRoZSBleHBlY3RlZCBiZWhhdmlvclxuICogZm9yIGhvbW9nZW5lb3VzIGFycmF5cyBvZiBTdHJpbmcocykgYW5kIE51bWJlcihzKSwgdW5saWtlIHRoZSBuYXRpdmUgc29ydCxcbiAqIGJ1dCB3aWxsIGdpdmUgdW5wcmVkaWN0YWJsZSByZXN1bHRzIGZvciBoZXRlcm9nZW5vdXMgbGlzdHMgb2Ygc3RyaW5ncyBhbmRcbiAqIG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgbnVtYmVycyBvZiBkaWdpdHMuXG4gKlxuICogVGhpcyBzb3J0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIHN0YWJsZS5cbiAqXG4gKiBSdW50aW1lOiBTYW1lIGFzIDxjb2RlPkFycmF5LnByb3RvdHlwZS5zb3J0PC9jb2RlPlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFyciBUaGUgYXJyYXkgdG8gYmUgc29ydGVkLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24oVCxUKTpudW1iZXI9fSBvcHRfY29tcGFyZUZuIE9wdGlvbmFsIGNvbXBhcmlzb25cbiAqICAgICBmdW5jdGlvbiBieSB3aGljaCB0aGVcbiAqICAgICBhcnJheSBpcyB0byBiZSBvcmRlcmVkLiBTaG91bGQgdGFrZSAyIGFyZ3VtZW50cyB0byBjb21wYXJlLCBhbmQgcmV0dXJuIGFcbiAqICAgICBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICogICAgIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5zb3J0ID0gZnVuY3Rpb24oYXJyLCBvcHRfY29tcGFyZUZuKSB7XG4gIC8vIFRPRE8oYXJ2KTogVXBkYXRlIHR5cGUgYW5ub3RhdGlvbiBzaW5jZSBudWxsIGlzIG5vdCBhY2NlcHRlZC5cbiAgYXJyLnNvcnQob3B0X2NvbXBhcmVGbiB8fCBnb29nLmFycmF5LmRlZmF1bHRDb21wYXJlKTtcbn07XG5cblxuLyoqXG4gKiBTb3J0cyB0aGUgc3BlY2lmaWVkIGFycmF5IGludG8gYXNjZW5kaW5nIG9yZGVyIGluIGEgc3RhYmxlIHdheS4gIElmIG5vXG4gKiBvcHRfY29tcGFyZUZuIGlzIHNwZWNpZmllZCwgZWxlbWVudHMgYXJlIGNvbXBhcmVkIHVzaW5nXG4gKiA8Y29kZT5nb29nLmFycmF5LmRlZmF1bHRDb21wYXJlPC9jb2RlPiwgd2hpY2ggY29tcGFyZXMgdGhlIGVsZW1lbnRzIHVzaW5nXG4gKiB0aGUgYnVpbHQgaW4gPCBhbmQgPiBvcGVyYXRvcnMuICBUaGlzIHdpbGwgcHJvZHVjZSB0aGUgZXhwZWN0ZWQgYmVoYXZpb3JcbiAqIGZvciBob21vZ2VuZW91cyBhcnJheXMgb2YgU3RyaW5nKHMpIGFuZCBOdW1iZXIocykuXG4gKlxuICogUnVudGltZTogU2FtZSBhcyA8Y29kZT5BcnJheS5wcm90b3R5cGUuc29ydDwvY29kZT4sIHBsdXMgYW4gYWRkaXRpb25hbFxuICogTyhuKSBvdmVyaGVhZCBvZiBjb3B5aW5nIHRoZSBhcnJheSB0d2ljZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnIgVGhlIGFycmF5IHRvIGJlIHNvcnRlZC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKFQsIFQpOiBudW1iZXI9fSBvcHRfY29tcGFyZUZuIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqICAgICBieSB3aGljaCB0aGUgYXJyYXkgaXMgdG8gYmUgb3JkZXJlZC4gU2hvdWxkIHRha2UgMiBhcmd1bWVudHMgdG8gY29tcGFyZSxcbiAqICAgICBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBkZXBlbmRpbmcgb25cbiAqICAgICB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlXG4gKiAgICAgc2Vjb25kLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hcnJheS5zdGFibGVTb3J0ID0gZnVuY3Rpb24oYXJyLCBvcHRfY29tcGFyZUZuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB2YXIgdmFsdWVDb21wYXJlRm4gPSBvcHRfY29tcGFyZUZuIHx8IGdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmU7XG4gIGZ1bmN0aW9uIHN0YWJsZUNvbXBhcmVGbihvYmoxLCBvYmoyKSB7XG4gICAgcmV0dXJuIHZhbHVlQ29tcGFyZUZuKG9iajEudmFsdWUsIG9iajIudmFsdWUpIHx8IG9iajEuaW5kZXggLSBvYmoyLmluZGV4O1xuICB9O1xuICBnb29nLmFycmF5LnNvcnQoYXJyLCBzdGFibGVDb21wYXJlRm4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IGFycltpXS52YWx1ZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNvcnQgdGhlIHNwZWNpZmllZCBhcnJheSBpbnRvIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiBpdGVtIGtleXNcbiAqIHJldHVybmVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxuICogSWYgbm8gb3B0X2NvbXBhcmVGbiBpcyBzcGVjaWZpZWQsIHRoZSBrZXlzIGFyZSBjb21wYXJlZCBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqIHVzaW5nIDxjb2RlPmdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmU8L2NvZGU+LlxuICpcbiAqIFJ1bnRpbWU6IE8oUyhmKG4pKSwgd2hlcmUgUyBpcyBydW50aW1lIG9mIDxjb2RlPmdvb2cuYXJyYXkuc29ydDwvY29kZT5cbiAqIGFuZCBmKG4pIGlzIHJ1bnRpbWUgb2YgdGhlIGtleSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnIgVGhlIGFycmF5IHRvIGJlIHNvcnRlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IEt9IGtleUZuIEZ1bmN0aW9uIHRha2luZyBhcnJheSBlbGVtZW50IGFuZCByZXR1cm5pbmdcbiAqICAgICBhIGtleSB1c2VkIGZvciBzb3J0aW5nIHRoaXMgZWxlbWVudC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKEssIEspOiBudW1iZXI9fSBvcHRfY29tcGFyZUZuIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqICAgICBieSB3aGljaCB0aGUga2V5cyBhcmUgdG8gYmUgb3JkZXJlZC4gU2hvdWxkIHRha2UgMiBhcmd1bWVudHMgdG8gY29tcGFyZSxcbiAqICAgICBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBkZXBlbmRpbmcgb25cbiAqICAgICB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlXG4gKiAgICAgc2Vjb25kLlxuICogQHRlbXBsYXRlIFQsS1xuICovXG5nb29nLmFycmF5LnNvcnRCeUtleSA9IGZ1bmN0aW9uKGFyciwga2V5Rm4sIG9wdF9jb21wYXJlRm4pIHtcbiAgdmFyIGtleUNvbXBhcmVGbiA9IG9wdF9jb21wYXJlRm4gfHwgZ29vZy5hcnJheS5kZWZhdWx0Q29tcGFyZTtcbiAgZ29vZy5hcnJheS5zb3J0KGFyciwgZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBrZXlDb21wYXJlRm4oa2V5Rm4oYSksIGtleUZuKGIpKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogU29ydHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBieSB0aGUgc3BlY2lmaWVkIG9iamVjdCBrZXkgYW5kIGNvbXBhcmVcbiAqIGZ1bmN0aW9uLiBJZiBubyBjb21wYXJlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGUga2V5IHZhbHVlcyBhcmVcbiAqIGNvbXBhcmVkIGluIGFzY2VuZGluZyBvcmRlciB1c2luZyA8Y29kZT5nb29nLmFycmF5LmRlZmF1bHRDb21wYXJlPC9jb2RlPi5cbiAqIFRoaXMgd29uJ3Qgd29yayBmb3Iga2V5cyB0aGF0IGdldCByZW5hbWVkIGJ5IHRoZSBjb21waWxlci4gU28gdXNlXG4gKiB7J2Zvbyc6IDEsICdiYXInOiAyfSByYXRoZXIgdGhhbiB7Zm9vOiAxLCBiYXI6IDJ9LlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhcnIgQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBzb3J0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgb2JqZWN0IGtleSB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdF9jb21wYXJlRm4gVGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIGtleVxuICogICAgIHZhbHVlcy5cbiAqL1xuZ29vZy5hcnJheS5zb3J0T2JqZWN0c0J5S2V5ID0gZnVuY3Rpb24oYXJyLCBrZXksIG9wdF9jb21wYXJlRm4pIHtcbiAgZ29vZy5hcnJheS5zb3J0QnlLZXkoYXJyLFxuICAgICAgZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmpba2V5XTsgfSxcbiAgICAgIG9wdF9jb21wYXJlRm4pO1xufTtcblxuXG4vKipcbiAqIFRlbGxzIGlmIHRoZSBhcnJheSBpcyBzb3J0ZWQuXG4gKiBAcGFyYW0geyFBcnJheTxUPn0gYXJyIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKFQsVCk6bnVtYmVyPX0gb3B0X2NvbXBhcmVGbiBGdW5jdGlvbiB0byBjb21wYXJlIHRoZVxuICogICAgIGFycmF5IGVsZW1lbnRzLlxuICogICAgIFNob3VsZCB0YWtlIDIgYXJndW1lbnRzIHRvIGNvbXBhcmUsIGFuZCByZXR1cm4gYSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sXG4gKiAgICAgb3IgYSBwb3NpdGl2ZSBudW1iZXIgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc3RyaWN0IElmIHRydWUgbm8gZXF1YWwgZWxlbWVudHMgYXJlIGFsbG93ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBhcnJheSBpcyBzb3J0ZWQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5nb29nLmFycmF5LmlzU29ydGVkID0gZnVuY3Rpb24oYXJyLCBvcHRfY29tcGFyZUZuLCBvcHRfc3RyaWN0KSB7XG4gIHZhciBjb21wYXJlID0gb3B0X2NvbXBhcmVGbiB8fCBnb29nLmFycmF5LmRlZmF1bHRDb21wYXJlO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wYXJlUmVzdWx0ID0gY29tcGFyZShhcnJbaSAtIDFdLCBhcnJbaV0pO1xuICAgIGlmIChjb21wYXJlUmVzdWx0ID4gMCB8fCBjb21wYXJlUmVzdWx0ID09IDAgJiYgb3B0X3N0cmljdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gYXJyYXlzIGZvciBlcXVhbGl0eS4gVHdvIGFycmF5cyBhcmUgY29uc2lkZXJlZCBlcXVhbCBpZiB0aGV5XG4gKiBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBlbGVtZW50cyBhcmUgZXF1YWwgYWNjb3JkaW5nIHRvXG4gKiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2dvb2cuYXJyYXkuQXJyYXlMaWtlfSBhcnIxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2VxdWFsc0ZuIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiAgICAgU2hvdWxkIHRha2UgMiBhcmd1bWVudHMgdG8gY29tcGFyZSwgYW5kIHJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudHNcbiAqICAgICBhcmUgZXF1YWwuIERlZmF1bHRzIHRvIHtAbGluayBnb29nLmFycmF5LmRlZmF1bHRDb21wYXJlRXF1YWxpdHl9IHdoaWNoXG4gKiAgICAgY29tcGFyZXMgdGhlIGVsZW1lbnRzIHVzaW5nIHRoZSBidWlsdC1pbiAnPT09JyBvcGVyYXRvci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5nb29nLmFycmF5LmVxdWFscyA9IGZ1bmN0aW9uKGFycjEsIGFycjIsIG9wdF9lcXVhbHNGbikge1xuICBpZiAoIWdvb2cuaXNBcnJheUxpa2UoYXJyMSkgfHwgIWdvb2cuaXNBcnJheUxpa2UoYXJyMikgfHxcbiAgICAgIGFycjEubGVuZ3RoICE9IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsID0gYXJyMS5sZW5ndGg7XG4gIHZhciBlcXVhbHNGbiA9IG9wdF9lcXVhbHNGbiB8fCBnb29nLmFycmF5LmRlZmF1bHRDb21wYXJlRXF1YWxpdHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKCFlcXVhbHNGbihhcnIxW2ldLCBhcnIyW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiAzLXdheSBhcnJheSBjb21wYXJlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshQXJyYXk8VkFMVUU+fCFnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyMSBUaGUgZmlyc3QgYXJyYXkgdG9cbiAqICAgICBjb21wYXJlLlxuICogQHBhcmFtIHshQXJyYXk8VkFMVUU+fCFnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5IHRvXG4gKiAgICAgY29tcGFyZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVkFMVUUsIFZBTFVFKTogbnVtYmVyPX0gb3B0X2NvbXBhcmVGbiBPcHRpb25hbCBjb21wYXJpc29uXG4gKiAgICAgZnVuY3Rpb24gYnkgd2hpY2ggdGhlIGFycmF5IGlzIHRvIGJlIG9yZGVyZWQuIFNob3VsZCB0YWtlIDIgYXJndW1lbnRzIHRvXG4gKiAgICAgY29tcGFyZSwgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciwgemVybywgb3IgYSBwb3NpdGl2ZSBudW1iZXJcbiAqICAgICBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuLCBlcXVhbCB0bywgb3JcbiAqICAgICBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEByZXR1cm4ge251bWJlcn0gTmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBkZXBlbmRpbmcgb25cbiAqICAgICB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlXG4gKiAgICAgc2Vjb25kLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmdvb2cuYXJyYXkuY29tcGFyZTMgPSBmdW5jdGlvbihhcnIxLCBhcnIyLCBvcHRfY29tcGFyZUZuKSB7XG4gIHZhciBjb21wYXJlID0gb3B0X2NvbXBhcmVGbiB8fCBnb29nLmFycmF5LmRlZmF1bHRDb21wYXJlO1xuICB2YXIgbCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmUoYXJyMVtpXSwgYXJyMltpXSk7XG4gICAgaWYgKHJlc3VsdCAhPSAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ29vZy5hcnJheS5kZWZhdWx0Q29tcGFyZShhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xufTtcblxuXG4vKipcbiAqIENvbXBhcmVzIGl0cyB0d28gYXJndW1lbnRzIGZvciBvcmRlciwgdXNpbmcgdGhlIGJ1aWx0IGluIDwgYW5kID5cbiAqIG9wZXJhdG9ycy5cbiAqIEBwYXJhbSB7VkFMVUV9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7VkFMVUV9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCxcbiAqICAgICByZXNwZWN0aXZlbHkuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZ29vZy5hcnJheS5kZWZhdWx0Q29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcblxuXG4vKipcbiAqIENvbXBhcmVzIGl0cyB0d28gYXJndW1lbnRzIGZvciBpbnZlcnNlIG9yZGVyLCB1c2luZyB0aGUgYnVpbHQgaW4gPCBhbmQgPlxuICogb3BlcmF0b3JzLlxuICogQHBhcmFtIHtWQUxVRX0gYSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHtWQUxVRX0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiwgZXF1YWwgdG8sIG9yIGxlc3MgdGhhbiB0aGUgc2Vjb25kLFxuICogICAgIHJlc3BlY3RpdmVseS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICovXG5nb29nLmFycmF5LmludmVyc2VEZWZhdWx0Q29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIC1nb29nLmFycmF5LmRlZmF1bHRDb21wYXJlKGEsIGIpO1xufTtcblxuXG4vKipcbiAqIENvbXBhcmVzIGl0cyB0d28gYXJndW1lbnRzIGZvciBlcXVhbGl0eSwgdXNpbmcgdGhlIGJ1aWx0IGluID09PSBvcGVyYXRvci5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBhcmd1bWVudHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmVFcXVhbGl0eSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG5cbi8qKlxuICogSW5zZXJ0cyBhIHZhbHVlIGludG8gYSBzb3J0ZWQgYXJyYXkuIFRoZSBhcnJheSBpcyBub3QgbW9kaWZpZWQgaWYgdGhlXG4gKiB2YWx1ZSBpcyBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPnxnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7VkFMVUV9IHZhbHVlIFRoZSBvYmplY3QgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtmdW5jdGlvbihWQUxVRSwgVkFMVUUpOiBudW1iZXI9fSBvcHRfY29tcGFyZUZuIE9wdGlvbmFsIGNvbXBhcmlzb25cbiAqICAgICBmdW5jdGlvbiBieSB3aGljaCB0aGUgYXJyYXkgaXMgb3JkZXJlZC4gU2hvdWxkIHRha2UgMiBhcmd1bWVudHMgdG9cbiAqICAgICBjb21wYXJlLCBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlclxuICogICAgIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvclxuICogICAgIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyBpbnNlcnRlZC5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICovXG5nb29nLmFycmF5LmJpbmFyeUluc2VydCA9IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgb3B0X2NvbXBhcmVGbikge1xuICB2YXIgaW5kZXggPSBnb29nLmFycmF5LmJpbmFyeVNlYXJjaChhcnJheSwgdmFsdWUsIG9wdF9jb21wYXJlRm4pO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZ29vZy5hcnJheS5pbnNlcnRBdChhcnJheSwgdmFsdWUsIC0oaW5kZXggKyAxKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIGEgc29ydGVkIGFycmF5LlxuICogQHBhcmFtIHshQXJyYXk8VkFMVUU+fCFnb29nLmFycmF5LkFycmF5TGlrZX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7VkFMVUV9IHZhbHVlIFRoZSBvYmplY3QgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtmdW5jdGlvbihWQUxVRSwgVkFMVUUpOiBudW1iZXI9fSBvcHRfY29tcGFyZUZuIE9wdGlvbmFsIGNvbXBhcmlzb25cbiAqICAgICBmdW5jdGlvbiBieSB3aGljaCB0aGUgYXJyYXkgaXMgb3JkZXJlZC4gU2hvdWxkIHRha2UgMiBhcmd1bWVudHMgdG9cbiAqICAgICBjb21wYXJlLCBhbmQgcmV0dXJuIGEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlclxuICogICAgIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvclxuICogICAgIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmdvb2cuYXJyYXkuYmluYXJ5UmVtb3ZlID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlLCBvcHRfY29tcGFyZUZuKSB7XG4gIHZhciBpbmRleCA9IGdvb2cuYXJyYXkuYmluYXJ5U2VhcmNoKGFycmF5LCB2YWx1ZSwgb3B0X2NvbXBhcmVGbik7XG4gIHJldHVybiAoaW5kZXggPj0gMCkgPyBnb29nLmFycmF5LnJlbW92ZUF0KGFycmF5LCBpbmRleCkgOiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBTcGxpdHMgYW4gYXJyYXkgaW50byBkaXNqb2ludCBidWNrZXRzIGFjY29yZGluZyB0byBhIHNwbGl0dGluZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFycmF5IFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTLCBULG51bWJlcixBcnJheTxUPik6P30gc29ydGVyIEZ1bmN0aW9uIHRvIGNhbGwgZm9yXG4gKiAgICAgZXZlcnkgZWxlbWVudC4gIFRoaXMgdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGUgaW5kZXggYW5kIHRoZVxuICogICAgIGFycmF5KSBhbmQgbXVzdCByZXR1cm4gYSB2YWxpZCBvYmplY3Qga2V5IChhIHN0cmluZywgbnVtYmVyLCBldGMpLCBvclxuICogICAgIHVuZGVmaW5lZCwgaWYgdGhhdCBvYmplY3Qgc2hvdWxkIG5vdCBiZSBwbGFjZWQgaW4gYSBidWNrZXQuXG4gKiBAcGFyYW0ge1M9fSBvcHRfb2JqIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnIHdpdGhpblxuICogICAgIHNvcnRlci5cbiAqIEByZXR1cm4geyFPYmplY3R9IEFuIG9iamVjdCwgd2l0aCBrZXlzIGJlaW5nIGFsbCBvZiB0aGUgdW5pcXVlIHJldHVybiB2YWx1ZXNcbiAqICAgICBvZiBzb3J0ZXIsIGFuZCB2YWx1ZXMgYmVpbmcgYXJyYXlzIGNvbnRhaW5pbmcgdGhlIGl0ZW1zIGZvclxuICogICAgIHdoaWNoIHRoZSBzcGxpdHRlciByZXR1cm5lZCB0aGF0IGtleS5cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZ29vZy5hcnJheS5idWNrZXQgPSBmdW5jdGlvbihhcnJheSwgc29ydGVyLCBvcHRfb2JqKSB7XG4gIHZhciBidWNrZXRzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuICAgIHZhciBrZXkgPSBzb3J0ZXIuY2FsbChvcHRfb2JqLCB2YWx1ZSwgaSwgYXJyYXkpO1xuICAgIGlmIChnb29nLmlzRGVmKGtleSkpIHtcbiAgICAgIC8vIFB1c2ggdGhlIHZhbHVlIHRvIHRoZSByaWdodCBidWNrZXQsIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2tleV0gfHwgKGJ1Y2tldHNba2V5XSA9IFtdKTtcbiAgICAgIGJ1Y2tldC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVja2V0cztcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBidWlsdCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheSBhbmQgdGhlIGtleS1nZW5lcmF0aW9uXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8VD58Z29vZy5hcnJheS5BcnJheUxpa2V9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBvdmVyXG4gKiAgICAgd2hpY2ggdG8gaXRlcmF0ZSB3aG9zZSBlbGVtZW50cyB3aWxsIGJlIHRoZSB2YWx1ZXMgaW4gdGhlIG5ldyBvYmplY3QuXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlMsIFQsIG51bWJlciwgPykgOiBzdHJpbmd9IGtleUZ1bmMgVGhlIGZ1bmN0aW9uIHRvXG4gKiAgICAgY2FsbCBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICogICAgIGluZGV4IGFuZCB0aGUgYXJyYXkpIGFuZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZVxuICogICAgIGtleSBmb3IgdGhlIGVsZW1lbnQgaW4gdGhlIG5ldyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lXG4gKiAgICAga2V5IGZvciBtb3JlIHRoYW4gb25lIGVsZW1lbnQsIHRoZSB2YWx1ZSBmb3IgdGhhdCBrZXkgaXNcbiAqICAgICBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkLlxuICogQHBhcmFtIHtTPX0gb3B0X29iaiBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJ1xuICogICAgIHdpdGhpbiBrZXlGdW5jLlxuICogQHJldHVybiB7IU9iamVjdDxUPn0gVGhlIG5ldyBvYmplY3QuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmdvb2cuYXJyYXkudG9PYmplY3QgPSBmdW5jdGlvbihhcnIsIGtleUZ1bmMsIG9wdF9vYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICBnb29nLmFycmF5LmZvckVhY2goYXJyLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgIHJldFtrZXlGdW5jLmNhbGwob3B0X29iaiwgZWxlbWVudCwgaW5kZXgsIGFycildID0gZWxlbWVudDtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJhbmdlIG9mIG51bWJlcnMgaW4gYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi5cbiAqXG4gKiBSYW5nZSB0YWtlcyAxLCAyLCBvciAzIGFyZ3VtZW50czpcbiAqIDxwcmU+XG4gKiByYW5nZSg1KSBpcyB0aGUgc2FtZSBhcyByYW5nZSgwLCA1LCAxKSBhbmQgcHJvZHVjZXMgWzAsIDEsIDIsIDMsIDRdXG4gKiByYW5nZSgyLCA1KSBpcyB0aGUgc2FtZSBhcyByYW5nZSgyLCA1LCAxKSBhbmQgcHJvZHVjZXMgWzIsIDMsIDRdXG4gKiByYW5nZSgtMiwgLTUsIC0xKSBwcm9kdWNlcyBbLTIsIC0zLCAtNF1cbiAqIHJhbmdlKC0yLCAtNSwgMSkgcHJvZHVjZXMgW10sIHNpbmNlIHN0ZXBwaW5nIGJ5IDEgd291bGRuJ3QgZXZlciByZWFjaCAtNS5cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydE9yRW5kIFRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgcmFuZ2UgaWYgYW4gZW5kIGFyZ3VtZW50XG4gKiAgICAgaXMgcHJvdmlkZWQuIE90aGVyd2lzZSwgdGhlIHN0YXJ0IHZhbHVlIGlzIDAsIGFuZCB0aGlzIGlzIHRoZSBlbmQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIG9wdGlvbmFsIGVuZCB2YWx1ZSBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9zdGVwIFRoZSBzdGVwIHNpemUgYmV0d2VlbiByYW5nZSB2YWx1ZXMuIERlZmF1bHRzIHRvIDFcbiAqICAgICBpZiBvcHRfc3RlcCBpcyB1bmRlZmluZWQgb3IgMC5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBudW1iZXJzIGZvciB0aGUgcmVxdWVzdGVkIHJhbmdlLiBNYXkgYmVcbiAqICAgICBhbiBlbXB0eSBhcnJheSBpZiBhZGRpbmcgdGhlIHN0ZXAgd291bGQgbm90IGNvbnZlcmdlIHRvd2FyZCB0aGUgZW5kXG4gKiAgICAgdmFsdWUuXG4gKi9cbmdvb2cuYXJyYXkucmFuZ2UgPSBmdW5jdGlvbihzdGFydE9yRW5kLCBvcHRfZW5kLCBvcHRfc3RlcCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IHN0YXJ0T3JFbmQ7XG4gIHZhciBzdGVwID0gb3B0X3N0ZXAgfHwgMTtcbiAgaWYgKG9wdF9lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gc3RhcnRPckVuZDtcbiAgICBlbmQgPSBvcHRfZW5kO1xuICB9XG5cbiAgaWYgKHN0ZXAgKiAoZW5kIC0gc3RhcnQpIDwgMCkge1xuICAgIC8vIFNpZ24gbWlzbWF0Y2g6IHN0YXJ0ICsgc3RlcCB3aWxsIG5ldmVyIHJlYWNoIHRoZSBlbmQgdmFsdWUuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcbiAgICAgIGFycmF5LnB1c2goaSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA+IGVuZDsgaSArPSBzdGVwKSB7XG4gICAgICBhcnJheS5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHRoZSBnaXZlbiB2YWx1ZSByZXBlYXRlZCBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSB7VkFMVUV9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXBlYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgcmVwZWF0IGNvdW50LlxuICogQHJldHVybiB7IUFycmF5PFZBTFVFPn0gQW4gYXJyYXkgd2l0aCB0aGUgcmVwZWF0ZWQgdmFsdWUuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZ29vZy5hcnJheS5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSwgbikge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgZXZlcnkgYXJndW1lbnQgd2l0aCBhbGwgYXJyYXlzXG4gKiBleHBhbmRlZCBpbi1wbGFjZSByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSB2YWx1ZXMgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm4geyFBcnJheTw/Pn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZmxhdHRlbmVkIHZhbHVlcy5cbiAqL1xuZ29vZy5hcnJheS5mbGF0dGVuID0gZnVuY3Rpb24odmFyX2FyZ3MpIHtcbiAgdmFyIENIVU5LX1NJWkUgPSA4MTkyO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoZ29vZy5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGVsZW1lbnQubGVuZ3RoOyBjICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgdmFyIGNodW5rID0gZ29vZy5hcnJheS5zbGljZShlbGVtZW50LCBjLCBjICsgQ0hVTktfU0laRSk7XG4gICAgICAgIHZhciByZWN1cnNlUmVzdWx0ID0gZ29vZy5hcnJheS5mbGF0dGVuLmFwcGx5KG51bGwsIGNodW5rKTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByZWN1cnNlUmVzdWx0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocmVjdXJzZVJlc3VsdFtyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUm90YXRlcyBhbiBhcnJheSBpbi1wbGFjZS4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgdGhlIGVsZW1lbnQgYXRcbiAqIGluZGV4IGkgd2lsbCBiZSB0aGUgZWxlbWVudCBwcmV2aW91c2x5IGF0IGluZGV4IChpIC0gbikgJVxuICogYXJyYXkubGVuZ3RoLCBmb3IgYWxsIHZhbHVlcyBvZiBpIGJldHdlZW4gMCBhbmQgYXJyYXkubGVuZ3RoIC0gMSxcbiAqIGluY2x1c2l2ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgc3VwcG9zZSBsaXN0IGNvbXByaXNlcyBbdCwgYSwgbiwgaywgc10uIEFmdGVyIGludm9raW5nXG4gKiByb3RhdGUoYXJyYXksIDEpIChvciByb3RhdGUoYXJyYXksIC00KSksIGFycmF5IHdpbGwgY29tcHJpc2UgW3MsIHQsIGEsIG4sIGtdLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PFQ+fSBhcnJheSBUaGUgYXJyYXkgdG8gcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGFtb3VudCB0byByb3RhdGUuXG4gKiBAcmV0dXJuIHshQXJyYXk8VD59IFRoZSBhcnJheS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXJyYXkucm90YXRlID0gZnVuY3Rpb24oYXJyYXksIG4pIHtcbiAgZ29vZy5hc3NlcnRzLmFzc2VydChhcnJheS5sZW5ndGggIT0gbnVsbCk7XG5cbiAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgIG4gJT0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgZ29vZy5hcnJheS5BUlJBWV9QUk9UT1RZUEVfLnVuc2hpZnQuYXBwbHkoYXJyYXksIGFycmF5LnNwbGljZSgtbiwgbikpO1xuICAgIH0gZWxzZSBpZiAobiA8IDApIHtcbiAgICAgIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5wdXNoLmFwcGx5KGFycmF5LCBhcnJheS5zcGxpY2UoMCwgLW4pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vKipcbiAqIE1vdmVzIG9uZSBpdGVtIG9mIGFuIGFycmF5IHRvIGEgbmV3IHBvc2l0aW9uIGtlZXBpbmcgdGhlIG9yZGVyIG9mIHRoZSByZXN0XG4gKiBvZiB0aGUgaXRlbXMuIEV4YW1wbGUgdXNlIGNhc2U6IGtlZXBpbmcgYSBsaXN0IG9mIEphdmFTY3JpcHQgb2JqZWN0c1xuICogc3luY2hyb25pemVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbGlzdCBvZiBET00gZWxlbWVudHMgYWZ0ZXIgb25lIG9mIHRoZVxuICogZWxlbWVudHMgaGFzIGJlZW4gZHJhZ2dlZCB0byBhIG5ldyBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7IShBcnJheXxBcmd1bWVudHN8e2xlbmd0aDpudW1iZXJ9KX0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBpdGVtIHRvIG1vdmUgYmV0d2VlbiAwIGFuZFxuICogICAgIHtAY29kZSBhcnIubGVuZ3RoIC0gMX0uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBUYXJnZXQgaW5kZXggYmV0d2VlbiAwIGFuZCB7QGNvZGUgYXJyLmxlbmd0aCAtIDF9LlxuICovXG5nb29nLmFycmF5Lm1vdmVJdGVtID0gZnVuY3Rpb24oYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgZ29vZy5hc3NlcnRzLmFzc2VydChmcm9tSW5kZXggPj0gMCAmJiBmcm9tSW5kZXggPCBhcnIubGVuZ3RoKTtcbiAgZ29vZy5hc3NlcnRzLmFzc2VydCh0b0luZGV4ID49IDAgJiYgdG9JbmRleCA8IGFyci5sZW5ndGgpO1xuICAvLyBSZW1vdmUgMSBpdGVtIGF0IGZyb21JbmRleC5cbiAgdmFyIHJlbW92ZWRJdGVtcyA9IGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5zcGxpY2UuY2FsbChhcnIsIGZyb21JbmRleCwgMSk7XG4gIC8vIEluc2VydCB0aGUgcmVtb3ZlZCBpdGVtIGF0IHRvSW5kZXguXG4gIGdvb2cuYXJyYXkuQVJSQVlfUFJPVE9UWVBFXy5zcGxpY2UuY2FsbChhcnIsIHRvSW5kZXgsIDAsIHJlbW92ZWRJdGVtc1swXSk7XG4gIC8vIFdlIGRvbid0IHVzZSBnb29nLmFycmF5Lmluc2VydEF0IGFuZCBnb29nLmFycmF5LnJlbW92ZUF0LCBiZWNhdXNlIHRoZXkncmVcbiAgLy8gc2lnbmlmaWNhbnRseSBzbG93ZXIgdGhhbiBzcGxpY2UuXG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBmb3Igd2hpY2ggdGhlIGVsZW1lbnQgYXQgcG9zaXRpb24gaSBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIGl0aCBlbGVtZW50IG9mIHRoZSBwcm92aWRlZCBhcnJheXMuICBUaGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBvbmx5IGJlIGFzIGxvbmdcbiAqIGFzIHRoZSBzaG9ydGVzdCBhcnJheSBwcm92aWRlZDsgYWRkaXRpb25hbCB2YWx1ZXMgYXJlIGlnbm9yZWQuICBGb3IgZXhhbXBsZSxcbiAqIHRoZSByZXN1bHQgb2YgemlwcGluZyBbMSwgMl0gYW5kIFszLCA0LCA1XSBpcyBbWzEsM10sIFsyLCA0XV0uXG4gKlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIHRoZSB6aXAoKSBmdW5jdGlvbiBpbiBQeXRob24uICBTZWUge0BsaW5rXG4gKiBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjemlwfVxuICpcbiAqIEBwYXJhbSB7Li4uIWdvb2cuYXJyYXkuQXJyYXlMaWtlfSB2YXJfYXJncyBBcnJheXMgdG8gYmUgY29tYmluZWQuXG4gKiBAcmV0dXJuIHshQXJyYXk8IUFycmF5PD8+Pn0gQSBuZXcgYXJyYXkgb2YgYXJyYXlzIGNyZWF0ZWQgZnJvbVxuICogICAgIHByb3ZpZGVkIGFycmF5cy5cbiAqL1xuZ29vZy5hcnJheS56aXAgPSBmdW5jdGlvbih2YXJfYXJncykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgdHJ1ZTsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmd1bWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBhcnIgPSBhcmd1bWVudHNbal07XG4gICAgICAvLyBJZiBpIGlzIGxhcmdlciB0aGFuIHRoZSBhcnJheSBsZW5ndGgsIHRoaXMgaXMgdGhlIHNob3J0ZXN0IGFycmF5LlxuICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFsdWUucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaHVmZmxlcyB0aGUgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgYXJyYXkgdXNpbmcgdGhlIEZpc2hlci1ZYXRlcyBpbi1wbGFjZVxuICogc2h1ZmZsZSAoYWxzbyBrbm93biBhcyB0aGUgS251dGggU2h1ZmZsZSkuIEJ5IGRlZmF1bHQsIGNhbGxzIE1hdGgucmFuZG9tKClcbiAqIGFuZCBzbyByZXNldHMgdGhlIHN0YXRlIG9mIHRoYXQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFNpbWlsYXJseSwgbWF5IHJlc2V0XG4gKiB0aGUgc3RhdGUgb2YgdGhlIGFueSBvdGhlciBzcGVjaWZpZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gKlxuICogUnVudGltZTogTyhuKVxuICpcbiAqIEBwYXJhbSB7IUFycmF5PD8+fSBhcnIgVGhlIGFycmF5IHRvIGJlIHNodWZmbGVkLlxuICogQHBhcmFtIHtmdW5jdGlvbigpOm51bWJlcj19IG9wdF9yYW5kRm4gT3B0aW9uYWwgcmFuZG9tIGZ1bmN0aW9uIHRvIHVzZSBmb3JcbiAqICAgICBzaHVmZmxpbmcuXG4gKiAgICAgVGFrZXMgbm8gYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIHJhbmRvbSBudW1iZXIgb24gdGhlIGludGVydmFsIFswLCAxKS5cbiAqICAgICBEZWZhdWx0cyB0byBNYXRoLnJhbmRvbSgpIHVzaW5nIEphdmFTY3JpcHQncyBidWlsdC1pbiBNYXRoIGxpYnJhcnkuXG4gKi9cbmdvb2cuYXJyYXkuc2h1ZmZsZSA9IGZ1bmN0aW9uKGFyciwgb3B0X3JhbmRGbikge1xuICB2YXIgcmFuZEZuID0gb3B0X3JhbmRGbiB8fCBNYXRoLnJhbmRvbTtcblxuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAvLyBDaG9vc2UgYSByYW5kb20gYXJyYXkgaW5kZXggaW4gWzAsIGldIChpbmNsdXNpdmUgd2l0aCBpKS5cbiAgICB2YXIgaiA9IE1hdGguZmxvb3IocmFuZEZuKCkgKiAoaSArIDEpKTtcblxuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgZnJvbSBhcnIsIGJhc2VkIG9uIHRoZSBpbmRleGVzIG9mIGVsZW1lbnRzXG4gKiBwcm92aWRlZCBieSBpbmRleF9hcnIuIEZvciBleGFtcGxlLCB0aGUgcmVzdWx0IG9mIGluZGV4IGNvcHlpbmdcbiAqIFsnYScsICdiJywgJ2MnXSB3aXRoIGluZGV4X2FyciBbMSwwLDAsMl0gaXMgWydiJywgJ2EnLCAnYScsICdjJ10uXG4gKlxuICogQHBhcmFtIHshQXJyYXk8VD59IGFyciBUaGUgYXJyYXkgdG8gZ2V0IGEgaW5kZXhlZCBjb3B5IGZyb20uXG4gKiBAcGFyYW0geyFBcnJheTxudW1iZXI+fSBpbmRleF9hcnIgQW4gYXJyYXkgb2YgaW5kZXhlcyB0byBnZXQgZnJvbSBhcnIuXG4gKiBAcmV0dXJuIHshQXJyYXk8VD59IEEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIGZyb20gYXJyIGluIGluZGV4X2FyciBvcmRlci5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmdvb2cuYXJyYXkuY29weUJ5SW5kZXggPSBmdW5jdGlvbihhcnIsIGluZGV4X2Fycikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGdvb2cuYXJyYXkuZm9yRWFjaChpbmRleF9hcnIsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW2luZGV4XSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0aWVzIHVzZWQgYnkgZ29vZy5sYWJzLnVzZXJBZ2VudCB0b29scy4gVGhlc2UgZnVuY3Rpb25zXG4gKiBzaG91bGQgbm90IGJlIHVzZWQgb3V0c2lkZSBvZiBnb29nLmxhYnMudXNlckFnZW50LiouXG4gKlxuICpcbiAqIEBhdXRob3Igbm5hemVAZ29vZ2xlLmNvbSAoTmF0aGFuIE5hemUpXG4gKi9cblxuZ29vZy5wcm92aWRlKCdnb29nLmxhYnMudXNlckFnZW50LnV0aWwnKTtcblxuZ29vZy5yZXF1aXJlKCdnb29nLnN0cmluZycpO1xuXG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIHVzZXJBZ2VudCBzdHJpbmcgZnJvbSBuYXZpZ2F0b3IgaWYgaXQgZXhpc3RzLlxuICogSWYgbmF2aWdhdG9yIG9yIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIGlzIG1pc3NpbmcsIHJldHVybnMgYW4gZW1wdHlcbiAqIHN0cmluZy5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXROYXRpdmVVc2VyQWdlbnRTdHJpbmdfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuYXZpZ2F0b3IgPSBnb29nLmxhYnMudXNlckFnZW50LnV0aWwuZ2V0TmF2aWdhdG9yXygpO1xuICBpZiAobmF2aWdhdG9yKSB7XG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgaWYgKHVzZXJBZ2VudCkge1xuICAgICAgcmV0dXJuIHVzZXJBZ2VudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufTtcblxuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIG5hdGl2ZSBuYXZpZ2F0b3IuXG4gKiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIHN0dWJiZWQgb3V0IGluIHRlc3RpbmcuXG4gKiBAcmV0dXJuIHtOYXZpZ2F0b3J9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxhYnMudXNlckFnZW50LnV0aWwuZ2V0TmF2aWdhdG9yXyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5nbG9iYWwubmF2aWdhdG9yO1xufTtcblxuXG4vKipcbiAqIEEgcG9zc2libGUgb3ZlcnJpZGUgZm9yIGFwcGxpY2F0aW9ucyB3aGljaCB3aXNoIHRvIG5vdCBjaGVja1xuICogbmF2aWdhdG9yLnVzZXJBZ2VudCBidXQgdXNlIGEgc3BlY2lmaWVkIHZhbHVlIGZvciBkZXRlY3Rpb24gaW5zdGVhZC5cbiAqIEBwcml2YXRlIHtzdHJpbmd9XG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQudXRpbC51c2VyQWdlbnRfID1cbiAgICBnb29nLmxhYnMudXNlckFnZW50LnV0aWwuZ2V0TmF0aXZlVXNlckFnZW50U3RyaW5nXygpO1xuXG5cbi8qKlxuICogQXBwbGljYXRpb25zIG1heSBvdmVycmlkZSBicm93c2VyIGRldGVjdGlvbiBvbiB0aGUgYnVpbHQgaW5cbiAqIG5hdmlnYXRvci51c2VyQWdlbnQgb2JqZWN0IGJ5IHNldHRpbmcgdGhpcyBzdHJpbmcuIFNldCB0byBudWxsIHRvIHVzZSB0aGVcbiAqIGJyb3dzZXIgb2JqZWN0IGluc3RlYWQuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfdXNlckFnZW50IFRoZSBVc2VyLUFnZW50IG92ZXJyaWRlLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LnV0aWwuc2V0VXNlckFnZW50ID0gZnVuY3Rpb24ob3B0X3VzZXJBZ2VudCkge1xuICBnb29nLmxhYnMudXNlckFnZW50LnV0aWwudXNlckFnZW50XyA9IG9wdF91c2VyQWdlbnQgfHxcbiAgICAgIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXROYXRpdmVVc2VyQWdlbnRTdHJpbmdfKCk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC51c2VyQWdlbnRfO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgY29udGFpbnMgdGhlIGdpdmVuIHN0cmluZywgaWdub3JpbmdcbiAqICAgICBjYXNlLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIGdvb2cuc3RyaW5nLmNvbnRhaW5zKHVzZXJBZ2VudCwgc3RyKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBzdHJpbmcuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudElnbm9yZUNhc2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIGdvb2cuc3RyaW5nLmNhc2VJbnNlbnNpdGl2ZUNvbnRhaW5zKHVzZXJBZ2VudCwgc3RyKTtcbn07XG5cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHVzZXIgYWdlbnQgaW50byB0dXBsZXMgZm9yIGVhY2ggc2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnRcbiAqIEByZXR1cm4geyFBcnJheTwhQXJyYXk8c3RyaW5nPj59IFR1cGxlcyBvZiBrZXksIHZlcnNpb24sIGFuZCB0aGUgY29udGVudHNcbiAqICAgICBvZiB0aGUgcGFyZW50aGV0aWNhbC5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLmV4dHJhY3RWZXJzaW9uVHVwbGVzID0gZnVuY3Rpb24odXNlckFnZW50KSB7XG4gIC8vIE1hdGNoZXMgZWFjaCBzZWN0aW9uIG9mIGEgdXNlciBhZ2VudCBzdHJpbmcuXG4gIC8vIEV4YW1wbGUgVUE6XG4gIC8vIE1vemlsbGEvNS4wIChpUGFkOyBVOyBDUFUgT1MgM18yXzEgbGlrZSBNYWMgT1MgWDsgZW4tdXMpXG4gIC8vIEFwcGxlV2ViS2l0LzUzMS4yMS4xMCAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS83QjQwNVxuICAvLyBUaGlzIGhhcyB0aHJlZSB2ZXJzaW9uIHR1cGxlczogTW96aWxsYSwgQXBwbGVXZWJLaXQsIGFuZCBNb2JpbGUuXG5cbiAgdmFyIHZlcnNpb25SZWdFeHAgPSBuZXcgUmVnRXhwKFxuICAgICAgLy8gS2V5LiBOb3RlIHRoYXQgYSBrZXkgbWF5IGhhdmUgYSBzcGFjZS5cbiAgICAgIC8vIChpLmUuICdNb2JpbGUgU2FmYXJpJyBpbiAnTW9iaWxlIFNhZmFyaS81LjAnKVxuICAgICAgJyhcXFxcd1tcXFxcdyBdKyknICtcblxuICAgICAgJy8nICsgICAgICAgICAgICAgICAgLy8gc2xhc2hcbiAgICAgICcoW15cXFxcc10rKScgKyAgICAgICAgLy8gdmVyc2lvbiAoaS5lLiAnNS4wYicpXG4gICAgICAnXFxcXHMqJyArICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgICcoPzpcXFxcKCguKj8pXFxcXCkpPycsICAvLyBwYXJlbnRoZXRpY2FsIGluZm8uIHBhcmVudGhlc2VzIG5vdCBtYXRjaGVkLlxuICAgICAgJ2cnKTtcblxuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgbWF0Y2g7XG5cbiAgLy8gSXRlcmF0ZSBhbmQgY29sbGVjdCB0aGUgdmVyc2lvbiB0dXBsZXMuICBFYWNoIGl0ZXJhdGlvbiB3aWxsIGJlIHRoZVxuICAvLyBuZXh0IHJlZ2V4IG1hdGNoLlxuICB3aGlsZSAobWF0Y2ggPSB2ZXJzaW9uUmVnRXhwLmV4ZWModXNlckFnZW50KSkge1xuICAgIGRhdGEucHVzaChbXG4gICAgICBtYXRjaFsxXSwgIC8vIGtleVxuICAgICAgbWF0Y2hbMl0sICAvLyB2YWx1ZVxuICAgICAgLy8gfHwgdW5kZWZpbmVkIGFzIHRoaXMgaXMgbm90IHVuZGVmaW5lZCBpbiBJRTcgYW5kIElFOFxuICAgICAgbWF0Y2hbM10gfHwgdW5kZWZpbmVkICAvLyBpbmZvXG4gICAgXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbiIsIi8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgb2JqZWN0cy9tYXBzL2hhc2hlcy5cbiAqIEBhdXRob3IgYXJ2QGdvb2dsZS5jb20gKEVyaWsgQXJ2aWRzc29uKVxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5vYmplY3QnKTtcblxuXG4vKipcbiAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBvYmplY3QvbWFwL2hhc2guXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsViw/LE9iamVjdDxLLFY+KTo/fSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgMyBhcmd1bWVudHMgKHRoZSB2YWx1ZSwgdGhlXG4gKiAgICAga2V5IGFuZCB0aGUgb2JqZWN0KSBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtUPX0gb3B0X29iaiBUaGlzIGlzIHVzZWQgYXMgdGhlICd0aGlzJyBvYmplY3Qgd2l0aGluIGYuXG4gKiBAdGVtcGxhdGUgVCxLLFZcbiAqL1xuZ29vZy5vYmplY3QuZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgZiwgb3B0X29iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgZi5jYWxsKG9wdF9vYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gYW4gb2JqZWN0L21hcC9oYXNoLiBJZiB0aGF0IGNhbGwgcmV0dXJuc1xuICogdHJ1ZSwgYWRkcyB0aGUgZWxlbWVudCB0byBhIG5ldyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3Qgb3ZlciB3aGljaCB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsViw/LE9iamVjdDxLLFY+KTpib29sZWFufSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXNcbiAqICAgICBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIHZhbHVlLCB0aGUga2V5IGFuZCB0aGUgb2JqZWN0KVxuICogICAgIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi4gSWYgdGhlIHJldHVybiB2YWx1ZSBpcyB0cnVlIHRoZVxuICogICAgIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBvYmplY3QuIElmIGl0IGlzIGZhbHNlIHRoZVxuICogICAgIGVsZW1lbnQgaXMgbm90IGluY2x1ZGVkLlxuICogQHBhcmFtIHtUPX0gb3B0X29iaiBUaGlzIGlzIHVzZWQgYXMgdGhlICd0aGlzJyBvYmplY3Qgd2l0aGluIGYuXG4gKiBAcmV0dXJuIHshT2JqZWN0PEssVj59IGEgbmV3IG9iamVjdCBpbiB3aGljaCBvbmx5IGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZVxuICogICAgIHRlc3QgYXJlIHByZXNlbnQuXG4gKiBAdGVtcGxhdGUgVCxLLFZcbiAqL1xuZ29vZy5vYmplY3QuZmlsdGVyID0gZnVuY3Rpb24ob2JqLCBmLCBvcHRfb2JqKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChmLmNhbGwob3B0X29iaiwgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLyoqXG4gKiBGb3IgZXZlcnkgZWxlbWVudCBpbiBhbiBvYmplY3QvbWFwL2hhc2ggY2FsbHMgYSBmdW5jdGlvbiBhbmQgaW5zZXJ0cyB0aGVcbiAqIHJlc3VsdCBpbnRvIGEgbmV3IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCBvdmVyIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VCxWLD8sT2JqZWN0PEssVj4pOlJ9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgIHRha2VzIDMgYXJndW1lbnRzICh0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoZSBvYmplY3QpXG4gKiAgICAgYW5kIHNob3VsZCByZXR1cm4gc29tZXRoaW5nLiBUaGUgcmVzdWx0IHdpbGwgYmUgaW5zZXJ0ZWRcbiAqICAgICBpbnRvIGEgbmV3IG9iamVjdC5cbiAqIEBwYXJhbSB7VD19IG9wdF9vYmogVGhpcyBpcyB1c2VkIGFzIHRoZSAndGhpcycgb2JqZWN0IHdpdGhpbiBmLlxuICogQHJldHVybiB7IU9iamVjdDxLLFI+fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgcmVzdWx0cyBmcm9tIGYuXG4gKiBAdGVtcGxhdGUgVCxLLFYsUlxuICovXG5nb29nLm9iamVjdC5tYXAgPSBmdW5jdGlvbihvYmosIGYsIG9wdF9vYmopIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcmVzW2tleV0gPSBmLmNhbGwob3B0X29iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vKipcbiAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBvYmplY3QvbWFwL2hhc2guIElmIGFueVxuICogY2FsbCByZXR1cm5zIHRydWUsIHJldHVybnMgdHJ1ZSAod2l0aG91dCBjaGVja2luZyB0aGUgcmVzdCkuIElmXG4gKiBhbGwgY2FsbHMgcmV0dXJuIGZhbHNlLCByZXR1cm5zIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PEssVj59IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsViw/LE9iamVjdDxLLFY+KTpib29sZWFufSBmIFRoZSBmdW5jdGlvbiB0b1xuICogICAgIGNhbGwgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb25cbiAqICAgICB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIHZhbHVlLCB0aGUga2V5IGFuZCB0aGUgb2JqZWN0KSBhbmQgc2hvdWxkXG4gKiAgICAgcmV0dXJuIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7VD19IG9wdF9vYmogVGhpcyBpcyB1c2VkIGFzIHRoZSAndGhpcycgb2JqZWN0IHdpdGhpbiBmLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHRlc3QuXG4gKiBAdGVtcGxhdGUgVCxLLFZcbiAqL1xuZ29vZy5vYmplY3Quc29tZSA9IGZ1bmN0aW9uKG9iaiwgZiwgb3B0X29iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGYuY2FsbChvcHRfb2JqLCBvYmpba2V5XSwga2V5LCBvYmopKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhbiBvYmplY3QvbWFwL2hhc2guIElmXG4gKiBhbGwgY2FsbHMgcmV0dXJuIHRydWUsIHJldHVybnMgdHJ1ZS4gSWYgYW55IGNhbGwgcmV0dXJucyBmYWxzZSwgcmV0dXJuc1xuICogZmFsc2UgYXQgdGhpcyBwb2ludCBhbmQgZG9lcyBub3QgY29udGludWUgdG8gY2hlY2sgdGhlIHJlbWFpbmluZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VCxWLD8sT2JqZWN0PEssVj4pOmJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uIHRvXG4gKiAgICAgY2FsbCBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvblxuICogICAgIHRha2VzIDMgYXJndW1lbnRzICh0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoZSBvYmplY3QpIGFuZCBzaG91bGRcbiAqICAgICByZXR1cm4gYSBib29sZWFuLlxuICogQHBhcmFtIHtUPX0gb3B0X29iaiBUaGlzIGlzIHVzZWQgYXMgdGhlICd0aGlzJyBvYmplY3Qgd2l0aGluIGYuXG4gKiBAcmV0dXJuIHtib29sZWFufSBmYWxzZSBpZiBhbnkgZWxlbWVudCBmYWlscyB0aGUgdGVzdC5cbiAqIEB0ZW1wbGF0ZSBULEssVlxuICovXG5nb29nLm9iamVjdC5ldmVyeSA9IGZ1bmN0aW9uKG9iaiwgZiwgb3B0X29iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFmLmNhbGwob3B0X29iaiwgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBvYmplY3QgbWFwLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlXG4gKiAgICAgcGFpcnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBvYmplY3QgbWFwLlxuICovXG5nb29nLm9iamVjdC5nZXRDb3VudCA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBKUzEuNSBoYXMgX19jb3VudF9fIGJ1dCBpdCBoYXMgYmVlbiBkZXByZWNhdGVkIHNvIGl0IHJhaXNlcyBhIHdhcm5pbmcuLi5cbiAgLy8gaW4gb3RoZXIgd29yZHMgZG8gbm90IHVzZS4gQWxzbyBfX2NvdW50X18gb25seSBpbmNsdWRlcyB0aGUgZmllbGRzIG9uIHRoZVxuICAvLyBhY3R1YWwgb2JqZWN0IGFuZCBub3QgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgdmFyIHJ2ID0gMDtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHJ2Kys7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgb25lIGtleSBmcm9tIHRoZSBvYmplY3QgbWFwLCBpZiBhbnkgZXhpc3RzLlxuICogRm9yIG1hcCBsaXRlcmFscyB0aGUgcmV0dXJuZWQga2V5IHdpbGwgYmUgdGhlIGZpcnN0IG9uZSBpbiBtb3N0IG9mIHRoZVxuICogYnJvd3NlcnMgKGEga25vdyBleGNlcHRpb24gaXMgS29ucXVlcm9yKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcGljayBhIGtleSBmcm9tLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGtleSBvciB1bmRlZmluZWQgaWYgdGhlIG9iamVjdCBpcyBlbXB0eS5cbiAqL1xuZ29vZy5vYmplY3QuZ2V0QW55S2V5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBvbmUgdmFsdWUgZnJvbSB0aGUgb2JqZWN0IG1hcCwgaWYgYW55IGV4aXN0cy5cbiAqIEZvciBtYXAgbGl0ZXJhbHMgdGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIGZpcnN0IG9uZSBpbiBtb3N0IG9mIHRoZVxuICogYnJvd3NlcnMgKGEga25vdyBleGNlcHRpb24gaXMgS29ucXVlcm9yKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCB0byBwaWNrIGEgdmFsdWUgZnJvbS5cbiAqIEByZXR1cm4ge1Z8dW5kZWZpbmVkfSBUaGUgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmdvb2cub2JqZWN0LmdldEFueVZhbHVlID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3QvaGFzaC9tYXAgY29udGFpbnMgdGhlIGdpdmVuIG9iamVjdCBhcyBhIHZhbHVlLlxuICogQW4gYWxpYXMgZm9yIGdvb2cub2JqZWN0LmNvbnRhaW5zVmFsdWUob2JqLCB2YWwpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PEssVj59IG9iaiBUaGUgb2JqZWN0IGluIHdoaWNoIHRvIGxvb2sgZm9yIHZhbC5cbiAqIEBwYXJhbSB7Vn0gdmFsIFRoZSBvYmplY3QgZm9yIHdoaWNoIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWwgaXMgcHJlc2VudC5cbiAqIEB0ZW1wbGF0ZSBLLFZcbiAqL1xuZ29vZy5vYmplY3QuY29udGFpbnMgPSBmdW5jdGlvbihvYmosIHZhbCkge1xuICByZXR1cm4gZ29vZy5vYmplY3QuY29udGFpbnNWYWx1ZShvYmosIHZhbCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QvbWFwL2hhc2guXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0byBnZXQgdGhlIHZhbHVlcy5cbiAqIEByZXR1cm4geyFBcnJheTxWPn0gVGhlIHZhbHVlcyBpbiB0aGUgb2JqZWN0L21hcC9oYXNoLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5nb29nLm9iamVjdC5nZXRWYWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXNbaSsrXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyBvZiB0aGUgb2JqZWN0L21hcC9oYXNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUga2V5cy5cbiAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBBcnJheSBvZiBwcm9wZXJ0eSBrZXlzLlxuICovXG5nb29nLm9iamVjdC5nZXRLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcmVzW2krK10gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLyoqXG4gKiBHZXQgYSB2YWx1ZSBmcm9tIGFuIG9iamVjdCBtdWx0aXBsZSBsZXZlbHMgZGVlcC4gIFRoaXMgaXMgdXNlZnVsIGZvclxuICogcHVsbGluZyB2YWx1ZXMgZnJvbSBkZWVwbHkgbmVzdGVkIG9iamVjdHMsIHN1Y2ggYXMgSlNPTiByZXNwb25zZXMuXG4gKiBFeGFtcGxlIHVzYWdlOiBnZXRWYWx1ZUJ5S2V5cyhqc29uT2JqLCAnZm9vJywgJ2VudHJpZXMnLCAzKVxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIEFuIG9iamVjdCB0byBnZXQgdGhlIHZhbHVlIGZyb20uICBDYW4gYmUgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xudW1iZXJ8IUFycmF5PG51bWJlcnxzdHJpbmc+KX0gdmFyX2FyZ3MgQSBudW1iZXIgb2Yga2V5c1xuICogICAgIChhcyBzdHJpbmdzLCBvciBudW1iZXJzLCBmb3IgYXJyYXktbGlrZSBvYmplY3RzKS4gIENhbiBhbHNvIGJlXG4gKiAgICAgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIGFycmF5IG9mIGtleXMuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0aW5nIHZhbHVlLiAgSWYsIGF0IGFueSBwb2ludCwgdGhlIHZhbHVlIGZvciBhIGtleVxuICogICAgIGlzIHVuZGVmaW5lZCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKi9cbmdvb2cub2JqZWN0LmdldFZhbHVlQnlLZXlzID0gZnVuY3Rpb24ob2JqLCB2YXJfYXJncykge1xuICB2YXIgaXNBcnJheUxpa2UgPSBnb29nLmlzQXJyYXlMaWtlKHZhcl9hcmdzKTtcbiAgdmFyIGtleXMgPSBpc0FycmF5TGlrZSA/IHZhcl9hcmdzIDogYXJndW1lbnRzO1xuXG4gIC8vIFN0YXJ0IHdpdGggdGhlIDJuZCBwYXJhbWV0ZXIgZm9yIHRoZSB2YXJpYWJsZSBwYXJhbWV0ZXJzIHN5bnRheC5cbiAgZm9yICh2YXIgaSA9IGlzQXJyYXlMaWtlID8gMCA6IDE7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqID0gb2JqW2tleXNbaV1dO1xuICAgIGlmICghZ29vZy5pc0RlZihvYmopKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdC9tYXAvaGFzaCBjb250YWlucyB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBpbiB3aGljaCB0byBsb29rIGZvciBrZXkuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IGZvciB3aGljaCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgSWYgdGhlIG1hcCBjb250YWlucyB0aGUga2V5LlxuICovXG5nb29nLm9iamVjdC5jb250YWluc0tleSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gIHJldHVybiBrZXkgaW4gb2JqO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdC9tYXAvaGFzaCBjb250YWlucyB0aGUgZ2l2ZW4gdmFsdWUuIFRoaXMgaXMgTyhuKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCBpbiB3aGljaCB0byBsb29rIGZvciB2YWwuXG4gKiBAcGFyYW0ge1Z9IHZhbCBUaGUgdmFsdWUgZm9yIHdoaWNoIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBJZiB0aGUgbWFwIGNvbnRhaW5zIHRoZSB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBLLFZcbiAqL1xuZ29vZy5vYmplY3QuY29udGFpbnNWYWx1ZSA9IGZ1bmN0aW9uKG9iaiwgdmFsKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqW2tleV0gPT0gdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIFNlYXJjaGVzIGFuIG9iamVjdCBmb3IgYW4gZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gY29uZGl0aW9uIGFuZFxuICogcmV0dXJucyBpdHMga2V5LlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3QgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsVixzdHJpbmcsT2JqZWN0PEssVj4pOmJvb2xlYW59IGYgVGhlXG4gKiAgICAgIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRha2VzIDMgYXJndW1lbnRzICh0aGUgdmFsdWUsXG4gKiAgICAgdGhlIGtleSBhbmQgdGhlIG9iamVjdCkgYW5kIHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICogQHBhcmFtIHtUPX0gb3B0X3RoaXMgQW4gb3B0aW9uYWwgXCJ0aGlzXCIgY29udGV4dCBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIGtleSBvZiBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgZnVuY3Rpb25cbiAqICAgICByZXR1cm5zIHRydWUgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggZWxlbWVudCBpcyBmb3VuZC5cbiAqIEB0ZW1wbGF0ZSBULEssVlxuICovXG5nb29nLm9iamVjdC5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBmLCBvcHRfdGhpcykge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGYuY2FsbChvcHRfdGhpcywgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblxuLyoqXG4gKiBTZWFyY2hlcyBhbiBvYmplY3QgZm9yIGFuIGVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgdGhlIGdpdmVuIGNvbmRpdGlvbiBhbmRcbiAqIHJldHVybnMgaXRzIHZhbHVlLlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3QgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsVixzdHJpbmcsT2JqZWN0PEssVj4pOmJvb2xlYW59IGYgVGhlIGZ1bmN0aW9uXG4gKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZWxlbWVudC4gVGFrZXMgMyBhcmd1bWVudHMgKHRoZSB2YWx1ZSwgdGhlIGtleVxuICogICAgIGFuZCB0aGUgb2JqZWN0KSBhbmQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4gKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBBbiBvcHRpb25hbCBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtWfSBUaGUgdmFsdWUgb2YgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBvclxuICogICAgIHVuZGVmaW5lZCBpZiBubyBzdWNoIGVsZW1lbnQgaXMgZm91bmQuXG4gKiBAdGVtcGxhdGUgVCxLLFZcbiAqL1xuZ29vZy5vYmplY3QuZmluZFZhbHVlID0gZnVuY3Rpb24ob2JqLCBmLCBvcHRfdGhpcykge1xuICB2YXIga2V5ID0gZ29vZy5vYmplY3QuZmluZEtleShvYmosIGYsIG9wdF90aGlzKTtcbiAgcmV0dXJuIGtleSAmJiBvYmpba2V5XTtcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3QvbWFwL2hhc2ggaXMgZW1wdHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG9iaiBpcyBlbXB0eS5cbiAqL1xuZ29vZy5vYmplY3QuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleSB2YWx1ZSBwYWlycyBmcm9tIHRoZSBvYmplY3QvbWFwL2hhc2guXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5nb29nLm9iamVjdC5jbGVhciA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGRlbGV0ZSBvYmpbaV07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGEga2V5LXZhbHVlIHBhaXIgYmFzZWQgb24gdGhlIGtleS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGtleS5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICovXG5nb29nLm9iamVjdC5yZW1vdmUgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICB2YXIgcnY7XG4gIGlmICgocnYgPSBrZXkgaW4gb2JqKSkge1xuICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcnY7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBvYmplY3QuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGtleSBpc1xuICogYWxyZWFkeSBpbiB1c2UuIFVzZSBzZXQgaWYgeW91IHdhbnQgdG8gY2hhbmdlIGFuIGV4aXN0aW5nIHBhaXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gYWRkIHRoZSBrZXktdmFsdWUgcGFpci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBhZGQuXG4gKiBAcGFyYW0ge1Z9IHZhbCBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5nb29nLm9iamVjdC5hZGQgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoZSBvYmplY3QgYWxyZWFkeSBjb250YWlucyB0aGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICB9XG4gIGdvb2cub2JqZWN0LnNldChvYmosIGtleSwgdmFsKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgZm9yIHdoaWNoIHRvIGdldCB0aGUgdmFsdWUuXG4gKiBAcGFyYW0ge1I9fSBvcHRfdmFsIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaXRlbSBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuXG4gKiAgICAga2V5IChkZWZhdWx0IGlzIHVuZGVmaW5lZCkuXG4gKiBAcmV0dXJuIHtWfFJ8dW5kZWZpbmVkfSBUaGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuXG4gKiBAdGVtcGxhdGUgSyxWLFJcbiAqL1xuZ29vZy5vYmplY3QuZ2V0ID0gZnVuY3Rpb24ob2JqLCBrZXksIG9wdF92YWwpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG9wdF92YWw7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBvYmplY3QvbWFwL2hhc2guXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gYWRkIHRoZSBrZXktdmFsdWUgcGFpci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBhZGQuXG4gKiBAcGFyYW0ge1Z9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmdvb2cub2JqZWN0LnNldCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICBvYmpba2V5XSA9IHZhbHVlO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSBrZXktdmFsdWUgcGFpciB0byB0aGUgb2JqZWN0L21hcC9oYXNoIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PEssVj59IG9iaiBUaGUgb2JqZWN0IHRvIHdoaWNoIHRvIGFkZCB0aGUga2V5LXZhbHVlIHBhaXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gYWRkLlxuICogQHBhcmFtIHtWfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIGlmIHRoZSBrZXkgd2Fzbid0IHByZXNlbnQuXG4gKiBAcmV0dXJuIHtWfSBUaGUgdmFsdWUgb2YgdGhlIGVudHJ5IGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5nb29nLm9iamVjdC5zZXRJZlVuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4ga2V5IGluIG9iaiA/IG9ialtrZXldIDogKG9ialtrZXldID0gdmFsdWUpO1xufTtcblxuXG4vKipcbiAqIFNldHMgYSBrZXkgYW5kIHZhbHVlIHRvIGFuIG9iamVjdCBpZiB0aGUga2V5IGlzIG5vdCBzZXQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gKiB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgdGhlXG4gKiBvYmplY3Qgd2lsbCBub3QgYmUgY2hhbmdlZCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCAodGhlIGZ1bmN0aW9uXG4gKiB3aWxsIGJlIGxhemlseSBldmFsdWF0ZWQgLS0gb25seSBjYWxsZWQgaWYgbmVjZXNzYXJ5KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHVzZSB3aXRoIGEgbWFwIHVzZWQgYSBhcyBhIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdDxLLFY+fSBvYmogVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgdGhlIGtleS12YWx1ZSBwYWlyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGFkZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpWfSBmIFRoZSB2YWx1ZSB0byBhZGQgaWYgdGhlIGtleSB3YXNuJ3QgcHJlc2VudC5cbiAqIEByZXR1cm4ge1Z9IFRoZSB2YWx1ZSBvZiB0aGUgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmdvb2cub2JqZWN0LnNldFdpdGhSZXR1cm5WYWx1ZUlmTm90U2V0ID0gZnVuY3Rpb24ob2JqLCBrZXksIGYpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cblxuICB2YXIgdmFsID0gZigpO1xuICBvYmpba2V5XSA9IHZhbDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gb2JqZWN0cyBmb3IgZXF1YWxpdHkgdXNpbmcgPT09IG9uIHRoZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0PEssVj59IGFcbiAqIEBwYXJhbSB7IU9iamVjdDxLLFY+fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHRlbXBsYXRlIEssVlxuICovXG5nb29nLm9iamVjdC5lcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGZvciAodmFyIGsgaW4gYSkge1xuICAgIGlmICghKGsgaW4gYikgfHwgYVtrXSAhPT0gYltrXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrIGluIGIpIHtcbiAgICBpZiAoIShrIGluIGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERvZXMgYSBmbGF0IGNsb25lIG9mIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqIE9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm4geyFPYmplY3Q8SyxWPn0gQ2xvbmUgb2YgdGhlIGlucHV0IG9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBLLFZcbiAqL1xuZ29vZy5vYmplY3QuY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gV2UgY2Fubm90IHVzZSB0aGUgcHJvdG90eXBlIHRyaWNrIGJlY2F1c2UgYSBsb3Qgb2YgbWV0aG9kcyBkZXBlbmQgb24gd2hlcmVcbiAgLy8gdGhlIGFjdHVhbCBrZXkgaXMgc2V0LlxuXG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHJlc1trZXldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHJlcztcbiAgLy8gV2UgY291bGQgYWxzbyB1c2UgZ29vZy5taXhpbiBidXQgSSB3YW50ZWQgdGhpcyB0byBiZSBpbmRlcGVuZGVudCBmcm9tIHRoYXQuXG59O1xuXG5cbi8qKlxuICogQ2xvbmVzIGEgdmFsdWUuIFRoZSBpbnB1dCBtYXkgYmUgYW4gT2JqZWN0LCBBcnJheSwgb3IgYmFzaWMgdHlwZS4gT2JqZWN0cyBhbmRcbiAqIGFycmF5cyB3aWxsIGJlIGNsb25lZCByZWN1cnNpdmVseS5cbiAqXG4gKiBXQVJOSU5HUzpcbiAqIDxjb2RlPmdvb2cub2JqZWN0LnVuc2FmZUNsb25lPC9jb2RlPiBkb2VzIG5vdCBkZXRlY3QgcmVmZXJlbmNlIGxvb3BzLiBPYmplY3RzXG4gKiB0aGF0IHJlZmVyIHRvIHRoZW1zZWx2ZXMgd2lsbCBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uXG4gKlxuICogPGNvZGU+Z29vZy5vYmplY3QudW5zYWZlQ2xvbmU8L2NvZGU+IGlzIHVuYXdhcmUgb2YgdW5pcXVlIGlkZW50aWZpZXJzLCBhbmRcbiAqIGNvcGllcyBVSURzIGNyZWF0ZWQgYnkgPGNvZGU+Z2V0VWlkPC9jb2RlPiBpbnRvIGNsb25lZCByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm4geyp9IEEgY2xvbmUgb2YgdGhlIGlucHV0IHZhbHVlLlxuICovXG5nb29nLm9iamVjdC51bnNhZmVDbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgdHlwZSA9IGdvb2cudHlwZU9mKG9iaik7XG4gIGlmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2FycmF5Jykge1xuICAgIGlmIChnb29nLmlzRnVuY3Rpb24ob2JqLmNsb25lKSkge1xuICAgICAgcmV0dXJuIG9iai5jbG9uZSgpO1xuICAgIH1cbiAgICB2YXIgY2xvbmUgPSB0eXBlID09ICdhcnJheScgPyBbXSA6IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGNsb25lW2tleV0gPSBnb29nLm9iamVjdC51bnNhZmVDbG9uZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgaW4gd2hpY2ggYWxsIHRoZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIGludGVyY2hhbmdlZFxuICogKGtleXMgYmVjb21lIHZhbHVlcyBhbmQgdmFsdWVzIGJlY29tZSBrZXlzKS4gSWYgbXVsdGlwbGUga2V5cyBtYXAgdG8gdGhlXG4gKiBzYW1lIHZhbHVlLCB0aGUgY2hvc2VuIHRyYW5zcG9zZWQgdmFsdWUgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0cmFuc3Bvc2UuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgdHJhbnNwb3NlZCBvYmplY3QuXG4gKi9cbmdvb2cub2JqZWN0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgdHJhbnNwb3NlZCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdHJhbnNwb3NlZFtvYmpba2V5XV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zcG9zZWQ7XG59O1xuXG5cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBmaWVsZHMgdGhhdCBhcmUgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLm9iamVjdC5QUk9UT1RZUEVfRklFTERTXyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLyoqXG4gKiBFeHRlbmRzIGFuIG9iamVjdCB3aXRoIGFub3RoZXIgb2JqZWN0LlxuICogVGhpcyBvcGVyYXRlcyAnaW4tcGxhY2UnOyBpdCBkb2VzIG5vdCBjcmVhdGUgYSBuZXcgT2JqZWN0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiB2YXIgbyA9IHt9O1xuICogZ29vZy5vYmplY3QuZXh0ZW5kKG8sIHthOiAwLCBiOiAxfSk7XG4gKiBvOyAvLyB7YTogMCwgYjogMX1cbiAqIGdvb2cub2JqZWN0LmV4dGVuZChvLCB7YjogMiwgYzogM30pO1xuICogbzsgLy8ge2E6IDAsIGI6IDIsIGM6IDN9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIG1vZGlmeS4gRXhpc3RpbmcgcHJvcGVydGllcyB3aWxsIGJlXG4gKiAgICAgb3ZlcndyaXR0ZW4gaWYgdGhleSBhcmUgYWxzbyBwcmVzZW50IGluIG9uZSBvZiB0aGUgb2JqZWN0cyBpblxuICogICAgIHtAY29kZSB2YXJfYXJnc30uXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG4gKi9cbmdvb2cub2JqZWN0LmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFyX2FyZ3MpIHtcbiAgdmFyIGtleSwgc291cmNlO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuXG4gICAgLy8gRm9yIElFIHRoZSBmb3ItaW4tbG9vcCBkb2VzIG5vdCBjb250YWluIGFueSBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdFxuICAgIC8vIGVudW1lcmFibGUgb24gdGhlIHByb3RvdHlwZSBvYmplY3QgKGZvciBleGFtcGxlIGlzUHJvdG90eXBlT2YgZnJvbVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUpIGFuZCBpdCB3aWxsIGFsc28gbm90IGluY2x1ZGUgJ3JlcGxhY2UnIG9uIG9iamVjdHMgdGhhdFxuICAgIC8vIGV4dGVuZCBTdHJpbmcgYW5kIGNoYW5nZSAncmVwbGFjZScgKG5vdCB0aGF0IGl0IGlzIGNvbW1vbiBmb3IgYW55b25lIHRvXG4gICAgLy8gZXh0ZW5kIGFueXRoaW5nIGV4Y2VwdCBPYmplY3QpLlxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBnb29nLm9iamVjdC5QUk9UT1RZUEVfRklFTERTXy5sZW5ndGg7IGorKykge1xuICAgICAga2V5ID0gZ29vZy5vYmplY3QuUFJPVE9UWVBFX0ZJRUxEU19bal07XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGJ1aWx0IGZyb20gdGhlIGtleS12YWx1ZSBwYWlycyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGFuZCBpdCBpcyBhbiBhcnJheVxuICogICAgIHRoZW4gdGhpcyBpcyB1c2VkIGFzIHRoZSBhcmd1bWVudHMsICBvdGhlcndpc2UgZXZlbiBhcmd1bWVudHMgYXJlIHVzZWQgYXNcbiAqICAgICB0aGUgcHJvcGVydHkgbmFtZXMgYW5kIG9kZCBhcmd1bWVudHMgYXJlIHVzZWQgYXMgdGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSB1bmV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cyBvciB0aGVyZSBpcyBvbmx5IG9uZVxuICogICAgIG5vbiBhcnJheSBhcmd1bWVudC5cbiAqL1xuZ29vZy5vYmplY3QuY3JlYXRlID0gZnVuY3Rpb24odmFyX2FyZ3MpIHtcbiAgdmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdMZW5ndGggPT0gMSAmJiBnb29nLmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIHJldHVybiBnb29nLm9iamVjdC5jcmVhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzWzBdKTtcbiAgfVxuXG4gIGlmIChhcmdMZW5ndGggJSAyKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1VuZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzJyk7XG4gIH1cblxuICB2YXIgcnYgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdMZW5ndGg7IGkgKz0gMikge1xuICAgIHJ2W2FyZ3VtZW50c1tpXV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICB9XG4gIHJldHVybiBydjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGVyZSB0aGUgcHJvcGVydHkgbmFtZXMgY29tZSBmcm9tIHRoZSBhcmd1bWVudHMgYnV0XG4gKiB0aGUgdmFsdWUgaXMgYWx3YXlzIHNldCB0byB0cnVlXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGFuZCBpdCBpcyBhbiBhcnJheVxuICogICAgIHRoZW4gdGhpcyBpcyB1c2VkIGFzIHRoZSBhcmd1bWVudHMsICBvdGhlcndpc2UgdGhlIGFyZ3VtZW50cyBhcmUgdXNlZFxuICogICAgIGFzIHRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuICovXG5nb29nLm9iamVjdC5jcmVhdGVTZXQgPSBmdW5jdGlvbih2YXJfYXJncykge1xuICB2YXIgYXJnTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGFyZ0xlbmd0aCA9PSAxICYmIGdvb2cuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgcmV0dXJuIGdvb2cub2JqZWN0LmNyZWF0ZVNldC5hcHBseShudWxsLCBhcmd1bWVudHNbMF0pO1xuICB9XG5cbiAgdmFyIHJ2ID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnTGVuZ3RoOyBpKyspIHtcbiAgICBydlthcmd1bWVudHNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcnY7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbW11dGFibGUgdmlldyBvZiB0aGUgdW5kZXJseWluZyBvYmplY3QsIGlmIHRoZSBicm93c2VyXG4gKiBzdXBwb3J0cyBpbW11dGFibGUgb2JqZWN0cy5cbiAqXG4gKiBJbiBkZWZhdWx0IG1vZGUsIHdyaXRlcyB0byB0aGlzIHZpZXcgd2lsbCBmYWlsIHNpbGVudGx5LiBJbiBzdHJpY3QgbW9kZSxcbiAqIHRoZXkgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3Q8SyxWPn0gb2JqIEFuIG9iamVjdC5cbiAqIEByZXR1cm4geyFPYmplY3Q8SyxWPn0gQW4gaW1tdXRhYmxlIHZpZXcgb2YgdGhhdCBvYmplY3QsIG9yIHRoZVxuICogICAgIG9yaWdpbmFsIG9iamVjdCBpZiB0aGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBpbW11dGFibGVzLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5nb29nLm9iamVjdC5jcmVhdGVJbW11dGFibGVWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXN1bHQgPSBvYmo7XG4gIGlmIChPYmplY3QuaXNGcm96ZW4gJiYgIU9iamVjdC5pc0Zyb3plbihvYmopKSB7XG4gICAgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShvYmopO1xuICAgIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIEFuIG9iamVjdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyBhbiBpbW11dGFibGUgdmlldyBvZiB0aGUgb2JqZWN0LlxuICovXG5nb29nLm9iamVjdC5pc0ltbXV0YWJsZVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICEhT2JqZWN0LmlzRnJvemVuICYmIE9iamVjdC5pc0Zyb3plbihvYmopO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2xvc3VyZSB1c2VyIGFnZW50IGRldGVjdGlvbiAoQnJvd3NlcikuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vXCI+VXNlciBhZ2VudCBzdHJpbmdzPC9hPlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcmVuZGVyaW5nIGVuZ2luZSwgcGxhdGZvcm0sIG9yIGRldmljZSBzZWUgdGhlIG90aGVyXG4gKiBzdWItbmFtZXNwYWNlcyBpbiBnb29nLmxhYnMudXNlckFnZW50LCBnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLFxuICogZ29vZy5sYWJzLnVzZXJBZ2VudC5kZXZpY2UgcmVzcGVjdGl2ZWx5LilcbiAqXG4gKiBAYXV0aG9yIG1hcnRvbmVAZ29vZ2xlLmNvbSAoQW5keSBNYXJ0b25lKVxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyJyk7XG5cbmdvb2cucmVxdWlyZSgnZ29vZy5hcnJheScpO1xuZ29vZy5yZXF1aXJlKCdnb29nLmxhYnMudXNlckFnZW50LnV0aWwnKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5vYmplY3QnKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5zdHJpbmcnKTtcblxuXG4vLyBUT0RPKG5uYXplKTogUmVmYWN0b3IgdG8gcmVtb3ZlIGV4Y2Vzc2l2ZSBleGNsdXNpb24gbG9naWMgaW4gbWF0Y2hpbmdcbi8vIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIE9wZXJhLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoT3BlcmFfID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ09wZXJhJykgfHxcbiAgICAgIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnT1BSJyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgSUUuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hJRV8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnVHJpZGVudCcpIHx8XG4gICAgICBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ01TSUUnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBFZGdlLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoRWRnZV8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnRWRnZScpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIEZpcmVmb3guXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hGaXJlZm94XyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdGaXJlZm94Jyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgU2FmYXJpLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoU2FmYXJpXyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdTYWZhcmknKSAmJlxuICAgICAgIShnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hDaHJvbWVfKCkgfHxcbiAgICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoQ29hc3RfKCkgfHxcbiAgICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoT3BlcmFfKCkgfHxcbiAgICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoRWRnZV8oKSB8fFxuICAgICAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNTaWxrKCkgfHxcbiAgICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdBbmRyb2lkJykpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIENvYXN0IChPcGVyYSdzIFdlYmtpdC1iYXNlZFxuICogICAgIGlPUyBicm93c2VyKS5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaENvYXN0XyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdDb2FzdCcpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIGlPUyBXZWJ2aWV3LlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoSW9zV2Vidmlld18gPSBmdW5jdGlvbigpIHtcbiAgLy8gaU9TIFdlYnZpZXcgZG9lcyBub3Qgc2hvdyB1cCBhcyBDaHJvbWUgb3IgU2FmYXJpLiBBbHNvIGNoZWNrIGZvciBPcGVyYSdzXG4gIC8vIFdlYktpdC1iYXNlZCBpT1MgYnJvd3NlciwgQ29hc3QuXG4gIHJldHVybiAoZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdpUGFkJykgfHxcbiAgICAgICAgICBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ2lQaG9uZScpKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaFNhZmFyaV8oKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaENocm9tZV8oKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaENvYXN0XygpICYmXG4gICAgICBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ0FwcGxlV2ViS2l0Jyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgQ2hyb21lLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoQ2hyb21lXyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnQ2hyb21lJykgfHxcbiAgICAgIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnQ3JpT1MnKSkgJiZcbiAgICAgICFnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hPcGVyYV8oKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaEVkZ2VfKCk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgdGhlIEFuZHJvaWQgYnJvd3Nlci5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaEFuZHJvaWRCcm93c2VyXyA9IGZ1bmN0aW9uKCkge1xuICAvLyBBbmRyb2lkIGNhbiBhcHBlYXIgaW4gdGhlIHVzZXIgYWdlbnQgc3RyaW5nIGZvciBDaHJvbWUgb24gQW5kcm9pZC5cbiAgLy8gVGhpcyBpcyBub3QgdGhlIEFuZHJvaWQgc3RhbmRhbG9uZSBicm93c2VyIGlmIGl0IGRvZXMuXG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ0FuZHJvaWQnKSAmJlxuICAgICAgIShnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNDaHJvbWUoKSB8fFxuICAgICAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNGaXJlZm94KCkgfHxcbiAgICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmlzT3BlcmEoKSB8fFxuICAgICAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNTaWxrKCkpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIE9wZXJhLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNPcGVyYSA9IGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaE9wZXJhXztcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIElFLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNJRSA9IGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaElFXztcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIEVkZ2UuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0VkZ2UgPSBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hFZGdlXztcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIEZpcmVmb3guXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0ZpcmVmb3ggPVxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaEZpcmVmb3hfO1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgU2FmYXJpLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNTYWZhcmkgPVxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5tYXRjaFNhZmFyaV87XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBDb2FzdCAoT3BlcmEncyBXZWJraXQtYmFzZWRcbiAqICAgICBpT1MgYnJvd3NlcikuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0NvYXN0ID1cbiAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hDb2FzdF87XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBpT1MgV2Vidmlldy5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmlzSW9zV2VidmlldyA9XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoSW9zV2Vidmlld187XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBDaHJvbWUuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0Nocm9tZSA9XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLm1hdGNoQ2hyb21lXztcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIHRoZSBBbmRyb2lkIGJyb3dzZXIuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0FuZHJvaWRCcm93c2VyID1cbiAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIubWF0Y2hBbmRyb2lkQnJvd3Nlcl87XG5cblxuLyoqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOlxuICogaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vc2lsay9sYXRlc3QvZGV2ZWxvcGVyZ3VpZGUvdXNlci1hZ2VudC5odG1sXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBTaWxrLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNTaWxrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ1NpbGsnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBicm93c2VyIHZlcnNpb24gb3IgZW1wdHkgc3RyaW5nIGlmIHZlcnNpb24gY2Fubm90IGJlXG4gKiAgICAgZGV0ZXJtaW5lZC4gTm90ZSB0aGF0IGZvciBJbnRlcm5ldCBFeHBsb3JlciwgdGhpcyByZXR1cm5zIHRoZSB2ZXJzaW9uIG9mXG4gKiAgICAgdGhlIGJyb3dzZXIsIG5vdCB0aGUgdmVyc2lvbiBvZiB0aGUgcmVuZGVyaW5nIGVuZ2luZS4gKElFIDggaW5cbiAqICAgICBjb21wYXRpYmlsaXR5IG1vZGUgd2lsbCByZXR1cm4gOC4wIHJhdGhlciB0aGFuIDcuMC4gVG8gZGV0ZXJtaW5lIHRoZVxuICogICAgIHJlbmRlcmluZyBlbmdpbmUgdmVyc2lvbiwgbG9vayBhdCBkb2N1bWVudC5kb2N1bWVudE1vZGUgaW5zdGVhZC4gU2VlXG4gKiAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk2OTg4KHY9dnMuODUpLmFzcHggZm9yIG1vcmVcbiAqICAgICBkZXRhaWxzLilcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmdldFZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVzZXJBZ2VudFN0cmluZyA9IGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQoKTtcbiAgLy8gU3BlY2lhbCBjYXNlIElFIHNpbmNlIElFJ3MgdmVyc2lvbiBpcyBpbnNpZGUgdGhlIHBhcmVudGhlc2lzIGFuZFxuICAvLyB3aXRob3V0IHRoZSAnLycuXG4gIGlmIChnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNJRSgpKSB7XG4gICAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5nZXRJRVZlcnNpb25fKHVzZXJBZ2VudFN0cmluZyk7XG4gIH1cblxuICB2YXIgdmVyc2lvblR1cGxlcyA9IGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5leHRyYWN0VmVyc2lvblR1cGxlcyhcbiAgICAgIHVzZXJBZ2VudFN0cmluZyk7XG5cbiAgLy8gQ29uc3RydWN0IGEgbWFwIGZvciBlYXN5IGxvb2t1cC5cbiAgdmFyIHZlcnNpb25NYXAgPSB7fTtcbiAgZ29vZy5hcnJheS5mb3JFYWNoKHZlcnNpb25UdXBsZXMsIGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgLy8gTm90ZSB0aGF0IHRoZSB0dXBsZSBpcyBvZiBsZW5ndGggdGhyZWUsIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhlXG4gICAgLy8gZmlyc3QgdHdvLlxuICAgIHZhciBrZXkgPSB0dXBsZVswXTtcbiAgICB2YXIgdmFsdWUgPSB0dXBsZVsxXTtcbiAgICB2ZXJzaW9uTWFwW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgdmFyIHZlcnNpb25NYXBIYXNLZXkgPSBnb29nLnBhcnRpYWwoZ29vZy5vYmplY3QuY29udGFpbnNLZXksIHZlcnNpb25NYXApO1xuXG4gIC8vIEdpdmVzIHRoZSB2YWx1ZSB3aXRoIHRoZSBmaXJzdCBrZXkgaXQgZmluZHMsIG90aGVyd2lzZSBlbXB0eSBzdHJpbmcuXG4gIGZ1bmN0aW9uIGxvb2tVcFZhbHVlV2l0aEtleXMoa2V5cykge1xuICAgIHZhciBrZXkgPSBnb29nLmFycmF5LmZpbmQoa2V5cywgdmVyc2lvbk1hcEhhc0tleSk7XG4gICAgcmV0dXJuIHZlcnNpb25NYXBba2V5XSB8fCAnJztcbiAgfVxuXG4gIC8vIENoZWNrIE9wZXJhIGJlZm9yZSBDaHJvbWUgc2luY2UgT3BlcmEgMTUrIGhhcyBcIkNocm9tZVwiIGluIHRoZSBzdHJpbmcuXG4gIC8vIFNlZVxuICAvLyBodHRwOi8vbXkub3BlcmEuY29tL09ESU4vYmxvZy8yMDEzLzA3LzE1L29wZXJhLXVzZXItYWdlbnQtc3RyaW5ncy1vcGVyYS0xNS1hbmQtYmV5b25kXG4gIGlmIChnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgLy8gT3BlcmEgMTAgaGFzIFZlcnNpb24vMTAuMCBidXQgT3BlcmEvOS44LCBzbyBsb29rIGZvciBcIlZlcnNpb25cIiBmaXJzdC5cbiAgICAvLyBPcGVyYSB1c2VzICdPUFInIGZvciBtb3JlIHJlY2VudCBVQXMuXG4gICAgcmV0dXJuIGxvb2tVcFZhbHVlV2l0aEtleXMoWydWZXJzaW9uJywgJ09wZXJhJywgJ09QUiddKTtcbiAgfVxuXG4gIC8vIENoZWNrIEVkZ2UgYmVmb3JlIENocm9tZSBzaW5jZSBpdCBoYXMgQ2hyb21lIGluIHRoZSBzdHJpbmcuXG4gIGlmIChnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNFZGdlKCkpIHtcbiAgICByZXR1cm4gbG9va1VwVmFsdWVXaXRoS2V5cyhbJ0VkZ2UnXSk7XG4gIH1cblxuICBpZiAoZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmlzQ2hyb21lKCkpIHtcbiAgICByZXR1cm4gbG9va1VwVmFsdWVXaXRoS2V5cyhbJ0Nocm9tZScsICdDcmlPUyddKTtcbiAgfVxuXG4gIC8vIFVzdWFsbHkgcHJvZHVjdHMgYnJvd3NlciB2ZXJzaW9ucyBhcmUgaW4gdGhlIHRoaXJkIHR1cGxlIGFmdGVyIFwiTW96aWxsYVwiXG4gIC8vIGFuZCB0aGUgZW5naW5lLlxuICB2YXIgdHVwbGUgPSB2ZXJzaW9uVHVwbGVzWzJdO1xuICByZXR1cm4gdHVwbGUgJiYgdHVwbGVbMV0gfHwgJyc7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2ZXJzaW9uIFRoZSB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYnJvd3NlciB2ZXJzaW9uIGlzIGhpZ2hlciBvciB0aGUgc2FtZSBhcyB0aGVcbiAqICAgICBnaXZlbiB2ZXJzaW9uLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNWZXJzaW9uT3JIaWdoZXIgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIHJldHVybiBnb29nLnN0cmluZy5jb21wYXJlVmVyc2lvbnMoZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmdldFZlcnNpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgSUUgdmVyc2lvbi4gTW9yZSBpbmZvcm1hdGlvbjpcbiAqIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9iZzE4MjYyNSh2PXZzLjg1KS5hc3B4I3VhU3RyaW5nXG4gKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4NjkzMDEodj12cy44NSkuYXNweFxuICogaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWUvYXJjaGl2ZS8yMDEwLzAzLzIzL2ludHJvZHVjaW5nLWllOS1zLXVzZXItYWdlbnQtc3RyaW5nLmFzcHhcbiAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOS8wMS8wOS90aGUtaW50ZXJuZXQtZXhwbG9yZXItOC11c2VyLWFnZW50LXN0cmluZy11cGRhdGVkLWVkaXRpb24uYXNweFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnQgdGhlIFVzZXItQWdlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuZ2V0SUVWZXJzaW9uXyA9IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAvLyBJRTExIG1heSBpZGVudGlmeSBpdHNlbGYgYXMgTVNJRSA5LjAgb3IgTVNJRSAxMC4wIGR1ZSB0byBhbiBJRSAxMSB1cGdyYWRlXG4gIC8vIGJ1Zy4gRXhhbXBsZSBVQTpcbiAgLy8gTW96aWxsYS81LjAgKE1TSUUgOS4wOyBXaW5kb3dzIE5UIDYuMTsgV09XNjQ7IFRyaWRlbnQvNy4wOyBydjoxMS4wKVxuICAvLyBsaWtlIEdlY2tvLlxuICAvLyBTZWUgaHR0cDovL3d3dy53aGF0aXNteWJyb3dzZXIuY29tL2RldmVsb3BlcnMvdW5rbm93bi11c2VyLWFnZW50LWZyYWdtZW50cy5cbiAgdmFyIHJ2ID0gL3J2OiAqKFtcXGRcXC5dKikvLmV4ZWModXNlckFnZW50KTtcbiAgaWYgKHJ2ICYmIHJ2WzFdKSB7XG4gICAgcmV0dXJuIHJ2WzFdO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSAnJztcbiAgdmFyIG1zaWUgPSAvTVNJRSArKFtcXGRcXC5dKykvLmV4ZWModXNlckFnZW50KTtcbiAgaWYgKG1zaWUgJiYgbXNpZVsxXSkge1xuICAgIC8vIElFIGluIGNvbXBhdGliaWxpdHkgbW9kZSB1c3VhbGx5IGlkZW50aWZpZXMgaXRzZWxmIGFzIE1TSUUgNy4wOyBpbiB0aGlzXG4gICAgLy8gY2FzZSwgdXNlIHRoZSBUcmlkZW50IHZlcnNpb24gdG8gZGV0ZXJtaW5lIHRoZSB2ZXJzaW9uIG9mIElFLiBGb3IgbW9yZVxuICAgIC8vIGRldGFpbHMsIHNlZSB0aGUgbGlua3MgYWJvdmUuXG4gICAgdmFyIHRyaWRlbnRWZXJzaW9uID0gL1RyaWRlbnRcXC8oXFxkLlxcZCkvLmV4ZWModXNlckFnZW50KTtcbiAgICBpZiAobXNpZVsxXSA9PSAnNy4wJykge1xuICAgICAgaWYgKHRyaWRlbnRWZXJzaW9uICYmIHRyaWRlbnRWZXJzaW9uWzFdKSB7XG4gICAgICAgIHN3aXRjaCAodHJpZGVudFZlcnNpb25bMV0pIHtcbiAgICAgICAgICBjYXNlICc0LjAnOlxuICAgICAgICAgICAgdmVyc2lvbiA9ICc4LjAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnNS4wJzpcbiAgICAgICAgICAgIHZlcnNpb24gPSAnOS4wJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzYuMCc6XG4gICAgICAgICAgICB2ZXJzaW9uID0gJzEwLjAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnNy4wJzpcbiAgICAgICAgICAgIHZlcnNpb24gPSAnMTEuMCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9ICc3LjAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gbXNpZVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZlcnNpb247XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDbG9zdXJlIHVzZXIgYWdlbnQgcGxhdGZvcm0gZGV0ZWN0aW9uLlxuICogQHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL1wiPlVzZXIgYWdlbnQgc3RyaW5nczwvYT5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGJyb3dzZXIgYnJhbmQsIHJlbmRlcmluZyBlbmdpbmUsIG9yIGRldmljZSBzZWUgdGhlXG4gKiBvdGhlciBzdWItbmFtZXNwYWNlcyBpbiBnb29nLmxhYnMudXNlckFnZW50IChicm93c2VyLCBlbmdpbmUsIGFuZCBkZXZpY2VcbiAqIHJlc3BlY3RpdmVseSkuXG4gKlxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybScpO1xuXG5nb29nLnJlcXVpcmUoJ2dvb2cubGFicy51c2VyQWdlbnQudXRpbCcpO1xuZ29vZy5yZXF1aXJlKCdnb29nLnN0cmluZycpO1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGxhdGZvcm0gaXMgQW5kcm9pZC5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0FuZHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnQW5kcm9pZCcpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBsYXRmb3JtIGlzIGlQb2QuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJcG9kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ2lQb2QnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBpUGhvbmUuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJcGhvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnaVBob25lJykgJiZcbiAgICAgICFnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ2lQb2QnKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnaVBhZCcpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBsYXRmb3JtIGlzIGlQYWQuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJcGFkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ2lQYWQnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBpT1MuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJb3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJcGhvbmUoKSB8fFxuICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0lwYWQoKSB8fFxuICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0lwb2QoKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBNYWMuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNNYWNpbnRvc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnTWFjaW50b3NoJyk7XG59O1xuXG5cbi8qKlxuICogTm90ZTogQ2hyb21lT1MgaXMgbm90IGNvbnNpZGVyZWQgdG8gYmUgTGludXggYXMgaXQgZG9lcyBub3QgcmVwb3J0IGl0c2VsZlxuICogYXMgTGludXggaW4gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGxhdGZvcm0gaXMgTGludXguXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNMaW51eCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdMaW51eCcpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBsYXRmb3JtIGlzIFdpbmRvd3MuXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ1dpbmRvd3MnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBDaHJvbWVPUy5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0Nocm9tZU9TID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ0NyT1MnKTtcbn07XG5cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgcGxhdGZvcm0uIFdlIG9ubHkgZGV0ZXJtaW5lIHRoZSB2ZXJzaW9uIGZvciBXaW5kb3dzLFxuICogTWFjLCBhbmQgQ2hyb21lIE9TLiBJdCBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSBvbiBMaW51eC4gRm9yIFdpbmRvd3MsIHdlIG9ubHlcbiAqIGxvb2sgYXQgdGhlIE5UIHZlcnNpb24uIE5vbi1OVC1iYXNlZCB2ZXJzaW9ucyAoZS5nLiA5NSwgOTgsIGV0Yy4pIGFyZSBnaXZlblxuICogdmVyc2lvbiAwLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGxhdGZvcm0gdmVyc2lvbiBvciBlbXB0eSBzdHJpbmcgaWYgdmVyc2lvbiBjYW5ub3QgYmVcbiAqICAgICBkZXRlcm1pbmVkLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmdldFZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVzZXJBZ2VudFN0cmluZyA9IGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQoKTtcbiAgdmFyIHZlcnNpb24gPSAnJywgcmU7XG4gIGlmIChnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmlzV2luZG93cygpKSB7XG4gICAgcmUgPSAvV2luZG93cyAoPzpOVHxQaG9uZSkgKFswLTkuXSspLztcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHVzZXJBZ2VudFN0cmluZyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnNpb24gPSAnMC4wJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0lvcygpKSB7XG4gICAgcmUgPSAvKD86aVBob25lfGlQb2R8aVBhZHxDUFUpXFxzK09TXFxzKyhcXFMrKS87XG4gICAgdmFyIG1hdGNoID0gcmUuZXhlYyh1c2VyQWdlbnRTdHJpbmcpO1xuICAgIC8vIFJlcG9ydCB0aGUgdmVyc2lvbiBhcyB4LnkueiBhbmQgbm90IHhfeV96XG4gICAgdmVyc2lvbiA9IG1hdGNoICYmIG1hdGNoWzFdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgfSBlbHNlIGlmIChnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmlzTWFjaW50b3NoKCkpIHtcbiAgICByZSA9IC9NYWMgT1MgWCAoWzAtOV8uXSspLztcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHVzZXJBZ2VudFN0cmluZyk7XG4gICAgLy8gTm90ZTogc29tZSBvbGQgdmVyc2lvbnMgb2YgQ2FtaW5vIGRvIG5vdCByZXBvcnQgYW4gT1NYIHZlcnNpb24uXG4gICAgLy8gRGVmYXVsdCB0byAxMC5cbiAgICB2ZXJzaW9uID0gbWF0Y2ggPyBtYXRjaFsxXS5yZXBsYWNlKC9fL2csICcuJykgOiAnMTAnO1xuICB9IGVsc2UgaWYgKGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICByZSA9IC9BbmRyb2lkXFxzKyhbXlxcKTtdKykoXFwpfDspLztcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHVzZXJBZ2VudFN0cmluZyk7XG4gICAgdmVyc2lvbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICB9IGVsc2UgaWYgKGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNDaHJvbWVPUygpKSB7XG4gICAgcmUgPSAvKD86Q3JPU1xccysoPzppNjg2fHg4Nl82NClcXHMrKFswLTkuXSspKS87XG4gICAgdmFyIG1hdGNoID0gcmUuZXhlYyh1c2VyQWdlbnRTdHJpbmcpO1xuICAgIHZlcnNpb24gPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdmVyc2lvbiB8fCAnJztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZlcnNpb24gVGhlIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBicm93c2VyIHZlcnNpb24gaXMgaGlnaGVyIG9yIHRoZSBzYW1lIGFzIHRoZVxuICogICAgIGdpdmVuIHZlcnNpb24uXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNWZXJzaW9uT3JIaWdoZXIgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIHJldHVybiBnb29nLnN0cmluZy5jb21wYXJlVmVyc2lvbnMoZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbikgPj0gMDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENsb3N1cmUgdXNlciBhZ2VudCBkZXRlY3Rpb24uXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVXNlcl9hZ2VudFxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYnJvd3NlciBicmFuZCwgcGxhdGZvcm0sIG9yIGRldmljZSBzZWUgdGhlIG90aGVyXG4gKiBzdWItbmFtZXNwYWNlcyBpbiBnb29nLmxhYnMudXNlckFnZW50IChicm93c2VyLCBwbGF0Zm9ybSwgYW5kIGRldmljZSkuXG4gKlxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUnKTtcblxuZ29vZy5yZXF1aXJlKCdnb29nLmFycmF5Jyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cubGFicy51c2VyQWdlbnQudXRpbCcpO1xuZ29vZy5yZXF1aXJlKCdnb29nLnN0cmluZycpO1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyaW5nIGVuZ2luZSBpcyBQcmVzdG8uXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmlzUHJlc3RvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ1ByZXN0bycpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmluZyBlbmdpbmUgaXMgVHJpZGVudC5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNUcmlkZW50ID0gZnVuY3Rpb24oKSB7XG4gIC8vIElFIG9ubHkgc3RhcnRlZCBpbmNsdWRpbmcgdGhlIFRyaWRlbnQgdG9rZW4gaW4gSUU4LlxuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdUcmlkZW50JykgfHxcbiAgICAgIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnTVNJRScpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmluZyBlbmdpbmUgaXMgRWRnZS5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LnV0aWwubWF0Y2hVc2VyQWdlbnQoJ0VkZ2UnKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJpbmcgZW5naW5lIGlzIFdlYktpdC5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNXZWJLaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudElnbm9yZUNhc2UoJ1dlYktpdCcpICYmXG4gICAgICAhZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNFZGdlKCk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyaW5nIGVuZ2luZSBpcyBHZWNrby5cbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNHZWNrbyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLm1hdGNoVXNlckFnZW50KCdHZWNrbycpICYmXG4gICAgICAhZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNXZWJLaXQoKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmlzVHJpZGVudCgpICYmXG4gICAgICAhZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNFZGdlKCk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcmVuZGVyaW5nIGVuZ2luZSdzIHZlcnNpb24gb3IgZW1wdHkgc3RyaW5nIGlmIHZlcnNpb25cbiAqICAgICBjYW4ndCBiZSBkZXRlcm1pbmVkLlxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmVuZ2luZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciB1c2VyQWdlbnRTdHJpbmcgPSBnb29nLmxhYnMudXNlckFnZW50LnV0aWwuZ2V0VXNlckFnZW50KCk7XG4gIGlmICh1c2VyQWdlbnRTdHJpbmcpIHtcbiAgICB2YXIgdHVwbGVzID0gZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsLmV4dHJhY3RWZXJzaW9uVHVwbGVzKFxuICAgICAgICB1c2VyQWdlbnRTdHJpbmcpO1xuXG4gICAgdmFyIGVuZ2luZVR1cGxlID0gZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuZ2V0RW5naW5lVHVwbGVfKHR1cGxlcyk7XG4gICAgaWYgKGVuZ2luZVR1cGxlKSB7XG4gICAgICAvLyBJbiBHZWNrbywgdGhlIHZlcnNpb24gc3RyaW5nIGlzIGVpdGhlciBpbiB0aGUgYnJvd3NlciBpbmZvIG9yIHRoZVxuICAgICAgLy8gRmlyZWZveCB2ZXJzaW9uLiAgU2VlIEdlY2tvIHVzZXIgYWdlbnQgc3RyaW5nIHJlZmVyZW5jZTpcbiAgICAgIC8vIGh0dHA6Ly9nb28uZ2wvbVVMcWFcbiAgICAgIGlmIChlbmdpbmVUdXBsZVswXSA9PSAnR2Vja28nKSB7XG4gICAgICAgIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LmVuZ2luZS5nZXRWZXJzaW9uRm9yS2V5XyhcbiAgICAgICAgICAgIHR1cGxlcywgJ0ZpcmVmb3gnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZ2luZVR1cGxlWzFdO1xuICAgIH1cblxuICAgIC8vIE1TSUUgaGFzIG9ubHkgb25lIHZlcnNpb24gaWRlbnRpZmllciwgYW5kIHRoZSBUcmlkZW50IHZlcnNpb24gaXNcbiAgICAvLyBzcGVjaWZpZWQgaW4gdGhlIHBhcmVudGhldGljYWwuIElFIEVkZ2UgaXMgY292ZXJlZCBpbiB0aGUgZW5naW5lIHR1cGxlXG4gICAgLy8gZGV0ZWN0aW9uLlxuICAgIHZhciBicm93c2VyVHVwbGUgPSB0dXBsZXNbMF07XG4gICAgdmFyIGluZm87XG4gICAgaWYgKGJyb3dzZXJUdXBsZSAmJiAoaW5mbyA9IGJyb3dzZXJUdXBsZVsyXSkpIHtcbiAgICAgIHZhciBtYXRjaCA9IC9UcmlkZW50XFwvKFteXFxzO10rKS8uZXhlYyhpbmZvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheTwhQXJyYXk8c3RyaW5nPj59IHR1cGxlcyBFeHRyYWN0ZWQgdmVyc2lvbiB0dXBsZXMuXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFRoZSBlbmdpbmUgdHVwbGUgb3IgdW5kZWZpbmVkIGlmIG5vdFxuICogICAgIGZvdW5kLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuZ2V0RW5naW5lVHVwbGVfID0gZnVuY3Rpb24odHVwbGVzKSB7XG4gIGlmICghZ29vZy5sYWJzLnVzZXJBZ2VudC5lbmdpbmUuaXNFZGdlKCkpIHtcbiAgICByZXR1cm4gdHVwbGVzWzFdO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHVwbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gdHVwbGVzW2ldO1xuICAgIGlmICh0dXBsZVswXSA9PSAnRWRnZScpIHtcbiAgICAgIHJldHVybiB0dXBsZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZlcnNpb24gVGhlIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJpbmcgZW5naW5lIHZlcnNpb24gaXMgaGlnaGVyIG9yIHRoZSBzYW1lXG4gKiAgICAgYXMgdGhlIGdpdmVuIHZlcnNpb24uXG4gKi9cbmdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmlzVmVyc2lvbk9ySGlnaGVyID0gZnVuY3Rpb24odmVyc2lvbikge1xuICByZXR1cm4gZ29vZy5zdHJpbmcuY29tcGFyZVZlcnNpb25zKGdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmdldFZlcnNpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5PCFBcnJheTxzdHJpbmc+Pn0gdHVwbGVzIFZlcnNpb24gdHVwbGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGxvb2sgZm9yLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcgb2YgdGhlIGdpdmVuIGtleSwgaWYgcHJlc2VudC5cbiAqICAgICBPdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmxhYnMudXNlckFnZW50LmVuZ2luZS5nZXRWZXJzaW9uRm9yS2V5XyA9IGZ1bmN0aW9uKHR1cGxlcywga2V5KSB7XG4gIC8vIFRPRE8obm5hemUpOiBNb3ZlIHRvIHV0aWwgaWYgdXNlZnVsIGVsc2V3aGVyZS5cblxuICB2YXIgcGFpciA9IGdvb2cuYXJyYXkuZmluZCh0dXBsZXMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICByZXR1cm4ga2V5ID09IHBhaXJbMF07XG4gIH0pO1xuXG4gIHJldHVybiBwYWlyICYmIHBhaXJbMV0gfHwgJyc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMDYgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZW5kZXJpbmcgZW5naW5lIGRldGVjdGlvbi5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS9cIj5Vc2VyIGFnZW50IHN0cmluZ3M8L2E+XG4gKiBGb3IgaW5mb3JtYXRpb24gb24gdGhlIGJyb3dzZXIgYnJhbmQgKHN1Y2ggYXMgU2FmYXJpIHZlcnN1cyBDaHJvbWUpLCBzZWVcbiAqIGdvb2cudXNlckFnZW50LnByb2R1Y3QuXG4gKiBAYXV0aG9yIGFydkBnb29nbGUuY29tIChFcmlrIEFydmlkc3NvbilcbiAqIEBzZWUgLi4vZGVtb3MvdXNlcmFnZW50Lmh0bWxcbiAqL1xuXG5nb29nLnByb3ZpZGUoJ2dvb2cudXNlckFnZW50Jyk7XG5cbmdvb2cucmVxdWlyZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cubGFicy51c2VyQWdlbnQuZW5naW5lJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0nKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC51dGlsJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuc3RyaW5nJyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHdlIGtub3cgYXQgY29tcGlsZS10aW1lIHRoYXQgdGhlIGJyb3dzZXIgaXMgSUUuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfSUUnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHdlIGtub3cgYXQgY29tcGlsZS10aW1lIHRoYXQgdGhlIGJyb3dzZXIgaXMgRURHRS5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LkFTU1VNRV9FREdFJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB3ZSBrbm93IGF0IGNvbXBpbGUtdGltZSB0aGF0IHRoZSBicm93c2VyIGlzIEdFQ0tPLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy51c2VyQWdlbnQuQVNTVU1FX0dFQ0tPJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB3ZSBrbm93IGF0IGNvbXBpbGUtdGltZSB0aGF0IHRoZSBicm93c2VyIGlzIFdFQktJVC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LkFTU1VNRV9XRUJLSVQnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHdlIGtub3cgYXQgY29tcGlsZS10aW1lIHRoYXQgdGhlIGJyb3dzZXIgaXMgYVxuICogICAgIG1vYmlsZSBkZXZpY2UgcnVubmluZyBXZWJLaXQgZS5nLiBpUGhvbmUgb3IgQW5kcm9pZC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LkFTU1VNRV9NT0JJTEVfV0VCS0lUJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB3ZSBrbm93IGF0IGNvbXBpbGUtdGltZSB0aGF0IHRoZSBicm93c2VyIGlzIE9QRVJBLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy51c2VyQWdlbnQuQVNTVU1FX09QRVJBJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGVcbiAqICAgICB7QGNvZGUgZ29vZy51c2VyQWdlbnQuaXNWZXJzaW9uT3JIaWdoZXJ9XG4gKiAgICAgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBmb3IgYW55IHZlcnNpb24uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfQU5ZX1ZFUlNJT04nLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHdlIGtub3cgdGhlIGJyb3dzZXIgZW5naW5lIGF0IGNvbXBpbGUtdGltZS5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuQlJPV1NFUl9LTk9XTl8gPVxuICAgIGdvb2cudXNlckFnZW50LkFTU1VNRV9JRSB8fFxuICAgIGdvb2cudXNlckFnZW50LkFTU1VNRV9FREdFIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX0dFQ0tPIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX01PQklMRV9XRUJLSVQgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfV0VCS0lUIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX09QRVJBO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdXNlckFnZW50IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1c2VyQWdlbnQgc3RyaW5nLlxuICovXG5nb29nLnVzZXJBZ2VudC5nZXRVc2VyQWdlbnRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5nZXRVc2VyQWdlbnQoKTtcbn07XG5cblxuLyoqXG4gKiBUT0RPKG5uYXplKTogQ2hhbmdlIHR5cGUgdG8gXCJOYXZpZ2F0b3JcIiBhbmQgdXBkYXRlIGNvbXBpbGF0aW9uIHRhcmdldHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuYXRpdmUgbmF2aWdhdG9yIG9iamVjdC5cbiAqL1xuZ29vZy51c2VyQWdlbnQuZ2V0TmF2aWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIE5lZWQgYSBsb2NhbCBuYXZpZ2F0b3IgcmVmZXJlbmNlIGluc3RlYWQgb2YgdXNpbmcgdGhlIGdsb2JhbCBvbmUsXG4gIC8vIHRvIGF2b2lkIHRoZSByYXJlIGNhc2Ugd2hlcmUgdGhleSByZWZlcmVuY2UgZGlmZmVyZW50IG9iamVjdHMuXG4gIC8vIChpbiBhIFdvcmtlclBvb2wsIGZvciBleGFtcGxlKS5cbiAgcmV0dXJuIGdvb2cuZ2xvYmFsWyduYXZpZ2F0b3InXSB8fCBudWxsO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgT3BlcmEuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQuT1BFUkEgPSBnb29nLnVzZXJBZ2VudC5CUk9XU0VSX0tOT1dOXyA/XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX09QRVJBIDpcbiAgICBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNPcGVyYSgpO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5JRSA9IGdvb2cudXNlckFnZW50LkJST1dTRVJfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfSUUgOlxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0lFKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIE1pY3Jvc29mdCBFZGdlLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LkVER0UgPSBnb29nLnVzZXJBZ2VudC5CUk9XU0VSX0tOT1dOXyA/XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX0VER0UgOlxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmlzRWRnZSgpO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBNUyBJbnRlcm5ldCBFeHBsb3JlciBvciBNUyBFZGdlLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LkVER0VfT1JfSUUgPSBnb29nLnVzZXJBZ2VudC5FREdFIHx8IGdvb2cudXNlckFnZW50LklFO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBHZWNrby4gR2Vja28gaXMgdGhlIHJlbmRlcmluZyBlbmdpbmUgdXNlZCBieVxuICogTW96aWxsYSwgRmlyZWZveCwgYW5kIG90aGVycy5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5HRUNLTyA9IGdvb2cudXNlckFnZW50LkJST1dTRVJfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfR0VDS08gOlxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuZW5naW5lLmlzR2Vja28oKTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgV2ViS2l0LiBXZWJLaXQgaXMgdGhlIHJlbmRlcmluZyBlbmdpbmUgdGhhdFxuICogU2FmYXJpLCBBbmRyb2lkIGFuZCBvdGhlcnMgdXNlLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LldFQktJVCA9IGdvb2cudXNlckFnZW50LkJST1dTRVJfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfV0VCS0lUIHx8IGdvb2cudXNlckFnZW50LkFTU1VNRV9NT0JJTEVfV0VCS0lUIDpcbiAgICBnb29nLmxhYnMudXNlckFnZW50LmVuZ2luZS5pc1dlYktpdCgpO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBydW5uaW5nIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9naWMgY2FuIGJlIHRlc3RlZC5cbiAqXG4gKiBUT0RPKG5uYXplKTogSW52ZXN0aWdhdGUgc3dhcHBpbmcgaW4gZ29vZy5sYWJzLnVzZXJBZ2VudC5kZXZpY2UuaXNNb2JpbGUoKS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24gYSBtb2JpbGUgZGV2aWNlLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuaXNNb2JpbGVfID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLnVzZXJBZ2VudC5XRUJLSVQgJiZcbiAgICAgICAgIGdvb2cubGFicy51c2VyQWdlbnQudXRpbC5tYXRjaFVzZXJBZ2VudCgnTW9iaWxlJyk7XG59O1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBydW5uaW5nIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBUT0RPKG5uYXplKTogQ29uc2lkZXIgZGVwcmVjYXRpbmcgTU9CSUxFIHdoZW4gbGFicy51c2VyQWdlbnRcbiAqICAgaXMgcHJvbW90ZWQgYXMgdGhlIGdlY2tvL3dlYmtpdCBsb2dpYyBpcyBsaWtlbHkgaW5hY2N1cmF0ZS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQuTU9CSUxFID0gZ29vZy51c2VyQWdlbnQuQVNTVU1FX01PQklMRV9XRUJLSVQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2cudXNlckFnZW50LmlzTW9iaWxlXygpO1xuXG5cbi8qKlxuICogVXNlZCB3aGlsZSB0cmFuc2l0aW9uaW5nIGNvZGUgdG8gdXNlIFdFQktJVCBpbnN0ZWFkLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGdvb2cudXNlckFnZW50LnByb2R1Y3QuU0FGQVJJfSBpbnN0ZWFkLlxuICogVE9ETyhuaWNrc2FudG9zKTogRGVsZXRlIHRoaXMgZnJvbSBnb29nLnVzZXJBZ2VudC5cbiAqL1xuZ29vZy51c2VyQWdlbnQuU0FGQVJJID0gZ29vZy51c2VyQWdlbnQuV0VCS0lUO1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGxhdGZvcm0gKG9wZXJhdGluZyBzeXN0ZW0pIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmdcbiAqICAgICBvbi4gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmcgYmVjYXVzZSBuYXZpZ2F0b3IucGxhdGZvcm0gbWF5IG5vdCBiZSBkZWZpbmVkXG4gKiAgICAgKG9uIFJoaW5vLCBmb3IgZXhhbXBsZSkuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnVzZXJBZ2VudC5kZXRlcm1pbmVQbGF0Zm9ybV8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5hdmlnYXRvciA9IGdvb2cudXNlckFnZW50LmdldE5hdmlnYXRvcigpO1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5wbGF0Zm9ybSB8fCAnJztcbn07XG5cblxuLyoqXG4gKiBUaGUgcGxhdGZvcm0gKG9wZXJhdGluZyBzeXN0ZW0pIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24uIERlZmF1bHQgdG9cbiAqIGVtcHR5IHN0cmluZyBiZWNhdXNlIG5hdmlnYXRvci5wbGF0Zm9ybSBtYXkgbm90IGJlIGRlZmluZWQgKG9uIFJoaW5vLCBmb3JcbiAqIGV4YW1wbGUpLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZ29vZy51c2VyQWdlbnQuUExBVEZPUk0gPSBnb29nLnVzZXJBZ2VudC5kZXRlcm1pbmVQbGF0Zm9ybV8oKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhIE1hY2ludG9zaCBvcGVyYXRpbmdcbiAqICAgICBzeXN0ZW0uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfTUFDJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBydW5uaW5nIG9uIGEgV2luZG93cyBvcGVyYXRpbmdcbiAqICAgICBzeXN0ZW0uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfV0lORE9XUycsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhIExpbnV4IG9wZXJhdGluZ1xuICogICAgIHN5c3RlbS5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LkFTU1VNRV9MSU5VWCcsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhIFgxMSB3aW5kb3dpbmdcbiAqICAgICBzeXN0ZW0uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfWDExJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBydW5uaW5nIG9uIEFuZHJvaWQuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfQU5EUk9JRCcsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhbiBpUGhvbmUuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfSVBIT05FJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBydW5uaW5nIG9uIGFuIGlQYWQuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5BU1NVTUVfSVBBRCcsIGZhbHNlKTtcblxuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuUExBVEZPUk1fS05PV05fID1cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfTUFDIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX1dJTkRPV1MgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfTElOVVggfHxcbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfWDExIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX0FORFJPSUQgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfSVBIT05FIHx8XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX0lQQUQ7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24gYSBNYWNpbnRvc2ggb3BlcmF0aW5nIHN5c3RlbS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5NQUMgPSBnb29nLnVzZXJBZ2VudC5QTEFURk9STV9LTk9XTl8gP1xuICAgIGdvb2cudXNlckFnZW50LkFTU1VNRV9NQUMgOiBnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmlzTWFjaW50b3NoKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24gYSBXaW5kb3dzIG9wZXJhdGluZyBzeXN0ZW0uXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQuV0lORE9XUyA9IGdvb2cudXNlckFnZW50LlBMQVRGT1JNX0tOT1dOXyA/XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX1dJTkRPV1MgOlxuICAgIGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNXaW5kb3dzKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIExpbnV4IHBlciB0aGUgbGVnYWN5IGJlaGF2aW9yIG9mXG4gKiBnb29nLnVzZXJBZ2VudC5MSU5VWCwgd2hpY2ggY29uc2lkZXJlZCBDaHJvbWVPUyB0byBhbHNvIGJlXG4gKiBMaW51eC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnVzZXJBZ2VudC5pc0xlZ2FjeUxpbnV4XyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0xpbnV4KCkgfHxcbiAgICAgIGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNDaHJvbWVPUygpO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhIExpbnV4IG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogTm90ZSB0aGF0IGdvb2cudXNlckFnZW50LkxJTlVYIGNvbnNpZGVycyBDaHJvbWVPUyB0byBiZSBMaW51eCxcbiAqIHdoaWxlIGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0gY29uc2lkZXJzIENocm9tZU9TIGFuZFxuICogTGludXggdG8gYmUgZGlmZmVyZW50IE9TZXMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LkxJTlVYID0gZ29vZy51c2VyQWdlbnQuUExBVEZPUk1fS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfTElOVVggOlxuICAgIGdvb2cudXNlckFnZW50LmlzTGVnYWN5TGludXhfKCk7XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIGFuIFgxMSB3aW5kb3dpbmcgc3lzdGVtLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuaXNYMTFfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuYXZpZ2F0b3IgPSBnb29nLnVzZXJBZ2VudC5nZXROYXZpZ2F0b3IoKTtcbiAgcmV0dXJuICEhbmF2aWdhdG9yICYmXG4gICAgICBnb29nLnN0cmluZy5jb250YWlucyhuYXZpZ2F0b3JbJ2FwcFZlcnNpb24nXSB8fCAnJywgJ1gxMScpO1xufTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhIFgxMSB3aW5kb3dpbmcgc3lzdGVtLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LlgxMSA9IGdvb2cudXNlckFnZW50LlBMQVRGT1JNX0tOT1dOXyA/XG4gICAgZ29vZy51c2VyQWdlbnQuQVNTVU1FX1gxMSA6XG4gICAgZ29vZy51c2VyQWdlbnQuaXNYMTFfKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24gQW5kcm9pZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5BTkRST0lEID0gZ29vZy51c2VyQWdlbnQuUExBVEZPUk1fS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfQU5EUk9JRCA6XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0FuZHJvaWQoKTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgaXMgcnVubmluZyBvbiBhbiBpUGhvbmUuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQuSVBIT05FID0gZ29vZy51c2VyQWdlbnQuUExBVEZPUk1fS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfSVBIT05FIDpcbiAgICBnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmlzSXBob25lKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IGlzIHJ1bm5pbmcgb24gYW4gaVBhZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5JUEFEID0gZ29vZy51c2VyQWdlbnQuUExBVEZPUk1fS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfSVBBRCA6XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0lwYWQoKTtcblxuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBudW1iZXIgb2YgdGhlIHVzZXJcbiAqICAgICBhZ2VudC5cbiAqIEFzc3VtZXMgdXNlciBhZ2VudCBpcyBvcGVyYS5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cudXNlckFnZW50Lm9wZXJhVmVyc2lvbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZlcnNpb24gPSBnb29nLmdsb2JhbC5vcGVyYS52ZXJzaW9uO1xuICB0cnkge1xuICAgIHJldHVybiB2ZXJzaW9uKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBudW1iZXIgb2YgdGhlIHVzZXJcbiAqICAgICBhZ2VudC5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cudXNlckFnZW50LmRldGVybWluZVZlcnNpb25fID0gZnVuY3Rpb24oKSB7XG4gIC8vIEFsbCBicm93c2VycyBoYXZlIGRpZmZlcmVudCB3YXlzIHRvIGRldGVjdCB0aGUgdmVyc2lvbiBhbmQgdGhleSBhbGwgaGF2ZVxuICAvLyBkaWZmZXJlbnQgbmFtaW5nIHNjaGVtZXMuXG5cbiAgaWYgKGdvb2cudXNlckFnZW50Lk9QRVJBICYmIGdvb2cuZ2xvYmFsWydvcGVyYSddKSB7XG4gICAgcmV0dXJuIGdvb2cudXNlckFnZW50Lm9wZXJhVmVyc2lvbl8oKTtcbiAgfVxuXG4gIC8vIHZlcnNpb24gaXMgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIgYmVjYXVzZSBpdCBtYXkgY29udGFpbiAnYicsICdhJyxcbiAgLy8gYW5kIHNvIG9uLlxuICB2YXIgdmVyc2lvbiA9ICcnO1xuICB2YXIgYXJyID0gZ29vZy51c2VyQWdlbnQuZ2V0VmVyc2lvblJlZ2V4UmVzdWx0XygpO1xuICBpZiAoYXJyKSB7XG4gICAgdmVyc2lvbiA9IGFyciA/IGFyclsxXSA6ICcnO1xuICB9XG5cbiAgaWYgKGdvb2cudXNlckFnZW50LklFKSB7XG4gICAgLy8gSUU5IGNhbiBiZSBpbiBkb2N1bWVudCBtb2RlIDkgYnV0IGJlIHJlcG9ydGluZyBhbiBpbmNvbnNpc3RlbnQgdXNlciBhZ2VudFxuICAgIC8vIHZlcnNpb24uICBJZiBpdCBpcyBpZGVudGlmeWluZyBhcyBhIHZlcnNpb24gbG93ZXIgdGhhbiA5IHdlIHRha2UgdGhlXG4gICAgLy8gZG9jdW1lbnRNb2RlIGFzIHRoZSB2ZXJzaW9uIGluc3RlYWQuICBJRTggaGFzIHNpbWlsYXIgYmVoYXZpb3IuXG4gICAgLy8gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IHRoZSBYLVVBLUNvbXBhdGlibGUgaGVhZGVyIHRvIGVuc3VyZSB0aGF0IElFOVxuICAgIC8vIHVzZXMgZG9jdW1lbnRNb2RlIDkuXG4gICAgdmFyIGRvY01vZGUgPSBnb29nLnVzZXJBZ2VudC5nZXREb2N1bWVudE1vZGVfKCk7XG4gICAgaWYgKGRvY01vZGUgPiBwYXJzZUZsb2F0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGRvY01vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH0gVGhlIHZlcnNpb24gcmVnZXggbWF0Y2hlcyBmcm9tIHBhcnNpbmcgdGhlIHVzZXJcbiAqICAgICBhZ2VudCBzdHJpbmcuIFRoZXNlIHJlZ2V4IHN0YXRlbWVudHMgbXVzdCBiZSBleGVjdXRlZCBpbmxpbmUgc28gdGhleSBjYW5cbiAqICAgICBiZSBjb21waWxlZCBvdXQgYnkgdGhlIGNsb3N1cmUgY29tcGlsZXIgd2l0aCB0aGUgcmVzdCBvZiB0aGUgdXNlcmFnZW50XG4gKiAgICAgZGV0ZWN0aW9uIGxvZ2ljIHdoZW4gQVNTVU1FXyogaXMgc3BlY2lmaWVkLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuZ2V0VmVyc2lvblJlZ2V4UmVzdWx0XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ29vZy51c2VyQWdlbnQuZ2V0VXNlckFnZW50U3RyaW5nKCk7XG4gIGlmIChnb29nLnVzZXJBZ2VudC5HRUNLTykge1xuICAgIHJldHVybiAvcnZcXDooW15cXCk7XSspKFxcKXw7KS8uZXhlYyh1c2VyQWdlbnQpO1xuICB9XG4gIGlmIChnb29nLnVzZXJBZ2VudC5FREdFKSB7XG4gICAgcmV0dXJuIC9FZGdlXFwvKFtcXGRcXC5dKykvLmV4ZWModXNlckFnZW50KTtcbiAgfVxuICBpZiAoZ29vZy51c2VyQWdlbnQuSUUpIHtcbiAgICByZXR1cm4gL1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLy5leGVjKHVzZXJBZ2VudCk7XG4gIH1cbiAgaWYgKGdvb2cudXNlckFnZW50LldFQktJVCkge1xuICAgIC8vIFdlYktpdC8xMjUuNFxuICAgIHJldHVybiAvV2ViS2l0XFwvKFxcUyspLy5leGVjKHVzZXJBZ2VudCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBkb2N1bWVudCBtb2RlIChmb3IgdGVzdGluZykuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnVzZXJBZ2VudC5nZXREb2N1bWVudE1vZGVfID0gZnVuY3Rpb24oKSB7XG4gIC8vIE5PVEUodXNlcik6IGdvb2cudXNlckFnZW50IG1heSBiZSB1c2VkIGluIGNvbnRleHQgd2hlcmUgdGhlcmUgaXMgbm8gRE9NLlxuICB2YXIgZG9jID0gZ29vZy5nbG9iYWxbJ2RvY3VtZW50J107XG4gIHJldHVybiBkb2MgPyBkb2NbJ2RvY3VtZW50TW9kZSddIDogdW5kZWZpbmVkO1xufTtcblxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSB1c2VyIGFnZW50LiBUaGlzIGlzIGEgc3RyaW5nIGJlY2F1c2UgaXQgbWlnaHQgY29udGFpblxuICogJ2InIChhcyBpbiBiZXRhKSBhcyB3ZWxsIGFzIG11bHRpcGxlIGRvdHMuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5nb29nLnVzZXJBZ2VudC5WRVJTSU9OID0gZ29vZy51c2VyQWdlbnQuZGV0ZXJtaW5lVmVyc2lvbl8oKTtcblxuXG4vKipcbiAqIENvbXBhcmVzIHR3byB2ZXJzaW9uIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHYxIFZlcnNpb24gb2YgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2MiBWZXJzaW9uIG9mIHNlY29uZCBpdGVtLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gIDEgaWYgZmlyc3QgYXJndW1lbnQgaXMgaGlnaGVyXG4gKiAgICAgICAgICAgICAgICAgICAwIGlmIGFyZ3VtZW50cyBhcmUgZXF1YWxcbiAqICAgICAgICAgICAgICAgICAgLTEgaWYgc2Vjb25kIGFyZ3VtZW50IGlzIGhpZ2hlci5cbiAqIEBkZXByZWNhdGVkIFVzZSBnb29nLnN0cmluZy5jb21wYXJlVmVyc2lvbnMuXG4gKi9cbmdvb2cudXNlckFnZW50LmNvbXBhcmUgPSBmdW5jdGlvbih2MSwgdjIpIHtcbiAgcmV0dXJuIGdvb2cuc3RyaW5nLmNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpO1xufTtcblxuXG4vKipcbiAqIENhY2hlIGZvciB7QGxpbmsgZ29vZy51c2VyQWdlbnQuaXNWZXJzaW9uT3JIaWdoZXJ9LlxuICogQ2FsbHMgdG8gY29tcGFyZVZlcnNpb25zIGFyZSBzdXJwcmlzaW5nbHkgZXhwZW5zaXZlIGFuZCwgYXMgYSBicm93c2VyJ3NcbiAqIHZlcnNpb24gbnVtYmVyIGlzIHVubGlrZWx5IHRvIGNoYW5nZSBkdXJpbmcgYSBzZXNzaW9uLCB3ZSBjYWNoZSB0aGUgcmVzdWx0cy5cbiAqIEBjb25zdFxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQuaXNWZXJzaW9uT3JIaWdoZXJDYWNoZV8gPSB7fTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHVzZXIgYWdlbnQgdmVyc2lvbiBpcyBoaWdoZXIgb3IgdGhlIHNhbWUgYXMgdGhlIGdpdmVuIHZlcnNpb24uXG4gKiBOT1RFOiBXaGVuIGNoZWNraW5nIHRoZSB2ZXJzaW9uIG51bWJlcnMgZm9yIEZpcmVmb3ggYW5kIFNhZmFyaSwgYmUgc3VyZSB0b1xuICogdXNlIHRoZSBlbmdpbmUncyB2ZXJzaW9uLCBub3QgdGhlIGJyb3dzZXIncyB2ZXJzaW9uIG51bWJlci4gIEZvciBleGFtcGxlLFxuICogRmlyZWZveCAzLjAgY29ycmVzcG9uZHMgdG8gR2Vja28gMS45IGFuZCBTYWZhcmkgMy4wIHRvIFdlYmtpdCA1MjIuMTEuXG4gKiBPcGVyYSBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbWF0Y2ggdGhlIHByb2R1Y3QgcmVsZWFzZSBudW1iZXIuPGJyPlxuICogQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWZhcmlfdmVyc2lvbl9oaXN0b3J5XCI+XG4gKiAgICAgV2Via2l0PC9hPlxuICogQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZWNrb19lbmdpbmVcIj5HZWNrbzwvYT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZlcnNpb24gVGhlIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB1c2VyIGFnZW50IHZlcnNpb24gaXMgaGlnaGVyIG9yIHRoZSBzYW1lIGFzXG4gKiAgICAgdGhlIGdpdmVuIHZlcnNpb24uXG4gKi9cbmdvb2cudXNlckFnZW50LmlzVmVyc2lvbk9ySGlnaGVyID0gZnVuY3Rpb24odmVyc2lvbikge1xuICByZXR1cm4gZ29vZy51c2VyQWdlbnQuQVNTVU1FX0FOWV9WRVJTSU9OIHx8XG4gICAgICBnb29nLnVzZXJBZ2VudC5pc1ZlcnNpb25PckhpZ2hlckNhY2hlX1t2ZXJzaW9uXSB8fFxuICAgICAgKGdvb2cudXNlckFnZW50LmlzVmVyc2lvbk9ySGlnaGVyQ2FjaGVfW3ZlcnNpb25dID1cbiAgICAgICAgICBnb29nLnN0cmluZy5jb21wYXJlVmVyc2lvbnMoZ29vZy51c2VyQWdlbnQuVkVSU0lPTiwgdmVyc2lvbikgPj0gMCk7XG59O1xuXG5cbi8qKlxuICogRGVwcmVjYXRlZCBhbGlhcyB0byB7QGNvZGUgZ29vZy51c2VyQWdlbnQuaXNWZXJzaW9uT3JIaWdoZXJ9LlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2ZXJzaW9uIFRoZSB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdXNlciBhZ2VudCB2ZXJzaW9uIGlzIGhpZ2hlciBvciB0aGUgc2FtZSBhc1xuICogICAgIHRoZSBnaXZlbiB2ZXJzaW9uLlxuICogQGRlcHJlY2F0ZWQgVXNlIGdvb2cudXNlckFnZW50LmlzVmVyc2lvbk9ySGlnaGVyKCkuXG4gKi9cbmdvb2cudXNlckFnZW50LmlzVmVyc2lvbiA9IGdvb2cudXNlckFnZW50LmlzVmVyc2lvbk9ySGlnaGVyO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgSUUgZWZmZWN0aXZlIGRvY3VtZW50IG1vZGUgaXMgaGlnaGVyIG9yIHRoZSBzYW1lIGFzIHRoZSBnaXZlblxuICogZG9jdW1lbnQgbW9kZSB2ZXJzaW9uLlxuICogTk9URTogT25seSBmb3IgSUUsIHJldHVybiBmYWxzZSBmb3IgYW5vdGhlciBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb2N1bWVudE1vZGUgVGhlIGRvY3VtZW50IG1vZGUgdmVyc2lvbiB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIElFIGVmZmVjdGl2ZSBkb2N1bWVudCBtb2RlIGlzIGhpZ2hlciBvciB0aGVcbiAqICAgICBzYW1lIGFzIHRoZSBnaXZlbiB2ZXJzaW9uLlxuICovXG5nb29nLnVzZXJBZ2VudC5pc0RvY3VtZW50TW9kZU9ySGlnaGVyID0gZnVuY3Rpb24oZG9jdW1lbnRNb2RlKSB7XG4gIHJldHVybiBnb29nLnVzZXJBZ2VudC5ET0NVTUVOVF9NT0RFID49IGRvY3VtZW50TW9kZTtcbn07XG5cblxuLyoqXG4gKiBEZXByZWNhdGVkIGFsaWFzIHRvIHtAY29kZSBnb29nLnVzZXJBZ2VudC5pc0RvY3VtZW50TW9kZU9ySGlnaGVyfS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIFRoZSB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgSUUgZWZmZWN0aXZlIGRvY3VtZW50IG1vZGUgaXMgaGlnaGVyIG9yIHRoZVxuICogICAgICBzYW1lIGFzIHRoZSBnaXZlbiB2ZXJzaW9uLlxuICogQGRlcHJlY2F0ZWQgVXNlIGdvb2cudXNlckFnZW50LmlzRG9jdW1lbnRNb2RlT3JIaWdoZXIoKS5cbiAqL1xuZ29vZy51c2VyQWdlbnQuaXNEb2N1bWVudE1vZGUgPSBnb29nLnVzZXJBZ2VudC5pc0RvY3VtZW50TW9kZU9ySGlnaGVyO1xuXG5cbi8qKlxuICogRm9yIElFIHZlcnNpb24gPCA3LCBkb2N1bWVudE1vZGUgaXMgdW5kZWZpbmVkLCBzbyBhdHRlbXB0IHRvIHVzZSB0aGVcbiAqIENTUzFDb21wYXQgcHJvcGVydHkgdG8gc2VlIGlmIHdlIGFyZSBpbiBzdGFuZGFyZHMgbW9kZS4gSWYgd2UgYXJlIGluXG4gKiBzdGFuZGFyZHMgbW9kZSwgdHJlYXQgdGhlIGJyb3dzZXIgdmVyc2lvbiBhcyB0aGUgZG9jdW1lbnQgbW9kZS4gT3RoZXJ3aXNlLFxuICogSUUgaXMgZW11bGF0aW5nIHZlcnNpb24gNS5cbiAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICogQGNvbnN0XG4gKi9cbmdvb2cudXNlckFnZW50LkRPQ1VNRU5UX01PREUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBkb2MgPSBnb29nLmdsb2JhbFsnZG9jdW1lbnQnXTtcbiAgdmFyIG1vZGUgPSBnb29nLnVzZXJBZ2VudC5nZXREb2N1bWVudE1vZGVfKCk7XG4gIGlmICghZG9jIHx8ICFnb29nLnVzZXJBZ2VudC5JRSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG1vZGUgfHwgKGRvY1snY29tcGF0TW9kZSddID09ICdDU1MxQ29tcGF0JyA/XG4gICAgICBwYXJzZUludChnb29nLnVzZXJBZ2VudC5WRVJTSU9OLCAxMCkgOiA1KTtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgMjAwOCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERldGVjdHMgdGhlIHNwZWNpZmljIGJyb3dzZXIgYW5kIG5vdCBqdXN0IHRoZSByZW5kZXJpbmcgZW5naW5lLlxuICpcbiAqL1xuXG5nb29nLnByb3ZpZGUoJ2dvb2cudXNlckFnZW50LnByb2R1Y3QnKTtcblxuZ29vZy5yZXF1aXJlKCdnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXInKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybScpO1xuZ29vZy5yZXF1aXJlKCdnb29nLnVzZXJBZ2VudCcpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY29kZSBpcyBydW5uaW5nIG9uIHRoZSBGaXJlZm94IHdlYiBicm93c2VyLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy51c2VyQWdlbnQucHJvZHVjdC5BU1NVTUVfRklSRUZPWCcsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgd2Uga25vdyBhdCBjb21waWxlLXRpbWUgdGhhdCB0aGUgcHJvZHVjdCBpcyBhblxuICogICAgIGlQaG9uZS5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0lQSE9ORScsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgd2Uga25vdyBhdCBjb21waWxlLXRpbWUgdGhhdCB0aGUgcHJvZHVjdCBpcyBhblxuICogICAgIGlQYWQuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9JUEFEJywgZmFsc2UpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB3ZSBrbm93IGF0IGNvbXBpbGUtdGltZSB0aGF0IHRoZSBwcm9kdWN0IGlzIGFuXG4gKiAgICAgQU9TUCBicm93c2VyIG9yIFdlYlZpZXcgaW5zaWRlIGEgcHJlIEtpdEthdCBBbmRyb2lkIHBob25lIG9yIHRhYmxldC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0FORFJPSUQnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gdGhlIENocm9tZSB3ZWIgYnJvd3NlciBvblxuICogYW55IHBsYXRmb3JtIG9yIEFPU1AgYnJvd3NlciBvciBXZWJWaWV3IGluIGEgS2l0S2F0KyBBbmRyb2lkIHBob25lIG9yIHRhYmxldC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0NIUk9NRScsIGZhbHNlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvZGUgaXMgcnVubmluZyBvbiB0aGUgU2FmYXJpIHdlYiBicm93c2VyLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy51c2VyQWdlbnQucHJvZHVjdC5BU1NVTUVfU0FGQVJJJywgZmFsc2UpO1xuXG5cbi8qKlxuICogV2hldGhlciB3ZSBrbm93IHRoZSBwcm9kdWN0IHR5cGUgYXQgY29tcGlsZS10aW1lLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnVzZXJBZ2VudC5wcm9kdWN0LlBST0RVQ1RfS05PV05fID1cbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfSUUgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5BU1NVTUVfT1BFUkEgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9GSVJFRk9YIHx8XG4gICAgZ29vZy51c2VyQWdlbnQucHJvZHVjdC5BU1NVTUVfSVBIT05FIHx8XG4gICAgZ29vZy51c2VyQWdlbnQucHJvZHVjdC5BU1NVTUVfSVBBRCB8fFxuICAgIGdvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0FORFJPSUQgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9DSFJPTUUgfHxcbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9TQUZBUkk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gdGhlIE9wZXJhIHdlYiBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LnByb2R1Y3QuT1BFUkEgPSBnb29nLnVzZXJBZ2VudC5PUEVSQTtcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGNvZGUgaXMgcnVubmluZyBvbiBhbiBJRSB3ZWIgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5wcm9kdWN0LklFID0gZ29vZy51c2VyQWdlbnQuSUU7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gdGhlIEZpcmVmb3ggd2ViIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQucHJvZHVjdC5GSVJFRk9YID0gZ29vZy51c2VyQWdlbnQucHJvZHVjdC5QUk9EVUNUX0tOT1dOXyA/XG4gICAgZ29vZy51c2VyQWdlbnQucHJvZHVjdC5BU1NVTUVfRklSRUZPWCA6XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmlzRmlyZWZveCgpO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBpcyBhbiBpUGhvbmUgb3IgaVBvZCAoYXMgaW4gaVBvZCB0b3VjaCkuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQucHJvZHVjdC5pc0lwaG9uZU9ySXBvZF8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJcGhvbmUoKSB8fFxuICAgICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5wbGF0Zm9ybS5pc0lwb2QoKTtcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gYW4gaVBob25lIG9yIGlQb2QgdG91Y2guXG4gKlxuICogaVBvZCB0b3VjaCBpcyBjb25zaWRlcmVkIGFuIGlQaG9uZSBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQucHJvZHVjdC5JUEhPTkUgPSBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LlBST0RVQ1RfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9JUEhPTkUgOlxuICAgIGdvb2cudXNlckFnZW50LnByb2R1Y3QuaXNJcGhvbmVPcklwb2RfKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gYW4gaVBhZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5wcm9kdWN0LklQQUQgPSBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LlBST0RVQ1RfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9JUEFEIDpcbiAgICBnb29nLmxhYnMudXNlckFnZW50LnBsYXRmb3JtLmlzSXBhZCgpO1xuXG5cbi8qKlxuICogV2hldGhlciB0aGUgY29kZSBpcyBydW5uaW5nIG9uIEFPU1AgYnJvd3NlciBvciBXZWJWaWV3IGluc2lkZVxuICogYSBwcmUgS2l0S2F0IEFuZHJvaWQgcGhvbmUgb3IgdGFibGV0LlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cudXNlckFnZW50LnByb2R1Y3QuQU5EUk9JRCA9IGdvb2cudXNlckFnZW50LnByb2R1Y3QuUFJPRFVDVF9LTk9XTl8gP1xuICAgIGdvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0FORFJPSUQgOlxuICAgIGdvb2cubGFicy51c2VyQWdlbnQuYnJvd3Nlci5pc0FuZHJvaWRCcm93c2VyKCk7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gdGhlIENocm9tZSB3ZWIgYnJvd3NlciBvbiBhbnkgcGxhdGZvcm1cbiAqIG9yIEFPU1AgYnJvd3NlciBvciBXZWJWaWV3IGluIGEgS2l0S2F0KyBBbmRyb2lkIHBob25lIG9yIHRhYmxldC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLnVzZXJBZ2VudC5wcm9kdWN0LkNIUk9NRSA9IGdvb2cudXNlckFnZW50LnByb2R1Y3QuUFJPRFVDVF9LTk9XTl8gP1xuICAgIGdvb2cudXNlckFnZW50LnByb2R1Y3QuQVNTVU1FX0NIUk9NRSA6XG4gICAgZ29vZy5sYWJzLnVzZXJBZ2VudC5icm93c2VyLmlzQ2hyb21lKCk7XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaSBvbiBkZXNrdG9wLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy51c2VyQWdlbnQucHJvZHVjdC5pc1NhZmFyaURlc2t0b3BfID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnb29nLmxhYnMudXNlckFnZW50LmJyb3dzZXIuaXNTYWZhcmkoKSAmJlxuICAgICAgIWdvb2cubGFicy51c2VyQWdlbnQucGxhdGZvcm0uaXNJb3MoKTtcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjb2RlIGlzIHJ1bm5pbmcgb24gdGhlIGRlc2t0b3AgU2FmYXJpIHdlYiBicm93c2VyLlxuICogTm90ZTogdGhlIGxlZ2FjeSBiZWhhdmlvciBoZXJlIGlzIG9ubHkgdHJ1ZSBmb3IgU2FmYXJpIG5vdCBydW5uaW5nXG4gKiBvbiBpT1MuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZ29vZy51c2VyQWdlbnQucHJvZHVjdC5TQUZBUkkgPSBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LlBST0RVQ1RfS05PV05fID9cbiAgICBnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkFTU1VNRV9TQUZBUkkgOlxuICAgIGdvb2cudXNlckFnZW50LnByb2R1Y3QuaXNTYWZhcmlEZXNrdG9wXygpO1xuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcblxuZ29vZy5wcm92aWRlKCd3NjliLmltZy5CaXRNYXRyaXhMaWtlJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgZm9yIHJlYWRhYmxlIGJpdG1hdHJpeC5cbiAgICogQGludGVyZmFjZVxuICAgKi9cbiAgdzY5Yi5pbWcuQml0TWF0cml4TGlrZSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgbWF0cml4LlxuICAgKi9cbiAgdzY5Yi5pbWcuQml0TWF0cml4TGlrZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBtYXRyaXguXG4gICAqL1xuICB3NjliLmltZy5CaXRNYXRyaXhMaWtlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHkgcG9zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBiaXQgYXQgZ2l2ZW4gcG9zaXRpb24uXG4gICAqL1xuICB3NjliLmltZy5CaXRNYXRyaXhMaWtlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIH07XG59KTtcbiIsIi8vIChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5pbWcuUkdCQUJpdE1hdHJpeCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5CaXRNYXRyaXhMaWtlJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBXcmFwcyByZ2JhIGltYWdlIGRhdGEgaW4gYW4gcmVhZC1vbmx5IEJpdE1hdGl4LWxpa2UgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQHBhcmFtIHsoVWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheSl9IGRhdGEgaW1hZ2UgZGF0YSB3aXRoXG4gICAqIHZhbHVlcyAyNTUgPSB3aGl0ZSwgMCA9IGJsYWNrLlxuICAgKiBhcnJheS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHt3NjliLmltZy5CaXRNYXRyaXhMaWtlfVxuICAgKi9cbiAgdzY5Yi5pbWcuUkdCQUJpdE1hdHJpeCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfTtcbiAgdmFyIHBybyA9IHc2OWIuaW1nLlJHQkFCaXRNYXRyaXgucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgbWF0cml4LlxuICAgKi9cbiAgcHJvLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgbWF0cml4LlxuICAgKi9cbiAgcHJvLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCB4IHBvcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgeSBwb3MuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGJpdCBhdCBnaXZlbiBwb3NpdGlvbi5cbiAgICovXG4gIHByby5nZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHBvcyA9IDQgKiAoeSAqIHRoaXMud2lkdGggKyB4KTtcbiAgICBpZiAodGhpcy5kYXRhW3Bvc10gPiAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbn0pO1xuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbmdvb2cucHJvdmlkZSgndzY5Yi5xci5Gb3JtYXRFcnJvcicpO1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLkludmFsaWRDaGFyc2V0RXJyb3InKTtcbmdvb2cucHJvdmlkZSgndzY5Yi5xci5Ob3RGb3VuZEVycm9yJyk7XG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuUmVhZGVyRXJyb3InKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5kZWJ1Zy5FcnJvcicpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21zZyBtZXNzYWdlLlxuICAgKiBAZXh0ZW5kcyB7Z29vZy5kZWJ1Zy5FcnJvcn1cbiAgICovXG4gIHc2OWIucXIuUmVhZGVyRXJyb3IgPSBmdW5jdGlvbihvcHRfbXNnKSB7XG4gICAgZ29vZy5iYXNlKHRoaXMsIG9wdF9tc2cpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKHc2OWIucXIuUmVhZGVyRXJyb3IsIGdvb2cuZGVidWcuRXJyb3IpO1xuXG4gIC8qKlxuICAgKiBUaHJvd24gaWYgZGVjb2RpbmcgZmFpbHMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tc2cgbWVzc2FnZS5cbiAgICogQGV4dGVuZHMge3c2OWIucXIuUmVhZGVyRXJyb3J9XG4gICAqL1xuICB3NjliLnFyLkZvcm1hdEVycm9yID0gZnVuY3Rpb24ob3B0X21zZykge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBvcHRfbXNnKTtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyh3NjliLnFyLkZvcm1hdEVycm9yLCB3NjliLnFyLlJlYWRlckVycm9yKTtcblxuICAvKipcbiAgICogVGhyb3duIGlmIGRldGVjdGlvbiBmYWlscy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21zZyBtZXNzYWdlLlxuICAgKiBAZXh0ZW5kcyB7dzY5Yi5xci5SZWFkZXJFcnJvcn1cbiAgICovXG4gIHc2OWIucXIuTm90Rm91bmRFcnJvciA9IGZ1bmN0aW9uKG9wdF9tc2cpIHtcbiAgICBnb29nLmJhc2UodGhpcywgb3B0X21zZyk7XG4gIH07XG4gIGdvb2cuaW5oZXJpdHModzY5Yi5xci5Ob3RGb3VuZEVycm9yLCB3NjliLnFyLlJlYWRlckVycm9yKTtcblxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbXNnIG1lc3NhZ2UuXG4gICAqIEBleHRlbmRzIHtnb29nLmRlYnVnLkVycm9yfVxuICAgKi9cbiAgdzY5Yi5xci5JbnZhbGlkQ2hhcnNldEVycm9yID0gZnVuY3Rpb24ob3B0X21zZykge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBvcHRfbXNnIHx8ICdJbnZhbGlkQ2hhcnNldCcpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKHc2OWIucXIuSW52YWxpZENoYXJzZXRFcnJvciwgZ29vZy5kZWJ1Zy5FcnJvcik7XG59KTtcbiIsIi8vIChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuUVJJbWFnZScpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBAdHlwZWRlZiB7KFVpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXkpfSAqL1xuICB3NjliLnFyLkltYWdlRGF0YTtcbiAgLyoqXG4gICAqIEltYWdlIGRhdGEgY29udGFpbmVyIHdpdGggd2lkdGgvaGVpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggaW1hZ2Ugd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGltYWdlIGhlaWdodCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5JbWFnZURhdGF9IGRhdGEgZGF0YSBhcnJheS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB3NjliLnFyLlFSSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH07XG4gIHZhciBRUkltYWdlID0gdzY5Yi5xci5RUkltYWdlO1xuICB2YXIgcHJvID0gUVJJbWFnZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB2YWx1ZSBhdCBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3MgKGNvbCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHkgcG9zIChyb3cpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlLlxuICAgKi9cbiAgcHJvLmdldCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLndpZHRoICsgeF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGguXG4gICAqL1xuICBwcm8uZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHQuXG4gICAqL1xuICBwcm8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLkltYWdlRGF0YX0gcmF3IGRhdGEuXG4gICAqL1xuICBwcm8uZ2V0TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaW5kZXguXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gb3B0X3JvdyBwcmUtYWxsb2NhdGVkLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSByb3cuXG4gICAqL1xuICBwcm8uZ2V0Um93ID0gZnVuY3Rpb24oeSwgb3B0X3Jvdykge1xuICAgIHZhciByb3c7XG4gICAgaWYgKG9wdF9yb3cgPT0gbnVsbCB8fCBvcHRfcm93Lmxlbmd0aCA8IHRoaXMud2lkdGgpXG4gICAgICByb3cgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoKTtcbiAgICBlbHNlXG4gICAgICByb3cgPSBvcHRfcm93O1xuICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy53aWR0aDtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreClcbiAgICAgIHJvd1t4XSA9IHRoaXMuZGF0YVtvZmZzZXQgKyB4XTtcbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCBpbmRleCBpbiBkYXRhIGZvciBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3MgKGNvbCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHkgcG9zIChyb3cpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZGV4IGluIGRhdGEuXG4gICAqL1xuICBwcm8uZ2V0SW5kZXggPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGggKiB5ICsgeDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHZhbHVlIGF0IGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCB4IHBvcyAoY29sKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgeSBwb3MgKHJvdykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQuXG4gICAqL1xuICBwcm8uc2V0VmFsdWUgPSBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVt5ICogdGhpcy53aWR0aCArIHhdID0gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBJbWFnZSB3aXRoIG5ldyBlbXB0eSBidWZmZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBpbWFnZSB3aWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBpbWFnZSBoZWlnaHQuXG4gICAqIEByZXR1cm4ge3c2OWIucXIuUVJJbWFnZX0gaW1hZ2Ugd2l0aCBnaXZlbiBzaXplIGFuZCBhIG5ldywgZW1wdHkgYnVmZmVyLlxuICAgKi9cbiAgUVJJbWFnZS5uZXdFbXB0eSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gbmV3IFFSSW1hZ2Uod2lkdGgsIGhlaWdodCxcbiAgICAgIG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcih3aWR0aCAqIGhlaWdodCkpKTtcbiAgfTtcbn0pO1xuXG4iLCIvLyAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuZ29vZy5wcm92aWRlKCd3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlJyk7XG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciB3b3JrZXIgbWVzc2FnZSB0eXBlcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnc2OWIucXIuV29ya2VyTWVzc2FnZVR5cGUgPSB7XG4gIERFQ09ERUQ6ICdzdWNjZXNzJyxcbiAgTk9URk9VTkQ6ICdub3Rmb3VuZCcsXG4gIFBBVFRFUk46ICdwYXR0ZXJuJ1xufTtcblxuZ29vZy5leHBvcnRTeW1ib2woJ3c2OWIucXIuV29ya2VyTWVzc2FnZVR5cGUnLCB3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlKTtcbmdvb2cuZXhwb3J0U3ltYm9sKCd3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlLkRFQ09ERUQnLFxuICB3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlLkRFQ09ERUQpO1xuZ29vZy5leHBvcnRTeW1ib2woJ3c2OWIucXIuV29ya2VyTWVzc2FnZVR5cGUuTk9URk9VTkQnLFxuICB3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlLk5PVEZPVU5EKTtcbiIsIi8vIENvcHlyaWdodCAyMDA3IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSB1dGlsaXR5IGNsYXNzIGZvciByZXByZXNlbnRpbmcgdHdvLWRpbWVuc2lvbmFsIHNpemVzLlxuICogQGF1dGhvciBicmVubmVtYW5AZ29vZ2xlLmNvbSAoU2hhd24gQnJlbm5lbWFuKVxuICovXG5cblxuZ29vZy5wcm92aWRlKCdnb29nLm1hdGguU2l6ZScpO1xuXG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIHNpemVzIGNvbnNpc3Rpbmcgb2YgYSB3aWR0aCBhbmQgaGVpZ2h0LiBVbmRlZmluZWRcbiAqIHdpZHRoIGFuZCBoZWlnaHQgc3VwcG9ydCBpcyBkZXByZWNhdGVkIGFuZCByZXN1bHRzIGluIGNvbXBpbGVyIHdhcm5pbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodC5cbiAqIEBzdHJ1Y3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5nb29nLm1hdGguU2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgLyoqXG4gICAqIFdpZHRoXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgLyoqXG4gICAqIEhlaWdodFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5cbi8qKlxuICogQ29tcGFyZXMgc2l6ZXMgZm9yIGVxdWFsaXR5LlxuICogQHBhcmFtIHtnb29nLm1hdGguU2l6ZX0gYSBBIFNpemUuXG4gKiBAcGFyYW0ge2dvb2cubWF0aC5TaXplfSBiIEEgU2l6ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIHRoZSBzaXplcyBoYXZlIGVxdWFsIHdpZHRocyBhbmQgZXF1YWxcbiAqICAgICBoZWlnaHRzLCBvciBpZiBib3RoIGFyZSBudWxsLlxuICovXG5nb29nLm1hdGguU2l6ZS5lcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhID09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWEgfHwgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGEud2lkdGggPT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PSBiLmhlaWdodDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHshZ29vZy5tYXRoLlNpemV9IEEgbmV3IGNvcHkgb2YgdGhlIFNpemUuXG4gKi9cbmdvb2cubWF0aC5TaXplLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IGdvb2cubWF0aC5TaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cblxuaWYgKGdvb2cuREVCVUcpIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBuaWNlIHN0cmluZyByZXByZXNlbnRpbmcgc2l6ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBJbiB0aGUgZm9ybSAoNTAgeCA3MykuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcoJyArIHRoaXMud2lkdGggKyAnIHggJyArIHRoaXMuaGVpZ2h0ICsgJyknO1xuICB9O1xufVxuXG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbG9uZ2VyIG9mIHRoZSB0d28gZGltZW5zaW9ucyBpbiB0aGUgc2l6ZS5cbiAqL1xuZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLmdldExvbmdlc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaG9ydGVyIG9mIHRoZSB0d28gZGltZW5zaW9ucyBpbiB0aGUgc2l6ZS5cbiAqL1xuZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLmdldFNob3J0ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXJlYSBvZiB0aGUgc2l6ZSAod2lkdGggKiBoZWlnaHQpLlxuICovXG5nb29nLm1hdGguU2l6ZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBlcmltZXRlciBvZiB0aGUgc2l6ZSAod2lkdGggKyBoZWlnaHQpICogMi5cbiAqL1xuZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLnBlcmltZXRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMud2lkdGggKyB0aGlzLmhlaWdodCkgKiAyO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJhdGlvIG9mIHRoZSBzaXplJ3Mgd2lkdGggdG8gaXRzIGhlaWdodC5cbiAqL1xuZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLmFzcGVjdFJhdGlvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2l6ZSBoYXMgemVybyBhcmVhLCBmYWxzZSBpZiBib3RoIGRpbWVuc2lvbnNcbiAqICAgICBhcmUgbm9uLXplcm8gbnVtYmVycy5cbiAqL1xuZ29vZy5tYXRoLlNpemUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLmFyZWEoKTtcbn07XG5cblxuLyoqXG4gKiBDbGFtcHMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcGFyYW1ldGVycyB1cHdhcmQgdG8gaW50ZWdlciB2YWx1ZXMuXG4gKiBAcmV0dXJuIHshZ29vZy5tYXRoLlNpemV9IFRoaXMgc2l6ZSB3aXRoIGNlaWwnZCBjb21wb25lbnRzLlxuICovXG5nb29nLm1hdGguU2l6ZS5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMud2lkdGgpO1xuICB0aGlzLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmhlaWdodCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IWdvb2cubWF0aC5TaXplfSB0YXJnZXQgVGhlIHRhcmdldCBzaXplLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIFNpemUgaXMgdGhlIHNhbWUgc2l6ZSBvciBzbWFsbGVyIHRoYW4gdGhlXG4gKiAgICAgdGFyZ2V0IHNpemUgaW4gYm90aCBkaW1lbnNpb25zLlxuICovXG5nb29nLm1hdGguU2l6ZS5wcm90b3R5cGUuZml0c0luc2lkZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdGhpcy53aWR0aCA8PSB0YXJnZXQud2lkdGggJiYgdGhpcy5oZWlnaHQgPD0gdGFyZ2V0LmhlaWdodDtcbn07XG5cblxuLyoqXG4gKiBDbGFtcHMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcGFyYW1ldGVycyBkb3dud2FyZCB0byBpbnRlZ2VyIHZhbHVlcy5cbiAqIEByZXR1cm4geyFnb29nLm1hdGguU2l6ZX0gVGhpcyBzaXplIHdpdGggZmxvb3JlZCBjb21wb25lbnRzLlxuICovXG5nb29nLm1hdGguU2l6ZS5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53aWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCk7XG4gIHRoaXMuaGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFJvdW5kcyB0aGUgd2lkdGggYW5kIGhlaWdodCBwYXJhbWV0ZXJzIHRvIGludGVnZXIgdmFsdWVzLlxuICogQHJldHVybiB7IWdvb2cubWF0aC5TaXplfSBUaGlzIHNpemUgd2l0aCByb3VuZGVkIGNvbXBvbmVudHMuXG4gKi9cbmdvb2cubWF0aC5TaXplLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoKTtcbiAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogU2NhbGVzIHRoaXMgc2l6ZSBieSB0aGUgZ2l2ZW4gc2NhbGUgZmFjdG9ycy4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNjYWxlZFxuICogYnkge0Bjb2RlIHN4fSBhbmQge0Bjb2RlIG9wdF9zeX0gcmVzcGVjdGl2ZWx5LiAgSWYge0Bjb2RlIG9wdF9zeX0gaXMgbm90XG4gKiBnaXZlbiwgdGhlbiB7QGNvZGUgc3h9IGlzIHVzZWQgZm9yIGJvdGggdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNjYWxlIGZhY3RvciB0byB1c2UgZm9yIHRoZSB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3N5IFRoZSBzY2FsZSBmYWN0b3IgdG8gdXNlIGZvciB0aGUgaGVpZ2h0LlxuICogQHJldHVybiB7IWdvb2cubWF0aC5TaXplfSBUaGlzIFNpemUgb2JqZWN0IGFmdGVyIHNjYWxpbmcuXG4gKi9cbmdvb2cubWF0aC5TaXplLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHN4LCBvcHRfc3kpIHtcbiAgdmFyIHN5ID0gZ29vZy5pc051bWJlcihvcHRfc3kpID8gb3B0X3N5IDogc3g7XG4gIHRoaXMud2lkdGggKj0gc3g7XG4gIHRoaXMuaGVpZ2h0ICo9IHN5O1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBVbmlmb3JtbHkgc2NhbGVzIHRoZSBzaXplIHRvIHBlcmZlY3RseSBjb3ZlciB0aGUgZGltZW5zaW9ucyBvZiBhIGdpdmVuIHNpemUuXG4gKiBJZiB0aGUgc2l6ZSBpcyBhbHJlYWR5IGxhcmdlciB0aGFuIHRoZSB0YXJnZXQsIGl0IHdpbGwgYmUgc2NhbGVkIGRvd24gdG8gdGhlXG4gKiBtaW5pbXVtIHNpemUgYXQgd2hpY2ggaXQgc3RpbGwgY292ZXJzIHRoZSBlbnRpcmUgdGFyZ2V0LiBUaGUgb3JpZ2luYWwgYXNwZWN0XG4gKiByYXRpbyB3aWxsIGJlIHByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBib3RoIFNpemVzIGNvbnRhaW4gc3RyaWN0bHkgcG9zaXRpdmUgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7IWdvb2cubWF0aC5TaXplfSB0YXJnZXQgVGhlIHRhcmdldCBzaXplLlxuICogQHJldHVybiB7IWdvb2cubWF0aC5TaXplfSBUaGlzIFNpemUgb2JqZWN0LCBhZnRlciBvcHRpb25hbCBzY2FsaW5nLlxuICovXG5nb29nLm1hdGguU2l6ZS5wcm90b3R5cGUuc2NhbGVUb0NvdmVyID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHZhciBzID0gdGhpcy5hc3BlY3RSYXRpbygpIDw9IHRhcmdldC5hc3BlY3RSYXRpbygpID9cbiAgICAgIHRhcmdldC53aWR0aCAvIHRoaXMud2lkdGggOlxuICAgICAgdGFyZ2V0LmhlaWdodCAvIHRoaXMuaGVpZ2h0O1xuXG4gIHJldHVybiB0aGlzLnNjYWxlKHMpO1xufTtcblxuXG4vKipcbiAqIFVuaWZvcm1seSBzY2FsZXMgdGhlIHNpemUgdG8gZml0IGluc2lkZSB0aGUgZGltZW5zaW9ucyBvZiBhIGdpdmVuIHNpemUuIFRoZVxuICogb3JpZ2luYWwgYXNwZWN0IHJhdGlvIHdpbGwgYmUgcHJlc2VydmVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGJvdGggU2l6ZXMgY29udGFpbiBzdHJpY3RseSBwb3NpdGl2ZSBkaW1lbnNpb25zLlxuICogQHBhcmFtIHshZ29vZy5tYXRoLlNpemV9IHRhcmdldCBUaGUgdGFyZ2V0IHNpemUuXG4gKiBAcmV0dXJuIHshZ29vZy5tYXRoLlNpemV9IFRoaXMgU2l6ZSBvYmplY3QsIGFmdGVyIG9wdGlvbmFsIHNjYWxpbmcuXG4gKi9cbmdvb2cubWF0aC5TaXplLnByb3RvdHlwZS5zY2FsZVRvRml0ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHZhciBzID0gdGhpcy5hc3BlY3RSYXRpbygpID4gdGFyZ2V0LmFzcGVjdFJhdGlvKCkgP1xuICAgICAgdGFyZ2V0LndpZHRoIC8gdGhpcy53aWR0aCA6XG4gICAgICB0YXJnZXQuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XG5cbiAgcmV0dXJuIHRoaXMuc2NhbGUocyk7XG59O1xuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcblxuZ29vZy5wcm92aWRlKCd3NjliLmltZy5SR0JBSW1hZ2VEYXRhJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5PX0gb3B0X2RhdGEgb3B0aW9uYWwgaW1hZ2UgZGF0YS4gRGVmYXVsdHMgdG8gZW1wdHlcbiAgICogYXJyYXkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5pbWcuUkdCQUltYWdlRGF0YSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdF9kYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gb3B0X2RhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLmltZy5SR0JBSW1hZ2VEYXRhLnByb3RvdHlwZTtcblxuICBwcm8uc2V0ID0gZnVuY3Rpb24oeCwgeSwgcmVkLCBncmVlbiwgYmx1ZSwgb3B0X2FscGhhKSB7XG4gICAgdmFyIHBvcyA9IDQgKiAoeSAqIHRoaXMud2lkdGggKyB4KTtcbiAgICB0aGlzLmRhdGFbcG9zXSA9IHJlZDtcbiAgICB0aGlzLmRhdGFbcG9zICsgMV0gPSBncmVlbjtcbiAgICB0aGlzLmRhdGFbcG9zICsgMl0gPSBibHVlO1xuICAgIHRoaXMuZGF0YVtwb3MgKyAzXSA9IG9wdF9hbHBoYSB8fCAyNTU7XG4gIH07XG5cbiAgcHJvLnNldEdyYXkgPSBmdW5jdGlvbih4LCB5LCBncmF5KSB7XG4gICAgdGhpcy5zZXQoeCwgeSwgZ3JheSwgZ3JheSwgZ3JheSwgMjU1KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggcG9zLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBwb3MuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdIHZhbHVlcy5cbiAgICovXG4gIHByby5nZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHBvcyA9IDQgKiAoeSAqIHRoaXMud2lkdGggKyB4KTtcbiAgICByZXR1cm4gW3RoaXMuZGF0YVtwb3NdLCB0aGlzLmRhdGFbcG9zICsgMV0sXG4gICAgICB0aGlzLmRhdGFbcG9zICsgMl0sIHRoaXMuZGF0YVtwb3MgKyAzXV07XG4gIH07XG59KTtcbiIsIi8vIChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5nb29nLnByb3ZpZGUoJ3c2OWIuaW1nLldlYkdMUGFyYW1zJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cub2JqZWN0Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBIZWxwcyB0byBhcHBseSBwYXJhbWV0ZXJzIHRvIGEgd2ViZ2wgcHJvZ3JhbW0uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9jb25maWcgaW5pdGlhbCBjb25maWcsIHNlZSBzZXQoKS5cbiAgICovXG4gIHc2OWIuaW1nLldlYkdMUGFyYW1zID0gZnVuY3Rpb24ob3B0X2NvbmZpZykge1xuICAgIHRoaXMuZGF0YV8gPSB7fTtcbiAgICBpZiAob3B0X2NvbmZpZylcbiAgICAgIHRoaXMuc2V0KG9wdF9jb25maWcpO1xuICB9O1xuICB2YXIgcHJvID0gdzY5Yi5pbWcuV2ViR0xQYXJhbXMucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt3NjliLmltZy5XZWJHTFBhcmFtc30gcGFyYW1zIG9iamVjdC5cbiAgICovXG4gIHByby5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbXMgPSBuZXcgdzY5Yi5pbWcuV2ViR0xQYXJhbXMoKTtcbiAgICBwYXJhbXMuZGF0YV8gPSBnb29nLm9iamVjdC5jbG9uZSh0aGlzLmRhdGFfKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHBhcmFtZXRlcnMuIEV4YW1wbGU6XG4gICAqIHsnd2lkdGgnOiAxMi40LFxuICAgKiAnZGltZW5zaW9ucyc6IFsxMDI0LjAsIDcxOC4wXVxuICAgKiAnaW1hZ2VJZCc6IFsnaScsIDFdXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBtYXBwaW5nIG9mIG5hbWVzIHRvIGVpdGhlcjpcbiAgICAgKiAgb25lIG9yIG11bHRpcGxlIGZsb2F0IHZhbHVlcyxcbiAgICAgKiBbJ2knLCAyMSwgNDUsIDZdIG9uZSBvciBtdWx0aXBsZSBpbnRlZ2VycyB3aXRoIGEgcHJlY2VlZGluZyAnaScuXG4gICAqIEByZXR1cm4ge3c2OWIuaW1nLldlYkdMUGFyYW1zfSB0aGlzIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHByby5zZXQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBnb29nLm9iamVjdC5mb3JFYWNoKGNvbmZpZywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWVbMF0gPT0gJ2knKVxuICAgICAgICB0aGlzLnNldEludChrZXksIHZhbHVlLnNsaWNlKDEpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5zZXRGbG9hdChrZXksIHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgcGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHBhcmFtIHR5cGUuXG4gICAqIEBwYXJhbSB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbHVlIHRvIHNldC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByby5zZXRJbnRlcm5hbF8gPSBmdW5jdGlvbihuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YV9bbmFtZV0gPSBbdHlwZSwgdmFsdWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBhcyBwYXNzZWQgdG8gc2hhZGVyLlxuICAgKiBAcGFyYW0geyhudW1iZXJ8QXJyYXkuPG51bWJlcj4pfSB2YWx1ZSBpbnRlZ2VyLlxuICAgKiBAcmV0dXJuIHt3NjliLmltZy5XZWJHTFBhcmFtc30gdGhpcyBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwcm8uc2V0SW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoIHx8IDE7XG4gICAgdGhpcy5zZXRJbnRlcm5hbF8obmFtZSwgbGVuICsgJ2knLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGFzIHBhc3NlZCB0byBzaGFkZXIuXG4gICAqIEBwYXJhbSB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbHVlIGZsb2F0LlxuICAgKiBAcmV0dXJuIHt3NjliLmltZy5XZWJHTFBhcmFtc30gdGhpcyBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwcm8uc2V0RmxvYXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggfHwgMTtcbiAgICB0aGlzLnNldEludGVybmFsXyhuYW1lLCBsZW4gKyAnZicsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBwYXJhbWV0ZXIgbmFtZS5cbiAgICogQHJldHVybiB7P251bWJlcn0gdmFsdWUgb3IgbnVsbC5cbiAgICovXG4gIHByby5nZXRWYWx1ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHVwbGUgPSB0aGlzLmRhdGFfW25hbWVdO1xuICAgIGlmICh0dXBsZSlcbiAgICAgIHJldHVybiB0dXBsZVsxXTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQXBwbHkgcGFyYW1ldGVycyB0byBwcm9ncmFtLiBZb3UgbmVlZCB0byBjYWxsIHByb2dyYW0udXNlKCkgYW5kXG4gICAqIHByb2dyYW0uaW5pdENvbW1vbkF0dHJpYnV0ZXMoKSB5b3Vyc2VsZi5cbiAgICogQHBhcmFtIHt3NjliLmltZy5XZWJHTFByb2dyYW19IHByb2dyYW0gd2ViZ2wgcHJvZ3JhbS5cbiAgICovXG4gIHByby5hcHBseSA9IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgICB2YXIgc2V0dGVycyA9IHByb2dyYW0uZ2V0TmFtZWRTZXR0ZXJGdW5jdGlvbnMoKTtcbiAgICBnb29nLm9iamVjdC5mb3JFYWNoKHRoaXMuZGF0YV8sIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB2YXIgdHlwZSA9IHZhbHVlWzBdO1xuICAgICAgdmFyIHZhbHVlQXJncyA9IHZhbHVlWzFdO1xuICAgICAgc2V0dGVyc1t0eXBlXS5hcHBseShwcm9ncmFtLCBbbmFtZV0uY29uY2F0KHZhbHVlQXJncykpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGFwcGx5KCkgYnV0IHRha2VzIGNhcmUgb2YgY2FsbGluZyBwcm9ncmFtLnVzZSgpIGFuZFxuICAgKiBpbml0Q29tbW9uQXR0cmlidHVlcygpXG4gICAqIEBwYXJhbSB7dzY5Yi5pbWcuV2ViR0xQcm9ncmFtfSBwcm9ncmFtIHdlYmdsIHByb2dyYW0uXG4gICAqL1xuICBwcm8udXNlQW5kQXBwbHkgPSBmdW5jdGlvbihwcm9ncmFtKSB7XG4gICAgcHJvZ3JhbS51c2UoKTtcbiAgICBwcm9ncmFtLmluaXRDb21tb25BdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5hcHBseShwcm9ncmFtKTtcbiAgfTtcbn0pO1xuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcblxuZ29vZy5wcm92aWRlKCd3NjliLmltZy5XZWJHTFBpcGVsaW5lJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBIZWxwcyB0byBleGVjdXRlIG11bHRpcGFzcyB3ZWJnbCBwcm9ncmFtbXMgYnkgYXBwbHlpbmcgbXVsdGlwbGUgcHJvZ3JhbXNcbiAgICogYW5kIHBhcmFtZXRlciBzdWNjZXNzaXZlbHkuXG4gICAqIEBwYXJhbSB7dzY5Yi5pbWcuV2ViR0xGaWx0ZXJ9IGZpbHRlciB3ZWJnbCBmaWx0ZXIuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5pbWcuV2ViR0xQaXBlbGluZSA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHRoaXMucGFzc2VzXyA9IFtdO1xuICAgIHRoaXMuZmlsdGVyXyA9IGZpbHRlcjtcbiAgfTtcbiAgdmFyIHBybyA9IHc2OWIuaW1nLldlYkdMUGlwZWxpbmUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3c2OWIuaW1nLldlYkdMUHJvZ3JhbX0gcHJvZ3JhbSB0byBydW4uXG4gICAqIEBwYXJhbSB7dzY5Yi5pbWcuV2ViR0xQYXJhbXN9IHBhcmFtZXRlcnMgdG8gYXBwbHkuXG4gICAqL1xuICBwcm8uYWRkUGFzcyA9IGZ1bmN0aW9uKHByb2dyYW0sIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnBhc3Nlc18ucHVzaChbcHJvZ3JhbSwgcGFyYW1ldGVyc10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIHBhc3MuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlcil9IGNhbGxiYWNrIHRoYXQgdGFrZXMgdGhyZWVcbiAgICogcGFyYW10ZXJzOlxuICAgKiAtIGlucHV0IHRleHR1cmUgaWQuXG4gICAqIC0gb3V0IHRleHR1cmUgaWRcbiAgICogLSB3b3JraW5nIHRleHR1cmUgaWQgKGZvciBpbnRlcm1lZGlhdGUgcmVzdWx0cykuXG4gICAqL1xuICBwcm8uYWRkQ3VzdG9tUGFzcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wYXNzZXNfLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG5cbiAgcHJvLnJlbmRlciA9IGZ1bmN0aW9uKGluVGV4dHVyZUlkLCBvdXRUZXh0dXJlSWQsIHdvcmtUZXh0dXJlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRfcmVzdWx0T25TY3JlZW4pIHtcbiAgICB2YXIgcHJldlByb2dhcm0gPSBudWxsO1xuICAgIHZhciBmaWx0ZXIgPSB0aGlzLmZpbHRlcl87XG4gICAgdmFyIG51bVBhc3NlcyA9IHRoaXMucGFzc2VzXy5sZW5ndGg7XG4gICAgdmFyIHBpbmdQb25nVGV4dHVyZUlkcztcbiAgICAvLyBFbnN1cmVzIGxhc3QgcGFzcyBnb2VzIG9uIG91dFRleHR1cmVJZC5cbiAgICBpZiAobnVtUGFzc2VzICUgMiA9PSAwKVxuICAgICAgcGluZ1BvbmdUZXh0dXJlSWRzID0gW3dvcmtUZXh0dXJlSWQsIG91dFRleHR1cmVJZF07XG4gICAgZWxzZVxuICAgICAgcGluZ1BvbmdUZXh0dXJlSWRzID0gW291dFRleHR1cmVJZCwgd29ya1RleHR1cmVJZF07XG5cbiAgICB2YXIgcHJldlRleHR1cmVJZCA9IGluVGV4dHVyZUlkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGFzc2VzOyArK2kpIHtcbiAgICAgIHZhciBwYXNzID0gdGhpcy5wYXNzZXNfW2ldO1xuICAgICAgaWYgKHBhc3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gcGFzc1swXTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHBhc3NbMV07XG4gICAgICAgIGlmIChwcm9ncmFtICE9IHByZXZQcm9nYXJtKSB7XG4gICAgICAgICAgcHJvZ3JhbS51c2UoKTtcbiAgICAgICAgICBwcm9ncmFtLmluaXRDb21tb25BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgcHJldlByb2dhcm0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTFpKCdpbWFnZUluJywgcHJldlRleHR1cmVJZCk7XG4gICAgICAgIHBhcmFtcy5hcHBseShwcm9ncmFtKTtcbiAgICAgICAgaWYgKGkgPT0gbnVtUGFzc2VzIC0gMSAmJiBvcHRfcmVzdWx0T25TY3JlZW4pIHtcbiAgICAgICAgICBmaWx0ZXIudW5iaW5kRnJhbWVidWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGV4SWQgPSBwaW5nUG9uZ1RleHR1cmVJZHNbaSAlIDJdO1xuICAgICAgICAgIGZpbHRlci5hdHRhY2hUZXh0dXJlVG9GQih0ZXhJZCk7XG4gICAgICAgICAgcHJldlRleHR1cmVJZCA9IHRleElkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJhbXMuZ2V0VmFsdWUoJ291dE9mZnNldCcpO1xuICAgICAgICBmaWx0ZXIuc2V0Vmlld3BvcnQoXG4gICAgICAgICAgb2Zmc2V0ID8gb2Zmc2V0WzBdIDogMCxcbiAgICAgICAgICBvZmZzZXQgPyBvZmZzZXRbMV0gOiAwLFxuICAgICAgICAgIHBhcmFtcy5nZXRWYWx1ZSgnd2lkdGgnKSxcbiAgICAgICAgICBwYXJhbXMuZ2V0VmFsdWUoJ2hlaWdodCcpKTtcbiAgICAgICAgcHJvZ3JhbS5kcmF3UmVjdCgpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjdXN0b20gcGFzc1xuICAgICAgICB2YXIgb3V0VGV4ID0gcGluZ1BvbmdUZXh0dXJlSWRzW2kgJSAyXTtcbiAgICAgICAgdmFyIHdvcmtUZXggPSBwaW5nUG9uZ1RleHR1cmVJZHNbKGkgKyAxKSAlIDJdO1xuICAgICAgICBwYXNzKHByZXZUZXh0dXJlSWQsIG91dFRleCwgd29ya1RleCk7XG4gICAgICAgIHByZXZUZXh0dXJlSWQgPSBvdXRUZXg7XG4gICAgICB9XG5cbiAgICB9XG4gIH07XG5cblxufSk7XG4iLCJnb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy5yZWN0VmVydGV4Jyk7XG53NjliLnNoYWRlcnMucmVjdFZlcnRleCA9ICdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG4nICtcbiAgJ3ZvaWQgbWFpbih2b2lkKSB7XFxuJyArXG4gICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpO1xcbicgK1xuICAnfSc7XG5nb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy5zY2FsZScpO1xudzY5Yi5zaGFkZXJzLnNjYWxlID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB3aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBpbndpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBpbmhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgdGV4d2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBmcmFnQ29vcmRPZmZzZXQ7XFxuJyArXG4gICd1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZUluO1xcbicgK1xuICAndmVjMiBkaW0gPSB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbicgK1xuICAndmVjMiB0ZXhkaW0gPSB2ZWMyKHRleHdpZHRoLCB0ZXhoZWlnaHQpO1xcbicgK1xuICAndmVjMiBpbmRpbSA9IHZlYzIoaW53aWR0aCwgaW5oZWlnaHQpO1xcbicgK1xuICAndmVjMiB0ZXhzY2FsZSA9IGluZGltIC8gdGV4ZGltO1xcbicgK1xuICAndmVjMiBnZXROb3JtYWxpemVkRnJhZ0Nvb3JkKCkge1xcbicgK1xuICAncmV0dXJuIChnbF9GcmFnQ29vcmQueHkgLSBmcmFnQ29vcmRPZmZzZXQpICsgMC41O1xcbicgK1xuICAnfVxcbicgK1xuICAndW5pZm9ybSBmbG9hdCBvdXRPZmZzZXRYO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBpbk9mZnNldFg7XFxuJyArXG4gICd2ZWMyIG91dE9mZnNldCA9IHZlYzIob3V0T2Zmc2V0WCwgMCk7XFxuJyArXG4gICd2ZWMyIGluT2Zmc2V0ID0gdmVjMihpbk9mZnNldFgsIDApIC8gdGV4ZGltO1xcbicgK1xuICAndmVjMiBzdGVwWCA9IHZlYzIoMC43LCAwKSAvIGluZGltO1xcbicgK1xuICAndmVjMiBzdGVwWSA9IHZlYzIoMCwgMC43KSAvIGluZGltO1xcbicgK1xuICAndmVjMiBzY2FsZSA9IGluZGltIC8gZGltO1xcbicgK1xuICAndmVjMyBjb21iaW5lKHZlYzMgY29sb3IxLCB2ZWMzIGNvbG9yMikge1xcbicgK1xuICAncmV0dXJuIHZlYzMoXFxuJyArXG4gICdtaW4oY29sb3IxLngsIGNvbG9yMi54KSxcXG4nICtcbiAgJ21heChjb2xvcjEueSwgY29sb3IyLnkpLFxcbicgK1xuICAnY29sb3IxLnogKyBjb2xvcjIueik7XFxuJyArXG4gICd9XFxuJyArXG4gICd2ZWMzIHNhbXBsZSh2ZWMyIHAsIHZlYzIgb2Zmc2V0KSB7XFxuJyArXG4gICd2ZWMyIHBvcyA9IChwICsgb2Zmc2V0KTtcXG4nICtcbiAgJ3BvcyA9IG1pbih2ZWMyKDEuMCwgMS4wKSwgcG9zKTtcXG4nICtcbiAgJ3BvcyA9IG1heCh2ZWMyKDAuMCwgMC4wKSwgcG9zKTtcXG4nICtcbiAgJ3BvcyA9IGluT2Zmc2V0ICsgdGV4c2NhbGUgKiBwb3M7XFxuJyArXG4gICdyZXR1cm4gdGV4dHVyZTJEKGltYWdlSW4sIHBvcykueHl6O1xcbicgK1xuICAnfVxcbicgK1xuICAndm9pZCBtYWluKCkge1xcbicgK1xuICAndmVjMiBwID0gKGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSAtIG91dE9mZnNldCkgLyBkaW07XFxuJyArXG4gICd2ZWMzIHJlc3VsdCA9IHNhbXBsZShwLCAtIHN0ZXBYIC0gc3RlcFkpO1xcbicgK1xuICAncmVzdWx0ID0gY29tYmluZShyZXN1bHQsIHNhbXBsZShwLCBzdGVwWCArIHN0ZXBZKSk7XFxuJyArXG4gICdyZXN1bHQgPSBjb21iaW5lKHJlc3VsdCwgc2FtcGxlKHAsIHN0ZXBYIC0gc3RlcFkpKTtcXG4nICtcbiAgJ3Jlc3VsdCA9IGNvbWJpbmUocmVzdWx0LCBzYW1wbGUocCwgLXN0ZXBYICsgc3RlcFkpKTtcXG4nICtcbiAgJ3Jlc3VsdC56IC89IDQuMDtcXG4nICtcbiAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQocmVzdWx0LCAxLjApO1xcbicgK1xuICAnfSc7XG5nb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy50aHJlc2hvbGQnKTtcbnc2OWIuc2hhZGVycy50aHJlc2hvbGQgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGlud2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGluaGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXh3aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgdGV4aGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSB2ZWMyIGZyYWdDb29yZE9mZnNldDtcXG4nICtcbiAgJ3VuaWZvcm0gc2FtcGxlcjJEIGltYWdlSW47XFxuJyArXG4gICd2ZWMyIGRpbSA9IHZlYzIod2lkdGgsIGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleGRpbSA9IHZlYzIodGV4d2lkdGgsIHRleGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIGluZGltID0gdmVjMihpbndpZHRoLCBpbmhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleHNjYWxlID0gaW5kaW0gLyB0ZXhkaW07XFxuJyArXG4gICd2ZWMyIGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSB7XFxuJyArXG4gICdyZXR1cm4gKGdsX0ZyYWdDb29yZC54eSAtIGZyYWdDb29yZE9mZnNldCkgKyAwLjU7XFxuJyArXG4gICd9XFxuJyArXG4gICd1bmlmb3JtIHNhbXBsZXIyRCBvcmlnSW1hZ2U7XFxuJyArXG4gICd2ZWMyIHRleHNjYWxlQmxhY2tMZXZlbHMgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgJ3ZlYzIgcCA9IGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSAvIGRpbTtcXG4nICtcbiAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQob3JpZ0ltYWdlLCBwKTtcXG4nICtcbiAgJ2Zsb2F0IGdyYXkgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG4nICtcbiAgJ2Zsb2F0IGJsYWNrID0gdGV4dHVyZTJEKGltYWdlSW4sIHAgKiB0ZXhzY2FsZUJsYWNrTGV2ZWxzKS56O1xcbicgK1xuICAnZmxvYXQgYmluYXJ5ID0gZ3JheSA+IGJsYWNrID8gMS4wIDogMC4wO1xcbicgK1xuICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChiaW5hcnksIGJpbmFyeSwgYmluYXJ5LCAxLjApO1xcbicgK1xuICAnfSc7XG5nb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy5iaW5hcml6ZUF2ZzEnKTtcbnc2OWIuc2hhZGVycy5iaW5hcml6ZUF2ZzEgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGlud2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGluaGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXh3aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgdGV4aGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSB2ZWMyIGZyYWdDb29yZE9mZnNldDtcXG4nICtcbiAgJ3VuaWZvcm0gc2FtcGxlcjJEIGltYWdlSW47XFxuJyArXG4gICd2ZWMyIGRpbSA9IHZlYzIod2lkdGgsIGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleGRpbSA9IHZlYzIodGV4d2lkdGgsIHRleGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIGluZGltID0gdmVjMihpbndpZHRoLCBpbmhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleHNjYWxlID0gaW5kaW0gLyB0ZXhkaW07XFxuJyArXG4gICd2ZWMyIGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSB7XFxuJyArXG4gICdyZXR1cm4gKGdsX0ZyYWdDb29yZC54eSAtIGZyYWdDb29yZE9mZnNldCkgKyAwLjU7XFxuJyArXG4gICd9XFxuJyArXG4gICd2ZWMyIG1pcnJvck1hcmdpbiA9IDEuMCAvIGluZGltO1xcbicgK1xuICAndmVjMiBtaXJyb3JCb3JkZXIgPSAxLjAgLSBtaXJyb3JNYXJnaW47XFxuJyArXG4gICd2b2lkIG1pcnJvcihpbm91dCB2ZWMyIHBvcykge1xcbicgK1xuICAncG9zID0gcG9zIC0gc3RlcChtaXJyb3JCb3JkZXIsIHBvcykgKiAocG9zIC0gbWlycm9yQm9yZGVyKTtcXG4nICtcbiAgJ3BvcyAqPSAyLjAgKiAoMC41IC0gc3RlcCgwLjAsIC1wb3MpKTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBzYW1wbGVEaXJlY3Rpb247XFxuJyArXG4gICd2ZWMyIHNhbXBsZVN0ZXAgPSBzYW1wbGVEaXJlY3Rpb24gLyBpbmRpbTtcXG4nICtcbiAgJ3ZvaWQgYWRkU2FtcGxlKGlub3V0IHZlYzQgcmVzdWx0LCB2ZWMyIHAsIGZsb2F0IG9mZnNldCwgZmxvYXQgd2VpZ2h0KSB7XFxuJyArXG4gICd2ZWMyIHBvcyA9IChwICsgb2Zmc2V0ICogc2FtcGxlU3RlcCk7XFxuJyArXG4gICdtaXJyb3IocG9zKTtcXG4nICtcbiAgJ3BvcyAqPSB0ZXhzY2FsZTtcXG4nICtcbiAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2VJbiwgcG9zKTtcXG4nICtcbiAgJ2Zsb2F0IGdyYXkgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG4nICtcbiAgJ3Jlc3VsdC5yID0gbWluKHJlc3VsdC5yLCBncmF5KTtcXG4nICtcbiAgJ3Jlc3VsdC5nID0gbWF4KHJlc3VsdC5nLCBncmF5KTtcXG4nICtcbiAgJ3Jlc3VsdC5iICs9IGdyYXkgKiB3ZWlnaHQ7XFxuJyArXG4gICd9XFxuJyArXG4gICd2b2lkIGdhdXNzOShpbm91dCB2ZWM0IHJlc3VsdCwgdmVjMiBwKSB7XFxuJyArXG4gICdhZGRTYW1wbGUocmVzdWx0LCBwLCAtNC4wLCAwLjA0NTkpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgLTMuMCwgMC4wODIyKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIC0yLjAsIDAuMTI0Nyk7XFxuJyArXG4gICdhZGRTYW1wbGUocmVzdWx0LCBwLCAtMS4wLCAwLjE2MDEpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgMC4wLCAwLjE3NDEpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgMS4wLCAwLjE2MDEpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgMi4wLCAwLjEyNDcpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgMy4wLCAwLjA4MjIpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgNC4wLCAwLjA0NTkpO1xcbicgK1xuICAnfVxcbicgK1xuICAndm9pZCBtYWluKCkge1xcbicgK1xuICAndmVjMiBwID0gZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIC8gZGltO1xcbicgK1xuICAndmVjNCByZXN1bHQgID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApO1xcbicgK1xuICAnZ2F1c3M5KHJlc3VsdCwgcCk7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxuJyArXG4gICd9Jztcbmdvb2cucHJvdmlkZSgndzY5Yi5zaGFkZXJzLmJpbmFyaXplR3JvdXAnKTtcbnc2OWIuc2hhZGVycy5iaW5hcml6ZUdyb3VwID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB3aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBpbndpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBpbmhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgdGV4d2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBmcmFnQ29vcmRPZmZzZXQ7XFxuJyArXG4gICd1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZUluO1xcbicgK1xuICAndmVjMiBkaW0gPSB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbicgK1xuICAndmVjMiB0ZXhkaW0gPSB2ZWMyKHRleHdpZHRoLCB0ZXhoZWlnaHQpO1xcbicgK1xuICAndmVjMiBpbmRpbSA9IHZlYzIoaW53aWR0aCwgaW5oZWlnaHQpO1xcbicgK1xuICAndmVjMiB0ZXhzY2FsZSA9IGluZGltIC8gdGV4ZGltO1xcbicgK1xuICAndmVjMiBnZXROb3JtYWxpemVkRnJhZ0Nvb3JkKCkge1xcbicgK1xuICAncmV0dXJuIChnbF9GcmFnQ29vcmQueHkgLSBmcmFnQ29vcmRPZmZzZXQpICsgMC41O1xcbicgK1xuICAnfVxcbicgK1xuICAndmVjMiBtaXJyb3JNYXJnaW4gPSAxLjAgLyBpbmRpbTtcXG4nICtcbiAgJ3ZlYzIgbWlycm9yQm9yZGVyID0gMS4wIC0gbWlycm9yTWFyZ2luO1xcbicgK1xuICAndm9pZCBtaXJyb3IoaW5vdXQgdmVjMiBwb3MpIHtcXG4nICtcbiAgJ3BvcyA9IHBvcyAtIHN0ZXAobWlycm9yQm9yZGVyLCBwb3MpICogKHBvcyAtIG1pcnJvckJvcmRlcik7XFxuJyArXG4gICdwb3MgKj0gMi4wICogKDAuNSAtIHN0ZXAoMC4wLCAtcG9zKSk7XFxuJyArXG4gICd9XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgc2FtcGxlRGlyZWN0aW9uO1xcbicgK1xuICAndW5pZm9ybSB2ZWMyIG91dE9mZnNldDtcXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBpbk9mZnNldDtcXG4nICtcbiAgJ3ZlYzIgaW5PZmZzZXROb3JtYWxpemVkID0gaW5PZmZzZXQgLyB0ZXhkaW07XFxuJyArXG4gICd2ZWMyIHNhbXBsZVN0ZXAgPSBzYW1wbGVEaXJlY3Rpb24gLyBpbmRpbTtcXG4nICtcbiAgJ3ZvaWQgYWRkU2FtcGxlKGlub3V0IHZlYzQgcmVzdWx0LCB2ZWMyIHAsIGZsb2F0IG9mZnNldCwgZmxvYXQgd2VpZ2h0KSB7XFxuJyArXG4gICd2ZWMyIHBvcyA9IChwICsgb2Zmc2V0ICogc2FtcGxlU3RlcCk7XFxuJyArXG4gICdtaXJyb3IocG9zKTtcXG4nICtcbiAgJ3BvcyAqPSB0ZXhzY2FsZTtcXG4nICtcbiAgJ3BvcyArPSBpbk9mZnNldE5vcm1hbGl6ZWQ7XFxuJyArXG4gICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKGltYWdlSW4sIHBvcyk7XFxuJyArXG4gICdyZXN1bHQuciA9IG1pbihyZXN1bHQuciwgY29sb3Iucik7XFxuJyArXG4gICdyZXN1bHQuZyA9IG1heChyZXN1bHQuZywgY29sb3IuZyk7XFxuJyArXG4gICdyZXN1bHQuYiArPSBjb2xvci5iICogd2VpZ2h0O1xcbicgK1xuICAnfVxcbicgK1xuICAndm9pZCBnYXVzczkoaW5vdXQgdmVjNCByZXN1bHQsIHZlYzIgcCkge1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgLTQuMCwgMC4wNDU5KTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIC0zLjAsIDAuMDgyMik7XFxuJyArXG4gICdhZGRTYW1wbGUocmVzdWx0LCBwLCAtMi4wLCAwLjEyNDcpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgLTEuMCwgMC4xNjAxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDAuMCwgMC4xNzQxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDEuMCwgMC4xNjAxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDIuMCwgMC4xMjQ3KTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDMuMCwgMC4wODIyKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDQuMCwgMC4wNDU5KTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgJ3ZlYzIgcCA9IChnZXROb3JtYWxpemVkRnJhZ0Nvb3JkKCkgLSBvdXRPZmZzZXQpIC8gZGltO1xcbicgK1xuICAndmVjNCByZXN1bHQgID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbicgK1xuICAnZ2F1c3M5KHJlc3VsdCwgcCk7XFxuJyArXG4gICcvLyAvL1xcbicgK1xuICAnZ2xfRnJhZ0NvbG9yID0gcmVzdWx0O1xcbicgK1xuICAnLy9cXG4nICtcbiAgJ30nO1xuZ29vZy5wcm92aWRlKCd3NjliLnNoYWRlcnMuZGVidWcnKTtcbnc2OWIuc2hhZGVycy5kZWJ1ZyA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgd2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW53aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW5oZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXhoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgZnJhZ0Nvb3JkT2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2VJbjtcXG4nICtcbiAgJ3ZlYzIgZGltID0gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4ZGltID0gdmVjMih0ZXh3aWR0aCwgdGV4aGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgaW5kaW0gPSB2ZWMyKGlud2lkdGgsIGluaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4c2NhbGUgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZlYzIgZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIHtcXG4nICtcbiAgJ3JldHVybiAoZ2xfRnJhZ0Nvb3JkLnh5IC0gZnJhZ0Nvb3JkT2Zmc2V0KSArIDAuNTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBvdXRPZmZzZXQ7XFxuJyArXG4gICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICd2ZWMyIHAgPSAoZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIC0gb3V0T2Zmc2V0KSAvIGRpbTtcXG4nICtcbiAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDEuMCk7XFxuJyArXG4gICdjb2xvci5yZyA9IHA7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgJ30nO1xuZ29vZy5wcm92aWRlKCd3NjliLnNoYWRlcnMuZHVtbXknKTtcbnc2OWIuc2hhZGVycy5kdW1teSA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgd2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW53aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW5oZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXhoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgZnJhZ0Nvb3JkT2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2VJbjtcXG4nICtcbiAgJ3ZlYzIgZGltID0gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4ZGltID0gdmVjMih0ZXh3aWR0aCwgdGV4aGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgaW5kaW0gPSB2ZWMyKGlud2lkdGgsIGluaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4c2NhbGUgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZlYzIgZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIHtcXG4nICtcbiAgJ3JldHVybiAoZ2xfRnJhZ0Nvb3JkLnh5IC0gZnJhZ0Nvb3JkT2Zmc2V0KSArIDAuNTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZlYzIgbWlycm9yTWFyZ2luID0gMS4wIC8gaW5kaW07XFxuJyArXG4gICd2ZWMyIG1pcnJvckJvcmRlciA9IDEuMCAtIG1pcnJvck1hcmdpbjtcXG4nICtcbiAgJ3ZvaWQgbWlycm9yKGlub3V0IHZlYzIgcG9zKSB7XFxuJyArXG4gICdwb3MgPSBwb3MgLSBzdGVwKG1pcnJvckJvcmRlciwgcG9zKSAqIChwb3MgLSBtaXJyb3JCb3JkZXIpO1xcbicgK1xuICAncG9zICo9IDIuMCAqICgwLjUgLSBzdGVwKDAuMCwgLXBvcykpO1xcbicgK1xuICAnfVxcbicgK1xuICAndm9pZCBtYWluKCkge1xcbicgK1xuICAndmVjMiBwID0gKGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSAvIGRpbSk7XFxuJyArXG4gICdtaXJyb3IocCk7XFxuJyArXG4gICdwICo9IHRleHNjYWxlO1xcbicgK1xuICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGltYWdlSW4sIHApO1xcbicgK1xuICAnfSc7XG5nb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy5lc3RpbWF0ZUJsYWNrJyk7XG53NjliLnNoYWRlcnMuZXN0aW1hdGVCbGFjayA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgd2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW53aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW5oZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXhoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgZnJhZ0Nvb3JkT2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2VJbjtcXG4nICtcbiAgJ3ZlYzIgZGltID0gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4ZGltID0gdmVjMih0ZXh3aWR0aCwgdGV4aGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgaW5kaW0gPSB2ZWMyKGlud2lkdGgsIGluaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4c2NhbGUgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZlYzIgZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIHtcXG4nICtcbiAgJ3JldHVybiAoZ2xfRnJhZ0Nvb3JkLnh5IC0gZnJhZ0Nvb3JkT2Zmc2V0KSArIDAuNTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZlYzIgbWlycm9yTWFyZ2luID0gMS4wIC8gaW5kaW07XFxuJyArXG4gICd2ZWMyIG1pcnJvckJvcmRlciA9IDEuMCAtIG1pcnJvck1hcmdpbjtcXG4nICtcbiAgJ3ZvaWQgbWlycm9yKGlub3V0IHZlYzIgcG9zKSB7XFxuJyArXG4gICdwb3MgPSBwb3MgLSBzdGVwKG1pcnJvckJvcmRlciwgcG9zKSAqIChwb3MgLSBtaXJyb3JCb3JkZXIpO1xcbicgK1xuICAncG9zICo9IDIuMCAqICgwLjUgLSBzdGVwKDAuMCwgLXBvcykpO1xcbicgK1xuICAnfVxcbicgK1xuICAndmVjNCBzYW1wbGVBdCh2ZWMyIHBvcywgZmxvYXQgc2NhbGUpIHtcXG4nICtcbiAgJ21pcnJvcihwb3MpO1xcbicgK1xuICAndmVjMiBvZmZzZXQgPSBzY2FsZSAqIHZlYzIoaW5kaW0ueCwgMCkgLyB0ZXhkaW07XFxuJyArXG4gICdwb3MgPSBwb3MgKiB0ZXhzY2FsZSArIG9mZnNldDtcXG4nICtcbiAgJ3JldHVybiB0ZXh0dXJlMkQoaW1hZ2VJbiwgcG9zKTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ2Zsb2F0IGdldER5blJhbmdlKHZlYzQgY29sb3IpIHtcXG4nICtcbiAgJ3JldHVybiBjb2xvci5nIC0gY29sb3IucjtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgJ3ZlYzIgcCA9IGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSAvIGRpbTtcXG4nICtcbiAgJ3ZlYzQgY29sb3I7XFxuJyArXG4gICdmbG9hdCBtaW5EeW5SYW5nZSA9IDAuMztcXG4nICtcbiAgJ2NvbG9yID0gc2FtcGxlQXQocCwgMC4wKTtcXG4nICtcbiAgJ2lmIChnZXREeW5SYW5nZShjb2xvcikgPCBtaW5EeW5SYW5nZSkge1xcbicgK1xuICAnY29sb3IgPSBzYW1wbGVBdChwLCAxLjApO1xcbicgK1xuICAnaWYgKGdldER5blJhbmdlKGNvbG9yKSA8IG1pbkR5blJhbmdlKSB7XFxuJyArXG4gICdjb2xvciA9IHNhbXBsZUF0KHAsIDIuMCk7XFxuJyArXG4gICd9XFxuJyArXG4gICd9XFxuJyArXG4gICdjb2xvci56IC09IDAuMDI7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgJ30nO1xuZ29vZy5wcm92aWRlKCd3NjliLnNoYWRlcnMuZXh0cmFjdENoYW5uZWwnKTtcbnc2OWIuc2hhZGVycy5leHRyYWN0Q2hhbm5lbCA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgd2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW53aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW5oZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXhoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgZnJhZ0Nvb3JkT2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2VJbjtcXG4nICtcbiAgJ3ZlYzIgZGltID0gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4ZGltID0gdmVjMih0ZXh3aWR0aCwgdGV4aGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgaW5kaW0gPSB2ZWMyKGlud2lkdGgsIGluaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4c2NhbGUgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZlYzIgZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIHtcXG4nICtcbiAgJ3JldHVybiAoZ2xfRnJhZ0Nvb3JkLnh5IC0gZnJhZ0Nvb3JkT2Zmc2V0KSArIDAuNTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3VuaWZvcm0gaW50IGNoYW5uZWw7XFxuJyArXG4gICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICd2ZWMyIHAgPSAoZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIC8gZGltKTtcXG4nICtcbiAgJ3AgKj0gdGV4c2NhbGU7XFxuJyArXG4gICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKGltYWdlSW4sIHApO1xcbicgK1xuICAnZmxvYXQgZ3JheSA9IGNvbG9yLmI7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGdyYXksIGdyYXksIGdyYXksIDEuMCk7XFxuJyArXG4gICd9Jztcbmdvb2cucHJvdmlkZSgndzY5Yi5zaGFkZXJzLmZyYWdDb29yZFRlc3QnKTtcbnc2OWIuc2hhZGVycy5mcmFnQ29vcmRUZXN0ID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xuICAndm9pZCBtYWluKCkge1xcbicgK1xuICAndmVjNCByZXN1bHQgPSB2ZWM0KDEuMCk7XFxuJyArXG4gICdyZXN1bHQucmcgPSBnbF9GcmFnQ29vcmQueHkgLyAxMC4wO1xcbicgK1xuICAnZ2xfRnJhZ0NvbG9yID0gcmVzdWx0O1xcbicgK1xuICAnfSc7XG5nb29nLnByb3ZpZGUoJ3c2OWIuc2hhZGVycy5nYXVzc0JsdXInKTtcbnc2OWIuc2hhZGVycy5nYXVzc0JsdXIgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCBoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGlud2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGluaGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXh3aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgdGV4aGVpZ2h0O1xcbicgK1xuICAndW5pZm9ybSB2ZWMyIGZyYWdDb29yZE9mZnNldDtcXG4nICtcbiAgJ3VuaWZvcm0gc2FtcGxlcjJEIGltYWdlSW47XFxuJyArXG4gICd2ZWMyIGRpbSA9IHZlYzIod2lkdGgsIGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleGRpbSA9IHZlYzIodGV4d2lkdGgsIHRleGhlaWdodCk7XFxuJyArXG4gICd2ZWMyIGluZGltID0gdmVjMihpbndpZHRoLCBpbmhlaWdodCk7XFxuJyArXG4gICd2ZWMyIHRleHNjYWxlID0gaW5kaW0gLyB0ZXhkaW07XFxuJyArXG4gICd2ZWMyIGdldE5vcm1hbGl6ZWRGcmFnQ29vcmQoKSB7XFxuJyArXG4gICdyZXR1cm4gKGdsX0ZyYWdDb29yZC54eSAtIGZyYWdDb29yZE9mZnNldCkgKyAwLjU7XFxuJyArXG4gICd9XFxuJyArXG4gICd2ZWMyIG1pcnJvck1hcmdpbiA9IDEuMCAvIGluZGltO1xcbicgK1xuICAndmVjMiBtaXJyb3JCb3JkZXIgPSAxLjAgLSBtaXJyb3JNYXJnaW47XFxuJyArXG4gICd2b2lkIG1pcnJvcihpbm91dCB2ZWMyIHBvcykge1xcbicgK1xuICAncG9zID0gcG9zIC0gc3RlcChtaXJyb3JCb3JkZXIsIHBvcykgKiAocG9zIC0gbWlycm9yQm9yZGVyKTtcXG4nICtcbiAgJ3BvcyAqPSAyLjAgKiAoMC41IC0gc3RlcCgwLjAsIC1wb3MpKTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3VuaWZvcm0gdmVjMiBzYW1wbGVEaXJlY3Rpb247XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgb3V0T2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSB2ZWMyIGluT2Zmc2V0O1xcbicgK1xuICAndmVjMiBzYW1wbGVTdGVwID0gc2FtcGxlRGlyZWN0aW9uIC8gdGV4ZGltO1xcbicgK1xuICAndmVjMiBpbk9mZnNldE5vcm1hbGl6ZWQgPSBpbk9mZnNldCAvIHRleGRpbTtcXG4nICtcbiAgJ3ZvaWQgYWRkU2FtcGxlKGlub3V0IHZlYzQgcmVzdWx0LCB2ZWMyIHAsIGZsb2F0IG9mZnNldCwgZmxvYXQgd2VpZ2h0KSB7XFxuJyArXG4gICd2ZWMyIHBvcyA9IChwICsgKG9mZnNldCAqIHNhbXBsZVN0ZXApKTtcXG4nICtcbiAgJ21pcnJvcihwb3MpO1xcbicgK1xuICAncG9zICo9IHRleHNjYWxlO1xcbicgK1xuICAncG9zICs9IGluT2Zmc2V0Tm9ybWFsaXplZDtcXG4nICtcbiAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2VJbiwgcG9zKTtcXG4nICtcbiAgJ3Jlc3VsdC5yZ2IgKz0gY29sb3IucmdiICogd2VpZ2h0O1xcbicgK1xuICAnfVxcbicgK1xuICAndm9pZCBnYXVzczkoaW5vdXQgdmVjNCByZXN1bHQsIHZlYzIgcCkge1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgLTQuMCwgMC4wNDU5KTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIC0zLjAsIDAuMDgyMik7XFxuJyArXG4gICdhZGRTYW1wbGUocmVzdWx0LCBwLCAtMi4wLCAwLjEyNDcpO1xcbicgK1xuICAnYWRkU2FtcGxlKHJlc3VsdCwgcCwgLTEuMCwgMC4xNjAxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDAuMCwgMC4xNzQxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDEuMCwgMC4xNjAxKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDIuMCwgMC4xMjQ3KTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDMuMCwgMC4wODIyKTtcXG4nICtcbiAgJ2FkZFNhbXBsZShyZXN1bHQsIHAsIDQuMCwgMC4wNDU5KTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgJ3ZlYzIgcCA9IChnZXROb3JtYWxpemVkRnJhZ0Nvb3JkKCkgLSBvdXRPZmZzZXQpIC8gZGltO1xcbicgK1xuICAndmVjNCByZXN1bHQgID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbicgK1xuICAnZ2F1c3M5KHJlc3VsdCwgcCk7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxuJyArXG4gICd9Jztcbmdvb2cucHJvdmlkZSgndzY5Yi5zaGFkZXJzLmdyYXlzY2FsZScpO1xudzY5Yi5zaGFkZXJzLmdyYXlzY2FsZSA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgd2lkdGg7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IGhlaWdodDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW53aWR0aDtcXG4nICtcbiAgJ3VuaWZvcm0gZmxvYXQgaW5oZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIGZsb2F0IHRleHdpZHRoO1xcbicgK1xuICAndW5pZm9ybSBmbG9hdCB0ZXhoZWlnaHQ7XFxuJyArXG4gICd1bmlmb3JtIHZlYzIgZnJhZ0Nvb3JkT2Zmc2V0O1xcbicgK1xuICAndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2VJbjtcXG4nICtcbiAgJ3ZlYzIgZGltID0gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4ZGltID0gdmVjMih0ZXh3aWR0aCwgdGV4aGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgaW5kaW0gPSB2ZWMyKGlud2lkdGgsIGluaGVpZ2h0KTtcXG4nICtcbiAgJ3ZlYzIgdGV4c2NhbGUgPSBpbmRpbSAvIHRleGRpbTtcXG4nICtcbiAgJ3ZlYzIgZ2V0Tm9ybWFsaXplZEZyYWdDb29yZCgpIHtcXG4nICtcbiAgJ3JldHVybiAoZ2xfRnJhZ0Nvb3JkLnh5IC0gZnJhZ0Nvb3JkT2Zmc2V0KSArIDAuNTtcXG4nICtcbiAgJ31cXG4nICtcbiAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgJ3ZlYzIgcCA9IChnZXROb3JtYWxpemVkRnJhZ0Nvb3JkKCkgLyBkaW0pO1xcbicgK1xuICAncCAqPSB0ZXhzY2FsZTtcXG4nICtcbiAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2VJbiwgcCk7XFxuJyArXG4gICdmbG9hdCBncmF5ID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxuJyArXG4gICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGdyYXksIGdyYXksIGdyYXksIDEuMCk7XFxuJyArXG4gICd9JzsiLCIvLyAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuXG5nb29nLnByb3ZpZGUoJ3c2OWIuaW1nLldlYkdMUHJvZ3JhbScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnNoYWRlcnMucmVjdFZlcnRleCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogRmlsdGVycyBpbWFnZXMgdXNpbmcgd2ViZ2wgc2hhZGVycy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhZ21lbnRTb3VyY2UgZnJhZ21lbnRTb3VyY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3ZlcnRleFNvdXJjZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIuaW1nLldlYkdMUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBmcmFnbWVudFNvdXJjZSwgb3B0X3ZlcnRleFNvdXJjZSkge1xuICAgIHRoaXMuY29udGV4dF8gPSBnbDtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gdGhpcy5idWlsZFNoYWRlcl8oXG4gICAgICBvcHRfdmVydGV4U291cmNlIHx8IHc2OWIuc2hhZGVycy5yZWN0VmVydGV4LCB0cnVlKTtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmJ1aWxkU2hhZGVyXyhmcmFnbWVudFNvdXJjZSwgZmFsc2UpO1xuICAgIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBsaW5rIHNoYWRlciBwcm9ncmFtOiAnICtcbiAgICAgICAgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSkpO1xuICAgIH1cbiAgICB0aGlzLmdsUHJvZ3JhbSA9IHNoYWRlclByb2dyYW07XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLmltZy5XZWJHTFByb2dyYW0ucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBMaW5rZWQgc2hhZGVyIHByb2dyYW0uXG4gICAqL1xuICBwcm8uZ2xQcm9ncmFtID0gbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAqL1xuICBwcm8uY29udGV4XyA9IG51bGw7XG5cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNvbW1vbiBzaGFkZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHByby5pbml0Q29tbW9uQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIHByb2dyYW0gPSB0aGlzLmdsUHJvZ3JhbTtcbiAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB2YXIgdmVydGljZXMgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG5cbiAgICAvL3NldCBwb3NpdGlvbiBhdHRyaWJ1dGUgZGF0YVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoaXMgcHJvZ3JhbS5cbiAgICovXG4gIHByby51c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRfLnVzZVByb2dyYW0odGhpcy5nbFByb2dyYW0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3cyByZWN0YW5nZWxlLiBJbml0Q29tbW9uQXR0cmlidXRlcyBuZWVkcyB0byBoYXZlIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgKi9cbiAgcHJvLmRyYXdSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0XztcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHZhcmlhYmxlIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBmbG9hdCB2YWx1ZS5cbiAgICovXG4gIHByby5zZXRVbmlmb3JtMWYgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuY29udGV4dF8uZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuZ2xQcm9ncmFtLCBuYW1lKTtcbiAgICB0aGlzLmNvbnRleHRfLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3IgdmVjMi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdmFyaWFibGUgbmFtZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggZmxvYXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGZsb2F0IHZhbHVlLlxuICAgKi9cbiAgcHJvLnNldFVuaWZvcm0yZiA9IGZ1bmN0aW9uKG5hbWUsIHgsIHkpIHtcbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLmNvbnRleHRfLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmdsUHJvZ3JhbSwgbmFtZSk7XG4gICAgdGhpcy5jb250ZXh0Xy51bmlmb3JtMmYobG9jYXRpb24sIHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB2YXJpYWJsZSBuYW1lLlxuICAgKiBAcGFyYW0geyhBcnJheS48bnVtYmVyPnxGbG9hdDMyQXJyYXkpfSB2YWx1ZSBmbG9hdCB2YWx1ZS5cbiAgICovXG4gIHByby5zZXRVbmlmb3JtMWZ2ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLmNvbnRleHRfLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmdsUHJvZ3JhbSwgbmFtZSk7XG4gICAgdGhpcy5jb250ZXh0Xy51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHZhcmlhYmxlIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBpbnQgdmFsdWUuXG4gICAqL1xuICBwcm8uc2V0VW5pZm9ybTFpID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLmNvbnRleHRfLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLmdsUHJvZ3JhbSwgbmFtZSk7XG4gICAgdGhpcy5jb250ZXh0Xy51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IG1hcHBpbmcgb2YgdHlwZSBuYW1lcyB0byB1bmJvdW5kIHNldHRlciBmdW5jdGlvbnMuXG4gICAqL1xuICBwcm8uZ2V0TmFtZWRTZXR0ZXJGdW5jdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lZFNldHRlckZuc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9IG1hcHBpbmcgdHlwZSBuYW1lcyB0byBzZXR0ZXIgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvLm5hbWVkU2V0dGVyRm5zXyA9IHtcbiAgICAnMWknOiBwcm8uc2V0VW5pZm9ybTFpLFxuICAgICcxZic6IHByby5zZXRVbmlmb3JtMWYsXG4gICAgJzJmJzogcHJvLnNldFVuaWZvcm0yZlxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIHNoYWRlciBzb3VyY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0ZXggdHJ1ZSBmb3IgdmVydGV4IHNoYWRlciwgZmFsc2UgZm9yIGZyYWdtZW50XG4gICAqIHNoYWRlci5cbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9IHNoYWRlci5cbiAgICovXG4gIHByby5idWlsZFNoYWRlcl8gPSBmdW5jdGlvbihzb3VyY2UsIGlzVmVydGV4KSB7XG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKFxuICAgICAgaXNWZXJ0ZXggPyBnbC5WRVJURVhfU0hBREVSIDogZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBjb21waWxlIHNoYWRlcjogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH07XG5cbn0pO1xuXG4iLCIvLyAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuXG5nb29nLnByb3ZpZGUoJ3c2OWIuaW1nLk5vdFN1cHBvcnRlZEVycm9yJyk7XG5nb29nLnByb3ZpZGUoJ3c2OWIuaW1nLldlYkdMRmlsdGVyJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuZGVidWcuRXJyb3InKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuUkdCQUltYWdlRGF0YScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5XZWJHTFBhcmFtcycpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5XZWJHTFBpcGVsaW5lJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuaW1nLldlYkdMUHJvZ3JhbScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnNoYWRlcnMuZnJhZ0Nvb3JkVGVzdCcpO1xuXG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBXZWJHTFByb2dyYW0gPSB3NjliLmltZy5XZWJHTFByb2dyYW07XG4gIHZhciBSR0JBSW1hZ2VEYXRhID0gdzY5Yi5pbWcuUkdCQUltYWdlRGF0YTtcbiAgLyoqXG4gICAqIFRocm93biB3aGVuIHdlYmdsIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7Z29vZy5kZWJ1Zy5FcnJvcn1cbiAgICovXG4gIHc2OWIuaW1nLk5vdFN1cHBvcnRlZEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZ29vZy5iYXNlKHRoaXMpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKHc2OWIuaW1nLk5vdFN1cHBvcnRlZEVycm9yLCBnb29nLmRlYnVnLkVycm9yKTtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICB3NjliLmltZy5Ob3RTdXBwb3J0ZWRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdOb3RTdXBwb3J0ZWQnO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIGltYWdlcyB1c2luZyB3ZWJnbCBzaGFkZXJzLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50PX0gb3B0X2NhbnZhcyBjYW52YXMgdG8gdXNlLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIuaW1nLldlYkdMRmlsdGVyID0gZnVuY3Rpb24ob3B0X2NhbnZhcykge1xuICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoXG4gICAgICBvcHRfY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb250ZXh0XyA9IC8qKiBAdHlwZSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqLyAoXG4gICAgICAgIHRoaXMuY2FudmFzXy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XG4gICAgICAgICAgdGhpcy5jYW52YXNfLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250ZXh0XylcbiAgICAgIHRocm93IG5ldyB3NjliLmltZy5Ob3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgIHc2OWIuaW1nLldlYkdMRmlsdGVyLnRlc3RGcmFnQ29vcmRPZmZzZXQoKTtcblxuICAgIHRoaXMuZnJhbWVidWZmZXJfID0gdGhpcy5jb250ZXh0Xy5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICB9O1xuICB2YXIgXyA9IHc2OWIuaW1nLldlYkdMRmlsdGVyO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgXy5mcmFnQ29vcmRPZmZzZXRfID0gbnVsbDtcbiAgLy8gU2ltcGxlIHZlcnRleCBzaGFkZXIuXG5cbiAgdmFyIHBybyA9IHc2OWIuaW1nLldlYkdMRmlsdGVyLnByb3RvdHlwZTtcblxuXG4gIC8qKlxuICAgKiBSZW5kZXJpbmcgY29udGV4dCBvZiBiYWNrIGNhbnZhcy5cbiAgICogQHR5cGUge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByby5jb250ZXh0XyA9IG51bGw7XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIGNhbnZhcyB3aWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBjYW52YXMgaGVpZ2h0LlxuICAgKi9cbiAgcHJvLnNldFNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jYW52YXNfLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jYW52YXNfLmhlaWdodCA9IGhlaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aC5cbiAgICovXG4gIHByby5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhc18ud2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaGVpZ2h0LlxuICAgKi9cbiAgcHJvLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhc18uaGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdmlld3BvcnQgZm9yIG5leHQgcmVuZGVyaW5nIGNhbGwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGxlZnQgb2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBib3R0b20gb2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggc2l6ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBzaXplLlxuICAgKi9cbiAgcHJvLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuY29udGV4dF8udmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuYmluZCBmcmFtZWJ1ZmZlci5cbiAgICovXG4gIHByby51bmJpbmRGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dF87XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB3ZWJnbCBjb250ZXh0LlxuICAgKi9cbiAgcHJvLmdldENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0XztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkIHRleHR1cmUgaWQuXG4gICAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZS5cbiAgICovXG4gIHByby5nZXRUZXh0dXJlID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlc1tpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbnVtIHRleHR1cmVzLiBUaGUgZmlyc3QgdGV4dHVyZSBpc1xuICAgKi9cbiAgcHJvLmNyZWF0ZVRleHR1cmVzID0gZnVuY3Rpb24obnVtKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpXG4gICAgICB0aGlzLnRleHR1cmVzW2ldID0gdGhpcy5jcmVhdGVUZXh0dXJlKGksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIFVOUEFDS19GTElQX1lfV0VCR0wgcGFyYW1ldGVyIG9uIGdpdmVuIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0ZXh0dXJlIGlkLlxuICAgKi9cbiAgcHJvLnNldFRleHR1cmVGbGlwcGVkID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHRfO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZXNbaWRdKTtcbiAgICAvLyBmbGlwcGVkIGNvb3JkaW5hdGVzXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgMSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlIHRleHR1cmUgd2l0aCBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0ZXh0dXJlIHVuaXQgaWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3dpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGVpZ2h0IGluIHBpeHNlbHMuXG4gICAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZS5cbiAgICovXG4gIHByby5jcmVhdGVUZXh0dXJlID0gZnVuY3Rpb24oaWQsIG9wdF93aWR0aCwgb3B0X2hlaWdodCkge1xuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAvL3NldCBwcm9wZXJ0aWVzIGZvciB0aGUgdGV4dHVyZVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuXG4gICAgaWYgKG9wdF93aWR0aCAmJiBvcHRfaGVpZ2h0KVxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBvcHRfd2lkdGgsIG9wdF9oZWlnaHQsIDAsXG4gICAgICAgIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgLy8gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0YWNoIHRleHR1cmUgdG8gZnJhbWVidWZmZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSWQgdGV4dHVyZSBpZC5cbiAgICogQHBhcmFtIHtXZWJHTEZyYW1lYnVmZmVyPX0gb3B0X2ZyYW1lYnVmZmVyIGRlZmF1bHRzIHRvIHRoaXMuZnJhbWVidWZmZXIuXG4gICAqL1xuICBwcm8uYXR0YWNoVGV4dHVyZVRvRkIgPSBmdW5jdGlvbih0ZXh0dXJlSWQsIG9wdF9mcmFtZWJ1ZmZlcikge1xuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVzW3RleHR1cmVJZF07XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBvcHRfZnJhbWVidWZmZXIgfHwgdGhpcy5mcmFtZWJ1ZmZlcl8pO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9mZnNldCBmb3Igbm9ybWFsaXppbmcgZ2xfRnJhZ0Nvb3JkLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gb2Zmc2V0LlxuICAgKi9cbiAgcHJvLmdldEZyYWdDb29yZE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLmZyYWdDb29yZE9mZnNldF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpbWFnZSBkYXRhIG9mIGNhbnZhcy5cbiAgICogQHJldHVybiB7UkdCQUltYWdlRGF0YX0gaW1hZ2UgZGF0YS5cbiAgICovXG4gIHByby5nZXRJbWFnZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICB2YXIgaW1nZGF0YSA9IG5ldyBVaW50OEFycmF5KDQgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWdkYXRhKTtcbiAgICByZXR1cm4gbmV3IFJHQkFJbWFnZURhdGEod2lkdGgsIGhlaWdodCwgaW1nZGF0YSk7XG4gIH07XG5cblxuICAvKipcbiAgICogV2ViR0wgaW1wbGVtZW50YXRpb24gc3VwcGx5IGRpZmZlcmVudCBvZmZzZXRzIGZvciBnbF9GcmFnQ29vcmQgdG9cbiAgICogZnJhZ21lbnQgc2hhZGVycy4gRm9yIHRoZSBmaXJzdCBwaXhlbCB0aGlzIGNhbiBiZSAoMCwwKSwgKDAuNSwgMC41KVxuICAgKiBvciAoMS4wLCAxLjApLiBXZSBuZWVkIHRvIHRha2UgdGhpcyBpbnRvIGFjY291bnQgaW4gb3VyIHNoYWRlcnMuXG4gICAqL1xuICBfLnRlc3RGcmFnQ29vcmRPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoXy5mcmFnQ29vcmRPZmZzZXRfKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fFxuICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IDIwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAyMDtcbiAgICBjYW52YXMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKGdsLCB3NjliLnNoYWRlcnMuZnJhZ0Nvb3JkVGVzdCk7XG5cbiAgICBwcm9ncmFtLnVzZSgpO1xuICAgIHByb2dyYW0uaW5pdENvbW1vbkF0dHJpYnV0ZXMoKTtcblxuXG4gICAgcHJvZ3JhbS5kcmF3UmVjdCgpO1xuICAgIHZhciBpbWdkYXRhID0gbmV3IFVpbnQ4QXJyYXkoNCAqIGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCBnbC5SR0JBLFxuICAgICAgZ2wuVU5TSUdORURfQllURSwgaW1nZGF0YSk7XG5cbiAgICBmdW5jdGlvbiByb3VuZCh2YWwpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKDEwMCAqIHZhbCAvIDI1NSkgLyAxMDtcbiAgICB9XG5cbiAgICB2YXIgeE9mZnNldCA9IGltZ2RhdGFbMF07XG4gICAgdmFyIHlPZmZzZXQgPSBpbWdkYXRhWzFdO1xuICAgIC8vIGFzc3VtZSAwLjEgc3RlcHMuXG4gICAgeE9mZnNldCA9IHJvdW5kKHhPZmZzZXQpO1xuICAgIHlPZmZzZXQgPSByb3VuZCh5T2Zmc2V0KTtcbiAgICBfLmZyYWdDb29yZE9mZnNldF8gPSBbeE9mZnNldCwgeU9mZnNldF07XG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKCdkZXRlY3RlZCBmcmFnbWVudCBjb29yZCBvZmZzZXQ6ICgnICtcbiAgICAvLyAgIHhPZmZzZXQgKyAnICcgKyB5T2Zmc2V0ICsgJyknKTtcbiAgfTtcblxuXG59KTtcbiIsIi8vIChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5cbmdvb2cucmVxdWlyZSgnZ29vZy5tYXRoLlNpemUnKTtcbmdvb2cucHJvdmlkZSgndzY5Yi5pbWcuV2ViR0xCaW5hcml6ZXInKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuUkdCQUJpdE1hdHJpeCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5SR0JBSW1hZ2VEYXRhJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuaW1nLldlYkdMRmlsdGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuaW1nLldlYkdMUGFyYW1zJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuaW1nLldlYkdMUGlwZWxpbmUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuV2ViR0xQcm9ncmFtJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuc2hhZGVycy5iaW5hcml6ZUF2ZzEnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5zaGFkZXJzLmJpbmFyaXplR3JvdXAnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5zaGFkZXJzLmRlYnVnJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuc2hhZGVycy5lc3RpbWF0ZUJsYWNrJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuc2hhZGVycy5leHRyYWN0Q2hhbm5lbCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnNoYWRlcnMuZnJhZ0Nvb3JkVGVzdCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnNoYWRlcnMuZ2F1c3NCbHVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuc2hhZGVycy5ncmF5c2NhbGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5zaGFkZXJzLnJlY3RWZXJ0ZXgnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5zaGFkZXJzLnNjYWxlJyk7XG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIFdlYkdMRmlsdGVyID0gdzY5Yi5pbWcuV2ViR0xGaWx0ZXI7XG4gIHZhciBXZWJHTFByb2dyYW0gPSB3NjliLmltZy5XZWJHTFByb2dyYW07XG4gIHZhciBXZWJHTFBhcmFtcyA9IHc2OWIuaW1nLldlYkdMUGFyYW1zO1xuICB2YXIgV2ViR0xQaXBlbGluZSA9IHc2OWIuaW1nLldlYkdMUGlwZWxpbmU7XG4gIHZhciBSR0JBSW1hZ2VEYXRhID0gdzY5Yi5pbWcuUkdCQUltYWdlRGF0YTtcbiAgdmFyIFJHQkFCaXRNYXRyaXggPSB3NjliLmltZy5SR0JBQml0TWF0cml4O1xuICAvKipcbiAgICogV2ViR0wgc2hhZGVyIGJhc2VkIGltYWdlIGJpbmFyaXplci5cbiAgICogVGhlIGJhc2ljIGlkZWEgaXMgdG8gZXN0aW1hdGUgYW4gYXZlcmFnZSBibGFjayBsZXZlbCBmb3IgZWFjaCBwaXhlbCBieSBsb29raW5nIGF0XG4gICAqIG5laWdoYm91cmluZyBwaXhlbHMsIHdoaWxlIGNob29zaW5nIHRoZSBuZWlnaGJvdXJob29kIGxhcmdlIGVub3VnaCB0byBjb3ZlciBhIHN1ZmZpY2VudGx5XG4gICAqIGxhcmdlIGR5bmFtaWMgcmFuZ2UuXG4gICAqIFRoZW4gc2ltcGx5IGFwcGx5IHRocmVzaG9sZGluZyBiYXNlZCBvbiB0aGF0IHZhbHVlLlxuICAgKlxuICAgKiBJbiBkZXRhaWw6XG4gICAqIC0gU3VjY2Vzc2l2ZWx5IGFwcGx5IHNoYWRlcnMgdG8gY29tcHV0ZSBhIHNjYWxlIHNwYWNlIGFuZCB0aGUgZHluYW1pYyByYW5nZVxuICAgKiAoZ2F1c3NCbHVyLCBiaW5hcml6ZUF2ZzEsIGJpbmFyaXplR3JvdXApLlxuICAgKiAtIFJ1biBlc3RpbWF0ZUJsYWNrIHNoYWRlciB0byBwaWNrIGEgZ3JheSBsZXZlbCBlc3RpbWF0aW9uLiBJdCBqdXN0IGNob29zZXMgdGhlXG4gICAqIGdyYXkgbGV2ZWwgZnJvbSB0aGUgc21hbGxlc3Qgc2NhbGUgdGhhdCBzdGlsbCBzYXRpc2ZpZXMgYSBkeW5hbWljIHJhbmdlIGNvbnN0cmFpbnQuXG4gICAqIC0gUnVuIHRocmVzaG9sZGluZyBzaGFkZXIgdG8gYXBwbHkgdGhyZXNob2xkaW5nIG9uIGlucHV0IGltYWdlIGdyYXkgdmFsdWVzIHdpdGhcbiAgICogYmxhY2sgbGV2ZWwgZXN0aW1hdGlvbnMuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50PX0gb3B0X2NhbnZhcyBjYW52YXMgdG8gdXNlLlxuICAgKi9cbiAgdzY5Yi5pbWcuV2ViR0xCaW5hcml6ZXIgPSBmdW5jdGlvbihvcHRfY2FudmFzKSB7XG4gICAgdGhpcy5maWx0ZXJfID0gbmV3IFdlYkdMRmlsdGVyKG9wdF9jYW52YXMpO1xuICB9O1xuICB2YXIgcHJvID0gdzY5Yi5pbWcuV2ViR0xCaW5hcml6ZXIucHJvdG90eXBlO1xuICB2YXIgXyA9IHc2OWIuaW1nLldlYkdMQmluYXJpemVyO1xuICAvKipcbiAgICogQHR5cGUgez9ib29sZWFufVxuICAgKi9cbiAgXy5pc1N1cHBvcnRlZF8gPSBudWxsO1xuXG4gIHByby5waXBlbGluZV8gPSBudWxsO1xuICBwcm8uc2V0dXBDYWxsZWRfID0gZmFsc2U7XG4gIC8qKlxuICAgKiBJZiBjYW52YXMgaXMgZGlzcGxheWVkIGRpcmVjdGx5LCBpbnB1dCBkYXRhIG5lZWRzIHRvIGJlIGZsaXBwZWQgYXJvdW5kXG4gICAqIHkgYXhpcy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm8uZmxpcElucHV0XyA9IGZhbHNlO1xuXG5cbiAgLyoqXG4gICAqIFNpemUgb2YgbmF0aXZlIGlucHV0IGltYWdlL3ZpZGVvLlxuICAgKiBAdHlwZSB7P2dvb2cubWF0aC5TaXplfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvLmluU2l6ZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIGZyYWdtZW50IHNvdXJjZS5cbiAgICogQHJldHVybiB7dzY5Yi5pbWcuV2ViR0xQcm9ncmFtfSBjb21waWxlZCBwcm9ncmFtLlxuICAgKi9cbiAgcHJvLmdldFByb2dyYW0gPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFdlYkdMUHJvZ3JhbSh0aGlzLmZpbHRlcl8uZ2V0Q29udGV4dCgpLCBzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsaXAgd2hldGhlciB0byBmbGlwIGlucHV0IGFycm91bmQgeSBheGlzLlxuICAgKi9cbiAgcHJvLnNldEZsaXBJbnB1dCA9IGZ1bmN0aW9uKGZsaXApIHtcbiAgICB0aGlzLmZsaXBJbnB1dF8gPSBmbGlwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBiaW5hcml6ZXIgZm9yIGdpdmVuIGltYWdlIGRpbWVuc2lvbnMuXG4gICAqIE9ubHkgY2FsbCB0aGlzIG9uY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9pbldpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaW5IZWlnaHQgaW4gcGl4ZWxzLlxuICAgKi9cbiAgcHJvLnNldHVwID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0X2luV2lkdGgsIG9wdF9pbkhlaWdodCkge1xuICAgIGlmICghb3B0X2luSGVpZ2h0KVxuICAgICAgb3B0X2luSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmICghb3B0X2luV2lkdGgpXG4gICAgICBvcHRfaW5XaWR0aCA9IHdpZHRoO1xuICAgIGlmICghdGhpcy5zZXR1cENhbGxlZF8pIHtcbiAgICAgIC8vIGNvbXBpbGUgc2hhZGVyc1xuICAgICAgdGhpcy5wcm9ncmFtRHluUmFuZ2UxID0gdGhpcy5nZXRQcm9ncmFtKHc2OWIuc2hhZGVycy5iaW5hcml6ZUF2ZzEpO1xuICAgICAgdGhpcy5wcm9ncmFtRHluUmFuZ2UyID0gdGhpcy5nZXRQcm9ncmFtKHc2OWIuc2hhZGVycy5iaW5hcml6ZUdyb3VwKTtcbiAgICAgIHRoaXMucHJvZ3JhbUVzdGltYXRlQmxhY2sgPSB0aGlzLmdldFByb2dyYW0odzY5Yi5zaGFkZXJzLmVzdGltYXRlQmxhY2spO1xuICAgICAgdGhpcy5wcm9ncmFtVGhyZXNob2xkID0gdGhpcy5nZXRQcm9ncmFtKHc2OWIuc2hhZGVycy50aHJlc2hvbGQpO1xuICAgICAgdGhpcy5wcm9ncmFtR2F1c3MgPSB0aGlzLmdldFByb2dyYW0odzY5Yi5zaGFkZXJzLmdhdXNzQmx1cik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNldHVwQ2FsbGVkXyB8fFxuICAgICAgdGhpcy5maWx0ZXJfLmdldFdpZHRoKCkgIT0gd2lkdGggfHxcbiAgICAgIHRoaXMuZmlsdGVyXy5nZXRIZWlnaHQoKSAhPSBoZWlnaHQgfHxcbiAgICAgIHRoaXMuaW5TaXplXy53aWR0aCAhPSBvcHRfaW5XaWR0aCB8fFxuICAgICAgdGhpcy5pblNpemVfLmhlaWdodCAhPSBvcHRfaW5IZWlnaHQpIHtcbiAgICAgIHRoaXMuZmlsdGVyXy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5pblNpemVfID0gbmV3IGdvb2cubWF0aC5TaXplKG9wdF9pbldpZHRoLCBvcHRfaW5IZWlnaHQpO1xuICAgICAgdGhpcy5maWx0ZXJfLmNyZWF0ZVRleHR1cmVzKDMpO1xuICAgICAgaWYgKHRoaXMuZmxpcElucHV0XylcbiAgICAgICAgdGhpcy5maWx0ZXJfLnNldFRleHR1cmVGbGlwcGVkKDApO1xuICAgICAgdGhpcy5waXBlbGluZV8gPSB0aGlzLmNyZWF0ZVBpcGVsaW5lKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBDYWxsZWRfID0gdHJ1ZTtcbiAgfTtcblxuICBwcm8uY3JlYXRlUGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmZpbHRlcl8uZ2V0V2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5maWx0ZXJfLmdldEhlaWdodCgpO1xuICAgIHZhciBpblNpemUgPSB0aGlzLmluU2l6ZV87XG5cbiAgICB2YXIgcGlwZWxpbmUgPSBuZXcgV2ViR0xQaXBlbGluZSh0aGlzLmZpbHRlcl8pO1xuICAgIC8vIFNvbWUgc2hhZGVycyB0aGF0IGFyZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAvLyB2YXIgZ3JheXNjYWxlID0gbmV3IFdlYkdMUHJvZ3JhbShnbCwgdzY5Yi5zaGFkZXJzLmdyYXlzY2FsZSk7XG4gICAgLy8gdmFyIGR1bW15ID0gdGhpcy5nZXRQcm9ncmFtKHc2OWIuc2hhZGVycy5kdW1teSk7XG4gICAgLy8gdmFyIGV4dHJhY3RDaGFubmVsID0gdGhpcy5nZXRQcm9ncmFtKHc2OWIuc2hhZGVycy5leHRyYWN0Q2hhbm5lbCk7XG4gICAgLy8gdmFyIGRlYnVnID0gbmV3IFdlYkdMUHJvZ3JhbShnbCwgdzY5Yi5zaGFkZXJzLmRlYnVnKTtcbiAgICB2YXIgYmFzZVBhcmFtcyA9IG5ldyBXZWJHTFBhcmFtcyhcbiAgICAgIHtcbiAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG4gICAgICAgICdoZWlnaHQnOiBoZWlnaHQsXG4gICAgICAgICdpbndpZHRoJzogd2lkdGgsXG4gICAgICAgICdpbmhlaWdodCc6IGhlaWdodCxcbiAgICAgICAgJ3RleHdpZHRoJzogd2lkdGgsXG4gICAgICAgICd0ZXhoZWlnaHQnOiBoZWlnaHQsXG4gICAgICAgICdpbk9mZnNldCc6IFswLCAwXSxcbiAgICAgICAgJ291dE9mZnNldCc6IFswLCAwXSxcbiAgICAgICAgJ2ZyYWdDb29yZE9mZnNldCc6IHRoaXMuZmlsdGVyXy5nZXRGcmFnQ29vcmRPZmZzZXQoKVxuICAgICAgfSk7XG4gICAgdmFyIGRvd25TY2FsZVBvd2VyID0gMztcbiAgICB2YXIgc2NhbGVkV2l0aCA9IE1hdGgubWF4KDEsIHdpZHRoID4+IGRvd25TY2FsZVBvd2VyKTtcbiAgICB2YXIgc2NhbGVkSGVpZ2h0ID0gTWF0aC5tYXgoMSwgaGVpZ2h0ID4+IGRvd25TY2FsZVBvd2VyKTtcbiAgICB2YXIgc21hbGxJbWdQYXJhbXMgPSBiYXNlUGFyYW1zLmNsb25lKCkuc2V0KHtcbiAgICAgICd3aWR0aCc6IHNjYWxlZFdpdGgsXG4gICAgICAnaGVpZ2h0Jzogc2NhbGVkSGVpZ2h0LFxuICAgICAgJ2lud2lkdGgnOiBzY2FsZWRXaXRoLFxuICAgICAgJ2luaGVpZ2h0Jzogc2NhbGVkSGVpZ2h0XG4gICAgfSk7XG5cbiAgICAvLyBBcHBseSBnYXVzcyBhbmQgZG93bnNhbXBsZSB0byBzY2FsZWRXaWR0aC9IZWlnaHRcbiAgICBwaXBlbGluZS5hZGRQYXNzKHRoaXMucHJvZ3JhbUdhdXNzLFxuICAgICAgYmFzZVBhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAgICd3aWR0aCc6IHNjYWxlZFdpdGgsXG4gICAgICAgICdzYW1wbGVEaXJlY3Rpb24nOiBbMCwgMV0sXG4gICAgICAgICd0ZXh3aWR0aCc6IGluU2l6ZS53aWR0aCxcbiAgICAgICAgJ3RleGhlaWdodCc6IGluU2l6ZS5oZWlnaHRcbiAgICAgIH0pKTtcblxuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtR2F1c3MsXG4gICAgICBzbWFsbEltZ1BhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAgICdpbmhlaWdodCc6IGhlaWdodCxcbiAgICAgICAgJ3NhbXBsZURpcmVjdGlvbic6IFsxLCAwXVxuICAgICAgfSkpO1xuXG4gICAgLy8gQ29tcHV0ZSBtb3JlIGR5bmFtaWMgcmFuZ2VzIGFuZCB0d28gbW9yZSBzY2FsZXMgb24gZ3JheVxuICAgIC8vIGxldmVsIGltYWdlLCBpbiBhIGxheW91dCBuZXh0IHRvIGVhY2ggb3RoZXIuIEtlcm5lbCBzaXplIGluY3JlYXNlc1xuICAgIC8vIGZyb20gbGVmdCB0byByaWdodC5cbiAgICBwaXBlbGluZS5hZGRQYXNzKHRoaXMucHJvZ3JhbUR5blJhbmdlMSwgc21hbGxJbWdQYXJhbXMuY2xvbmUoKS5zZXQoe1xuICAgICAgJ3NhbXBsZURpcmVjdGlvbic6IFswLCAxXVxuICAgIH0pKTtcbiAgICBwaXBlbGluZS5hZGRQYXNzKHRoaXMucHJvZ3JhbUR5blJhbmdlMiwgc21hbGxJbWdQYXJhbXMuY2xvbmUoKS5zZXQoe1xuICAgICAgJ3NhbXBsZURpcmVjdGlvbic6IFsxLCAwXVxuICAgIH0pKTtcblxuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtRHluUmFuZ2UyLCBzbWFsbEltZ1BhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAnc2FtcGxlRGlyZWN0aW9uJzogWzAsIDJdXG4gICAgfSkpO1xuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtRHluUmFuZ2UyLCBzbWFsbEltZ1BhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAnc2FtcGxlRGlyZWN0aW9uJzogWzIsIDBdLFxuICAgICAgJ291dE9mZnNldCc6IFtzY2FsZWRXaXRoLCAwXVxuICAgIH0pKTtcblxuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtRHluUmFuZ2UyLCBzbWFsbEltZ1BhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAnc2FtcGxlRGlyZWN0aW9uJzogWzAsIDJdLFxuICAgICAgJ2luT2Zmc2V0JzogW3NjYWxlZFdpdGgsIDBdXG4gICAgfSkpO1xuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtRHluUmFuZ2UyLCBzbWFsbEltZ1BhcmFtcy5jbG9uZSgpLnNldCh7XG4gICAgICAnc2FtcGxlRGlyZWN0aW9uJzogWzIsIDBdLFxuICAgICAgJ291dE9mZnNldCc6IFtzY2FsZWRXaXRoICogMiwgMF1cbiAgICB9KSk7XG4gICAgLy8gVXNlIHNjYWxlIHNwYWNlIGFuZCBkeW5hbWljIHJhbmdlIGVzdGltYXRpb25zIHRvIGVzdGltYXRlIGJsYWNrIGxldmVsLlxuICAgIHBpcGVsaW5lLmFkZFBhc3ModGhpcy5wcm9ncmFtRXN0aW1hdGVCbGFjaywgc21hbGxJbWdQYXJhbXMpO1xuICAgIC8vIHBpcGVsaW5lLmFkZFBhc3MoZXh0cmFjdENoYW5uZWwsXG4gICAgLy8gIHNtYWxsSW1nUGFyYW1zLmNsb25lKCkuc2V0SW50KCdjaGFubmVsJywgMikpO1xuXG4gICAgcGlwZWxpbmUuYWRkUGFzcyh0aGlzLnByb2dyYW1UaHJlc2hvbGQsIHNtYWxsSW1nUGFyYW1zLmNsb25lKClcbiAgICAgIC5zZXRJbnQoJ29yaWdJbWFnZScsIDApXG4gICAgICAuc2V0KHtcbiAgICAgICAgJ3dpZHRoJzogaW5TaXplLndpZHRoLCAnaGVpZ2h0JzogaW5TaXplLmhlaWdodCxcbiAgICAgICAgJ2lud2lkdGgnOiBzY2FsZWRXaXRoLCAnaW5oZWlnaHQnOiBzY2FsZWRIZWlnaHRcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gcGlwZWxpbmU7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7dzY5Yi5pbWcuUkdCQUltYWdlRGF0YX0gaW1hZ2UgZGF0YS5cbiAgICovXG4gIHByby5nZXRJbWFnZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJfLmdldEltYWdlRGF0YSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt3NjliLmltZy5SR0JBQml0TWF0cml4fSBpbWFnZSBkYXRhIHdyYXBwZWQgaW4gUkdCQUJpdG1hdHJpeC5cbiAgICovXG4gIHByby5nZXRCaXRNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW1nZGF0YSA9IHRoaXMuZmlsdGVyXy5nZXRJbWFnZURhdGEoKTtcbiAgICByZXR1cm4gbmV3IFJHQkFCaXRNYXRyaXgoaW1nZGF0YS53aWR0aCwgaW1nZGF0YS5oZWlnaHQsIGltZ2RhdGEuZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KEltYWdlfEhUTUxWaWRlb0VsZW1lbnR8UkdCQUltYWdlRGF0YXxJbWFnZURhdGEpfSBpbWFnZSBpbWFnZVxuICAgKiB0byByZW5kZXIuXG4gICAqL1xuICBwcm8ucmVuZGVyID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICBpZiAoIXRoaXMuc2V0dXBDYWxsZWRfKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGdsID0gdGhpcy5maWx0ZXJfLmdldENvbnRleHQoKTtcbiAgICAvLyBiaW5kIGlucHV0IGltYWdlIHRvIHRleHR1cmUgMC5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmZpbHRlcl8uZ2V0VGV4dHVyZSgwKSk7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgUkdCQUltYWdlRGF0YSkge1xuICAgICAgLy8gY3VzdG9tIGltYWdlIGRhdGFcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCxcbiAgICAgICAgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UuZGF0YSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBpbWFnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5waXBlbGluZV8ucmVuZGVyKDAsIDEsIDIsIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQHJldHVybiB7dzY5Yi5pbWcuUkdCQUltYWdlRGF0YX0gdGVzdCBpbWFnZS5cbiAgICovXG4gIF8uY3JlYXRlU3VwcG9ydENoZWNrSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGltZ2RhdGEgPSBuZXcgVWludDhBcnJheSg0ICogd2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJ1aWxkIGdyYWRpZW50XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIHZhciBwb3MgPSA0ICogKHdpZHRoICogeSArIHgpO1xuICAgICAgICB2YXIgZ3JheSA9IHg7XG4gICAgICAgIGltZ2RhdGFbcG9zXSA9IGdyYXk7XG4gICAgICAgIGltZ2RhdGFbcG9zICsgMV0gPSBncmF5O1xuICAgICAgICBpbWdkYXRhW3BvcyArIDJdID0gZ3JheTtcbiAgICAgICAgaW1nZGF0YVtwb3MgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSR0JBSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQsIGltZ2RhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgXy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNyZWF0ZSB0ZXN0IGltYWdlXG4gICAgaWYgKF8uaXNTdXBwb3J0ZWRfID09PSBudWxsKSB7XG4gICAgICB2YXIgd2lkdGggPSAxMDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gMjA7XG4gICAgICB2YXIgaW1nID0gXy5jcmVhdGVTdXBwb3J0Q2hlY2tJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIC8vIHNldCBjb250cmFzdCBvbiBzb21lIHBpeGVscy5cbiAgICAgIGltZy5zZXRHcmF5KDMwLCA0LCAxOCk7XG4gICAgICBpbWcuc2V0R3JheSg5MCwgNCwgNTApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJpbmFyaXplciA9IG5ldyB3NjliLmltZy5XZWJHTEJpbmFyaXplcigpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAvLyBObyB3ZWJnbCBzdXBwb3J0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBiaW5hcml6ZXIuc2V0RmxpcElucHV0KGZhbHNlKTtcbiAgICAgIGJpbmFyaXplci5zZXR1cCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJpbmFyaXplci5yZW5kZXIoaW1nKTtcbiAgICAgIHZhciBiaW5hcnkgPSBiaW5hcml6ZXIuZ2V0SW1hZ2VEYXRhKCk7XG4gICAgICAvLyBDaGVjayBzb21lIGJsYWNrIGFuZCB3aGl0ZSB2YWx1ZXMuXG4gICAgICBfLmlzU3VwcG9ydGVkXyA9IChiaW5hcnkuZ2V0KDMwLCA0KVswXSA9PSAwICYmXG4gICAgICBiaW5hcnkuZ2V0KDkwLCA0KVswXSA9PSAwICYmXG4gICAgICBiaW5hcnkuZ2V0KDMxLCA0KVswXSA9PSAyNTUgJiZcbiAgICAgIGJpbmFyeS5nZXQoMjksIDQpWzBdID09IDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBfLmlzU3VwcG9ydGVkXztcbiAgfTtcblxufSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAwOCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE5hbWVzcGFjZSB3aXRoIGNyeXB0byByZWxhdGVkIGhlbHBlciBmdW5jdGlvbnMuXG4gKi9cblxuZ29vZy5wcm92aWRlKCdnb29nLmNyeXB0Jyk7XG5cbmdvb2cucmVxdWlyZSgnZ29vZy5hcnJheScpO1xuZ29vZy5yZXF1aXJlKCdnb29nLmFzc2VydHMnKTtcblxuXG4vKipcbiAqIFR1cm5zIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYnl0ZXM7IGEgXCJieXRlXCIgYmVpbmcgYSBKUyBudW1iZXIgaW4gdGhlXG4gKiByYW5nZSAwLTI1NS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHZhbHVlIHRvIGFycmlmeS5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBBcnJheSBvZiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gKiAgICAgVUNTIGNoYXJhY3RlciBjb2RlcyBvZiBlYWNoIGNoYXJhY3RlciBpbiBzdHIuXG4gKi9cbmdvb2cuY3J5cHQuc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIG91dHB1dCA9IFtdLCBwID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHdoaWxlIChjID4gMHhmZikge1xuICAgICAgb3V0cHV0W3ArK10gPSBjICYgMHhmZjtcbiAgICAgIGMgPj49IDg7XG4gICAgfVxuICAgIG91dHB1dFtwKytdID0gYztcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxuICovXG5nb29nLmNyeXB0LmJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyIENIVU5LX1NJWkUgPSA4MTkyO1xuXG4gIC8vIFNwZWNpYWwtY2FzZSB0aGUgc2ltcGxlIGNhc2UgZm9yIHNwZWVkJ3Mgc2FrZS5cbiAgaWYgKGJ5dGVzLmxlbmd0aCA8PSBDSFVOS19TSVpFKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG5cbiAgLy8gVGhlIHJlbWFpbmluZyBsb2dpYyBzcGxpdHMgY29udmVyc2lvbiBieSBjaHVua3Mgc2luY2VcbiAgLy8gRnVuY3Rpb24jYXBwbHkoKSBoYXMgYSBtYXhpbXVtIHBhcmFtZXRlciBjb3VudC5cbiAgLy8gU2VlIGRpc2N1c3Npb246IGh0dHA6Ly9nb28uZ2wvTHJXbVo5XG5cbiAgdmFyIHN0ciA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgdmFyIGNodW5rID0gZ29vZy5hcnJheS5zbGljZShieXRlcywgaSwgaSArIENIVU5LX1NJWkUpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgaGV4IHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZlxuICogdGhlIGhleCB2YWx1ZXMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxBcnJheTxudW1iZXI+fSBhcnJheSBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZ1xuICogICAgIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBzdHJpbmcuXG4gKi9cbmdvb2cuY3J5cHQuYnl0ZUFycmF5VG9IZXggPSBmdW5jdGlvbihhcnJheSkge1xuICByZXR1cm4gZ29vZy5hcnJheS5tYXAoYXJyYXksIGZ1bmN0aW9uKG51bUJ5dGUpIHtcbiAgICB2YXIgaGV4Qnl0ZSA9IG51bUJ5dGUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhCeXRlLmxlbmd0aCA+IDEgPyBoZXhCeXRlIDogJzAnICsgaGV4Qnl0ZTtcbiAgfSkuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIGludG8gYW4gaW50ZWdlciBhcnJheS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHJpbmcgSGV4IHN0cmluZyBvZiAxNi1iaXQgaW50ZWdlcnMgKHR3byBjaGFyYWN0ZXJzXG4gKiAgICAgcGVyIGludGVnZXIpLlxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IEFycmF5IG9mIHswLDI1NX0gaW50ZWdlcnMgZm9yIHRoZSBnaXZlbiBzdHJpbmcuXG4gKi9cbmdvb2cuY3J5cHQuaGV4VG9CeXRlQXJyYXkgPSBmdW5jdGlvbihoZXhTdHJpbmcpIHtcbiAgZ29vZy5hc3NlcnRzLmFzc2VydChoZXhTdHJpbmcubGVuZ3RoICUgMiA9PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICdLZXkgc3RyaW5nIGxlbmd0aCBtdXN0IGJlIG11bHRpcGxlIG9mIDInKTtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0cmluZy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGFyci5wdXNoKHBhcnNlSW50KGhleFN0cmluZy5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBcImJ5dGVcIiBhcnJheS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgMTYtYml0IHVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IFVURi04IGJ5dGUgYXJyYXkuXG4gKi9cbmdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXG4gIHZhciBvdXQgPSBbXSwgcCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgb3V0W3ArK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgYXJyYXkgdG8gSmF2YVNjcmlwdCdzIDE2LWJpdCBVbmljb2RlLlxuICogQHBhcmFtIHtVaW50OEFycmF5fEFycmF5PG51bWJlcj59IGJ5dGVzIFVURi04IGJ5dGUgYXJyYXkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IDE2LWJpdCBVbmljb2RlIHN0cmluZy5cbiAqL1xuZ29vZy5jcnlwdC51dGY4Qnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbihieXRlcykge1xuICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICB2YXIgb3V0ID0gW10sIHBvcyA9IDAsIGMgPSAwO1xuICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgdmFyIGMxID0gYnl0ZXNbcG9zKytdO1xuICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcbiAgICB9IGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICB2YXIgYzIgPSBieXRlc1twb3MrK107XG4gICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgdmFyIGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgIChjMSAmIDE1KSA8PCAxMiB8IChjMiAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogWE9SIHR3byBieXRlIGFycmF5cy5cbiAqIEBwYXJhbSB7IUFycmF5QnVmZmVyVmlld3whQXJyYXk8bnVtYmVyPn0gYnl0ZXMxIEJ5dGUgYXJyYXkgMS5cbiAqIEBwYXJhbSB7IUFycmF5QnVmZmVyVmlld3whQXJyYXk8bnVtYmVyPn0gYnl0ZXMyIEJ5dGUgYXJyYXkgMi5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBSZXN1bHRpbmcgWE9SIG9mIHRoZSB0d28gYnl0ZSBhcnJheXMuXG4gKi9cbmdvb2cuY3J5cHQueG9yQnl0ZUFycmF5ID0gZnVuY3Rpb24oYnl0ZXMxLCBieXRlczIpIHtcbiAgZ29vZy5hc3NlcnRzLmFzc2VydChcbiAgICAgIGJ5dGVzMS5sZW5ndGggPT0gYnl0ZXMyLmxlbmd0aCxcbiAgICAgICdYT1IgYXJyYXkgbGVuZ3RocyBtdXN0IG1hdGNoJyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzMS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGJ5dGVzMVtpXSBeIGJ5dGVzMltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAwNyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJhc2U2NCBlbi9kZWNvZGluZy4gTm90IG11Y2ggdG8gc2F5IGhlcmUgZXhjZXB0IHRoYXQgd2VcbiAqIHdvcmsgd2l0aCBkZWNvZGVkIHZhbHVlcyBpbiBhcnJheXMgb2YgYnl0ZXMuIEJ5IFwiYnl0ZVwiIEkgbWVhbiBhIG51bWJlclxuICogaW4gWzAsIDI1NV0uXG4gKlxuICogQGF1dGhvciBkb3VnaHRpZUBnb29nbGUuY29tIChHYXZpbiBEb3VnaHRpZSlcbiAqL1xuXG5nb29nLnByb3ZpZGUoJ2dvb2cuY3J5cHQuYmFzZTY0Jyk7XG5cbmdvb2cucmVxdWlyZSgnZ29vZy5hc3NlcnRzJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuY3J5cHQnKTtcbmdvb2cucmVxdWlyZSgnZ29vZy51c2VyQWdlbnQnKTtcblxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcblxuXG4vKipcbiAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmNyeXB0LmJhc2U2NC5ieXRlVG9DaGFyTWFwXyA9IG51bGw7XG5cblxuLyoqXG4gKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5jcnlwdC5iYXNlNjQuY2hhclRvQnl0ZU1hcF8gPSBudWxsO1xuXG5cbi8qKlxuICogTWFwcyBieXRlcyB0byB3ZWJzYWZlIGNoYXJhY3RlcnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0gbnVsbDtcblxuXG4vKipcbiAqIE1hcHMgd2Vic2FmZSBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuY3J5cHQuYmFzZTY0LmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IG51bGw7XG5cblxuLyoqXG4gKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmdvb2cuY3J5cHQuYmFzZTY0LkVOQ09ERURfVkFMU19CQVNFID1cbiAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICtcbiAgICAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICtcbiAgICAnMDEyMzQ1Njc4OSc7XG5cblxuLyoqXG4gKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZ29vZy5jcnlwdC5iYXNlNjQuRU5DT0RFRF9WQUxTID1cbiAgICBnb29nLmNyeXB0LmJhc2U2NC5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuXG5cbi8qKlxuICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5nb29nLmNyeXB0LmJhc2U2NC5FTkNPREVEX1ZBTFNfV0VCU0FGRSA9XG4gICAgZ29vZy5jcnlwdC5iYXNlNjQuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcblxuXG4vKipcbiAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxuICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmdvb2cuY3J5cHQuYmFzZTY0LkhBU19OQVRJVkVfU1VQUE9SVCA9IGdvb2cudXNlckFnZW50LkdFQ0tPIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb29nLnVzZXJBZ2VudC5XRUJLSVQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2cudXNlckFnZW50Lk9QRVJBIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YoZ29vZy5nbG9iYWwuYXRvYikgPT0gJ2Z1bmN0aW9uJztcblxuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fFVpbnQ4QXJyYXl9IGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcbiAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXG4gKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmdvb2cuY3J5cHQuYmFzZTY0LmVuY29kZUJ5dGVBcnJheSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfd2ViU2FmZSkge1xuICAvLyBBc3NlcnQgYXZvaWRzIHJ1bnRpbWUgZGVwZW5kZW5jeSBvbiBnb29nLmlzQXJyYXlMaWtlLCB3aGljaCBoZWxwcyByZWR1Y2VcbiAgLy8gc2l6ZSBvZiBqc2NvbXBpbGVyIG91dHB1dCwgYW5kIHdoaWNoIHlpZWxkcyBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UuXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnQoZ29vZy5pc0FycmF5TGlrZShpbnB1dCksXG4gICAgICAgICAgICAgICAgICAgICAgJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xuXG4gIGdvb2cuY3J5cHQuYmFzZTY0LmluaXRfKCk7XG5cbiAgdmFyIGJ5dGVUb0NoYXJNYXAgPSBvcHRfd2ViU2FmZSA/XG4gICAgICAgICAgICAgICAgICAgICAgZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfIDpcbiAgICAgICAgICAgICAgICAgICAgICBnb29nLmNyeXB0LmJhc2U2NC5ieXRlVG9DaGFyTWFwXztcblxuICB2YXIgb3V0cHV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBieXRlMSA9IGlucHV0W2ldO1xuICAgIHZhciBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xuICAgIHZhciBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xuXG4gICAgdmFyIG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICB2YXIgb3V0Qnl0ZTIgPSAoKGJ5dGUxICYgMHgwMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XG4gICAgdmFyIG91dEJ5dGUzID0gKChieXRlMiAmIDB4MEYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgIHZhciBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzRjtcblxuICAgIGlmICghaGF2ZUJ5dGUzKSB7XG4gICAgICBvdXRCeXRlNCA9IDY0O1xuXG4gICAgICBpZiAoIWhhdmVCeXRlMikge1xuICAgICAgICBvdXRCeXRlMyA9IDY0O1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLFxuICAgICAgICAgICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLFxuICAgICAgICAgICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTNdLFxuICAgICAgICAgICAgICAgIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcbiAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZ29vZy5jcnlwdC5iYXNlNjQuZW5jb2RlU3RyaW5nID0gZnVuY3Rpb24oaW5wdXQsIG9wdF93ZWJTYWZlKSB7XG4gIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgaWYgKGdvb2cuY3J5cHQuYmFzZTY0LkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhb3B0X3dlYlNhZmUpIHtcbiAgICByZXR1cm4gZ29vZy5nbG9iYWwuYnRvYShpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGdvb2cuY3J5cHQuYmFzZTY0LmVuY29kZUJ5dGVBcnJheShcbiAgICAgIGdvb2cuY3J5cHQuc3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQpLCBvcHRfd2ViU2FmZSk7XG59O1xuXG5cbi8qKlxuICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdG8gZGVjb2RlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxuICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICovXG5nb29nLmNyeXB0LmJhc2U2NC5kZWNvZGVTdHJpbmcgPSBmdW5jdGlvbihpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICBpZiAoZ29vZy5jcnlwdC5iYXNlNjQuSEFTX05BVElWRV9TVVBQT1JUICYmICFvcHRfd2ViU2FmZSkge1xuICAgIHJldHVybiBnb29nLmdsb2JhbC5hdG9iKGlucHV0KTtcbiAgfVxuICByZXR1cm4gZ29vZy5jcnlwdC5ieXRlQXJyYXlUb1N0cmluZyhcbiAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCBvcHRfd2ViU2FmZSkpO1xufTtcblxuXG4vKipcbiAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gKlxuICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcbiAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXG4gKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xuICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqL1xuZ29vZy5jcnlwdC5iYXNlNjQuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbihpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgZ29vZy5jcnlwdC5iYXNlNjQuaW5pdF8oKTtcblxuICB2YXIgY2hhclRvQnl0ZU1hcCA9IG9wdF93ZWJTYWZlID9cbiAgICAgICAgICAgICAgICAgICAgICBnb29nLmNyeXB0LmJhc2U2NC5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gOlxuICAgICAgICAgICAgICAgICAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LmNoYXJUb0J5dGVNYXBfO1xuXG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKSB7XG4gICAgdmFyIGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XG5cbiAgICB2YXIgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICB2YXIgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xuICAgICsraTtcblxuICAgIHZhciBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgIHZhciBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICsraTtcblxuICAgIHZhciBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgIHZhciBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICsraTtcblxuICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHxcbiAgICAgICAgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH1cblxuICAgIHZhciBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcbiAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XG5cbiAgICBpZiAoYnl0ZTMgIT0gNjQpIHtcbiAgICAgIHZhciBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweEYwKSB8IChieXRlMyA+PiAyKTtcbiAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcblxuICAgICAgaWYgKGJ5dGU0ICE9IDY0KSB7XG4gICAgICAgIHZhciBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweEMwKSB8IGJ5dGU0O1xuICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cblxuLyoqXG4gKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxuICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmNyeXB0LmJhc2U2NC5pbml0XyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWdvb2cuY3J5cHQuYmFzZTY0LmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcbiAgICBnb29nLmNyeXB0LmJhc2U2NC5jaGFyVG9CeXRlTWFwXyA9IHt9O1xuICAgIGdvb2cuY3J5cHQuYmFzZTY0LmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgIGdvb2cuY3J5cHQuYmFzZTY0LmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xuXG4gICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdvb2cuY3J5cHQuYmFzZTY0LkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xuICAgICAgZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcF9baV0gPVxuICAgICAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XG4gICAgICBnb29nLmNyeXB0LmJhc2U2NC5jaGFyVG9CeXRlTWFwX1tnb29nLmNyeXB0LmJhc2U2NC5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xuICAgICAgZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID1cbiAgICAgICAgICBnb29nLmNyeXB0LmJhc2U2NC5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XG4gICAgICBnb29nLmNyeXB0LmJhc2U2NC5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bXG4gICAgICAgICAgZ29vZy5jcnlwdC5iYXNlNjQuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG5cbiAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxuICAgICAgaWYgKGkgPj0gZ29vZy5jcnlwdC5iYXNlNjQuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XG4gICAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LmNoYXJUb0J5dGVNYXBfW1xuICAgICAgICAgICAgZ29vZy5jcnlwdC5iYXNlNjQuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LmNoYXJUb0J5dGVNYXBXZWJTYWZlX1tcbiAgICAgICAgICAgIGdvb2cuY3J5cHQuYmFzZTY0LkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuZ29vZy5wcm92aWRlKCd3NjliLmltZ3Rvb2xzJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xuZ29vZy5yZXF1aXJlKCdnb29nLmNyeXB0LmJhc2U2NCcpO1xuZ29vZy5yZXF1aXJlKCdnb29nLm1hdGguU2l6ZScpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgXyA9IHc2OWIuaW1ndG9vbHM7XG4gIHZhciBTaXplID0gZ29vZy5tYXRoLlNpemU7XG4gIHZhciBiYXNlNjQgPSBnb29nLmNyeXB0LmJhc2U2NDtcblxuICAvKipcbiAgICogR2V0IGNvbnRlbnQgb2YgY2FudmFzIGFzIHBuZyBzdG9yZWQgaW4gYSBibG9iLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgY2FudmFzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQmxvYil9IGNhbGxiYWNrIGNhbGxlZCB3aXRoIGJsb2IgZGF0YS5cbiAgICovXG4gIF8uZ2V0Q2FudmFzQXNCbG9iID0gZnVuY3Rpb24oY2FudmFzLCBjYWxsYmFjaykge1xuICAgIGlmIChjYW52YXNbJ3RvQmxvYiddKSB7XG4gICAgICAvLyB0b0Jsb2Igc3VwcG9ydGVkXG4gICAgICBjYW52YXNbJ3RvQmxvYiddKGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcy50b0RhdGFVUkwpIHtcbiAgICAgIHZhciB1cmwgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICB2YXIgcHJlZml4ID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnO1xuICAgICAgaWYgKCFnb29nLnN0cmluZy5zdGFydHNXaXRoKHVybCwgcHJlZml4KSlcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIHZhciBkYXRhID0gdXJsLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKTtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShiYXNlNjQuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoZGF0YSkpO1xuICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsndHlwZSc6ICdpbWFnZS9wbmcnfSk7XG4gICAgICBjYWxsYmFjayhibG9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBJbWFnZSBkYXRhIG9mIGdpdmVuIEltYWdlIG9iamVjdC4gU2FtZSBvcmlnaW4gcG9saWN5IGFwcGxpZXMgdG9cbiAgICogaW1hZ2Ugc3JjLiBJbWFnZSBoYXMgdG8gYmUgbG9hZGVkLiBJbWFnZSBpcyBzY2FsZWQgZG93biB0byBvcHRfbWF4U2l6ZVxuICAgKiBpZiBpdHMgd2lkdGggb3IgaGVpZ2h0IGlzIGxhcmdlci5cbiAgICogQHBhcmFtIHtJbWFnZXxIVE1MVmlkZW9FbGVtZW50fSBpbWcgaW1hZ2UuXG4gICAqIEBwYXJhbSB7KG51bWJlcnxTaXplKT19IG9wdF9tYXhTaXplIG1heCBzaXplIG9mIGFueSBkaW1lbnNpb24gaW4gcGl4ZWxzIG9yIFNpemUgb2JqZWN0XG4gICAqIHRoYXQgaW1nIGRhdGEgc2hvdWxkIGNvdmVyIChjcm9wcGluZyBib3R0b20tcmlnaHQgY29ybmVycykuXG4gICAqIEByZXR1cm4geyFJbWFnZURhdGF9IGltYWdlIGRhdGEuXG4gICAqL1xuICBfLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uKGltZywgb3B0X21heFNpemUpIHtcbiAgICB2YXIgc2l6ZSA9IG5ldyBTaXplKFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbWcud2lkdGggfHwgaW1nLnZpZGVvV2lkdGgpLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbWcuaGVpZ2h0IHx8IGltZy52aWRlb0hlaWdodCkpO1xuXG4gICAgZ29vZy5hc3NlcnRzLmFzc2VydChzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDApO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAob3B0X21heFNpemUpIHtcbiAgICAgIGlmIChnb29nLmlzTnVtYmVyKG9wdF9tYXhTaXplKSkge1xuICAgICAgICBvcHRfbWF4U2l6ZSA9IG5ldyBTaXplKG9wdF9tYXhTaXplLCBvcHRfbWF4U2l6ZSk7XG4gICAgICAgIGlmICghc2l6ZS5maXRzSW5zaWRlKG9wdF9tYXhTaXplKSlcbiAgICAgICAgICBzaXplID0gc2l6ZS5zY2FsZVRvRml0KG9wdF9tYXhTaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc2l6ZS5maXRzSW5zaWRlKG9wdF9tYXhTaXplKSlcbiAgICAgICAgICBzaXplID0gc2l6ZS5zY2FsZVRvQ292ZXIob3B0X21heFNpemUpO1xuICAgICAgfVxuICAgICAgc2l6ZS5mbG9vcigpO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjYWxlcyBzaXplIGluLXBsYWNlIHRvIGZpdCBtYXggaWYgbGFyZ2VyIGtlZXBpbmcgdGhlIGFzcGVjdCByYXRpby5cbiAgICogQHBhcmFtIHtTaXplfSBzaXplIG9yaWdpbmFsIHNpemUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggc2l6ZSBpbiBwaXhlbHMuXG4gICAqL1xuICBfLnNjYWxlSWZMYXJnZXIgPSBmdW5jdGlvbihzaXplLCBtYXgpIHtcbiAgICB2YXIgcyA9IE1hdGgubWluKG1heCAvIHNpemUud2lkdGgsIG1heCAvIHNpemUuaGVpZ2h0KTtcbiAgICBpZiAocyA8PSAxKSB7XG4gICAgICBzaXplLnNjYWxlKHMpLnJvdW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIGdvb2cuZXhwb3J0U3ltYm9sKCd3NjliLmltZ3Rvb2xzLmdldEltYWdlRGF0YScsIF8uZ2V0SW1hZ2VEYXRhKTtcbiAgZ29vZy5leHBvcnRTeW1ib2woJ3c2OWIuaW1ndG9vbHMuZ2V0Q2FudmFzQXNCbG9iJywgXy5nZXRDYW52YXNBc0Jsb2IpO1xufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5EZWNvZGVSZXN1bHQnKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5hc3NlcnRzJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUmVhZGVyRXJyb3InKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEVuY2Fwc3VsYXRlcyBkZWNvZGVkIHJlc3VsdCByZWFkZXIgZXJyb3IuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3x3NjliLnFyLlJlYWRlckVycm9yKX0gdGV4dCBkZWNvZGVkIHRleHQgb3IgZXJyb3IuXG4gICAqIEBwYXJhbSB7QXJyYXkuPHc2OWIucXIuUmVzdWx0UG9pbnQ+PX0gb3B0X3BhdHRlcm5zIHNlZCBmb3IgZGVjb2RpbmcuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5EZWNvZGVSZXN1bHQgPSBmdW5jdGlvbih0ZXh0LCBvcHRfcGF0dGVybnMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7KHN0cmluZ3x3NjliLnFyLlJlYWRlckVycm9yKX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0XyA9IHRleHQ7XG4gICAgdGhpcy5wYXR0ZXJuc18gPSBvcHRfcGF0dGVybnMgfHwgW107XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLnFyLkRlY29kZVJlc3VsdC5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIE9ubHkgYXZhaWxhYmxlIGlmIHJlc3VsdCBpcyBub3QgYW4gZXJyb3IuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IGRlY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgcHJvLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0Vycm9yKCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLnJlc3VsdF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiByZXN1bHQgd2FzIGFuIGVycm9yLlxuICAgKi9cbiAgcHJvLmlzRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMucmVzdWx0XyBpbnN0YW5jZW9mIHc2OWIucXIuUmVhZGVyRXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHs/dzY5Yi5xci5SZWFkZXJFcnJvcn0gZXJyb3IuXG4gICAqL1xuICBwcm8uZ2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0Vycm9yKCkpXG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHt3NjliLnFyLlJlYWRlckVycm9yfSAqLyAodGhpcy5yZXN1bHRfKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPHc2OWIucXIuUmVzdWx0UG9pbnQ+fSBkZWNvZGVkIHN0cmluZy5cbiAgICovXG4gIHByby5nZXRQYXR0ZXJucyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5zXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OIG9iamVjdC5cbiAgICovXG4gIHByb1sndG9KU09OJ10gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3RleHQnOiB0aGlzLmdldFRleHQoKSxcbiAgICAgICdwYXR0ZXJucyc6IHRoaXMuZ2V0UGF0dGVybnMoKX07XG4gIH07XG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLlJlc3VsdFBvaW50Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1ggeCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NZIHkgcG9zLlxuICAgKi9cbiAgdzY5Yi5xci5SZXN1bHRQb2ludCA9IGZ1bmN0aW9uKHBvc1gsIHBvc1kpIHtcbiAgICB0aGlzLnggPSBwb3NYO1xuICAgIHRoaXMueSA9IHBvc1k7XG4gIH07XG4gIHZhciBSZXN1bHRQb2ludCA9IHc2OWIucXIuUmVzdWx0UG9pbnQ7XG4gIHZhciBwcm8gPSBSZXN1bHRQb2ludC5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0geCBwb3MuXG4gICAqL1xuICAgIHByby5nZXRYID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSB5IHBvcy5cbiAgICovXG4gIHByby5nZXRZID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfTtcbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5BbGlnbm1lbnRQYXR0ZXJuJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUmVzdWx0UG9pbnQnKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEVuY2Fwc3VsYXRlcyBhbiBhbGlnbm1lbnQgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSBzbWFsbGVyIHNxdWFyZVxuICAgKiBwYXR0ZXJucyBmb3VuZCBpbiBhbGwgYnV0IHRoZSBzaW1wbGVzdCBRUiBDb2Rlcy5cbiAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICogcG9ydGVkIHRvIGpzIGJ5IE1hbnVlbCBCcmF1blxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zWCB4IHBvcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1kgeSBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlc3RpbWF0ZWRNb2R1bGVTaXplIG1vZHVsZSBzaXplLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge3c2OWIucXIuUmVzdWx0UG9pbnR9XG4gICAqL1xuICB3NjliLnFyLkFsaWdubWVudFBhdHRlcm4gPSBmdW5jdGlvbihwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplKSB7XG4gICAgZ29vZy5iYXNlKHRoaXMsIHBvc1gsIHBvc1kpO1xuICAgIHRoaXMuY291bnQgPSAxO1xuICAgIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gIH07XG4gIHZhciBBbGlnbm1lbnRQYXR0ZXJuID0gdzY5Yi5xci5BbGlnbm1lbnRQYXR0ZXJuO1xuICBnb29nLmluaGVyaXRzKEFsaWdubWVudFBhdHRlcm4sIHc2OWIucXIuUmVzdWx0UG9pbnQpO1xuICB2YXIgcHJvID0gQWxpZ25tZW50UGF0dGVybi5wcm90b3R5cGU7XG5cbiAgcHJvLmluY3JlbWVudENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb3VudCsrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgYWxpZ25tZW50IHBhdHRlcm4gXCJhYm91dCBlcXVhbHNcIiBhbiBhbGlnbm1lbnRcbiAgICogcGF0dGVybiBhdCB0aGUgc3RhdGVkXG4gICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHlcbiAgICogdGhlIHNhbWUgc2l6ZS5cbiAgICovXG4gIHByby5hYm91dEVxdWFscyA9IGZ1bmN0aW9uKG1vZHVsZVNpemUsIGksIGopIHtcbiAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMueSkgPD0gbW9kdWxlU2l6ZSAmJlxuICAgICAgTWF0aC5hYnMoaiAtIHRoaXMueCkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgdmFyIG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8XG4gICAgICAgIG1vZHVsZVNpemVEaWZmIC8gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplIDw9IDEuMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1vZHVsZSBzaXplLlxuICAgKi9cbiAgcHJvLmdldEVzdGltYXRlZE1vZHVsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvblxuICAgKiBhbmQgbW9kdWxlIHNpemVcbiAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS5cbiAgICogQHJldHVybiB7QWxpZ25tZW50UGF0dGVybn0gYSBuZXcgY29udGFpbmluZyBhbiBhdmVyYWdlIG9mIHRoZSB0d28uXG4gICAqL1xuICBwcm8uY29tYmluZUVzdGltYXRlID0gZnVuY3Rpb24oaSwgaiwgbmV3TW9kdWxlU2l6ZSkge1xuICAgIHZhciBjb21iaW5lZFggPSAodGhpcy54ICsgaikgLyAyLjA7XG4gICAgdmFyIGNvbWJpbmVkWSA9ICh0aGlzLnkgKyBpKSAvIDIuMDtcbiAgICB2YXIgY29tYmluZWRNb2R1bGVTaXplID0gKHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSArIG5ld01vZHVsZVNpemUpIC8gMi4wO1xuICAgIHJldHVybiBuZXcgQWxpZ25tZW50UGF0dGVybihjb21iaW5lZFgsIGNvbWJpbmVkWSwgY29tYmluZWRNb2R1bGVTaXplKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gb2JqZWN0IGZvciBwYXR0ZXJuLlxuICAgKi9cbiAgcHJvWyd0b0pTT04nXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAneCc6IHRoaXMuZ2V0WCgpLFxuICAgICAgJ3knOiB0aGlzLmdldFkoKSxcbiAgICAgICdzaXplJzogdGhpcy5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCl9O1xuICB9O1xuXG5cblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG4gbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG4gKi9cbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuQWxpZ25tZW50UGF0dGVybkZpbmRlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5CaXRNYXRyaXhMaWtlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQWxpZ25tZW50UGF0dGVybicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLk5vdEZvdW5kRXJyb3InKTtcblxuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgQWxpZ25tZW50UGF0dGVybiA9IHc2OWIucXIuQWxpZ25tZW50UGF0dGVybjtcbiAgdmFyIE5vdEZvdW5kRXJyb3IgPSB3NjliLnFyLk5vdEZvdW5kRXJyb3I7XG4gIC8qKlxuICAgKiBUaGlzIGNsYXNzIGF0dGVtcHRzIHRvIGZpbmQgYWxpZ25tZW50IHBhdHRlcm5zIGluIGEgUVIgQ29kZS5cbiAgICogQWxpZ25tZW50IHBhdHRlcm5zIGxvb2sgbGlrZSBmaW5kZXJcbiAgICogcGF0dGVybnMgYnV0IGFyZSBzbWFsbGVyIGFuZCBhcHBlYXIgYXQgcmVndWxhciBpbnRlcnZhbHMgdGhyb3VnaG91dCB0aGVcbiAgICogaW1hZ2UuXG4gICAqXG4gICAqIEF0IHRoZSBtb21lbnQgdGhpcyBvbmx5IGxvb2tzIGZvciB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuLlxuICAgKlxuICAgKlxuICAgKiBUaGlzIGlzIG1vc3RseSBhIHNpbXBsaWZpZWQgY29weSBvZiB7QGxpbmsgRmluZGVyUGF0dGVybkZpbmRlcn0uXG4gICAqIEl0IGlzIGNvcGllZCxcbiAgICogcGFzdGVkIGFuZCBzdHJpcHBlZCBkb3duIGhlcmUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UgYnV0IGRvZXNcbiAgICogdW5mb3J0dW5hdGVseSBkdXBsaWNhdGVcbiAgICogc29tZSBjb2RlLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50LiBFYWNoIHRocmVhZCBtdXN0IGFsbG9jYXRlXG4gICAqIGl0cyBvd24gb2JqZWN0LlxuICAgKlxuICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pIC0gcG9ydGVkIHRvIGpzXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyF3NjliLmltZy5CaXRNYXRyaXhMaWtlfSBpbWFnZSBpbWFnZSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFggbGVmdCBjb2x1bW4gZnJvbSB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFkgc3RhdCB0b3Agcm93IGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGggb2YgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vZHVsZVNpemUgc2l6ZSBtb2R1bGUgc2l6ZSBzbyBmYXIuXG4gICAqIEBwYXJhbSB7P3c2OWIucXIuUmVzdWx0UG9pbnRDYWxsYmFja30gcmVzdWx0UG9pbnRDYWxsYmFjayBjYWxsYmFjay5cbiAgICovXG4gIHc2OWIucXIuQWxpZ25tZW50UGF0dGVybkZpbmRlciA9IGZ1bmN0aW9uKGltYWdlLCBzdGFydFgsIHN0YXJ0WSwgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgbW9kdWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjaykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHshdzY5Yi5pbWcuQml0TWF0cml4TGlrZX1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0WCA9IHN0YXJ0WDtcbiAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5tb2R1bGVTaXplID0gbW9kdWxlU2l6ZTtcbiAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gbmV3IEFycmF5KDAsIDAsIDApO1xuICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gIH07XG4gIHZhciBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyID0gdzY5Yi5xci5BbGlnbm1lbnRQYXR0ZXJuRmluZGVyO1xuICB2YXIgcHJvID0gQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGU7XG5cbiAgcHJvLmNlbnRlckZyb21FbmQgPSBmdW5jdGlvbihzdGF0ZUNvdW50LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXRlQ291bnRbMl0pIC0gc3RhdGVDb3VudFsxXSAvIDIuMDtcbiAgfTtcbiAgcHJvLmZvdW5kUGF0dGVybkNyb3NzID0gZnVuY3Rpb24oc3RhdGVDb3VudCkge1xuICAgIHZhciBtb2R1bGVTaXplID0gdGhpcy5tb2R1bGVTaXplO1xuICAgIHZhciBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFtpXSkgPj0gbWF4VmFyaWFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwcm8uY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24oc3RhcnRJLCBjZW50ZXJKLCBtYXhDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgIHZhciBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuXG4gICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcbiAgICB2YXIgaSA9IHN0YXJ0STtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJlxuICAgICAgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxuICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCArIGkpICYmXG4gICAgICBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlclxuICAgIGkgPSBzdGFydEkgKyAxO1xuICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiZcbiAgICAgIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGkgPT0gbWF4SSB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbWF4SSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmXG4gICAgICBzdGF0ZUNvdW50WzJdIDw9IG1heENvdW50KSB7XG4gICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmIChzdGF0ZUNvdW50WzJdID4gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXTtcbiAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PVxuICAgICAgMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID9cbiAgICAgIHRoaXMuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LFxuICAgICAgICBpKSA6IE5hTjtcbiAgfTtcblxuICAvKiogPHA+VGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZmluZCB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuIGluIHRoZVxuICAgKiBpbWFnZS4gSXQgaXMgYSBiaXQgbWVzc3kgc2luY2UgaXQncyBwcmV0dHkgcGVyZm9ybWFuY2UtY3JpdGljYWwgYW5kIHNvIGlzXG4gICAqIHdyaXR0ZW4gdG8gYmUgZmFzdCBmb3JlbW9zdC48L3A+XG4gICAqXG4gICAqIEByZXR1cm4ge0FsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kIHRocm93cyBOb3RGb3VuZEVycm9yIGlmIG5vdFxuICAgKiBmb3VuZC5cbiAgICovXG4gIHByby5oYW5kbGVQb3NzaWJsZUNlbnRlciA9IGZ1bmN0aW9uKHN0YXRlQ291bnQsIGksIGopIHtcbiAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdO1xuICAgIHZhciBjZW50ZXJKID0gdGhpcy5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgIHZhciBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgTWF0aC5mbG9vcihjZW50ZXJKKSxcbiAgICAgIDIgKiBzdGF0ZUNvdW50WzFdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gKHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICtcbiAgICAgICAgc3RhdGVDb3VudFsyXSkgLyAzLjA7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5wb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xuICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxuICAgICAgICBpZiAoY2VudGVyLmFib3V0RXF1YWxzKGVzdGltYXRlZE1vZHVsZVNpemUsIGNlbnRlckksIGNlbnRlckopKSB7XG4gICAgICAgICAgcmV0dXJuIGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhhZG4ndCBmb3VuZCB0aGlzIGJlZm9yZTsgc2F2ZSBpdFxuICAgICAgdmFyIHBvaW50ID0gbmV3IEFsaWdubWVudFBhdHRlcm4oY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICh0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2socG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKiogPHA+VGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZmluZCB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuIGluIHRoZVxuICAgKiBpbWFnZS4gSXQgaXMgYSBiaXQgbWVzc3kgc2luY2UgaXQncyBwcmV0dHkgcGVyZm9ybWFuY2UtY3JpdGljYWwgYW5kIHNvIGlzXG4gICAqIHdyaXR0ZW4gdG8gYmUgZmFzdCBmb3JlbW9zdC48L3A+XG4gICAqXG4gICAqIEByZXR1cm4ge0FsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vdFxuICAgKiBmb3VuZC5cbiAgICovXG5cbiAgcHJvLmZpbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRYID0gdGhpcy5zdGFydFg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgdmFyIG1heEogPSBzdGFydFggKyB0aGlzLndpZHRoO1xuICAgIHZhciBtaWRkbGVJID0gdGhpcy5zdGFydFkgKyAoaGVpZ2h0ID4+IDEpO1xuICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluIDE6MToxIHJhdGlvO1xuICAgIC8vIHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBzZWVuIHNvIGZhclxuICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEFycmF5KDAsIDAsIDApO1xuICAgIGZvciAodmFyIGlHZW4gPSAwOyBpR2VuIDwgaGVpZ2h0OyBpR2VuKyspIHtcbiAgICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkc1xuICAgICAgdmFyIGkgPSBtaWRkbGVJICtcbiAgICAgICAgKChpR2VuICYgMHgwMSkgPT0gMCA/ICgoaUdlbiArIDEpID4+IDEpIDogLSgoaUdlbiArIDEpID4+IDEpKTtcbiAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgIHZhciBqID0gc3RhcnRYO1xuICAgICAgLy8gQnVybiBvZmYgbGVhZGluZyB3aGl0ZSBwaXhlbHMgYmVmb3JlIGFueXRoaW5nIGVsc2U7IGlmIHdlIHN0YXJ0IGluIHRoZVxuICAgICAgLy8gbWlkZGxlIG9mIGEgd2hpdGUgcnVuLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY291bnQgaXRzIGxlbmd0aCxcbiAgICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgaWYgdGhlIHdoaXRlIHJ1biBjb250aW51ZWQgdG8gdGhlIGxlZnQgb2YgdGhlXG4gICAgICAvLyBzdGFydCBwb2ludFxuICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcbiAgICAgIHdoaWxlIChqIDwgbWF4Sikge1xuICAgICAgICBpZiAoaW1hZ2UuZ2V0KGosIGkpKSB7XG4gICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09IDEpIHtcbiAgICAgICAgICAgIC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvdW50aW5nIHdoaXRlIHBpeGVsc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PSAyKSB7XG4gICAgICAgICAgICAgIC8vIEEgd2lubmVyP1xuICAgICAgICAgICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xuICAgICAgICAgICAgICAgIC8vIFllc1xuICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGopO1xuICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAxO1xuICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlQ291bnRbKytjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdoaXRlIHBpeGVsXG4gICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PSAxKSB7XG4gICAgICAgICAgICAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgfVxuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xuICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKKTtcbiAgICAgICAgaWYgKGNvbmZpcm1lZCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhtbSwgbm90aGluZyB3ZSBzYXcgd2FzIG9ic2VydmVkIGFuZCBjb25maXJtZWQgdHdpY2UuIElmIHdlIGhhZFxuICAgIC8vIGFueSBndWVzcyBhdCBhbGwsIHJldHVybiBpdC5cbiAgICBpZiAodGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVDZW50ZXJzWzBdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCk7XG4gIH07XG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiAqL1xuXG4vKlxuICpcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5CaXRNYXRyaXgnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuQml0TWF0cml4TGlrZScpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGguXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2hlaWdodCBoZWlnaHQgZGVmYXVsdHMgdG8gd2lkdGguXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7dzY5Yi5pbWcuQml0TWF0cml4TGlrZX1cbiAgICovXG4gIHc2OWIucXIuQml0TWF0cml4ID0gZnVuY3Rpb24od2lkdGgsIG9wdF9oZWlnaHQpIHtcbiAgICB2YXIgaGVpZ2h0ID0gZ29vZy5pc0RlZihvcHRfaGVpZ2h0KSA/IG9wdF9oZWlnaHQgOiB3aWR0aDtcbiAgICBpZiAod2lkdGggPCAxIHx8IGhlaWdodCA8IDEpIHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgcm93U2l6ZSA9IHdpZHRoID4+IDU7XG4gICAgaWYgKCh3aWR0aCAmIDB4MWYpICE9IDApIHtcbiAgICAgIHJvd1NpemUrKztcbiAgICB9XG4gICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcbiAgICB0aGlzLmJpdHMgPSBuZXcgVWludDMyQXJyYXkocm93U2l6ZSAqIGhlaWdodCk7XG4gIH07XG5cbiAgdmFyIEJpdE1hdHJpeCA9IHc2OWIucXIuQml0TWF0cml4O1xuICB2YXIgcHJvID0gQml0TWF0cml4LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIG1hdHJpeC5cbiAgICovXG4gIHByby5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIG1hdHJpeC5cbiAgICovXG4gIHByby5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHkgcG9zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBiaXQgYXQgZ2l2ZW4gcG9zaXRpb24uXG4gICAqL1xuICBwcm8uZ2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgKHggPj4gNSk7XG4gICAgcmV0dXJuICgodGhpcy5iaXRzW29mZnNldF0gPj4gKHggJiAweDFmKSkgJiAxKSAhPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYml0IGF0IGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCB4IHBvcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgeSBwb3MuXG4gICAqL1xuICBwcm8uc2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgKHggPj4gNSk7XG4gICAgdGhpcy5iaXRzW29mZnNldF0gfD0gMSA8PCAoeCAmIDB4MWYpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGbGlwIGJpdCBhdCBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHkgcG9zLlxuICAgKi9cbiAgcHJvLmZsaXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyAoeCA+PiA1KTtcbiAgICB0aGlzLmJpdHNbb2Zmc2V0XSBePSAxIDw8ICh4ICYgMHgxZik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIG1hdHJpeC5cbiAgICovXG4gIHByby5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXggPSB0aGlzLmJpdHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIHRoaXMuYml0c1tpXSA9IDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYml0cyBpbiBnaXZlbiByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnQgcG9zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIHRvcCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQuXG4gICAqL1xuICBwcm8uc2V0UmVnaW9uID0gZnVuY3Rpb24obGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRvcCA8IDAgfHwgbGVmdCA8IDApIHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPCAxIHx8IHdpZHRoIDwgMSkge1xuICAgICAgdGhyb3cgRXJyb3IoKTsgICAvLyBIZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgYXQgbGVhc3QgMVxuICAgIH1cbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICBpZiAoYm90dG9tID4gdGhpcy5oZWlnaHQgfHwgcmlnaHQgPiB0aGlzLndpZHRoKSB7XG4gICAgICB0aHJvdyBFcnJvcigpOyAgLy8gVGhlIHJlZ2lvbiBtdXN0IGZpdCBpbnNpZGUgdGhlIG1hdHJpeFxuICAgIH1cbiAgICBmb3IgKHZhciB5ID0gdG9wOyB5IDwgYm90dG9tOyB5KyspIHtcbiAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplO1xuICAgICAgZm9yICh2YXIgeCA9IGxlZnQ7IHggPCByaWdodDsgeCsrKSB7XG4gICAgICAgIHRoaXMuYml0c1tvZmZzZXQgKyAoeCA+PiA1KV0gfD0gMSA8PCAoeCAmIDB4MWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBtYXRyaXggYXMgc3RyaW5nLlxuICAgKi9cbiAgcHJvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZXQoeCwgeSkgPyAnWCAnIDogJyAgJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH07XG5cbn0pO1xuXG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5HcmlkU2FtcGxlcicpO1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLkdyaWRTYW1wbGVySW50ZXJmYWNlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuTm90Rm91bmRFcnJvcicpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG5cbiAgLyoqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIGNhbiwgZ2l2ZW4gbG9jYXRpb25zIG9mIGZpbmRlciBwYXR0ZXJucyBmb3JcbiAgICogYSBRUiBjb2RlIGluIGFuIGltYWdlLCBzYW1wbGUgdGhlIHJpZ2h0IHBvaW50cyBpbiB0aGUgaW1hZ2UgdG8gcmVjb25zdHJ1Y3RcbiAgICogdGhlIFFSIGNvZGUsIGFjY291bnRpbmcgZm9yIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uIEl0IGlzIGFic3RyYWN0ZWQgc2luY2VcbiAgICogaXQgaXMgcmVsYXRpdmVseSBleHBlbnNpdmUgYW5kIHNob3VsZCBiZSBhbGxvd2VkIHRvIHRha2UgYWR2YW50YWdlIG9mXG4gICAqIHBsYXRmb3JtLXNwZWNpZmljIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbnMsIGxpa2UgU3VuJ3MgSmF2YSBBZHZhbmNlZFxuICAgKiBJbWFnaW5nIGxpYnJhcnksIGJ1dCB3aGljaCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBvdGhlciBlbnZpcm9ubWVudHMgc3VjaFxuICAgKiBhcyBKMk1FLCBhbmQgdmljZSB2ZXJzYS5cbiAgICpcbiAgICogVGhlIGltcGxlbWVudGF0aW9uIHVzZWQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgY2FsbGluZyB7XG4gICAqIHNldEdyaWRTYW1wbGVyKEdyaWRTYW1wbGVyKX0gd2l0aCBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIHdoaWNoIGltcGxlbWVudHNcbiAgICogdGhpcyBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAqIEBhdXRob3IgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSkgLSBwb3J0ZWQgdG8ganNcbiAgICovXG5cbiAgdmFyIF8gPSB3NjliLnFyLkdyaWRTYW1wbGVyO1xuXG4gIF8uZ3JpZFNhbXBsZXIgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlciB1c2VkIGJ5IHRoZSBsaWJyYXJ5LiBPbmUgZ2xvYmFsXG4gICAqIGluc3RhbmNlIGlzIHN0b3JlZCwgd2hpY2ggbWF5IHNvdW5kIHByb2JsZW1hdGljLiBCdXQsIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKiBwcm92aWRlZCBvdWdodCB0byBiZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGVudGlyZSBwbGF0Zm9ybSwgYW5kIGFsbCB1c2VzIG9mXG4gICAqIHRoaXMgbGlicmFyeSBpbiB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIEpWTS4gRm9yIGluc3RhbmNlLCBhbiBBbmRyb2lkXG4gICAqIGFjdGl2aXR5IGNhbiBzd2FwIGluIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgdGFrZXMgYWR2YW50YWdlIG9mIG5hdGl2ZVxuICAgKiBwbGF0Zm9ybSBsaWJyYXJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5HcmlkU2FtcGxlckludGVyZmFjZX0gbmV3R3JpZFNhbXBsZXIgVGhlXG4gICAqIHBsYXRmb3JtLXNwZWNpZmljIG9iamVjdCB0byBpbnN0YWxsLlxuICAgKi9cbiAgXy5zZXRHcmlkU2FtcGxlciA9IGZ1bmN0aW9uKG5ld0dyaWRTYW1wbGVyKSB7XG4gICAgXy5ncmlkU2FtcGxlciA9IG5ld0dyaWRTYW1wbGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLkdyaWRTYW1wbGVySW50ZXJmYWNlfSB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlci5cbiAgICovXG4gIF8uZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5ncmlkU2FtcGxlcjtcbiAgfTtcblxuICAvKipcbiAgICogR3JpZCBzYW1wbGUgaW50ZXJmYWNlLlxuICAgKiBAaW50ZXJmYWNlXG4gICAqL1xuICB3NjliLnFyLkdyaWRTYW1wbGVySW50ZXJmYWNlID0gZnVuY3Rpb24oKSB7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhbXBsZXMgYW4gaW1hZ2UgZm9yIGEgcmVjdGFuZ3VsYXIgbWF0cml4IG9mIGJpdHMgb2YgdGhlIGdpdmVuIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHt3NjliLnFyLkJpdE1hdHJpeH0gaW1hZ2UgaW1hZ2UgdG8gc2FtcGxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGltZW5zaW9uWCB3aWR0aCBvZiBCaXRNYXRyaXggdG8gc2FtcGxlIGZyb20gaW1hZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaW1lbnNpb25ZIGhlaWdodCBvZiBCaXRNYXRyaXggdG8gc2FtcGxlIGZyb21cbiAgICogaW1hZ2UuXG4gICAqIEByZXR1cm4ge3c2OWIucXIuQml0TWF0cml4fSByZXByZXNlbnRpbmcgYSBncmlkIG9mIHBvaW50cyBzYW1wbGVkIGZyb21cbiAgICogdGhlIGltYWdlIHdpdGhpbiBhIHJlZ2lvbiBkZWZpbmVkIGJ5IHRoZSBcImZyb21cIiBwYXJhbWV0ZXJzIGJ5IHRoZSBnaXZlblxuICAgKiBwb2ludHMgaXMgaW52YWxpZCBvciByZXN1bHRzIGluIHNhbXBsaW5nIG91dHNpZGUgdGhlIGltYWdlIGJvdW5kYXJpZXMuXG4gICAqL1xuICB3NjliLnFyLkdyaWRTYW1wbGVySW50ZXJmYWNlLnByb3RvdHlwZS5zYW1wbGVHcmlkID0gZnVuY3Rpb24oaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwM1RvWSwgcDRUb1gsIHA0VG9ZLCBwMUZyb21YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDFGcm9tWSwgcDJGcm9tWCwgcDJGcm9tWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwNEZyb21ZKSB7XG5cbiAgfTtcblxuICAvKipcbiAgICogU2FtcGxlcyBhbiBpbWFnZSBmb3IgYSByZWN0YW5ndWxhciBtYXRyaXggb2YgYml0cyBvZiB0aGUgZ2l2ZW4gZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge3c2OWIucXIuQml0TWF0cml4fSBpbWFnZSBpbWFnZSB0byBzYW1wbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaW1lbnNpb25YIHdpZHRoIG9mIEJpdE1hdHJpeCB0byBzYW1wbGUgZnJvbSBpbWFnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbWVuc2lvblkgaGVpZ2h0IG9mIEJpdE1hdHJpeCB0byBzYW1wbGUgZnJvbVxuICAgKiBpbWFnZS5cbiAgICogQHBhcmFtIHt3NjliLnFyLlBlcnNwZWN0aXZlVHJhbnNmb3JtfSB0cmFuc2Zvcm0gdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLkJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIGEgZ3JpZCBvZiBwb2ludHMgc2FtcGxlZCBmcm9tXG4gICAqIHRoZSBpbWFnZSB3aXRoaW4gYSByZWdpb24gZGVmaW5lZCBieSB0aGUgXCJmcm9tXCIgcGFyYW1ldGVycyBieSB0aGUgZ2l2ZW5cbiAgICogcG9pbnRzIGlzIGludmFsaWQgb3IgcmVzdWx0cyBpbiBzYW1wbGluZyBvdXRzaWRlIHRoZSBpbWFnZSBib3VuZGFyaWVzLlxuICAgKi9cbiAgdzY5Yi5xci5HcmlkU2FtcGxlckludGVyZmFjZS5wcm90b3R5cGUuc2FtcGxlR3JpZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGltYWdlLCBkaW1lbnNpb25YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uWSwgdHJhbnNmb3JtKSB7XG4gIH07XG5cbiAgLyoqXG4gICAqIDxwPkNoZWNrcyBhIHNldCBvZiBwb2ludHMgdGhhdCBoYXZlIGJlZW4gdHJhbnNmb3JtZWQgdG8gc2FtcGxlIHBvaW50cyBvblxuICAgKiBhbiBpbWFnZSBhZ2FpbnN0IHRoZSBpbWFnZSdzIGRpbWVuc2lvbnMgdG8gc2VlIGlmIHRoZSBwb2ludCBhcmUgZXZlblxuICAgKiB3aXRoaW4gdGhlIGltYWdlLjwvcD5cbiAgICpcbiAgICogPHA+VGhpcyBtZXRob2Qgd2lsbCBhY3R1YWxseSBcIm51ZGdlXCIgdGhlIGVuZHBvaW50cyBiYWNrIG9udG8gdGhlIGltYWdlIGlmXG4gICAqIHRoZXkgYXJlIGZvdW5kIHRvIGJlIGJhcmVseSAobGVzcyB0aGFuIDEgcGl4ZWwpIG9mZiB0aGUgaW1hZ2UuIFRoaXNcbiAgICogYWNjb3VudHMgZm9yIGltcGVyZmVjdCBkZXRlY3Rpb24gb2YgZmluZGVyIHBhdHRlcm5zIGluIGFuIGltYWdlIHdoZXJlIHRoZVxuICAgKiBRUiBDb2RlIHJ1bnMgYWxsIHRoZSB3YXkgdG8gdGhlIGltYWdlIGJvcmRlci48L3A+XG4gICAqXG4gICAqIDxwPkZvciBlZmZpY2llbmN5LCB0aGUgbWV0aG9kIHdpbGwgY2hlY2sgcG9pbnRzIGZyb20gZWl0aGVyIGVuZCBvZiB0aGVcbiAgICogbGluZSB1bnRpbCBvbmUgaXMgZm91bmQgdG8gYmUgd2l0aGluIHRoZSBpbWFnZS4gQmVjYXVzZSB0aGUgc2V0IG9mIHBvaW50c1xuICAgKiBhcmUgYXNzdW1lZCB0byBiZSBsaW5lYXIsIHRoaXMgaXMgdmFsaWQuPC9wPlxuICAgKlxuICAgKiBAcGFyYW0ge3c2OWIucXIuQml0TWF0cml4fSBpbWFnZSBpbWFnZSBpbnRvIHdoaWNoIHRoZSBwb2ludHMgc2hvdWxkIG1hcC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRzIGFjdHVhbCBwb2ludHMgaW4geDEseTEsLi4uLHhuLHluIGZvcm0uXG4gICAqL1xuICBfLmNoZWNrQW5kTnVkZ2VQb2ludHMgPSBmdW5jdGlvbihpbWFnZSwgcG9pbnRzKSB7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIHN0YXJ0IHVudGlsIHdlIHNlZSBzb21lIHRoYXQgYXJlIE9LOlxuICAgIHZhciBudWRnZWQgPSB0cnVlO1xuICAgIHZhciB4LCB5LCBvZmZzZXQ7XG4gICAgZm9yIChvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgIHggPSBwb2ludHNbb2Zmc2V0XSA+PiAwO1xuICAgICAgeSA9IHBvaW50c1tvZmZzZXQgKyAxXSA+PiAwO1xuICAgICAgaWYgKHggPCAtMSB8fCB4ID4gd2lkdGggfHwgeSA8IC0xIHx8IHkgPiBoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IHc2OWIucXIuTm90Rm91bmRFcnJvcigpO1xuICAgICAgfVxuICAgICAgbnVkZ2VkID0gZmFsc2U7XG4gICAgICBpZiAoeCA9PSAtMSkge1xuICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IDAuO1xuICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh4ID09IHdpZHRoKSB7XG4gICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxO1xuICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHkgPT0gLTEpIHtcbiAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC47XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHkgPT0gaGVpZ2h0KSB7XG4gICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGFuZCBudWRnZSBwb2ludHMgZnJvbSBlbmQ6XG4gICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICBmb3IgKG9mZnNldCA9IHBvaW50cy5sZW5ndGggLSAyOyBvZmZzZXQgPj0gMCAmJiBudWRnZWQ7IG9mZnNldCAtPSAyKSB7XG4gICAgICB4ID0gcG9pbnRzW29mZnNldF0gPj4gMDtcbiAgICAgIHkgPSBwb2ludHNbb2Zmc2V0ICsgMV0gPj4gMDtcbiAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyB3NjliLnFyLk5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG51ZGdlZCA9IGZhbHNlO1xuICAgICAgaWYgKHggPT0gLTEpIHtcbiAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjtcbiAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoeCA9PSB3aWR0aCkge1xuICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcbiAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID09IC0xKSB7XG4gICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IDAuO1xuICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh5ID09IGhlaWdodCkge1xuICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSBoZWlnaHQgLSAxO1xuICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuUGVyc3BlY3RpdmVUcmFuc2Zvcm0nKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5QZXJzcGVjdGl2ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKGExMSwgYTIxLCBhMzEsIGExMiwgYTIyLCBhMzIsIGExMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyMywgYTMzKSB7XG4gICAgdGhpcy5hMTEgPSBhMTE7XG4gICAgdGhpcy5hMTIgPSBhMTI7XG4gICAgdGhpcy5hMTMgPSBhMTM7XG4gICAgdGhpcy5hMjEgPSBhMjE7XG4gICAgdGhpcy5hMjIgPSBhMjI7XG4gICAgdGhpcy5hMjMgPSBhMjM7XG4gICAgdGhpcy5hMzEgPSBhMzE7XG4gICAgdGhpcy5hMzIgPSBhMzI7XG4gICAgdGhpcy5hMzMgPSBhMzM7XG4gIH07XG4gIHZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybSA9IHc2OWIucXIuUGVyc3BlY3RpdmVUcmFuc2Zvcm07XG4gIHZhciBwcm8gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGU7XG4gIHByby50cmFuc2Zvcm1Qb2ludHMxID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgdmFyIG1heCA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGExMSA9IHRoaXMuYTExO1xuICAgIHZhciBhMTIgPSB0aGlzLmExMjtcbiAgICB2YXIgYTEzID0gdGhpcy5hMTM7XG4gICAgdmFyIGEyMSA9IHRoaXMuYTIxO1xuICAgIHZhciBhMjIgPSB0aGlzLmEyMjtcbiAgICB2YXIgYTIzID0gdGhpcy5hMjM7XG4gICAgdmFyIGEzMSA9IHRoaXMuYTMxO1xuICAgIHZhciBhMzIgPSB0aGlzLmEzMjtcbiAgICB2YXIgYTMzID0gdGhpcy5hMzM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwb2ludHNbaV07XG4gICAgICB2YXIgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcbiAgICAgIHBvaW50c1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9O1xuXG4gIHByby50cmFuc2Zvcm1Qb2ludHMyID0gZnVuY3Rpb24oeFZhbHVlcywgeVZhbHVlcykge1xuICAgIHZhciBuID0geFZhbHVlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciB4ID0geFZhbHVlc1tpXTtcbiAgICAgIHZhciB5ID0geVZhbHVlc1tpXTtcbiAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMuYTEzICogeCArIHRoaXMuYTIzICogeSArIHRoaXMuYTMzO1xuICAgICAgeFZhbHVlc1tpXSA9ICh0aGlzLmExMSAqIHggKyB0aGlzLmEyMSAqIHkgKyB0aGlzLmEzMSkgLyBkZW5vbWluYXRvcjtcbiAgICAgIHlWYWx1ZXNbaV0gPSAodGhpcy5hMTIgKiB4ICsgdGhpcy5hMjIgKiB5ICsgdGhpcy5hMzIpIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9O1xuXG4gIHByby5idWlsZEFkam9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDpcbiAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTIyICogdGhpcy5hMzMgLVxuICAgICAgdGhpcy5hMjMgKiB0aGlzLmEzMixcbiAgICAgIHRoaXMuYTIzICogdGhpcy5hMzEgLSB0aGlzLmEyMSAqIHRoaXMuYTMzLFxuICAgICAgdGhpcy5hMjEgKiB0aGlzLmEzMiAtIHRoaXMuYTIyICogdGhpcy5hMzEsXG4gICAgICB0aGlzLmExMyAqIHRoaXMuYTMyIC0gdGhpcy5hMTIgKiB0aGlzLmEzMyxcbiAgICAgIHRoaXMuYTExICogdGhpcy5hMzMgLSB0aGlzLmExMyAqIHRoaXMuYTMxLFxuICAgICAgdGhpcy5hMTIgKiB0aGlzLmEzMSAtIHRoaXMuYTExICogdGhpcy5hMzIsXG4gICAgICB0aGlzLmExMiAqIHRoaXMuYTIzIC0gdGhpcy5hMTMgKiB0aGlzLmEyMixcbiAgICAgIHRoaXMuYTEzICogdGhpcy5hMjEgLSB0aGlzLmExMSAqIHRoaXMuYTIzLFxuICAgICAgdGhpcy5hMTEgKiB0aGlzLmEyMiAtIHRoaXMuYTEyICogdGhpcy5hMjEpO1xuICB9O1xuXG4gIHByby50aW1lcyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh0aGlzLmExMSAqIG90aGVyLmExMSArXG4gICAgICB0aGlzLmEyMSAqIG90aGVyLmExMiArIHRoaXMuYTMxICogb3RoZXIuYTEzLFxuICAgICAgdGhpcy5hMTEgKiBvdGhlci5hMjEgKyB0aGlzLmEyMSAqIG90aGVyLmEyMiArIHRoaXMuYTMxICogb3RoZXIuYTIzLFxuICAgICAgdGhpcy5hMTEgKiBvdGhlci5hMzEgKyB0aGlzLmEyMSAqIG90aGVyLmEzMiArIHRoaXMuYTMxICogb3RoZXIuYTMzLFxuICAgICAgdGhpcy5hMTIgKiBvdGhlci5hMTEgKyB0aGlzLmEyMiAqIG90aGVyLmExMiArIHRoaXMuYTMyICogb3RoZXIuYTEzLFxuICAgICAgdGhpcy5hMTIgKiBvdGhlci5hMjEgKyB0aGlzLmEyMiAqIG90aGVyLmEyMiArIHRoaXMuYTMyICogb3RoZXIuYTIzLFxuICAgICAgdGhpcy5hMTIgKiBvdGhlci5hMzEgKyB0aGlzLmEyMiAqIG90aGVyLmEzMiArIHRoaXMuYTMyICogb3RoZXIuYTMzLFxuICAgICAgdGhpcy5hMTMgKiBvdGhlci5hMTEgKyB0aGlzLmEyMyAqIG90aGVyLmExMiArIHRoaXMuYTMzICogb3RoZXIuYTEzLFxuICAgICAgdGhpcy5hMTMgKiBvdGhlci5hMjEgKyB0aGlzLmEyMyAqIG90aGVyLmEyMiArIHRoaXMuYTMzICogb3RoZXIuYTIzLFxuICAgICAgdGhpcy5hMTMgKiBvdGhlci5hMzEgKyB0aGlzLmEyMyAqIG90aGVyLmEzMiArIHRoaXMuYTMzICogb3RoZXIuYTMzKTtcbiAgfTtcblxuICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsID0gZnVuY3Rpb24oXG4gICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4MHAsIHkwcCwgeDFwLCB5MXAsIHgycCwgeTJwLCB4M3AsIHkzcCkge1xuXG4gICAgdmFyIHFUb1MgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUoXG4gICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgIHZhciBzVG9RID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKFxuICAgICAgeDBwLCB5MHAsIHgxcCwgeTFwLCB4MnAsIHkycCwgeDNwLFxuICAgICAgeTNwKTtcbiAgICByZXR1cm4gc1RvUS50aW1lcyhxVG9TKTtcbiAgfTtcblxuICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgZHkyID0geTMgLSB5MjtcbiAgICB2YXIgZHkzID0geTAgLSB5MSArIHkyIC0geTM7XG4gICAgaWYgKGR5MiA9PSAwLjAgJiYgZHkzID09IDAuMCkge1xuICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh4MSAtIHgwLCB4MiAtIHgxLCB4MCwgeTEgLSB5MCwgeTIgLSB5MSxcbiAgICAgICAgeTAsXG4gICAgICAgIDAuMCwgMC4wLCAxLjApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZHgxID0geDEgLSB4MjtcbiAgICAgIHZhciBkeDIgPSB4MyAtIHgyO1xuICAgICAgdmFyIGR4MyA9IHgwIC0geDEgKyB4MiAtIHgzO1xuICAgICAgdmFyIGR5MSA9IHkxIC0geTI7XG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XG4gICAgICB2YXIgYTEzID0gKGR4MyAqIGR5MiAtIGR4MiAqIGR5MykgLyBkZW5vbWluYXRvcjtcbiAgICAgIHZhciBhMjMgPSAoZHgxICogZHkzIC0gZHgzICogZHkxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh4MSAtIHgwICsgYTEzICogeDEsIHgzIC0geDAgKyBhMjMgKiB4MyxcbiAgICAgICAgeDAsXG4gICAgICAgIHkxIC0geTAgKyBhMTMgKiB5MSwgeTMgLSB5MCArIGEyMyAqIHkzLCB5MCwgYTEzLCBhMjMsIDEuMCk7XG4gICAgfVxuICB9O1xuXG4gIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1NxdWFyZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiwgeTIsIHgzLCB5Mykge1xuICAgIC8vIEhlcmUsIHRoZSBhZGpvaW50IHNlcnZlcyBhcyB0aGUgaW52ZXJzZTpcbiAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKFxuICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKS5idWlsZEFkam9pbnQoKTtcbiAgfTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkRlZmF1bHRHcmlkU2FtcGxlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkJpdE1hdHJpeCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkdyaWRTYW1wbGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR3JpZFNhbXBsZXJJbnRlcmZhY2UnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5QZXJzcGVjdGl2ZVRyYW5zZm9ybScpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybSA9IHc2OWIucXIuUGVyc3BlY3RpdmVUcmFuc2Zvcm07XG4gIHZhciBHcmlkU2FtcGxlciA9IHc2OWIucXIuR3JpZFNhbXBsZXI7XG4gIHZhciBCaXRNYXRyaXggPSB3NjliLnFyLkJpdE1hdHJpeDtcbiAgLyoqXG4gICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAqIEBhdXRob3IgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSkgLSBwb3J0ZWQgdG8ganMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7dzY5Yi5xci5HcmlkU2FtcGxlckludGVyZmFjZX1cbiAgICovXG4gIHc2OWIucXIuRGVmYXVsdEdyaWRTYW1wbGVyID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLnFyLkRlZmF1bHRHcmlkU2FtcGxlci5wcm90b3R5cGU7XG5cbiAgcHJvLnNhbXBsZUdyaWQgPSBmdW5jdGlvbihpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgcDFUb1gsIHAxVG9ZLCBwMlRvWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDFGcm9tWSwgcDJGcm9tWCwgcDJGcm9tWSwgcDNGcm9tWCwgcDNGcm9tWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwNEZyb21YLCBwNEZyb21ZKSB7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChcbiAgICAgIHAxVG9YLCBwMVRvWSwgcDJUb1gsIHAyVG9ZLCBwM1RvWCwgcDNUb1ksIHA0VG9YLCBwNFRvWSxcbiAgICAgIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlR3JpZFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgdHJhbnNmb3JtKTtcbiAgfTtcblxuICBwcm8uc2FtcGxlR3JpZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGltYWdlLCBkaW1lbnNpb25YLCBkaW1lbnNpb25ZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSkge1xuICAgIGlmIChkaW1lbnNpb25YIDw9IDAgfHwgZGltZW5zaW9uWSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgdzY5Yi5xci5Ob3RGb3VuZEVycm9yKCk7XG4gICAgfVxuICAgIHZhciBiaXRzID0gbmV3IEJpdE1hdHJpeChkaW1lbnNpb25YLCBkaW1lbnNpb25ZKTtcbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KGRpbWVuc2lvblggPDwgMSk7XG4gICAgdmFyIHg7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkaW1lbnNpb25ZOyB5KyspIHtcbiAgICAgIHZhciBtYXggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIGlWYWx1ZSA9IHkgKyAwLjU7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgcG9pbnRzW3hdID0gKHggPj4gMSkgKyAwLjU7XG4gICAgICAgIHBvaW50c1t4ICsgMV0gPSBpVmFsdWU7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtUG9pbnRzMShwb2ludHMpO1xuICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gc2VlIGlmIHBvaW50cyB0cmFuc2Zvcm1lZCB0byBzb21ldGhpbmcgaW5zaWRlIHRoZVxuICAgICAgLy8gaW1hZ2U7IHN1ZmZpY2llbnQgdG8gY2hlY2sgdGhlIGVuZHBvaW50c1xuICAgICAgR3JpZFNhbXBsZXIuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBtYXg7IHggKz0gMikge1xuICAgICAgICAgIGlmIChpbWFnZS5nZXQocG9pbnRzW3hdID4+IDAsIHBvaW50c1t4ICsgMV0gPj4gMCkpIHtcbiAgICAgICAgICAgIC8vIEJsYWNrKC1pc2gpIHBpeGVsXG4gICAgICAgICAgICBiaXRzLnNldCh4ID4+IDEsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoYWlvb2JlKSB7XG4gICAgICAgIC8vIFRoaXMgZmVlbHMgd3JvbmcsIGJ1dCwgc29tZXRpbWVzIGlmIHRoZSBmaW5kZXIgcGF0dGVybnMgYXJlXG4gICAgICAgIC8vIG1pc2lkZW50aWZpZWQsIHRoZSByZXN1bHRpbmcgdHJhbnNmb3JtIGdldHMgXCJ0d2lzdGVkXCIgc3VjaCB0aGF0IGl0XG4gICAgICAgIC8vIG1hcHMgYSBzdHJhaWdodCBsaW5lIG9mIHBvaW50cyB0byBhIHNldCBvZiBwb2ludHMgd2hvc2UgZW5kcG9pbnRzXG4gICAgICAgIC8vIGFyZSBpbiBib3VuZHMsIGJ1dCBvdGhlcnMgYXJlIG5vdC4gVGhlcmUgaXMgcHJvYmFibHkgc29tZVxuICAgICAgICAvLyBtYXRoZW1hdGljYWwgd2F5IHRvIGRldGVjdCB0aGlzIGFib3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IElcbiAgICAgICAgLy8gZG9uJ3Qga25vdyB5ZXQuICBUaGlzIHJlc3VsdHMgaW4gYW4gdWdseSBydW50aW1lIGV4Y2VwdGlvbiBkZXNwaXRlXG4gICAgICAgIC8vIG91ciBjbGV2ZXIgY2hlY2tzIGFib3ZlIC0tIGNhbid0IGhhdmUgdGhhdC4gV2UgY291bGQgY2hlY2sgZWFjaFxuICAgICAgICAvLyBwb2ludCdzIGNvb3JkaW5hdGVzIGJ1dCB0aGF0IGZlZWxzIGR1cGxpY2F0aXZlLiBXZSBzZXR0bGUgZm9yXG4gICAgICAgIC8vIGNhdGNoaW5nIGFuZCB3cmFwcGluZyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uXG4gICAgICAgIHRocm93IG5ldyB3NjliLnFyLk5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpdHM7XG4gIH07XG5cbiAgLy8gc2V0IGRlZmF1bHQgZ3JpZCBzYW1wbGVyLlxuICBHcmlkU2FtcGxlci5zZXRHcmlkU2FtcGxlcihuZXcgdzY5Yi5xci5EZWZhdWx0R3JpZFNhbXBsZXIoKSk7XG5cbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRGVjb2RlSGludFR5cGUnKTtcblxuLyoqXG4gKiBEZWNvZGUgaGludCBrZXkgY29uc3RhbnRzLlxuICogQGVudW0ge251bWJlcn1cbiAqL1xudzY5Yi5xci5EZWNvZGVIaW50VHlwZSA9IHtcbiAgVFJZX0hBUkRFUjogMSxcbiAgQ0hBUkFDVEVSX1NFVDogMlxufTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5GaW5kZXJQYXR0ZXJuJyk7XG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRmluZGVyUGF0dGVybkluZm8nKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5SZXN1bHRQb2ludCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1ggeCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NZIHkgcG9zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZXN0aW1hdGVkTW9kdWxlU2l6ZSBlc3RpbWF0ZWQgc2l6ZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfY291bnQgY291bnQsIGRlZmF1bHRzIHRvIDEuXG4gICAqIEBleHRlbmRzIHt3NjliLnFyLlJlc3VsdFBvaW50fVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuRmluZGVyUGF0dGVybiA9IGZ1bmN0aW9uKHBvc1gsIHBvc1ksIGVzdGltYXRlZE1vZHVsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdF9jb3VudCkge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBwb3NYLCBwb3NZKTtcbiAgICB0aGlzLmNvdW50ID0gZ29vZy5pc0RlZihvcHRfY291bnQpID8gb3B0X2NvdW50IDogMTtcbiAgICB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgPSBlc3RpbWF0ZWRNb2R1bGVTaXplO1xuICB9O1xuICB2YXIgRmluZGVyUGF0dGVybiA9IHc2OWIucXIuRmluZGVyUGF0dGVybjtcbiAgZ29vZy5pbmhlcml0cyhGaW5kZXJQYXR0ZXJuLCB3NjliLnFyLlJlc3VsdFBvaW50KTtcbiAgdmFyIHBybyA9IEZpbmRlclBhdHRlcm4ucHJvdG90eXBlO1xuXG4gIHByby5pbmNyZW1lbnRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY291bnQrKztcbiAgfTtcblxuICBwcm8uZ2V0Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgfTtcblxuICBwcm8uYWJvdXRFcXVhbHMgPSBmdW5jdGlvbihtb2R1bGVTaXplLCBpLCBqKSB7XG4gICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLnkpIDw9IG1vZHVsZVNpemUgJiZcbiAgICAgIE1hdGguYWJzKGogLSB0aGlzLngpIDw9IG1vZHVsZVNpemUpIHtcbiAgICAgIHZhciBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fFxuICAgICAgICBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kXG4gICAqIG1vZHVsZSBzaXplXG4gICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmdcbiAgICogYSB3ZWlnaHRlZCBhdmVyYWdlIGJhc2VkIG9uIGNvdW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGogcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNb2R1bGVTaXplIHNpemUuXG4gICAqIEByZXR1cm4ge0ZpbmRlclBhdHRlcm59IGNvbWJpbmVkIHBhdHRlcm4uXG4gICAqL1xuICBwcm8uY29tYmluZUVzdGltYXRlID0gZnVuY3Rpb24oaSwgaiwgbmV3TW9kdWxlU2l6ZSkge1xuICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgdmFyIGNvbWJpbmVkQ291bnQgPSBjb3VudCArIDE7XG4gICAgdmFyIGNvbWJpbmVkWCA9IChjb3VudCAqIHRoaXMueCArIGopIC8gY29tYmluZWRDb3VudDtcbiAgICB2YXIgY29tYmluZWRZID0gKGNvdW50ICogdGhpcy55ICsgaSkgLyBjb21iaW5lZENvdW50O1xuICAgIHZhciBjb21iaW5lZE1vZHVsZVNpemUgPSAoY291bnQgKiB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgK1xuICAgICAgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xuICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybihjb21iaW5lZFgsIGNvbWJpbmVkWSxcbiAgICAgIGNvbWJpbmVkTW9kdWxlU2l6ZSwgY29tYmluZWRDb3VudCk7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1vZHVsZSBzaXplLlxuICAgKi9cbiAgcHJvLmdldEVzdGltYXRlZE1vZHVsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHggcG9zLlxuICAgKi9cbiAgcHJvLmdldFggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy54O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHkgcG9zLlxuICAgKi9cbiAgcHJvLmdldFkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy55O1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0XG4gICAqIEFCIDwgQUMgYW5kXG4gICAqIEJDIDwgQUMgYW5kXG4gICAqIHRoZSBhbmdsZSBiZXR3ZWVuIEJDIGFuZCBCQSBpcyBsZXNzIHRoYW4gMTgwIGRlZ3JlZXMuXG5cbiAgICogQHBhcmFtIHtBcnJheS48dzY5Yi5xci5GaW5kZXJQYXR0ZXJuPn0gcGF0dGVybnMgcGF0dGVybnMgdG8gc29ydC5cbiAgICovXG4gIEZpbmRlclBhdHRlcm4ub3JkZXJCZXN0UGF0dGVybnMgPSBmdW5jdGlvbihwYXR0ZXJucykge1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgICAgdmFyIHhEaWZmID0gcGF0dGVybjEueCAtIHBhdHRlcm4yLng7XG4gICAgICB2YXIgeURpZmYgPSBwYXR0ZXJuMS55IC0gcGF0dGVybjIueTtcbiAgICAgIHJldHVybiAoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHogY29tcG9uZW50IG9mIHRoZSBjcm9zcyBwcm9kdWN0IGJldHdlZW5cbiAgICAvLyB2ZWN0b3JzIEJDIGFuZCBCQS5cbiAgICBmdW5jdGlvbiBjcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIHtcbiAgICAgIHZhciBiWCA9IHBvaW50Qi54O1xuICAgICAgdmFyIGJZID0gcG9pbnRCLnk7XG4gICAgICByZXR1cm4gKChwb2ludEMueCAtIGJYKSAqIChwb2ludEEueSAtIGJZKSkgLVxuICAgICAgICAoKHBvaW50Qy55IC0gYlkpICogKHBvaW50QS54IC0gYlgpKTtcbiAgICB9XG5cblxuICAgIC8vIEZpbmQgZGlzdGFuY2VzIGJldHdlZW4gcGF0dGVybiBjZW50ZXJzXG4gICAgdmFyIHplcm9PbmVEaXN0YW5jZSA9IGRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1sxXSk7XG4gICAgdmFyIG9uZVR3b0Rpc3RhbmNlID0gZGlzdGFuY2UocGF0dGVybnNbMV0sIHBhdHRlcm5zWzJdKTtcbiAgICB2YXIgemVyb1R3b0Rpc3RhbmNlID0gZGlzdGFuY2UocGF0dGVybnNbMF0sIHBhdHRlcm5zWzJdKTtcblxuICAgIHZhciBwb2ludEEsIHBvaW50QiwgcG9pbnRDO1xuICAgIC8vIEFzc3VtZSBvbmUgY2xvc2VzdCB0byBvdGhlciB0d28gaXMgQjsgQSBhbmQgQyB3aWxsIGp1c3QgYmUgZ3Vlc3NlcyBhdFxuICAgIC8vIGZpcnN0LlxuICAgIGlmIChvbmVUd29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UgJiZcbiAgICAgIG9uZVR3b0Rpc3RhbmNlID49IHplcm9Ud29EaXN0YW5jZSkge1xuICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XG4gICAgICBwb2ludEEgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgIH0gZWxzZSBpZiAoemVyb1R3b0Rpc3RhbmNlID49IG9uZVR3b0Rpc3RhbmNlICYmXG4gICAgICB6ZXJvVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlKSB7XG4gICAgICBwb2ludEIgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzJdO1xuICAgICAgcG9pbnRBID0gcGF0dGVybnNbMF07XG4gICAgICBwb2ludEMgPSBwYXR0ZXJuc1sxXTtcbiAgICB9XG5cbiAgICAvLyBVc2UgY3Jvc3MgcHJvZHVjdCB0byBmaWd1cmUgb3V0IHdoZXRoZXIgQSBhbmQgQyBhcmUgY29ycmVjdCBvciBmbGlwcGVkLlxuICAgIC8vIFRoaXMgYXNrcyB3aGV0aGVyIEJDIHggQkEgaGFzIGEgcG9zaXRpdmUgeiBjb21wb25lbnQsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGFycmFuZ2VtZW50IHdlIHdhbnQgZm9yIEEsIEIsIEMuIElmIGl0J3MgbmVnYXRpdmUsIHRoZW4gd2UndmUgZ290IGl0XG4gICAgLy8gZmxpcHBlZCBhcm91bmQgYW5kIHNob3VsZCBzd2FwIEEgYW5kIEMuXG4gICAgaWYgKGNyb3NzUHJvZHVjdFoocG9pbnRBLCBwb2ludEIsIHBvaW50QykgPCAwLjApIHtcbiAgICAgIHZhciB0ZW1wID0gcG9pbnRBO1xuICAgICAgcG9pbnRBID0gcG9pbnRDO1xuICAgICAgcG9pbnRDID0gdGVtcDtcbiAgICB9XG5cbiAgICBwYXR0ZXJuc1swXSA9IHBvaW50QTtcbiAgICBwYXR0ZXJuc1sxXSA9IHBvaW50QjtcbiAgICBwYXR0ZXJuc1syXSA9IHBvaW50QztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gb2JqZWN0IGZvciBwYXR0ZXJuLlxuICAgKi9cbiAgcHJvWyd0b0pTT04nXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAneCc6IHRoaXMuZ2V0WCgpLFxuICAgICAgJ3knOiB0aGlzLmdldFkoKSxcbiAgICAgICdzaXplJzogdGhpcy5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCl9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPEZpbmRlclBhdHRlcm4+fSBwYXR0ZXJuQ2VudGVycyBzaXplIDMgYXJyYXkgd2l0aFxuICAgKiBib3R0b20gbGVmdCwgdG9wIGxlZnQgYW5kIHRvcCByaWdodCBjb3JuZXIuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5GaW5kZXJQYXR0ZXJuSW5mbyA9IGZ1bmN0aW9uKHBhdHRlcm5DZW50ZXJzKSB7XG4gICAgLy8gQm90dG9tIGxlZnQgYW5kIHRvcCByaWdodCBpcyBmbGlwcGVkLiBXaHk/XG4gICAgdGhpcy5ib3R0b21MZWZ0ID0gcGF0dGVybkNlbnRlcnNbMF07XG4gICAgdGhpcy50b3BMZWZ0ID0gcGF0dGVybkNlbnRlcnNbMV07XG4gICAgdGhpcy50b3BSaWdodCA9IHBhdHRlcm5DZW50ZXJzWzJdO1xuICB9O1xufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkZpbmRlclBhdHRlcm5GaW5kZXInKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5hcnJheScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5CaXRNYXRyaXhMaWtlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRGVjb2RlSGludFR5cGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5GaW5kZXJQYXR0ZXJuJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRmluZGVyUGF0dGVybkluZm8nKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Ob3RGb3VuZEVycm9yJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUVJJbWFnZScpO1xuXG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBGaW5kZXJQYXR0ZXJuID0gdzY5Yi5xci5GaW5kZXJQYXR0ZXJuO1xuICB2YXIgRmluZGVyUGF0dGVybkluZm8gPSB3NjliLnFyLkZpbmRlclBhdHRlcm5JbmZvO1xuXG4gIC8qKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKHc2OWIucXIuQWxpZ25tZW50UGF0dGVybnx3NjliLnFyLkZpbmRlclBhdHRlcm4pKX0gKi9cbiAgdzY5Yi5xci5SZXN1bHRQb2ludENhbGxiYWNrO1xuXG4gIC8qKlxuICAgKiA8cD5UaGlzIGNsYXNzIGF0dGVtcHRzIHRvIGZpbmQgZmluZGVyIHBhdHRlcm5zIGluIGEgUVIgQ29kZS4gRmluZGVyXG4gICAqIHBhdHRlcm5zIGFyZSB0aGUgc3F1YXJlXG4gICAqIG1hcmtlcnMgYXQgdGhyZWUgY29ybmVycyBvZiBhIFFSIENvZGUuPC9wPlxuICAgKlxuICAgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50LiBFYWNoIHRocmVhZCBtdXN0IGFsbG9jYXRlXG4gICAqIGl0cyBvd24gb2JqZWN0LlxuICAgKlxuICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgKiBwb3J0ZWQgdG8ganMgYnkgTWFudWVsIEJyYXVuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyF3NjliLmltZy5CaXRNYXRyaXhMaWtlfSBpbWFnZSBiaW5hcnkgaW1hZ2UuXG4gICAqIEBwYXJhbSB7P3c2OWIucXIuUmVzdWx0UG9pbnRDYWxsYmFjaz19IG9wdF9jYWxsYmFjayBjYWxsYmFjay5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB3NjliLnFyLkZpbmRlclBhdHRlcm5GaW5kZXIgPSBmdW5jdGlvbihpbWFnZSwgb3B0X2NhbGxiYWNrKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyF3NjliLmltZy5CaXRNYXRyaXhMaWtlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEZpbmRlclBhdHRlcm4+fVxuICAgICAqL1xuICAgIHRoaXMucG9zc2libGVDZW50ZXJzXyA9IFtdO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudF8gPSBuZXcgQXJyYXkoNSk7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez93NjliLnFyLlJlc3VsdFBvaW50Q2FsbGJhY2t9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2tfID0gb3B0X2NhbGxiYWNrIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhc1NraXBwZWRfID0gZmFsc2U7XG5cbiAgfTtcbiAgdmFyIF8gPSB3NjliLnFyLkZpbmRlclBhdHRlcm5GaW5kZXI7XG4gIHZhciBwcm8gPSB3NjliLnFyLkZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlO1xuXG4gIC8vIG1hbnU6IGNoYW5nZWQgZnJvbSAyIHRvIDMgZm9yIG1vcmUgcm9idXN0bmVzcy5cbiAgXy5DRU5URVJfUVVPUlVNID0gMjtcbiAgXy5NSU5fU0tJUCA9IDM7IC8vIDEgcGl4ZWwvbW9kdWxlIHRpbWVzIDMgbW9kdWxlcy9jZW50ZXJcbiAgXy5NQVhfTU9EVUxFUyA9IDU3OyAvLyBzdXBwb3J0IHVwIHRvIHZlcnNpb24gMTAgZm9yIG1vYmlsZSBjbGllbnRzXG4gIF8uSU5URUdFUl9NQVRIX1NISUZUID0gODtcblxuICAvLyBNYXhpbXVtIHNrZXcgZXJyb3IgdG8gc2tpcCBzY2FubmluZyBzb29uLlxuICBfLlNLRVdfVEhSRVNIT0xEID0gMC4wNTtcbiAgLy8gUHJlY29tcHV0ZWQgY29tYmluYXRpb25zIGZvciAzIG91dCBvZiA2LlxuICBfLlNLRVdfQ09NQklOQVRJT05TID0gW1xuICAgIFswLCAxLCAyXSxcbiAgICBbMCwgMSwgM10sXG4gICAgWzAsIDEsIDRdLFxuICAgIFswLCAxLCA1XSxcbiAgICBbMCwgMiwgM10sXG4gICAgWzAsIDIsIDRdLFxuICAgIFswLCAyLCA1XSxcbiAgICBbMCwgMywgNF0sXG4gICAgWzAsIDMsIDVdLFxuICAgIFswLCA0LCA1XSxcbiAgICBbMSwgMiwgM10sXG4gICAgWzEsIDIsIDRdLFxuICAgIFsxLCAyLCA1XSxcbiAgICBbMSwgMywgNF0sXG4gICAgWzEsIDMsIDVdLFxuICAgIFsxLCA0LCA1XSxcbiAgICBbMiwgMywgNF0sXG4gICAgWzIsIDMsIDVdLFxuICAgIFsyLCA0LCA1XSxcbiAgICBbMywgNCwgNV1cbiAgXTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9oaW50cyBoaW50cy5cbiAgICogQHJldHVybiB7RmluZGVyUGF0dGVybkluZm99IGluZm8uXG4gICAqL1xuICBwcm8uZmluZCA9IGZ1bmN0aW9uKG9wdF9oaW50cykge1xuICAgIHZhciB0cnlIYXJkZXIgPSBvcHRfaGludHMgJiYgISFvcHRfaGludHNbdzY5Yi5xci5EZWNvZGVIaW50VHlwZS5UUllfSEFSREVSXTtcbiAgICB2YXIgbWF4SSA9IHRoaXMuaW1hZ2VfLmhlaWdodDtcbiAgICB2YXIgbWF4SiA9IHRoaXMuaW1hZ2VfLndpZHRoO1xuICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluXG4gICAgLy8gMToxOjM6MToxIHJhdGlvOyB0aGlzIHRyYWNrcyB0aGUgbnVtYmVyIG9mIHN1Y2ggbW9kdWxlcyBzZWVuIHNvIGZhclxuXG4gICAgLy8gTGV0J3MgYXNzdW1lIHRoYXQgdGhlIG1heGltdW0gdmVyc2lvbiBRUiBDb2RlIHdlIHN1cHBvcnQgdGFrZXMgdXAgMS80XG4gICAgLy8gdGhlIGhlaWdodCBvZiB0aGVcbiAgICAvLyB0aGlzLmltYWdlXywgYW5kIHRoZW4gYWNjb3VudCBmb3IgdGhlIGNlbnRlciBiZWluZyAzIG1vZHVsZXMgaW4gc2l6ZS5cbiAgICAvLyBUaGlzIGdpdmVzIHRoZSBzbWFsbGVzdFxuICAgIC8vIG51bWJlciBvZiBwaXhlbHMgdGhlIGNlbnRlciBjb3VsZCBiZSwgc28gc2tpcCB0aGlzIG9mdGVuLiBXaGVuIHRyeWluZ1xuICAgIC8vIGhhcmRlciwgbG9vayBmb3IgYWxsXG4gICAgLy8gUVIgdmVyc2lvbnMgcmVnYXJkbGVzcyBvZiBob3cgZGVuc2UgdGhleSBhcmUuXG4gICAgdmFyIGlTa2lwID0gTWF0aC5mbG9vcigoMyAqIG1heEkpIC8gKDQgKiBfLk1BWF9NT0RVTEVTKSk7XG4gICAgaWYgKGlTa2lwIDwgXy5NSU5fU0tJUCB8fCB0cnlIYXJkZXIpIHtcbiAgICAgIGlTa2lwID0gXy5NSU5fU0tJUDtcbiAgICB9XG5cbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEFycmF5KDUpO1xuICAgIHZhciBjb25maXJtZWQ7XG4gICAgZm9yICh2YXIgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcbiAgICAgIC8vIEdldCBhIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXNcbiAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgIHN0YXRlQ291bnRbM10gPSAwO1xuICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4SjsgaisrKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlXy5nZXQoaiwgaSkpIHtcbiAgICAgICAgICAvLyBCbGFjayBwaXhlbFxuICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT0gMSkgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgfSBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICBpZiAoKGN1cnJlbnRTdGF0ZSAmIDEpID09IDApIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09IDQpIHsgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgIGlmIChfLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllc1xuICAgICAgICAgICAgICAgIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgaik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZXhhbWluaW5nIGV2ZXJ5IG90aGVyIGxpbmUuIENoZWNraW5nIGVhY2ggbGluZVxuICAgICAgICAgICAgICAgICAgLy8gdHVybmVkIG91dCB0byBiZSB0b29cbiAgICAgICAgICAgICAgICAgIC8vIGV4cGVuc2l2ZSBhbmQgZGlkbid0IGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgICBpU2tpcCA9IDI7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkXykge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1NraXAgPiBzdGF0ZUNvdW50WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJldHdlZW4gcm93IG9mIGxvd2VyIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdG9wIG9mIHByZXN1bWVkIHRoaXJkIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgYmFjayB1cCBhIGJpdCB0byBnZXQgYSBmdWxsIGNoYW5jZSBvZiBkZXRlY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdCwgZW50aXJlIHdpZHRoIG9mIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVyblxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBieSByb3dTa2lwLCBidXQgYmFjayBvZmYgYnkgc3RhdGVDb3VudFsyXVxuICAgICAgICAgICAgICAgICAgICAgIC8vIChzaXplIG9mIGxhc3QgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gb2YgcGF0dGVybiB3ZSBzYXcpIHRvIGJlIGNvbnNlcnZhdGl2ZSwgYW5kIGFsc29cbiAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIG9mZiBieSBpU2tpcCB3aGljaFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgaSArPSByb3dTa2lwIC0gc3RhdGVDb3VudFsyXSAtIGlTa2lwO1xuICAgICAgICAgICAgICAgICAgICAgIGogPSBtYXhKIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xuICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbGVhciBzdGF0ZSB0byBzdGFydCBsb29raW5nIGFnYWluXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gTm8sIHNoaWZ0IGNvdW50cyBiYWNrIGJ5IHR3b1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlQ291bnRbKytjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXG4gICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XG4gICAgICAgIGlmIChjb25maXJtZWQpIHtcbiAgICAgICAgICBpU2tpcCA9IHN0YXRlQ291bnRbMF07XG4gICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZF8pIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgdGhpcmQgb25lXG4gICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnModHJ1ZSk7XG4gICAgdzY5Yi5xci5GaW5kZXJQYXR0ZXJuLm9yZGVyQmVzdFBhdHRlcm5zKHBhdHRlcm5JbmZvKTtcblxuICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybkluZm8ocGF0dGVybkluZm8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHNlZW4gYW5kIGFuXG4gICAqIGVuZCBwb3NpdGlvbixcbiAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIHJ1bi5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc3RhdGVDb3VudCBzdGF0ZSBjb3VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBlbmQgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gcG9zaXRpb24uXG4gICAqL1xuICBwcm8uY2VudGVyRnJvbUVuZCA9IGZ1bmN0aW9uKHN0YXRlQ291bnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFs0XSAtIHN0YXRlQ291bnRbM10pIC0gc3RhdGVDb3VudFsyXSAvIDIuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzdGF0ZUNvdW50IGNvdW50IG9mXG4gICAqIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHJlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWZmIHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgY291bnRzIGlzIGNsb3NlIGVub3VnaFxuICAgKiB0byB0aGUgMS8xLzMvMS8xIHJhdGlvcyB1c2VkIGJ5IGZpbmRlciBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2guXG4gICAqL1xuICBfLmZvdW5kUGF0dGVybkNyb3NzID0gZnVuY3Rpb24oc3RhdGVDb3VudCkge1xuICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICB2YXIgY291bnQgPSBzdGF0ZUNvdW50W2ldO1xuICAgICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdG90YWxNb2R1bGVTaXplICs9IGNvdW50O1xuICAgIH1cbiAgICBpZiAodG90YWxNb2R1bGVTaXplIDwgNykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbW9kdWxlU2l6ZSA9IE1hdGguZmxvb3IoKHRvdGFsTW9kdWxlU2l6ZSA8PCBfLklOVEVHRVJfTUFUSF9TSElGVCkgLyA3KTtcbiAgICB2YXIgbWF4VmFyaWFuY2UgPSBNYXRoLmZsb29yKG1vZHVsZVNpemUgLyAyKTtcbiAgICAvLyBBbGxvdyBsZXNzIHRoYW4gNTAlIHZhcmlhbmNlIGZyb20gMS0xLTMtMS0xIHByb3BvcnRpb25zXG4gICAgcmV0dXJuIE1hdGguYWJzKG1vZHVsZVNpemUgLSAoc3RhdGVDb3VudFswXSA8PCBfLklOVEVHRVJfTUFUSF9TSElGVCkpIDxcbiAgICAgIG1heFZhcmlhbmNlICYmXG4gICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gKHN0YXRlQ291bnRbMV0gPDwgXy5JTlRFR0VSX01BVEhfU0hJRlQpKSA8XG4gICAgICAgIG1heFZhcmlhbmNlICYmXG4gICAgICBNYXRoLmFicygzICogbW9kdWxlU2l6ZSAtIChzdGF0ZUNvdW50WzJdIDw8IF8uSU5URUdFUl9NQVRIX1NISUZUKSkgPFxuICAgICAgICAzICogbWF4VmFyaWFuY2UgJiZcbiAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSAoc3RhdGVDb3VudFszXSA8PCBfLklOVEVHRVJfTUFUSF9TSElGVCkpIDxcbiAgICAgICAgbWF4VmFyaWFuY2UgJiZcbiAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSAoc3RhdGVDb3VudFs0XSA8PCBfLklOVEVHRVJfTUFUSF9TSElGVCkpIDxcbiAgICAgICAgbWF4VmFyaWFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBjb3VudC5cbiAgICovXG4gIHByby5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnRfWzBdID0gMDtcbiAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50X1sxXSA9IDA7XG4gICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudF9bMl0gPSAwO1xuICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnRfWzNdID0gMDtcbiAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50X1s0XSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICogXCJjcm9zcy1jaGVja3NcIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZVxuICAgKiBwb3NzaWJsZSBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzXG4gICAqIGEgZmluZGVyIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdFxuICAgKiBzaG91bGQgYmVvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gICAqIGhvcml6b250YWwgc2Nhbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIG5vZG9jLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZlcnRpY2FsIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVybiwgb3Ige0BsaW5rIE5hTn1cbiAgICogaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgcHJvLmNyb3NzQ2hlY2tWZXJ0aWNhbCA9IGZ1bmN0aW9uKHN0YXJ0SSwgY2VudGVySiwgbWF4Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2VfO1xuXG4gICAgdmFyIG1heEkgPSBpbWFnZS5oZWlnaHQ7XG4gICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG5cbiAgICAvLyBTdGFydCBjb3VudGluZyB1cCBmcm9tIGNlbnRlclxuICAgIHZhciBpID0gc3RhcnRJO1xuICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpKSB7XG4gICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgd2hpbGUgKGkgPj0gMCAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmXG4gICAgICBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiZcbiAgICAgIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgaSA9IHN0YXJ0SSArIDE7XG4gICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkge1xuICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoaSA9PSBtYXhJKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IG1heEkgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJlxuICAgICAgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICBzdGF0ZUNvdW50WzNdKys7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmIChpID09IG1heEkgfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJlxuICAgICAgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICBzdGF0ZUNvdW50WzRdKys7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuXG4gICAgLy8gNDAlIGRpZmZlcmVudCB0aGFuIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArXG4gICAgICBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXG4gICAgICBzdGF0ZUNvdW50WzRdO1xuICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49XG4gICAgICAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgcmV0dXJuIF8uZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgP1xuICAgICAgdGhpcy5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5MaWtlIHtAbGluayAjY3Jvc3NDaGVja1ZlcnRpY2FsKGludCwgaW50LCBpbnQsIGludCl9LCBhbmQgaW4gZmFjdFxuICAgKiBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsLCBleGNlcHQgaXQgcmVhZHMgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2ZcbiAgICogdmVydGljYWxseS4gVGhpcyBpcyB1c2VkIHRvIGNyb3NzLWNyb3NzIGNoZWNrIGEgdmVydGljYWwgY3Jvc3MgY2hlY2tcbiAgICogYW5kIGxvY2F0ZSB0aGUgcmVhbCBjZW50ZXIgb2YgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SiBjb2wgd2hlcmUgYSBmaW5kZXIgcGF0dGVybiB3YXMgZGV0ZWN0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJJIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYVxuICAgKiBmaW5kZXIgcGF0dGVybi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZFxuICAgKiBiZSBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWxcbiAgICogc2Nhbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIG5vZG9jLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGhvcml6b250YWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciBOYU4gaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgcHJvLmNyb3NzQ2hlY2tIb3Jpem9udGFsID0gZnVuY3Rpb24oc3RhcnRKLCBjZW50ZXJJLCBtYXhDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlXztcblxuICAgIHZhciBtYXhKID0gaW1hZ2Uud2lkdGg7XG4gICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG5cbiAgICB2YXIgaiA9IHN0YXJ0SjtcbiAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkge1xuICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgai0tO1xuICAgIH1cbiAgICBpZiAoaiA8IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHdoaWxlIChqID49IDAgJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJlxuICAgICAgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgai0tO1xuICAgIH1cbiAgICBpZiAoaiA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJlxuICAgICAgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgai0tO1xuICAgIH1cbiAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGogPSBzdGFydEogKyAxO1xuICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkpIHtcbiAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgIGorKztcbiAgICB9XG4gICAgaWYgKGogPT0gbWF4Sikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiZcbiAgICAgIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgaisrO1xuICAgIH1cbiAgICBpZiAoaiA9PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiZcbiAgICAgIHN0YXRlQ291bnRbNF0gPCBtYXhDb3VudCkge1xuICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgaisrO1xuICAgIH1cbiAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzXG4gICAgLy8gc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgdGhhblxuICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArXG4gICAgICBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XG4gICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj1cbiAgICAgIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHJldHVybiBfLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID9cbiAgICAgIHRoaXMuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKSA6IE5hTjtcbiAgfTtcblxuICAvKipcbiAgICogPHA+VGhpcyBpcyBjYWxsZWQgd2hlbiBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvc3NpYmxlIGFsaWdubWVudFxuICAgKiBwYXR0ZXJuLiBJdCB3aWxsIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCxcbiAgICogd2lsbCwgYWgsIGNyb3NzLWNyb3NzLWNoZWNrIHdpdGggYW5vdGhlciBob3Jpem9udGFsIHNjYW4uIFRoaXMgaXMgbmVlZGVkXG4gICAqIHByaW1hcmlseSB0byBsb2NhdGUgdGhlIHJlYWwgaG9yaXpvbnRhbCBjZW50ZXIgb2YgdGhlIHBhdHRlcm4gaW4gY2FzZXMgb2ZcbiAgICogZXh0cmVtZSBza2V3LjwvcD5cbiAgICpcbiAgICogPHA+SWYgdGhhdCBzdWNjZWVkcyB0aGUgZmluZGVyIHBhdHRlcm4gbG9jYXRpb24gaXMgYWRkZWQgdG8gYSBsaXN0IHRoYXRcbiAgICogdHJhY2tzIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBsb2NhdGlvbiBoYXMgYmVlbiBuZWFybHktbWF0Y2hlZCBhcyBhXG4gICAqIGZpbmRlciBwYXR0ZXJuLiAgRWFjaCBhZGRpdGlvbmFsIGZpbmQgaXMgbW9yZSBldmlkZW5jZSB0aGF0IHRoZSBsb2NhdGlvblxuICAgKiBpcyBpbiBmYWN0IGEgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb21cbiAgICogaG9yaXpvbnRhbCBzY2FuLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSByb3cgd2hlcmUgZmluZGVyIHBhdHRlcm4gbWF5IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaiBlbmQgb2YgcG9zc2libGUgZmluZGVyIHBhdHRlcm4gaW4gcm93LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGEgZmluZGVyIHBhdHRlcm4gY2FuZGlkYXRlIHdhcyBmb3VuZCB0aGlzIHRpbWUuXG4gICAqL1xuICBwcm8uaGFuZGxlUG9zc2libGVDZW50ZXIgPSBmdW5jdGlvbihzdGF0ZUNvdW50LCBpLCBqKSB7XG4gICAgdmFyIHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICtcbiAgICAgIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTtcbiAgICB2YXIgY2VudGVySiA9IHRoaXMuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKTtcbiAgICB2YXIgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIE1hdGguZmxvb3IoY2VudGVySiksXG4gICAgICBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcbiAgICAgIC8vIFJlLWNyb3NzIGNoZWNrXG4gICAgICBjZW50ZXJKID0gdGhpcy5jcm9zc0NoZWNrSG9yaXpvbnRhbChNYXRoLmZsb29yKGNlbnRlckopLFxuICAgICAgICBNYXRoLmZsb29yKGNlbnRlckkpLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSkge1xuICAgICAgICB2YXIgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IHN0YXRlQ291bnRUb3RhbCAvIDcuO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucG9zc2libGVDZW50ZXJzXy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5wb3NzaWJsZUNlbnRlcnNfW2luZGV4XTtcbiAgICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxuICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzX1tpbmRleF0gPVxuICAgICAgICAgICAgICBjZW50ZXIuY29tYmluZUVzdGltYXRlKGNlbnRlckksIGNlbnRlckosIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgRmluZGVyUGF0dGVybihjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVyc18ucHVzaChwb2ludCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFja18gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrXyhwb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJvd3Mgd2UgY291bGQgc2FmZWx5IHNraXAgZHVyaW5nIHNjYW5uaW5nLFxuICAgKiBiYXNlZCBvbiB0aGUgZmlyc3QgdHdvIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBsb2NhdGVkLiBJbiBzb21lXG4gICAqIGNhc2VzIHRoZWlyIHBvc2l0aW9uIHdpbGwgYWxsb3cgdXMgdG8gaW5mZXIgdGhhdCB0aGUgdGhpcmQgcGF0dGVybiBtdXN0XG4gICAqIGxpZSBiZWxvdyBhIGNlcnRhaW4gcG9pbnQgZmFydGhlciBkb3duIGluIHRoZSBpbWFnZS5cbiAgICovXG4gIHByby5maW5kUm93U2tpcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVyc18ubGVuZ3RoO1xuICAgIGlmIChtYXggPD0gMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc3NpYmxlQ2VudGVyc18ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnBvc3NpYmxlQ2VudGVyc19baV07XG4gICAgICBpZiAoY2VudGVyLmdldENvdW50KCkgPj0gXy5DRU5URVJfUVVPUlVNKSB7XG4gICAgICAgIGlmIChmaXJzdENvbmZpcm1lZENlbnRlciA9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDb25maXJtZWRDZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0d28gY29uZmlybWVkIGNlbnRlcnNcbiAgICAgICAgICAvLyBIb3cgZmFyIGRvd24gY2FuIHdlIHNraXAgYmVmb3JlIHJlc3VtaW5nIGxvb2tpbmcgZm9yIHRoZSBuZXh0XG4gICAgICAgICAgLy8gcGF0dGVybj8gSW4gdGhlIHdvcnN0IGNhc2UsIG9ubHkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSB4IC8geSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNlbnRlcnMuXG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB5b3UgZmluZCB0b3AgbGVmdCBsYXN0LlxuICAgICAgICAgIHRoaXMuaGFzU2tpcHBlZF8gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChcbiAgICAgICAgICAgIE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFgoKSAtIGNlbnRlci5nZXRYKCkpIC1cbiAgICAgICAgICAgICAgTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WSgpIC0gY2VudGVyLmdldFkoKSkpIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWZmIHdlIGhhdmUgZm91bmQgYXQgbGVhc3QgMyBmaW5kZXIgcGF0dGVybnMgdGhhdFxuICAgKiBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcyBlYWNoLCBhbmRcbiAgICogLCB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVzIGlzIFwicHJldHR5IHNpbWlsYXJcIi5cbiAgICovXG4gIHByby5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDtcbiAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMC47XG4gICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzXy5sZW5ndGg7XG4gICAgdGhpcy5wb3NzaWJsZUNlbnRlcnNfLmZvckVhY2goZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgaWYgKHBhdHRlcm4uZ2V0Q291bnQoKSA+PSBfLkNFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgY29uZmlybWVkQ291bnQrKztcbiAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIGlmIChjb25maXJtZWRDb3VudCA8IDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT0ssIHdlIGhhdmUgYXQgbGVhc3QgMyBjb25maXJtZWQgY2VudGVycywgYnV0LCBpdCdzIHBvc3NpYmxlIHRoYXQgb25lXG4gICAgLy8gaXMgYSBcImZhbHNlIHBvc2l0aXZlXCJcbiAgICAvLyBhbmQgdGhhdCB3ZSBuZWVkIHRvIGtlZXAgbG9va2luZy4gV2UgZGV0ZWN0IHRoaXMgYnkgYXNraW5nIGlmIHRoZVxuICAgIC8vIGVzdGltYXRlZCBtb2R1bGUgc2l6ZXNcbiAgICAvLyB2YXJ5IHRvbyBtdWNoLiBXZSBhcmJpdHJhcmlseSBzYXkgdGhhdCB3aGVuIHRoZSB0b3RhbCBkZXZpYXRpb25cbiAgICAvLyBmcm9tIGF2ZXJhZ2UgZXhjZWVkc1xuICAgIC8vIDUlIG9mIHRoZSB0b3RhbCBtb2R1bGUgc2l6ZSBlc3RpbWF0ZXMsIGl0J3MgdG9vIG11Y2guXG4gICAgLy8gbWFudTogRG9lcyBpdCBtYWtlIHNlbnNlIHRvIGRpdmlkZSBieSBtYXggd2hpbGUgY291bnRpbmdcbiAgICAvLyBvbmx5IHRob3NlIHdpdGggPj0gQ0VOVEVSX1FVT1JVTS5cbiAgICB2YXIgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIG1heDtcbiAgICB2YXIgdG90YWxEZXZpYXRpb24gPSAwLjtcbiAgICB0aGlzLnBvc3NpYmxlQ2VudGVyc18uZm9yRWFjaChmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICB0b3RhbERldmlhdGlvbiArPSBNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgIH0pO1xuICAgIGlmICh0b3RhbERldmlhdGlvbiA+IDAuMDUgKiB0b3RhbE1vZHVsZVNpemUpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBza2V3IG9mIGJlc3QgcGF0dGVybnMuXG4gICAgdmFyIGNlbnRlcnMgPSB0aGlzLnNlbGVjdEJlc3RQYXR0ZXJucygpO1xuICAgIHZhciBza2V3ID0gXy5jb21wdXRlU2tldyhjZW50ZXJzKTtcblxuICAgIHJldHVybiBza2V3IDwgXy5TS0VXX1RIUkVTSE9MRDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NoZWNrU2tldyBjaGVjayBza2V3LCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHJldHVybiB7QXJyYXkuPEZpbmRlclBhdHRlcm4+fSB0aGUgMyBiZXN0IEZpbmRlclBhdHRlcm5zIGZyb20gb3VyIGxpc3RcbiAgICogb2YgY2FuZGlkYXRlcy4gVGhlIFwiYmVzdFwiIGFyZSB0aG9zZSB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZCBhdFxuICAgKiBsZWFzdCBDRU5URVJfUVVPUlVNIHRpbWVzLCBhbmQgd2hvc2UgbW9kdWxlIHNpemUgZGlmZmVycyBmcm9tIHRoZVxuICAgKiBhdmVyYWdlIGFtb25nIHRob3NlIHBhdHRlcm5zIHRoZSBsZWFzdC5cbiAgICovXG4gIHByby5zZWxlY3RCZXN0UGF0dGVybnMgPSBmdW5jdGlvbihvcHRfY2hlY2tTa2V3KSB7XG4gICAgdmFyIHN0YXJ0U2l6ZSA9IHRoaXMucG9zc2libGVDZW50ZXJzXy5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0U2l6ZSA8IDMpIHtcbiAgICAgIC8vIENvdWxkbid0IGZpbmQgZW5vdWdoIGZpbmRlciBwYXR0ZXJuc1xuICAgICAgdGhyb3cgbmV3IHc2OWIucXIuTm90Rm91bmRFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgYXZlcmFnZTtcbiAgICB2YXIgY2VudGVycyA9IGdvb2cuYXJyYXkuY2xvbmUodGhpcy5wb3NzaWJsZUNlbnRlcnNfKTtcblxuICAgIC8vIEZpbHRlciBvdXRsaWVyIHBvc3NpYmlsaXRpZXMgd2hvc2UgbW9kdWxlIHNpemUgaXMgdG9vIGRpZmZlcmVudFxuICAgIGlmIChzdGFydFNpemUgPiAzKSB7XG4gICAgICAvLyBCdXQgd2UgY2FuIG9ubHkgYWZmb3JkIHRvIGRvIHNvIGlmIHdlIGhhdmUgYXQgbGVhc3QgNCBwb3NzaWJpbGl0aWVzXG4gICAgICAvLyB0byBjaG9vc2UgZnJvbVxuICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuO1xuICAgICAgdmFyIHNxdWFyZSA9IDAuO1xuICAgICAgY2VudGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgICB2YXIgc2l6ZSA9IGNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBzaXplO1xuICAgICAgICBzcXVhcmUgKz0gc2l6ZSAqIHNpemU7XG4gICAgICB9KTtcbiAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBzdGFydFNpemU7XG4gICAgICB2YXIgc3RkRGV2ID0gTWF0aC5zcXJ0KHNxdWFyZSAvIHN0YXJ0U2l6ZSAtIGF2ZXJhZ2UgKiBhdmVyYWdlKTtcblxuICAgICAgY2VudGVycy5zb3J0KF8uRnVydGhlc3RGcm9tQXZlcmFnZUNvbXBhcmF0b3IoYXZlcmFnZSkpO1xuXG4gICAgICB2YXIgbGltaXQgPSBNYXRoLm1heCgwLjIgKiBhdmVyYWdlLCBzdGREZXYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRlcnMubGVuZ3RoICYmXG4gICAgICAgIGNlbnRlcnMubGVuZ3RoID4gMzsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY2VudGVyc1tpXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSkgPiBsaW1pdCkge1xuICAgICAgICAgIGdvb2cuYXJyYXkucmVtb3ZlQXQoY2VudGVycywgaSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNlbnRlcnMubGVuZ3RoID4gMykge1xuICAgICAgLy8gVGhyb3cgYXdheSBhbGwgYnV0IHRob3NlIGZpcnN0IHNpemUgY2FuZGlkYXRlIHBvaW50cyB3ZSBmb3VuZC5cblxuICAgICAgdG90YWxNb2R1bGVTaXplID0gMC47XG4gICAgICBjZW50ZXJzLmZvckVhY2goZnVuY3Rpb24ocG9zc2libGVDZW50ZXIpIHtcbiAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBvc3NpYmxlQ2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gY2VudGVycy5sZW5ndGg7XG5cbiAgICAgIGNlbnRlcnMuc29ydChfLkNlbnRlckNvbXBhcmF0b3IoYXZlcmFnZSkpO1xuXG4gICAgICBpZiAob3B0X2NoZWNrU2tldykge1xuICAgICAgICAvLyBjaGVjayBza2V3IGVycm9yIG9mIGZpcnN0IGZldyBzZXRzLlxuICAgICAgICB2YXIgd2l0aFNrZXcgPSBfLmdldENvbWJpbmF0aW9ucyhjZW50ZXJzKS5tYXAoZnVuY3Rpb24oY29tYmluYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4ge2NlbnRlcnM6IGNvbWJpbmF0aW9uLFxuICAgICAgICAgICAgc2tldzogXy5jb21wdXRlU2tldyhjb21iaW5hdGlvbil9O1xuICAgICAgICB9KTtcbiAgICAgICAgd2l0aFNrZXcuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGdvb2cuYXJyYXkuZGVmYXVsdENvbXBhcmUoYS5za2V3LCBiLnNrZXcpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcGljayBjYW5pZGF0ZXMgd2l0aCBsb3dlc3Qgc2tldy5cbiAgICAgICAgY2VudGVycyA9IHdpdGhTa2V3WzBdLmNlbnRlcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZW50ZXJzID0gY2VudGVycy5zbGljZSgwLCAzKTtcbiAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRlcnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjXG4gICAqIEBwYXJhbSB7QXJyYXkuPEZpbmRlclBhdHRlcm4+fSBjZW50ZXJzIGZpbmRlciBwYXR0ZXJuIGNhbmRpZGF0ZXMuXG4gICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48RmluZGVyUGF0dGVybj4+fSByZXN1bHQuXG4gICAqL1xuICBfLmdldENvbWJpbmF0aW9ucyA9IGZ1bmN0aW9uKGNlbnRlcnMpIHtcbiAgICB2YXIgbGVuID0gY2VudGVycy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIF8uU0tFV19DT01CSU5BVElPTlMuZm9yRWFjaChmdW5jdGlvbihpbmRpY2VzKSB7XG4gICAgICBpZiAoaW5kaWNlc1swXSA8IGxlbiAmJiBpbmRpY2VzWzFdICYmIGxlbiAmJiBpbmRpY2VzWzJdIDwgbGVuKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtjZW50ZXJzW2luZGljZXNbMF1dLCBjZW50ZXJzW2luZGljZXNbMV1dLFxuICAgICAgICAgIGNlbnRlcnNbaW5kaWNlc1syXV1dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5PcmRlcnMgYnkgZnVydGhlc3QgZnJvbSBhdmVyYWdlPC9wPlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXZlcmFnZSBhdmVyYWdlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihGaW5kZXJQYXR0ZXJuLCBGaW5kZXJQYXR0ZXJuKTpudW1iZXJ9IGNvbXBhcmUgZnVuY3Rpb24uXG4gICAqL1xuICBfLkZ1cnRoZXN0RnJvbUF2ZXJhZ2VDb21wYXJhdG9yID0gZnVuY3Rpb24oYXZlcmFnZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihjZW50ZXIxLCBjZW50ZXIyKSB7XG4gICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgdmFyIGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgIHJldHVybiBkQSA8IGRCID8gLTEgOiBkQSA9PSBkQiA/IDAgOiAxO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIDxwPk9yZGVycyBieSB7QGxpbmsgRmluZGVyUGF0dGVybiNnZXRDb3VudCgpfSwgZGVzY2VuZGluZy48L3A+XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhdmVyYWdlIGF2ZXJhZ2UuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKEZpbmRlclBhdHRlcm4sIEZpbmRlclBhdHRlcm4pOm51bWJlcn0gY29tcGFyZSBmdW5jdGlvbi5cbiAgICovXG4gIF8uQ2VudGVyQ29tcGFyYXRvciA9IGZ1bmN0aW9uKGF2ZXJhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2VudGVyMSwgY2VudGVyMikge1xuICAgICAgaWYgKGNlbnRlcjIuZ2V0Q291bnQoKSA9PSBjZW50ZXIxLmdldENvdW50KCkpIHtcbiAgICAgICAgdmFyIGRBID0gTWF0aC5hYnMoY2VudGVyMi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgdmFyIGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPT0gZEIgPyAwIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2VudGVyMi5nZXRDb3VudCgpIC0gY2VudGVyMS5nZXRDb3VudCgpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgLSBiIC8gfGEtYnwuXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5SZXN1bHRQb2ludH0gcGF0dGVybjEgYS5cbiAgICogQHBhcmFtIHt3NjliLnFyLlJlc3VsdFBvaW50fSBwYXR0ZXJuMiBiLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmVzdWx0IGFzIGFycmF5IFt4LCB5XS5cbiAgICovXG4gIF8uZGlmZiA9IGZ1bmN0aW9uKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgIHZhciBkaWZmWCA9IHBhdHRlcm4xLmdldFgoKSAtIHBhdHRlcm4yLmdldFgoKTtcbiAgICB2YXIgZGlmZlkgPSBwYXR0ZXJuMS5nZXRZKCkgLSBwYXR0ZXJuMi5nZXRZKCk7XG4gICAgdmFyIGxlbiA9IE1hdGguc3FydChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSk7XG4gICAgcmV0dXJuIFtkaWZmWCAvIGxlbiwgZGlmZlkgLyBsZW5dO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FsYXIgcHJvZHVjdFxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIHZlY3RvciBhLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIHZlY3RvciBhLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHNjYWxhciBwcm9kdWN0LlxuICAgKi9cbiAgXy5zY2FsYXJQcm9kdWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG9mIDEvMlxuICBfLlNRUlRfMDUgPSBNYXRoLnNxcnQoMC41KTtcbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgbnVtYmVyIHRoYXQgZXhwcmVzc2VzIGhvdyBnb29kIGFsaWduZW1lbnQgb2YgdGhlIGdpdmV2blxuICAgKiBwYXR0ZXJucyBjYW4gYmUgZXhwbGFpbmVkIGJ5IGEgc2ltbGlhcml0eSB0cmFuc2Zvcm1hdGlvbi4gVGhpc1xuICAgKiBhc3N1bWVzIHRoYXQgdGhleSBhcmUgb3JpZW50ZWQgaW4gdHJpYW5ndWxhciBzaGFwZS5cbiAgICogQHBhcmFtIHtBcnJheS48dzY5Yi5xci5SZXN1bHRQb2ludD59IHBhdHRlcm5zIGFycmF5IG9mIHNpemUgMy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBza2V3IGVycm9yLlxuICAgKi9cbiAgXy5jb21wdXRlU2tldyA9IGZ1bmN0aW9uKHBhdHRlcm5zKSB7XG4gICAgdmFyIGRpZmYwMSA9IF8uZGlmZihwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pO1xuICAgIHZhciBkaWZmMDIgPSBfLmRpZmYocGF0dGVybnNbMF0sIHBhdHRlcm5zWzJdKTtcbiAgICB2YXIgZGlmZjEyID0gXy5kaWZmKHBhdHRlcm5zWzFdLCBwYXR0ZXJuc1syXSk7XG4gICAgdmFyIHNjYWxhcnMgPSBbTWF0aC5hYnMoXy5zY2FsYXJQcm9kdWN0KGRpZmYwMSwgZGlmZjAyKSksXG4gICAgICBNYXRoLmFicyhfLnNjYWxhclByb2R1Y3QoZGlmZjAxLCBkaWZmMTIpKSxcbiAgICAgIE1hdGguYWJzKF8uc2NhbGFyUHJvZHVjdChkaWZmMDIsIGRpZmYxMikpXG4gICAgXTtcblxuICAgIHNjYWxhcnMuc29ydCgpO1xuICAgIHZhciBlcnJvciA9IHNjYWxhcnNbMF0gK1xuICAgICAgTWF0aC5hYnMoc2NhbGFyc1sxXSAtIF8uU1FSVF8wNSkgK1xuICAgICAgTWF0aC5hYnMoc2NhbGFyc1syXSAtIF8uU1FSVF8wNSk7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9O1xuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLk1hdGhVdGlscycpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgXyA9IHc2OWIucXIuTWF0aFV0aWxzO1xuXG4gIC8qKlxuICAgKiBFdWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqL1xuICBfLmRpc3RhbmNlID0gZnVuY3Rpb24oYVgsIGFZLCBiWCwgYlkpIHtcbiAgICB2YXIgeERpZmYgPSBhWCAtIGJYO1xuICAgIHZhciB5RGlmZiA9IGFZIC0gYlk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZik7XG4gIH07XG5cblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuICovXG5cbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLlZlcnNpb24nKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5CaXRNYXRyaXgnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Gb3JtYXRFcnJvcicpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgRm9ybWF0RXJyb3IgPSB3NjliLnFyLkZvcm1hdEVycm9yO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB3NjliLnFyLkVDQiA9IGZ1bmN0aW9uKGNvdW50LCBkYXRhQ29kZXdvcmRzKSB7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XG4gIH07XG4gIHZhciBFQ0IgPSB3NjliLnFyLkVDQjtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlY0NvZGV3b3Jkc1BlckJsb2NrIGNvZGUgd29yZHMgcGVyIGJsb2NrLlxuICAgKiBAcGFyYW0geyFFQ0J9IGVjQmxvY2tzMSBibG9jazEuXG4gICAqIEBwYXJhbSB7RUNCPX0gb3B0X2VjQmxvY2tzMiBibG9jazIuXG4gICAqL1xuICB3NjliLnFyLkVDQmxvY2tzID0gZnVuY3Rpb24oZWNDb2Rld29yZHNQZXJCbG9jaywgZWNCbG9ja3MxLCBvcHRfZWNCbG9ja3MyKSB7XG4gICAgdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrID0gZWNDb2Rld29yZHNQZXJCbG9jaztcbiAgICBpZiAob3B0X2VjQmxvY2tzMilcbiAgICAgIHRoaXMuZWNCbG9ja3MgPSBbZWNCbG9ja3MxLCBvcHRfZWNCbG9ja3MyXTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmVjQmxvY2tzID0gW2VjQmxvY2tzMV07XG5cbiAgfTtcbiAgdmFyIEVDQmxvY2tzID0gdzY5Yi5xci5FQ0Jsb2NrcztcblxuICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgfTtcblxuICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0VG90YWxFQ0NvZGV3b3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2sgKiB0aGlzLmdldE51bUJsb2NrcygpO1xuICB9O1xuXG4gIEVDQmxvY2tzLnByb3RvdHlwZS5nZXROdW1CbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lY0Jsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWwgKz0gdGhpcy5lY0Jsb2Nrc1tpXS5jb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuVmVyc2lvbiA9IGZ1bmN0aW9uKHZlcnNpb25OdW1iZXIsIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzLCBlY0Jsb2NrczEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjQmxvY2tzMiwgZWNCbG9ja3MzLCBlY0Jsb2NrczQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XG4gICAgdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycyA9IGFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xuICAgIHRoaXMuZWNCbG9ja3MgPSBuZXcgQXJyYXkoZWNCbG9ja3MxLCBlY0Jsb2NrczIsIGVjQmxvY2tzMywgZWNCbG9ja3M0KTtcblxuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIGVjQ29kZXdvcmRzID0gZWNCbG9ja3MxLmVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgdmFyIGVjYkFycmF5ID0gZWNCbG9ja3MxLmdldEVDQmxvY2tzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlY2JBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVjQmxvY2sgPSBlY2JBcnJheVtpXTtcbiAgICAgIHRvdGFsICs9IGVjQmxvY2suY291bnQgKiAoZWNCbG9jay5kYXRhQ29kZXdvcmRzICsgZWNDb2Rld29yZHMpO1xuICAgIH1cbiAgICB0aGlzLnRvdGFsQ29kZXdvcmRzID0gdG90YWw7XG4gIH07XG4gIHZhciBWZXJzaW9uID0gdzY5Yi5xci5WZXJzaW9uO1xuICB2YXIgcHJvID0gVmVyc2lvbi5wcm90b3R5cGU7XG5cbiAgcHJvLmdldFZlcnNpb25OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uTnVtYmVyO1xuICB9O1xuXG4gIHByby5nZXRUb3RhbENvZGV3b3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGRlYnVnIHN0cmluZy5cbiAgICovXG4gIHByby50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBkaW1lbnNpb24uXG4gICAqL1xuICBwcm8uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxNyArIDQgKiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gIH07XG5cbiAgcHJvLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgIHZhciBiaXRNYXRyaXggPSBuZXcgdzY5Yi5xci5CaXRNYXRyaXgoZGltZW5zaW9uKTtcblxuICAgIC8vIFRvcCBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCAwLCA5LCA5KTtcbiAgICAvLyBUb3AgcmlnaHQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDgsIDAsIDgsIDkpO1xuICAgIC8vIEJvdHRvbSBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSA4LCA5LCA4KTtcblxuICAgIC8vIEFsaWdubWVudCBwYXR0ZXJuc1xuICAgIHZhciBtYXggPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzLmxlbmd0aDtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heDsgeCsrKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnNbeF0gLSAyO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXg7IHkrKykge1xuICAgICAgICBpZiAoKHggPT0gMCAmJiAoeSA9PSAwIHx8IHkgPT0gbWF4IC0gMSkpIHx8ICh4ID09IG1heCAtIDEgJiYgeSA9PSAwKSkge1xuICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0ZXJuc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgYml0TWF0cml4LnNldFJlZ2lvbig2LCA5LCAxLCBkaW1lbnNpb24gLSAxNyk7XG4gICAgLy8gSG9yaXpvbnRhbCB0aW1pbmcgcGF0dGVyblxuICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbk51bWJlciA+IDYpIHtcbiAgICAgIC8vIFZlcnNpb24gaW5mbywgdG9wIHJpZ2h0XG4gICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDExLCAwLCAzLCA2KTtcbiAgICAgIC8vIFZlcnNpb24gaW5mbywgYm90dG9tIGxlZnRcbiAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gMTEsIDYsIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBiaXRNYXRyaXg7XG4gIH07XG4gIHByby5nZXRFQ0Jsb2Nrc0ZvckxldmVsID0gZnVuY3Rpb24oZWNMZXZlbCkge1xuICAgIHJldHVybiB0aGlzLmVjQmxvY2tzW2VjTGV2ZWwub3JkaW5hbF07XG4gIH07XG5cbiAgVmVyc2lvbi5WRVJTSU9OX0RFQ09ERV9JTkZPID0gbmV3IEFycmF5KDB4MDdDOTQsIDB4MDg1QkMsIDB4MDlBOTksIDB4MEE0RDMsXG4gICAgMHgwQkJGNiwgMHgwQzc2MiwgMHgwRDg0NywgMHgwRTYwRCwgMHgwRjkyOCwgMHgxMEI3OCwgMHgxMTQ1RCwgMHgxMkExNyxcbiAgICAweDEzNTMyLCAweDE0OUE2LCAweDE1NjgzLCAweDE2OEM5LCAweDE3N0VDLCAweDE4RUM0LCAweDE5MUUxLCAweDFBRkFCLFxuICAgIDB4MUIwOEUsIDB4MUNDMUEsIDB4MUQzM0YsIDB4MUVENzUsIDB4MUYyNTAsIDB4MjA5RDUsIDB4MjE2RjAsIDB4MjI4QkEsXG4gICAgMHgyMzc5RiwgMHgyNEIwQiwgMHgyNTQyRSwgMHgyNkE2NCwgMHgyNzU0MSwgMHgyOEM2OSk7XG5cbiAgVmVyc2lvbi5WRVJTSU9OUyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkobmV3IFZlcnNpb24oMSwgW10sXG4gICAgICBuZXcgRUNCbG9ja3MoNywgbmV3IEVDQigxLCAxOSkpLFxuICAgICAgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDE2KSksIG5ldyBFQ0Jsb2NrcygxMywgbmV3IEVDQigxLCAxMykpLFxuICAgICAgbmV3IEVDQmxvY2tzKDE3LCBuZXcgRUNCKDEsIDkpKSksXG4gICAgICBuZXcgVmVyc2lvbigyLCBuZXcgQXJyYXkoNiwgMTgpLCBuZXcgRUNCbG9ja3MoMTAsIG5ldyBFQ0IoMSwgMzQpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDE2LCBuZXcgRUNCKDEsIDI4KSksIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQigxLCAyMikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzLCBuZXcgQXJyYXkoNiwgMjIpLCBuZXcgRUNCbG9ja3MoMTUsIG5ldyBFQ0IoMSwgNTUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDEsIDQ0KSksIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCAxNykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMiwgMTMpKSksXG4gICAgICBuZXcgVmVyc2lvbig0LCBuZXcgQXJyYXkoNiwgMjYpLCBuZXcgRUNCbG9ja3MoMjAsIG5ldyBFQ0IoMSwgODApKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDIsIDMyKSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigyLCAyNCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMTYsIG5ldyBFQ0IoNCwgOSkpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDUsIG5ldyBBcnJheSg2LCAzMCksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigxLCAxMDgpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDIsIDQzKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCAxNSksIG5ldyBFQ0IoMiwgMTYpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDIsIDExKSwgbmV3IEVDQigyLCAxMikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDYsIG5ldyBBcnJheSg2LCAzNCksIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCA2OCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMTYsIG5ldyBFQ0IoNCwgMjcpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDQsIDE5KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig0LCAxNSkpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDcsIG5ldyBBcnJheSg2LCAyMiwgMzgpLCBuZXcgRUNCbG9ja3MoMjAsIG5ldyBFQ0IoMiwgNzgpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDQsIDMxKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCAxNCksIG5ldyBFQ0IoNCwgMTUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDQsIDEzKSwgbmV3IEVDQigxLCAxNCkpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDgsIG5ldyBBcnJheSg2LCAyNCwgNDIpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMiwgOTcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDIsIDM4KSwgbmV3IEVDQigyLCAzOSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoNCwgMTgpLCBuZXcgRUNCKDIsIDE5KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQig0LCAxNCksIG5ldyBFQ0IoMiwgMTUpKSksXG4gICAgICBuZXcgVmVyc2lvbig5LCBuZXcgQXJyYXkoNiwgMjYsIDQ2KSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIsIDExNikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMywgMzYpLCBuZXcgRUNCKDIsIDM3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQig0LCAxNiksIG5ldyBFQ0IoNCwgMTcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDQsIDEyKSwgbmV3IEVDQig0LCAxMykpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDEwLCBuZXcgQXJyYXkoNiwgMjgsIDUwKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDIsIDY4KSwgbmV3IEVDQigyLCA2OSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoNCwgNDMpLCBuZXcgRUNCKDEsIDQ0KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQig2LCAxOSksIG5ldyBFQ0IoMiwgMjApKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDYsIDE1KSwgbmV3IEVDQigyLCAxNikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDExLCBuZXcgQXJyYXkoNiwgMzAsIDU0KSwgbmV3IEVDQmxvY2tzKDIwLCBuZXcgRUNCKDQsIDgxKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxLCA1MCksIG5ldyBFQ0IoNCwgNTEpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDQsIDIyKSwgbmV3IEVDQig0LCAyMykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMywgMTIpLCBuZXcgRUNCKDgsIDEzKSkpLFxuICAgICAgbmV3IFZlcnNpb24oMTIsIG5ldyBBcnJheSg2LCAzMiwgNTgpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMiwgOTIpLCBuZXcgRUNCKDIsIDkzKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQig2LCAzNiksIG5ldyBFQ0IoMiwgMzcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDQsIDIwKSwgbmV3IEVDQig2LCAyMSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNywgMTQpLCBuZXcgRUNCKDQsIDE1KSkpLFxuICAgICAgbmV3IFZlcnNpb24oMTMsIG5ldyBBcnJheSg2LCAzNCwgNjIpLCBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoNCwgMTA3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQig4LCAzNyksIG5ldyBFQ0IoMSwgMzgpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDgsIDIwKSwgbmV3IEVDQig0LCAyMSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMTIsIDExKSwgbmV3IEVDQig0LCAxMikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDE0LCBuZXcgQXJyYXkoNiwgMjYsIDQ2LCA2NiksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigzLCAxMTUpLCBuZXcgRUNCKDEsIDExNikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoNCwgNDApLCBuZXcgRUNCKDUsIDQxKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQigxMSwgMTYpLCBuZXcgRUNCKDUsIDE3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigxMSwgMTIpLCBuZXcgRUNCKDUsIDEzKSkpLFxuICAgICAgbmV3IFZlcnNpb24oMTUsIG5ldyBBcnJheSg2LCAyNiwgNDgsIDcwKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDUsIDg3KSwgbmV3IEVDQigxLCA4OCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoNSwgNDEpLCBuZXcgRUNCKDUsIDQyKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig1LCAyNCksIG5ldyBFQ0IoNywgMjUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDExLCAxMiksIG5ldyBFQ0IoNywgMTMpKSksXG4gICAgICBuZXcgVmVyc2lvbigxNiwgbmV3IEFycmF5KDYsIDI2LCA1MCwgNzQpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoNSwgOTgpLCBuZXcgRUNCKDEsIDk5KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig3LCA0NSksIG5ldyBFQ0IoMywgNDYpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDE1LCAxOSksIG5ldyBFQ0IoMiwgMjApKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDMsIDE1KSwgbmV3IEVDQigxMywgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigxNywgbmV3IEFycmF5KDYsIDMwLCA1NCwgNzgpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgMTA3KSwgbmV3IEVDQig1LCAxMDgpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEwLCA0NiksIG5ldyBFQ0IoMSwgNDcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDIyKSwgbmV3IEVDQigxNSwgMjMpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDIsIDE0KSwgbmV3IEVDQigxNywgMTUpKSksXG4gICAgICBuZXcgVmVyc2lvbigxOCwgbmV3IEFycmF5KDYsIDMwLCA1NiwgODIpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNSwgMTIwKSwgbmV3IEVDQigxLCAxMjEpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDksIDQzKSwgbmV3IEVDQig0LCA0NCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTcsIDIyKSwgbmV3IEVDQigxLCAyMykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMiwgMTQpLCBuZXcgRUNCKDE5LCAxNSkpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDE5LCBuZXcgQXJyYXkoNiwgMzAsIDU4LCA4NiksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigzLCAxMTMpLCBuZXcgRUNCKDQsIDExNCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoMywgNDQpLCBuZXcgRUNCKDExLCA0NSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoMTcsIDIxKSwgbmV3IEVDQig0LCAyMikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoOSwgMTMpLCBuZXcgRUNCKDE2LCAxNCkpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDIwLCBuZXcgQXJyYXkoNiwgMzQsIDYyLCA5MCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigzLCAxMDcpLCBuZXcgRUNCKDUsIDEwOCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoMywgNDEpLCBuZXcgRUNCKDEzLCA0MikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTUsIDI0KSwgbmV3IEVDQig1LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTUsIDE1KSwgbmV3IEVDQigxMCwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigyMSwgbmV3IEFycmF5KDYsIDI4LCA1MCwgNzIsIDk0KSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDQsIDExNiksIG5ldyBFQ0IoNCwgMTE3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigxNywgNDIpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE3LCAyMiksIG5ldyBFQ0IoNiwgMjMpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE5LCAxNiksIG5ldyBFQ0IoNiwgMTcpKSksXG4gICAgICBuZXcgVmVyc2lvbigyMiwgbmV3IEFycmF5KDYsIDI2LCA1MCwgNzQsIDk4KSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDIsIDExMSksIG5ldyBFQ0IoNywgMTEyKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxNywgNDYpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDcsIDI0KSwgbmV3IEVDQigxNiwgMjUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDM0LCAxMykpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDIzLCBuZXcgQXJyYXkoNiwgMzAsIDU0LCA3NCwgMTAyKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQsIDEyMSksIG5ldyBFQ0IoNSwgMTIyKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig0LCA0NyksIG5ldyBFQ0IoMTQsIDQ4KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMSwgMjQpLCBuZXcgRUNCKDE0LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTYsIDE1KSwgbmV3IEVDQigxNCwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigyNCwgbmV3IEFycmF5KDYsIDI4LCA1NCwgODAsIDEwNiksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig2LCAxMTcpLCBuZXcgRUNCKDQsIDExOCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNiwgNDUpLCBuZXcgRUNCKDE0LCA0NikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTEsIDI0KSwgbmV3IEVDQigxNiwgMjUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDMwLCAxNiksIG5ldyBFQ0IoMiwgMTcpKSksXG4gICAgICBuZXcgVmVyc2lvbigyNSwgbmV3IEFycmF5KDYsIDMyLCA1OCwgODQsIDExMCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQig4LCAxMDYpLCBuZXcgRUNCKDQsIDEwNykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoOCwgNDcpLCBuZXcgRUNCKDEzLCA0OCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNywgMjQpLCBuZXcgRUNCKDIyLCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjIsIDE1KSwgbmV3IEVDQigxMywgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigyNiwgbmV3IEFycmF5KDYsIDMwLCA1OCwgODYsIDExNCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxMCwgMTE0KSwgbmV3IEVDQigyLCAxMTUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE5LCA0NiksIG5ldyBFQ0IoNCwgNDcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDI4LCAyMiksIG5ldyBFQ0IoNiwgMjMpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDMzLCAxNiksIG5ldyBFQ0IoNCwgMTcpKSksXG4gICAgICBuZXcgVmVyc2lvbigyNywgbmV3IEFycmF5KDYsIDM0LCA2MiwgOTAsIDExOCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig4LCAxMjIpLCBuZXcgRUNCKDQsIDEyMykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMjIsIDQ1KSwgbmV3IEVDQigzLCA0NikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoOCwgMjMpLCBuZXcgRUNCKDI2LCAyNCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTIsIDE1KSwgbmV3IEVDQigyOCwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigyOCwgbmV3IEFycmF5KDYsIDI2LCA1MCwgNzQsIDk4LCAxMjIpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMywgMTE3KSwgbmV3IEVDQigxMCwgMTE4KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigzLCA0NSksIG5ldyBFQ0IoMjMsIDQ2KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0LCAyNCksIG5ldyBFQ0IoMzEsIDI1KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMSwgMTUpLCBuZXcgRUNCKDMxLCAxNikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDI5LCBuZXcgQXJyYXkoNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNywgMTE2KSwgbmV3IEVDQig3LCAxMTcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDIxLCA0NSksIG5ldyBFQ0IoNywgNDYpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDEsIDIzKSwgbmV3IEVDQigzNywgMjQpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE5LCAxNSksIG5ldyBFQ0IoMjYsIDE2KSkpLFxuICAgICAgbmV3IFZlcnNpb24oMzAsIG5ldyBBcnJheSg2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig1LCAxMTUpLCBuZXcgRUNCKDEwLCAxMTYpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE5LCA0NyksIG5ldyBFQ0IoMTAsIDQ4KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxNSwgMjQpLCBuZXcgRUNCKDI1LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjMsIDE1KSwgbmV3IEVDQigyNSwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzMSwgbmV3IEFycmF5KDYsIDMwLCA1NiwgODIsIDEwOCwgMTM0KSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDEzLCAxMTUpLCBuZXcgRUNCKDMsIDExNikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMiwgNDYpLCBuZXcgRUNCKDI5LCA0NykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNDIsIDI0KSwgbmV3IEVDQigxLCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjMsIDE1KSwgbmV3IEVDQigyOCwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzMiwgbmV3IEFycmF5KDYsIDM0LCA2MCwgODYsIDExMiwgMTM4KSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE3LCAxMTUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEwLCA0NiksIG5ldyBFQ0IoMjMsIDQ3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMCwgMjQpLCBuZXcgRUNCKDM1LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTksIDE1KSwgbmV3IEVDQigzNSwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzMywgbmV3IEFycmF5KDYsIDMwLCA1OCwgODYsIDExNCwgMTQyKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE3LCAxMTUpLCBuZXcgRUNCKDEsIDExNikpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTQsIDQ2KSwgbmV3IEVDQigyMSwgNDcpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDI5LCAyNCksIG5ldyBFQ0IoMTksIDI1KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMSwgMTUpLCBuZXcgRUNCKDQ2LCAxNikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDM0LCBuZXcgQXJyYXkoNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTMsIDExNSksIG5ldyBFQ0IoNiwgMTE2KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxNCwgNDYpLCBuZXcgRUNCKDIzLCA0NykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNDQsIDI0KSwgbmV3IEVDQig3LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNTksIDE2KSwgbmV3IEVDQigxLCAxNykpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDM1LCBuZXcgQXJyYXkoNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMiwgMTIxKSwgbmV3IEVDQig3LCAxMjIpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEyLCA0NyksIG5ldyBFQ0IoMjYsIDQ4KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigzOSwgMjQpLCBuZXcgRUNCKDE0LCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjIsIDE1KSwgbmV3IEVDQig0MSwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzNiwgbmV3IEFycmF5KDYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTQpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNiwgMTIxKSwgbmV3IEVDQigxNCwgMTIyKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig2LCA0NyksIG5ldyBFQ0IoMzQsIDQ4KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0NiwgMjQpLCBuZXcgRUNCKDEwLCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMiwgMTUpLCBuZXcgRUNCKDY0LCAxNikpKSxcbiAgICAgIG5ldyBWZXJzaW9uKDM3LCBuZXcgQXJyYXkoNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OCksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxNywgMTIyKSwgbmV3IEVDQig0LCAxMjMpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDI5LCA0NiksIG5ldyBFQ0IoMTQsIDQ3KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0OSwgMjQpLCBuZXcgRUNCKDEwLCAyNSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjQsIDE1KSwgbmV3IEVDQig0NiwgMTYpKSksXG4gICAgICBuZXcgVmVyc2lvbigzOCwgbmV3IEFycmF5KDYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjIpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNCwgMTIyKSwgbmV3IEVDQigxOCwgMTIzKSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxMywgNDYpLCBuZXcgRUNCKDMyLCA0NykpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNDgsIDI0KSwgbmV3IEVDQigxNCwgMjUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQyLCAxNSksIG5ldyBFQ0IoMzIsIDE2KSkpLFxuICAgICAgbmV3IFZlcnNpb24oMzksIG5ldyBBcnJheSg2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2KSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIwLCAxMTcpLCBuZXcgRUNCKDQsIDExOCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNDAsIDQ3KSwgbmV3IEVDQig3LCA0OCkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNDMsIDI0KSwgbmV3IEVDQigyMiwgMjUpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDEwLCAxNSksIG5ldyBFQ0IoNjcsIDE2KSkpLFxuICAgICAgbmV3IFZlcnNpb24oNDAsIG5ldyBBcnJheSg2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE5LCAxMTgpLCBuZXcgRUNCKDYsIDExOSkpLFxuICAgICAgICBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTgsIDQ3KSwgbmV3IEVDQigzMSwgNDgpKSxcbiAgICAgICAgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDM0LCAyNCksIG5ldyBFQ0IoMzQsIDI1KSksXG4gICAgICAgIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigyMCwgMTUpLCBuZXcgRUNCKDYxLCAxNikpKSk7XG4gIH0oKTtcblxuICBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIgPSBmdW5jdGlvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgaWYgKHZlcnNpb25OdW1iZXIgPCAxIHx8IHZlcnNpb25OdW1iZXIgPiA0MCkge1xuICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBWZXJzaW9uLlZFUlNJT05TW3ZlcnNpb25OdW1iZXIgLSAxXTtcbiAgfTtcblxuICBWZXJzaW9uLmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbiA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgIGlmIChkaW1lbnNpb24gJSA0ICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gVmVyc2lvbi5nZXRWZXJzaW9uRm9yTnVtYmVyKChkaW1lbnNpb24gLSAxNykgPj4gMik7XG4gIH07XG5cbiAgVmVyc2lvbi5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24gPSBmdW5jdGlvbih2ZXJzaW9uQml0cykge1xuICAgIHZhciBiZXN0RGlmZmVyZW5jZSA9IDB4ZmZmZmZmZmY7XG4gICAgdmFyIGJlc3RWZXJzaW9uID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFZlcnNpb24uVkVSU0lPTl9ERUNPREVfSU5GTy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk9baV07XG4gICAgICAvLyBEbyB0aGUgdmVyc2lvbiBpbmZvIGJpdHMgbWF0Y2ggZXhhY3RseT8gZG9uZS5cbiAgICAgIGlmICh0YXJnZXRWZXJzaW9uID09IHZlcnNpb25CaXRzKSB7XG4gICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIoaSArIDcpO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlIHNlZSBpZiB0aGlzIGlzIHRoZSBjbG9zZXN0IHRvIGEgcmVhbCB2ZXJzaW9uIGluZm8gYml0IHN0cmluZ1xuICAgICAgLy8gd2UgaGF2ZSBzZWVuIHNvIGZhclxuICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gdzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nKFxuICAgICAgICB2ZXJzaW9uQml0cywgdGFyZ2V0VmVyc2lvbik7XG4gICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xuICAgICAgICBiZXN0VmVyc2lvbiA9IGkgKyA3O1xuICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBjYW4gdG9sZXJhdGUgdXAgdG8gMyBiaXRzIG9mIGVycm9yIHNpbmNlIG5vIHR3byB2ZXJzaW9uIGluZm8gY29kZXdvcmRzXG4gICAgLy8gd2lsbCBkaWZmZXIgaW4gbGVzcyB0aGFuIDQgYml0cy5cbiAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgcmV0dXJuIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlcihiZXN0VmVyc2lvbik7XG4gICAgfVxuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY2xvc2UgZW5vdWdoIG1hdGNoLCBmYWlsXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRGV0ZWN0b3InKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuQml0TWF0cml4TGlrZScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkFsaWdubWVudFBhdHRlcm4nKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5BbGlnbm1lbnRQYXR0ZXJuRmluZGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQml0TWF0cml4Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRGVmYXVsdEdyaWRTYW1wbGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRmluZGVyUGF0dGVybkZpbmRlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLk1hdGhVdGlscycpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLk5vdEZvdW5kRXJyb3InKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5WZXJzaW9uJyk7XG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIFZlcnNpb24gPSB3NjliLnFyLlZlcnNpb247XG4gIHZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybSA9IHc2OWIucXIuUGVyc3BlY3RpdmVUcmFuc2Zvcm07XG4gIHZhciBOb3RGb3VuZEVycm9yID0gdzY5Yi5xci5Ob3RGb3VuZEVycm9yO1xuICB2YXIgTWF0aFV0aWxzID0gdzY5Yi5xci5NYXRoVXRpbHM7XG4gIHZhciBBbGlnbm1lbnRQYXR0ZXJuID0gdzY5Yi5xci5BbGlnbm1lbnRQYXR0ZXJuO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuRGV0ZWN0b3JSZXN1bHQgPSBmdW5jdGlvbihiaXRzLCBwb2ludHMpIHtcbiAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICB9O1xuICB2YXIgRGV0ZWN0b3JSZXN1bHQgPSB3NjliLnFyLkRldGVjdG9yUmVzdWx0O1xuXG4gIC8qKlxuICAgKiBFbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgUVIgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGVcbiAgICogUVIgQ29kZSBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLlxuICAgKlxuICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pIC0gcG9ydGVkIHRvIGpzXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyF3NjliLmltZy5CaXRNYXRyaXhMaWtlfSBpbWFnZSB0aGUgaW1hZ2UuXG4gICAqIEBwYXJhbSB7P3c2OWIucXIuUmVzdWx0UG9pbnRDYWxsYmFjaz19IG9wdF9jYWxsYmFjayBjYWxsYmFjay5cbiAgICovXG4gIHc2OWIucXIuRGV0ZWN0b3IgPSBmdW5jdGlvbihpbWFnZSwgb3B0X2NhbGxiYWNrKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyF3NjliLmltZy5CaXRNYXRyaXhMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSBvcHRfY2FsbGJhY2sgfHwgbnVsbDtcbiAgfTtcbiAgdmFyIHBybyA9IHc2OWIucXIuRGV0ZWN0b3IucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiA8cD5UaGlzIG1ldGhvZCB0cmFjZXMgYSBsaW5lIGZyb20gYSBwb2ludCBpbiB0aGUgaW1hZ2UsIGluIHRoZVxuICAgKiBkaXJlY3Rpb24gdG93YXJkcyBhbm90aGVyIHBvaW50LlxuICAgKiBJdCBiZWdpbnMgaW4gYSBibGFjayByZWdpb24sIGFuZCBrZWVwcyBnb2luZyB1bnRpbCBpdCBmaW5kcyB3aGl0ZSxcbiAgICogdGhlbiBibGFjaywgdGhlbiB3aGl0ZSBhZ2Fpbi5cbiAgICogSXQgcmVwb3J0cyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgdG8gdGhpcyBwb2ludC48L3A+XG4gICAqXG4gICAqIDxwPlRoaXMgaXMgdXNlZCB3aGVuIGZpZ3VyaW5nIG91dCBob3cgd2lkZSBhIGZpbmRlciBwYXR0ZXJuIGlzLFxuICAgKiB3aGVuIHRoZSBmaW5kZXIgcGF0dGVybiBtYXkgYmUgc2tld2VkIG9yIHJvdGF0ZWQuPC9wPlxuICAgKi9cbiAgLyoqXG4gICAqIDxwPlRoaXMgbWV0aG9kIHRyYWNlcyBhIGxpbmUgZnJvbSBhIHBvaW50IGluIHRoZSBpbWFnZSwgaW4gdGhlIGRpcmVjdGlvblxuICAgKiB0b3dhcmRzIGFub3RoZXIgcG9pbnQuXG4gICAqIEl0IGJlZ2lucyBpbiBhIGJsYWNrIHJlZ2lvbiwgYW5kIGtlZXBzIGdvaW5nIHVudGlsIGl0IGZpbmRzIHdoaXRlLCB0aGVuXG4gICAqIGJsYWNrLCB0aGVuIHdoaXRlIGFnYWluLlxuICAgKiBJdCByZXBvcnRzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzdGFydCB0byB0aGlzIHBvaW50LjwvcD5cbiAgICpcbiAgICogPHA+VGhpcyBpcyB1c2VkIHdoZW4gZmlndXJpbmcgb3V0IGhvdyB3aWRlIGEgZmluZGVyIHBhdHRlcm4gaXMsIHdoZW4gdGhlXG4gICAqIGZpbmRlciBwYXR0ZXJuXG4gICAqIG1heSBiZSBza2V3ZWQgb3Igcm90YXRlZC48L3A+XG4gICAqL1xuICBwcm8uc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSkge1xuICAgIC8vIE1pbGQgdmFyaWFudCBvZiBCcmVzZW5oYW0ncyBhbGdvcml0aG07XG4gICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG1cbiAgICB2YXIgc3RlZXAgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSkgPiBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICB2YXIgdGVtcCA9IGZyb21YO1xuICAgICAgZnJvbVggPSBmcm9tWTtcbiAgICAgIGZyb21ZID0gdGVtcDtcbiAgICAgIHRlbXAgPSB0b1g7XG4gICAgICB0b1ggPSB0b1k7XG4gICAgICB0b1kgPSB0ZW1wO1xuICAgIH1cblxuICAgIHZhciBkeCA9IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7XG4gICAgdmFyIGVycm9yID0gLWR4ID4+IDE7XG4gICAgdmFyIHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XG4gICAgdmFyIHlzdGVwID0gZnJvbVkgPCB0b1kgPyAxIDogLTE7XG5cbiAgICAvLyBJbiBibGFjayBwaXhlbHMsIGxvb2tpbmcgZm9yIHdoaXRlLCBmaXJzdCBvciBzZWNvbmQgdGltZS5cbiAgICB2YXIgc3RhdGUgPSAwO1xuICAgIC8vIExvb3AgdXAgdW50aWwgeCA9PSB0b1gsIGJ1dCBub3QgYmV5b25kXG4gICAgdmFyIHhMaW1pdCA9IHRvWCArIHhzdGVwO1xuICAgIGZvciAodmFyIHggPSBmcm9tWCwgeSA9IGZyb21ZOyB4ICE9IHhMaW1pdDsgeCArPSB4c3RlcCkge1xuICAgICAgdmFyIHJlYWxYID0gc3RlZXAgPyB5IDogeDtcbiAgICAgIHZhciByZWFsWSA9IHN0ZWVwID8geCA6IHk7XG5cbiAgICAgIC8vIERvZXMgY3VycmVudCBwaXhlbCBtZWFuIHdlIGhhdmUgbW92ZWQgd2hpdGUgdG8gYmxhY2sgb3IgdmljZSB2ZXJzYT9cbiAgICAgIC8vIFNjYW5uaW5nIGJsYWNrIGluIHN0YXRlIDAsMiBhbmQgd2hpdGUgaW4gc3RhdGUgMSwgc28gaWYgd2UgZmluZFxuICAgICAgLy8gdGhlIHdyb25nXG4gICAgICAvLyBjb2xvciwgYWR2YW5jZSB0byBuZXh0IHN0YXRlIG9yIGVuZCBpZiB3ZSBhcmUgaW4gc3RhdGUgMiBhbHJlYWR5XG4gICAgICBpZiAoKHN0YXRlID09IDEpID09ICEhdGhpcy5pbWFnZS5nZXQocmVhbFgsIHJlYWxZKSkge1xuICAgICAgICBpZiAoc3RhdGUgPT0gMikge1xuICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoeCwgeSwgZnJvbVgsIGZyb21ZKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSsrO1xuICAgICAgfVxuXG4gICAgICBlcnJvciArPSBkeTtcbiAgICAgIGlmIChlcnJvciA+IDApIHtcbiAgICAgICAgaWYgKHkgPT0gdG9ZKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeSArPSB5c3RlcDtcbiAgICAgICAgZXJyb3IgLT0gZHg7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZvdW5kIGJsYWNrLXdoaXRlLWJsYWNrOyBnaXZlIHRoZSBiZW5lZml0IG9mIHRoZSBkb3VidCB0aGF0IHRoZSBuZXh0XG4gICAgLy8gcGl4ZWwgb3V0c2lkZSB0aGUgaW1hZ2VcbiAgICAvLyBpcyBcIndoaXRlXCIgc28gdGhpcyBsYXN0IHBvaW50IGF0ICh0b1greFN0ZXAsdG9ZKSBpcyB0aGUgcmlnaHQgZW5kaW5nLlxuICAgIC8vIFRoaXMgaXMgcmVhbGx5IGFcbiAgICAvLyBzbWFsbCBhcHByb3hpbWF0aW9uOyAodG9YK3hTdGVwLHRvWSt5U3RlcCkgbWlnaHQgYmUgcmVhbGx5IGNvcnJlY3QuXG4gICAgLy8gSWdub3JlIHRoaXMuXG4gICAgaWYgKHN0YXRlID09IDIpIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UodG9YICsgeHN0ZXAsIHRvWSwgZnJvbVgsIGZyb21ZKTtcbiAgICB9XG4gICAgLy8gZWxzZSB3ZSBkaWRuJ3QgZmluZCBldmVuIGJsYWNrLXdoaXRlLWJsYWNrOyBubyBlc3RpbWF0ZSBpcyByZWFsbHlcbiAgICAvLyBwb3NzaWJsZVxuICAgIHJldHVybiBOYU47XG4gIH07XG5cblxuICAvKipcbiAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlc1xuICAgKiB0aGUgdG90YWwgd2lkdGggb2ZcbiAgICogYSBmaW5kZXIgcGF0dGVybiBieSBsb29raW5nIGZvciBhIGJsYWNrLXdoaXRlLWJsYWNrIHJ1biBmcm9tIHRoZSBjZW50ZXJcbiAgICogaW4gdGhlIGRpcmVjdGlvblxuICAgKiBvZiBhbm90aGVyIHBvaW50IChhbm90aGVyIGZpbmRlciBwYXR0ZXJuIGNlbnRlciksIGFuZCBpbiB0aGUgb3Bwb3NpdGVcbiAgICogZGlyZWN0aW9uIHRvby48L3A+XG4gICAqL1xuICBwcm8uc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG5cbiAgICAvLyBOb3cgY291bnQgb3RoZXIgd2F5IC0tIGRvbid0IHJ1biBvZmYgaW1hZ2UgdGhvdWdoIG9mIGNvdXJzZVxuICAgIHZhciBzY2FsZSA9IDEuMDtcbiAgICB2YXIgb3RoZXJUb1ggPSBmcm9tWCAtICh0b1ggLSBmcm9tWCk7XG4gICAgaWYgKG90aGVyVG9YIDwgMCkge1xuICAgICAgc2NhbGUgPSBmcm9tWCAvIChmcm9tWCAtIG90aGVyVG9YKTtcbiAgICAgIG90aGVyVG9YID0gMDtcbiAgICB9IGVsc2UgaWYgKG90aGVyVG9YID49IHRoaXMuaW1hZ2Uud2lkdGgpIHtcbiAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2Uud2lkdGggLSAxIC0gZnJvbVgpIC8gKG90aGVyVG9YIC0gZnJvbVgpO1xuICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLndpZHRoIC0gMTtcbiAgICB9XG4gICAgdmFyIG90aGVyVG9ZID0gTWF0aC5mbG9vcihmcm9tWSAtICh0b1kgLSBmcm9tWSkgKiBzY2FsZSk7XG5cbiAgICBzY2FsZSA9IDEuMDtcbiAgICBpZiAob3RoZXJUb1kgPCAwKSB7XG4gICAgICBzY2FsZSA9IGZyb21ZIC8gKGZyb21ZIC0gb3RoZXJUb1kpO1xuICAgICAgb3RoZXJUb1kgPSAwO1xuICAgIH0gZWxzZSBpZiAob3RoZXJUb1kgPj0gdGhpcy5pbWFnZS5oZWlnaHQpIHtcbiAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuaGVpZ2h0IC0gMSAtIGZyb21ZKSAvIChvdGhlclRvWSAtIGZyb21ZKTtcbiAgICAgIG90aGVyVG9ZID0gdGhpcy5pbWFnZS5oZWlnaHQgLSAxO1xuICAgIH1cbiAgICBvdGhlclRvWCA9IE1hdGguZmxvb3IoZnJvbVggKyAob3RoZXJUb1ggLSBmcm9tWCkgKiBzY2FsZSk7XG5cbiAgICByZXN1bHQgKz0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCBvdGhlclRvWCwgb3RoZXJUb1kpO1xuICAgIHJldHVybiByZXN1bHQgLSAxLjA7IC8vIC0xIGJlY2F1c2Ugd2UgY291bnRlZCB0aGUgbWlkZGxlIHBpeGVsIHR3aWNlXG4gIH07XG5cbiAgLyoqXG4gICAqIDxwPkVzdGltYXRlcyBtb2R1bGUgc2l6ZSBiYXNlZCBvbiB0d28gZmluZGVyIHBhdHRlcm5zIC0tIGl0IHVzZXNcbiAgICoge0BsaW5rICNzaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cyhpbnQsIGludCwgaW50LCBpbnQpfSB0b1xuICAgKiBmaWd1cmUgdGhlXG4gICAqIHdpZHRoIG9mIGVhY2gsIG1lYXN1cmluZyBhbG9uZyB0aGUgYXhpcyBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuPC9wPlxuICAgKi9cbiAgcHJvLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkgPSBmdW5jdGlvbihwYXR0ZXJuLCBvdGhlclBhdHRlcm4pIHtcbiAgICB2YXIgbW9kdWxlU2l6ZUVzdDEgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKFxuICAgICAgTWF0aC5mbG9vcihwYXR0ZXJuLngpLFxuICAgICAgTWF0aC5mbG9vcihwYXR0ZXJuLnkpLCBNYXRoLmZsb29yKG90aGVyUGF0dGVybi54KSxcbiAgICAgIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLnkpKTtcbiAgICB2YXIgbW9kdWxlU2l6ZUVzdDIgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKFxuICAgICAgTWF0aC5mbG9vcihvdGhlclBhdHRlcm4ueCksXG4gICAgICBNYXRoLmZsb29yKG90aGVyUGF0dGVybi55KSwgTWF0aC5mbG9vcihwYXR0ZXJuLngpLFxuICAgICAgTWF0aC5mbG9vcihwYXR0ZXJuLnkpKTtcbiAgICBpZiAoaXNOYU4obW9kdWxlU2l6ZUVzdDEpKSB7XG4gICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDIgLyA3LjA7XG4gICAgfVxuICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MikpIHtcbiAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MSAvIDcuMDtcbiAgICB9XG4gICAgLy8gQXZlcmFnZSB0aGVtLCBhbmQgZGl2aWRlIGJ5IDcgc2luY2Ugd2UndmUgY291bnRlZCB0aGUgd2lkdGggb2YgMyBibGFja1xuICAgIC8vIG1vZHVsZXMsIGFuZCAxIHdoaXRlIGFuZCAxIGJsYWNrIG1vZHVsZSBvbiBlaXRoZXIgc2lkZS4gRXJnbywgZGl2aWRlIHN1bVxuICAgIC8vIGJ5IDE0LlxuICAgIHJldHVybiAobW9kdWxlU2l6ZUVzdDEgKyBtb2R1bGVTaXplRXN0MikgLyAxNC4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5Db21wdXRlcyBhbiBhdmVyYWdlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBiYXNlZCBvbiBlc3RpbWF0ZWQgZGVyaXZlZFxuICAgKiBmcm9tIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucy48L3A+XG4gICAqL1xuICBwcm8uY2FsY3VsYXRlTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KSB7XG4gICAgLy8gVGFrZSB0aGUgYXZlcmFnZVxuICAgIHJldHVybiAodGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHRvcExlZnQsXG4gICAgICB0b3BSaWdodCkgKyB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wO1xuICB9O1xuXG4gIHByby5kaXN0YW5jZSA9IGZ1bmN0aW9uKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgIHZhciB4RGlmZiA9IHBhdHRlcm4xLnggLSBwYXR0ZXJuMi54O1xuICAgIHZhciB5RGlmZiA9IHBhdHRlcm4xLnkgLSBwYXR0ZXJuMi55O1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKSk7XG4gIH07XG5cbiAgcHJvLmNvbXB1dGVEaW1lbnNpb24gPSBmdW5jdGlvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSkge1xuXG4gICAgdmFyIHRsdHJDZW50ZXJzRGltZW5zaW9uID0gdGhpcy5kaXN0YW5jZSh0b3BMZWZ0LFxuICAgICAgdG9wUmlnaHQpIC8gbW9kdWxlU2l6ZTtcbiAgICB2YXIgdGxibENlbnRlcnNEaW1lbnNpb24gPSB0aGlzLmRpc3RhbmNlKHRvcExlZnQsXG4gICAgICBib3R0b21MZWZ0KSAvIG1vZHVsZVNpemU7XG4gICAgdmFyIGRpbWVuc2lvbiA9IE1hdGgucm91bmQoKFxuICAgICAgdGx0ckNlbnRlcnNEaW1lbnNpb24gKyB0bGJsQ2VudGVyc0RpbWVuc2lvbikgLyAyKSArIDc7XG4gICAgc3dpdGNoIChkaW1lbnNpb24gJSA0KSB7XG4gICAgICAvLyBtb2QgNFxuICAgICAgY2FzZSAwOlxuICAgICAgICBkaW1lbnNpb24rKztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyAxPyBkbyBub3RoaW5nXG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZGltZW5zaW9uLS07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIHdvdWxkIGl0IGJlIGJldHRlciB0byBkbyBzb21ldGhpbmcgbGlrZSBkaW1lbnNpb24gKz0gMjsgP1xuICAgICAgICAvLyB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpO1xuICAgICAgICBkaW1lbnNpb24gKz0gMjtcbiAgICB9XG4gICAgLy8gU29tZXRpbWVzIGRpbWVuc2lvbiBpcyAxNyAtIHdoaWNoIGlzIGludmFsaWQuIFdoeT9cbiAgICByZXR1cm4gZGltZW5zaW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5BdHRlbXB0cyB0byBsb2NhdGUgYW4gYWxpZ25tZW50IHBhdHRlcm4gaW4gYSBsaW1pdGVkIHJlZ2lvbiBvZiB0aGVcbiAgICogaW1hZ2UsIHdoaWNoIGlzXG4gICAqIGd1ZXNzZWQgdG8gY29udGFpbiBpdC4gVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0uPC9wPlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmFsbEVzdE1vZHVsZVNpemUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIHNvIGZhci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVzdEFsaWdubWVudFggeCBjb29yZGluYXRlIG9mIGNlbnRlciBvZiBhcmVhIHByb2JhYmx5XG4gICAqIGNvbnRhaW5pbmcgYWxpZ25tZW50IHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlc3RBbGlnbm1lbnRZIHkgY29vcmRpbmF0ZSBvZiBhYm92ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFsbG93YW5jZUZhY3RvciBudW1iZXIgb2YgcGl4ZWxzIGluIGFsbCBkaXJlY3Rpb25zIHRvXG4gICAqIHNlYXJjaCBmcm9tIHRoZSBjZW50ZXIuXG4gICAqIEByZXR1cm4ge0FsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHByby5maW5kQWxpZ25tZW50SW5SZWdpb24gPSBmdW5jdGlvbihvdmVyYWxsRXN0TW9kdWxlU2l6ZSwgZXN0QWxpZ25tZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzdEFsaWdubWVudFksIGFsbG93YW5jZUZhY3Rvcikge1xuICAgIC8vIExvb2sgZm9yIGFuIGFsaWdubWVudCBwYXR0ZXJuICgzIG1vZHVsZXMgaW4gc2l6ZSkgYXJvdW5kIHdoZXJlIGl0XG4gICAgLy8gc2hvdWxkIGJlXG4gICAgdmFyIGFsbG93YW5jZSA9IE1hdGguZmxvb3IoYWxsb3dhbmNlRmFjdG9yICogb3ZlcmFsbEVzdE1vZHVsZVNpemUpO1xuICAgIHZhciBhbGlnbm1lbnRBcmVhTGVmdFggPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRYIC0gYWxsb3dhbmNlKTtcbiAgICB2YXIgYWxpZ25tZW50QXJlYVJpZ2h0WCA9IE1hdGgubWluKHRoaXMuaW1hZ2Uud2lkdGggLSAxLFxuICAgICAgZXN0QWxpZ25tZW50WCArIGFsbG93YW5jZSk7XG4gICAgaWYgKGFsaWdubWVudEFyZWFSaWdodFggLSBhbGlnbm1lbnRBcmVhTGVmdFggPFxuICAgICAgb3ZlcmFsbEVzdE1vZHVsZVNpemUgKiAzKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcigpO1xuICAgIH1cblxuICAgIHZhciBhbGlnbm1lbnRBcmVhVG9wWSA9IE1hdGgubWF4KDAsIGVzdEFsaWdubWVudFkgLSBhbGxvd2FuY2UpO1xuICAgIHZhciBhbGlnbm1lbnRBcmVhQm90dG9tWSA9IE1hdGgubWluKHRoaXMuaW1hZ2UuaGVpZ2h0IC0gMSxcbiAgICAgIGVzdEFsaWdubWVudFkgKyBhbGxvd2FuY2UpO1xuXG4gICAgdmFyIGFsaWdubWVudEZpbmRlciA9IG5ldyB3NjliLnFyLkFsaWdubWVudFBhdHRlcm5GaW5kZXIodGhpcy5pbWFnZSxcbiAgICAgIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYVRvcFksXG4gICAgICBhbGlnbm1lbnRBcmVhUmlnaHRYIC0gYWxpZ25tZW50QXJlYUxlZnRYLFxuICAgICAgYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSwgb3ZlcmFsbEVzdE1vZHVsZVNpemUsXG4gICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xuICAgIHJldHVybiBhbGlnbm1lbnRGaW5kZXIuZmluZCgpO1xuICB9O1xuXG4gIHByby5jcmVhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbikge1xuICAgIHZhciBkaW1NaW51c1RocmVlID0gZGltZW5zaW9uIC0gMy41O1xuICAgIHZhciBib3R0b21SaWdodFg7XG4gICAgdmFyIGJvdHRvbVJpZ2h0WTtcbiAgICB2YXIgc291cmNlQm90dG9tUmlnaHRYO1xuICAgIHZhciBzb3VyY2VCb3R0b21SaWdodFk7XG4gICAgaWYgKGFsaWdubWVudFBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgYm90dG9tUmlnaHRYID0gYWxpZ25tZW50UGF0dGVybi54O1xuICAgICAgYm90dG9tUmlnaHRZID0gYWxpZ25tZW50UGF0dGVybi55O1xuICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gc291cmNlQm90dG9tUmlnaHRZID0gZGltTWludXNUaHJlZSAtIDMuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgaGF2ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiwganVzdCBtYWtlIHVwIHRoZSBib3R0b20tcmlnaHQgcG9pbnRcbiAgICAgIGJvdHRvbVJpZ2h0WCA9ICh0b3BSaWdodC54IC0gdG9wTGVmdC54KSArIGJvdHRvbUxlZnQueDtcbiAgICAgIGJvdHRvbVJpZ2h0WSA9ICh0b3BSaWdodC55IC0gdG9wTGVmdC55KSArIGJvdHRvbUxlZnQueTtcbiAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IHNvdXJjZUJvdHRvbVJpZ2h0WSA9IGRpbU1pbnVzVGhyZWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoMy41LFxuICAgICAgMy41LFxuICAgICAgZGltTWludXNUaHJlZSwgMy41LCBzb3VyY2VCb3R0b21SaWdodFgsIHNvdXJjZUJvdHRvbVJpZ2h0WSwgMy41LFxuICAgICAgZGltTWludXNUaHJlZSwgdG9wTGVmdC54LCB0b3BMZWZ0LnksIHRvcFJpZ2h0LngsIHRvcFJpZ2h0LnksXG4gICAgICBib3R0b21SaWdodFgsXG4gICAgICBib3R0b21SaWdodFksIGJvdHRvbUxlZnQueCwgYm90dG9tTGVmdC55KTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH07XG5cbiAgcHJvLnNhbXBsZUdyaWQgPSBmdW5jdGlvbihpbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24pIHtcbiAgICB2YXIgc2FtcGxlciA9IHc2OWIucXIuR3JpZFNhbXBsZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb24sIGRpbWVuc2lvbiwgdHJhbnNmb3JtKTtcbiAgfTtcblxuICAvKipcbiAgICogVE9ETy5cbiAgICogQHBhcmFtIHt3NjliLnFyLkZpbmRlclBhdHRlcm5JbmZvfSBpbmZvIGluZm8uXG4gICAqIEByZXR1cm4geyF3NjliLnFyLkRldGVjdG9yUmVzdWx0fSByZXN1bHQuXG4gICAqL1xuICBwcm8ucHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvID0gZnVuY3Rpb24oaW5mbykge1xuXG4gICAgdmFyIHRvcExlZnQgPSBpbmZvLnRvcExlZnQ7XG4gICAgdmFyIHRvcFJpZ2h0ID0gaW5mby50b3BSaWdodDtcbiAgICB2YXIgYm90dG9tTGVmdCA9IGluZm8uYm90dG9tTGVmdDtcblxuICAgIHZhciBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcbiAgICBpZiAobW9kdWxlU2l6ZSA8IDEuMCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuY29tcHV0ZURpbWVuc2lvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCxcbiAgICAgIG1vZHVsZVNpemUpO1xuICAgIHZhciBwcm92aXNpb25hbFZlcnNpb24gPSBWZXJzaW9uLmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihcbiAgICAgIGRpbWVuc2lvbik7XG4gICAgdmFyIG1vZHVsZXNCZXR3ZWVuRlBDZW50ZXJzID1cbiAgICAgIHByb3Zpc2lvbmFsVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgLSA3O1xuXG4gICAgdmFyIGFsaWdubWVudFBhdHRlcm4gPSBudWxsO1xuICAgIC8vIEFueXRoaW5nIGFib3ZlIHZlcnNpb24gMSBoYXMgYW4gYWxpZ25tZW50IHBhdHRlcm5cbiAgICBpZiAocHJvdmlzaW9uYWxWZXJzaW9uLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzLmxlbmd0aCA+IDApIHtcblxuICAgICAgLy8gR3Vlc3Mgd2hlcmUgYSBcImJvdHRvbSByaWdodFwiIGZpbmRlciBwYXR0ZXJuIHdvdWxkIGhhdmUgYmVlblxuICAgICAgdmFyIGJvdHRvbVJpZ2h0WCA9IHRvcFJpZ2h0LnggLSB0b3BMZWZ0LnggKyBib3R0b21MZWZ0Lng7XG4gICAgICB2YXIgYm90dG9tUmlnaHRZID0gdG9wUmlnaHQueSAtIHRvcExlZnQueSArIGJvdHRvbUxlZnQueTtcblxuICAgICAgLy8gRXN0aW1hdGUgdGhhdCBhbGlnbm1lbnQgcGF0dGVybiBpcyBjbG9zZXIgYnkgMyBtb2R1bGVzXG4gICAgICAvLyBmcm9tIFwiYm90dG9tIHJpZ2h0XCIgdG8ga25vd24gdG9wIGxlZnQgbG9jYXRpb25cbiAgICAgIHZhciBjb3JyZWN0aW9uVG9Ub3BMZWZ0ID0gMS4wIC0gMy4wIC8gbW9kdWxlc0JldHdlZW5GUENlbnRlcnM7XG4gICAgICB2YXIgZXN0QWxpZ25tZW50WCA9IE1hdGguZmxvb3IodG9wTGVmdC54ICtcbiAgICAgICAgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFggLSB0b3BMZWZ0LngpKTtcbiAgICAgIHZhciBlc3RBbGlnbm1lbnRZID0gTWF0aC5mbG9vcih0b3BMZWZ0LnkgK1xuICAgICAgICBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WSAtIHRvcExlZnQueSkpO1xuXG4gICAgICAvLyBLaW5kIG9mIGFyYml0cmFyeSAtLSBleHBhbmQgc2VhcmNoIHJhZGl1cyBiZWZvcmUgZ2l2aW5nIHVwXG4gICAgICBmb3IgKHZhciBpID0gNDsgaSA8PSAxNjsgaSAqPSAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWxpZ25tZW50UGF0dGVybiA9XG4gICAgICAgICAgICB0aGlzLmZpbmRBbGlnbm1lbnRJblJlZ2lvbihtb2R1bGVTaXplLCBlc3RBbGlnbm1lbnRYLFxuICAgICAgICAgICAgICBlc3RBbGlnbm1lbnRZLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgLy8gdHJ5IG5leHQgcm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYWxpZ25tZW50IHBhdHRlcm4uLi4gd2VsbCB0cnkgYW55d2F5IHdpdGhvdXQgaXRcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsXG4gICAgICBhbGlnbm1lbnRQYXR0ZXJuLCBkaW1lbnNpb24pO1xuXG4gICAgdmFyIGJpdHMgPSB0aGlzLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24pO1xuXG4gICAgdmFyIHBvaW50cztcbiAgICBpZiAoYWxpZ25tZW50UGF0dGVybiA9PSBudWxsKSB7XG4gICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHQsIGFsaWdubWVudFBhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0KGJpdHMsIHBvaW50cyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7IXc2OWIucXIuRGV0ZWN0b3JSZXN1bHR9IHJlc3VsdC5cbiAgICovXG4gIHByby5kZXRlY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IG5ldyB3NjliLnFyLkZpbmRlclBhdHRlcm5GaW5kZXIodGhpcy5pbWFnZSxcbiAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjaykuZmluZCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKTtcbiAgfTtcbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWwnKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFNlZSBJU08gMTgwMDQ6MjAwNiwgNi41LjEuIFRoaXMgZW51bSBlbmNhcHN1bGF0ZXMgdGhlIGZvdXIgZXJyb3JcbiAgICogY29ycmVjdGlvbiBsZXZlbHMgZGVmaW5lZCBieSB0aGUgUVIgY29kZSBzdGFuZGFyZC5cbiAgICpcbiAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICogQGF1dGhvciBtYkB3NjliLmNvbSAoTWFudWVsIEJyYXVuKVxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBmdW5jdGlvbihvcmRpbmFsLCBiaXRzLCBuYW1lKSB7XG4gICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH07XG4gIHZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHc2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG5cbiAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbCgwLCAweDAxLCAnTCcpO1xuICBFcnJvckNvcnJlY3Rpb25MZXZlbC5NID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKDEsIDB4MDAsICdNJyk7XG4gIEVycm9yQ29ycmVjdGlvbkxldmVsLlEgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoMiwgMHgwMywgJ1EnKTtcbiAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSCA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbCgzLCAweDAyLCAnSCcpO1xuICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUyA9IFtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5NLFxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkwsXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSCxcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5RXTtcblxuICAvKipcbiAgICogZ2V0IGJ5IG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9uZSBvZiAnTCcsICdNJywgJ1EnLCAnSCc7LlxuICAgKiBAcmV0dXJuIHtFcnJvckNvcnJlY3Rpb25MZXZlbH0gZWMgbGV2ZWwgb3IgbnVsbCBpZiBuYW1lIGlzIGludmFsaWQuXG4gICAqL1xuICBFcnJvckNvcnJlY3Rpb25MZXZlbC5nZXRCeU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1hcCA9IHsnTCc6IEVycm9yQ29ycmVjdGlvbkxldmVsLkwsXG4gICAgICAnTSc6IEVycm9yQ29ycmVjdGlvbkxldmVsLk0sXG4gICAgICAnUSc6IEVycm9yQ29ycmVjdGlvbkxldmVsLlEsXG4gICAgICAnSCc6IEVycm9yQ29ycmVjdGlvbkxldmVsLkh9O1xuICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiBtYXBbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcHJvID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwucHJvdG90eXBlO1xuXG4gIHByby5nZXRCaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0cztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBkZWJ1ZyBzdHJpbmcuXG4gICAqL1xuICBwcm8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0cyBpbnQgY29udGFpbmluZyB0aGUgdHdvIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlJ3NcbiAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICogQHJldHVybiB7IUVycm9yQ29ycmVjdGlvbkxldmVsfSByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZXJyb3JcbiAgICogY29ycmVjdGlvbiBsZXZlbC5cbiAgICovXG4gIEVycm9yQ29ycmVjdGlvbkxldmVsLmZvckJpdHMgPSBmdW5jdGlvbihiaXRzKSB7XG4gICAgaWYgKGJpdHMgPCAwIHx8IGJpdHMgPj0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTW2JpdHNdO1xuICB9O1xufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuICovXG5cbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbicpO1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLlVSU2hpZnQnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5FcnJvckNvcnJlY3Rpb25MZXZlbCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgdG9kby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHMgdG9kby5cbiAgICogQHJldHVybiB7bnVtYmVyfSB0b2RvLlxuICAgKi9cbiAgdzY5Yi5xci5VUlNoaWZ0ID0gZnVuY3Rpb24obnVtYmVyLCBiaXRzKSB7XG4gICAgaWYgKG51bWJlciA+PSAwKVxuICAgICAgcmV0dXJuIG51bWJlciA+PiBiaXRzO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAobnVtYmVyID4+IGJpdHMpICsgKDIgPDwgfmJpdHMpO1xuICB9O1xuICB2YXIgVVJTaGlmdCA9IHc2OWIucXIuVVJTaGlmdDtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZm9ybWF0SW5mbyBmb3JtYXQgaW5mb3JtYXRpb24uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKGZvcm1hdEluZm8pIHtcbiAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID1cbiAgICAgIHc2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZm9yQml0cygoZm9ybWF0SW5mbyA+PiAzKSAmIDB4MDMpO1xuICAgIHRoaXMuZGF0YU1hc2sgPSAoZm9ybWF0SW5mbyAmIDB4MDcpO1xuICB9O1xuICB2YXIgRm9ybWF0SW5mb3JtYXRpb24gPSB3NjliLnFyLkZvcm1hdEluZm9ybWF0aW9uO1xuICB2YXIgcHJvID0gRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlO1xuXG4gIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIgPSAweDU0MTI7XG4gIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgPSBbXG4gICAgWzB4NTQxMiwgMHgwMF0sXG4gICAgWzB4NTEyNSwgMHgwMV0sXG4gICAgWzB4NUU3QywgMHgwMl0sXG4gICAgWzB4NUI0QiwgMHgwM10sXG4gICAgWzB4NDVGOSwgMHgwNF0sXG4gICAgWzB4NDBDRSwgMHgwNV0sXG4gICAgWzB4NEY5NywgMHgwNl0sXG4gICAgWzB4NEFBMCwgMHgwN10sXG4gICAgWzB4NzdDNCwgMHgwOF0sXG4gICAgWzB4NzJGMywgMHgwOV0sXG4gICAgWzB4N0RBQSwgMHgwQV0sXG4gICAgWzB4Nzg5RCwgMHgwQl0sXG4gICAgWzB4NjYyRiwgMHgwQ10sXG4gICAgWzB4NjMxOCwgMHgwRF0sXG4gICAgWzB4NkM0MSwgMHgwRV0sXG4gICAgWzB4Njk3NiwgMHgwRl0sXG4gICAgWzB4MTY4OSwgMHgxMF0sXG4gICAgWzB4MTNCRSwgMHgxMV0sXG4gICAgWzB4MUNFNywgMHgxMl0sXG4gICAgWzB4MTlEMCwgMHgxM10sXG4gICAgWzB4MDc2MiwgMHgxNF0sXG4gICAgWzB4MDI1NSwgMHgxNV0sXG4gICAgWzB4MEQwQywgMHgxNl0sXG4gICAgWzB4MDgzQiwgMHgxN10sXG4gICAgWzB4MzU1RiwgMHgxOF0sXG4gICAgWzB4MzA2OCwgMHgxOV0sXG4gICAgWzB4M0YzMSwgMHgxQV0sXG4gICAgWzB4M0EwNiwgMHgxQl0sXG4gICAgWzB4MjRCNCwgMHgxQ10sXG4gICAgWzB4MjE4MywgMHgxRF0sXG4gICAgWzB4MkVEQSwgMHgxRV0sXG4gICAgWzB4MkJFRCwgMHgxRl1cbiAgXTtcblxuICAvKipcbiAgICogT2Zmc2V0IGkgaG9sZHMgdGhlIG51bWJlciBvZiAxIGJpdHMgaW4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBpXG4gICAqL1xuICBGb3JtYXRJbmZvcm1hdGlvbi5CSVRTX1NFVF9JTl9IQUxGX0JZVEUgPSBbMCwgMSwgMSwgMiwgMSwgMiwgMiwgMyxcbiAgICAxLCAyLCAyLCAzLCAyLCAzLCAzLCA0XTtcblxuICBwcm8uR2V0SGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwub3JkaW5hbCA8PCAzKSB8IHRoaXMuZGF0YU1hc2s7XG4gIH07XG5cbiAgcHJvLkVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPT0gb3RoZXIuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgJiZcbiAgICAgIHRoaXMuZGF0YU1hc2sgPT0gb3RoZXIuZGF0YU1hc2s7XG4gIH07XG5cbiAgRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBhIF49IGI7IC8vIGEgbm93IGhhcyBhIDEgYml0IGV4YWN0bHkgd2hlcmUgaXRzIGJpdCBkaWZmZXJzIHdpdGggYidzXG4gICAgLy8gQ291bnQgYml0cyBzZXQgcXVpY2tseSB3aXRoIGEgc2VyaWVzIG9mIGxvb2t1cHM6XG4gICAgcmV0dXJuIEZvcm1hdEluZm9ybWF0aW9uLkJJVFNfU0VUX0lOX0hBTEZfQllURVthICYgMHgwRl0gK1xuICAgICAgRm9ybWF0SW5mb3JtYXRpb24uQklUU19TRVRfSU5fSEFMRl9CWVRFWyhVUlNoaWZ0KGEsIDQpICYgMHgwRildICtcbiAgICAgIEZvcm1hdEluZm9ybWF0aW9uLkJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCA4KSAmIDB4MEYpXSArXG4gICAgICBGb3JtYXRJbmZvcm1hdGlvbi5CSVRTX1NFVF9JTl9IQUxGX0JZVEVbKFVSU2hpZnQoYSwgMTIpICYgMHgwRildICtcbiAgICAgIEZvcm1hdEluZm9ybWF0aW9uLkJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCAxNikgJiAweDBGKV0gK1xuICAgICAgRm9ybWF0SW5mb3JtYXRpb24uQklUU19TRVRfSU5fSEFMRl9CWVRFWyhVUlNoaWZ0KGEsIDIwKSAmIDB4MEYpXSArXG4gICAgICBGb3JtYXRJbmZvcm1hdGlvbi5CSVRTX1NFVF9JTl9IQUxGX0JZVEVbKFVSU2hpZnQoYSwgMjQpICYgMHgwRildICtcbiAgICAgIEZvcm1hdEluZm9ybWF0aW9uLkJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCAyOCkgJiAweDBGKV07XG4gIH07XG5cbiAgRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24gPSBmdW5jdGlvbihtYXNrZWRGb3JtYXRJbmZvKSB7XG4gICAgdmFyIGZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKFxuICAgICAgbWFza2VkRm9ybWF0SW5mbyk7XG4gICAgaWYgKGZvcm1hdEluZm8gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZvcm1hdEluZm87XG4gICAgfVxuICAgIC8vIFNob3VsZCByZXR1cm4gbnVsbCwgYnV0LCBzb21lIFFSIGNvZGVzIGFwcGFyZW50bHlcbiAgICAvLyBkbyBub3QgbWFzayB0aGlzIGluZm8uIFRyeSBhZ2FpbiBieSBhY3R1YWxseSBtYXNraW5nIHRoZSBwYXR0ZXJuXG4gICAgLy8gZmlyc3RcbiAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvIF5cbiAgICAgIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIpO1xuICB9O1xuXG4gIEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24gPSBmdW5jdGlvbihtYXNrZWRGb3JtYXRJbmZvKSB7XG4gICAgLy8gRmluZCB0aGUgaW50IGluIEZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgd2l0aCBmZXdlc3QgYml0cyBkaWZmZXJpbmdcbiAgICB2YXIgYmVzdERpZmZlcmVuY2UgPSAweGZmZmZmZmZmO1xuICAgIHZhciBiZXN0Rm9ybWF0SW5mbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQLmxlbmd0aDtcbiAgICAgICAgIGkrKykge1xuICAgICAgdmFyIGRlY29kZUluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQW2ldO1xuICAgICAgdmFyIHRhcmdldEluZm8gPSBkZWNvZGVJbmZvWzBdO1xuICAgICAgaWYgKHRhcmdldEluZm8gPT0gbWFza2VkRm9ybWF0SW5mbykge1xuICAgICAgICAvLyBGb3VuZCBhbiBleGFjdCBtYXRjaFxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGRlY29kZUluZm9bMV0pO1xuICAgICAgfVxuICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhcbiAgICAgICAgbWFza2VkRm9ybWF0SW5mbywgdGFyZ2V0SW5mbyk7XG4gICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xuICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07XG4gICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEhhbW1pbmcgZGlzdGFuY2Ugb2YgdGhlIDMyIG1hc2tlZCBjb2RlcyBpcyA3LCBieSBjb25zdHJ1Y3Rpb24sXG4gICAgLy8gc28gPD0gMyBiaXRzIGRpZmZlcmluZyBtZWFucyB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcbiAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oYmVzdEZvcm1hdEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuICovXG5cbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkRhdGFNYXNrJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuVVJTaGlmdCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgVVJTaGlmdCA9IHc2OWIucXIuVVJTaGlmdDtcblxuICB2YXIgXyA9IHc2OWIucXIuRGF0YU1hc2s7XG5cbiAgLyoqIEBpbnRlcmZhY2UgKi9cbiAgXy5EYXRhTWFza0ludGVyZmFjZSA9IGZ1bmN0aW9uKCkge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5CaXRNYXRyaXh9IGJpdHMgYml0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbSBkaW1lbnNpb25zLlxuICAgKi9cbiAgXy5EYXRhTWFza0ludGVyZmFjZS5wcm90b3R5cGUudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24oYml0cywgZGltKSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgaWR4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaiBpZHguXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIHBvc2l0aW9uIGlzIG1hc2tlZC5cbiAgICovXG4gIF8uRGF0YU1hc2tJbnRlcmZhY2UucHJvdG90eXBlLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge307XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlZmVyZW5jZSBtYXNrIG51bWJlci5cbiAgICogQHJldHVybiB7IV8uRGF0YU1hc2tJbnRlcmZhY2V9IGRhdGEgbWFzay5cbiAgICovXG4gIF8uZm9yUmVmZXJlbmNlID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gICAgaWYgKHJlZmVyZW5jZSA8IDAgfHwgcmVmZXJlbmNlID4gNykge1xuICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIF8uREFUQV9NQVNLU19bcmVmZXJlbmNlXTtcbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBfLkRhdGFNYXNrMDAwID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIF8uRGF0YU1hc2swMDAucHJvdG90eXBlLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF8uRGF0YU1hc2swMDAucHJvdG90eXBlLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiAoKGkgKyBqKSAmIDB4MDEpID09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXy5EYXRhTWFzazAwMSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBfLkRhdGFNYXNrMDAxLnByb3RvdHlwZS51bm1hc2tCaXRNYXRyaXggPSBmdW5jdGlvbihiaXRzLCBkaW1lbnNpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfLkRhdGFNYXNrMDAxLnByb3RvdHlwZS5pc01hc2tlZCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICByZXR1cm4gKGkgJiAweDAxKSA9PSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIF8uRGF0YU1hc2swMTAgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgXy5EYXRhTWFzazAxMC5wcm90b3R5cGUudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24oYml0cywgZGltZW5zaW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkge1xuICAgICAgICAgIGJpdHMuZmxpcChqLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXy5EYXRhTWFzazAxMC5wcm90b3R5cGUuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgcmV0dXJuIGogJSAzID09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXy5EYXRhTWFzazAxMSA9IGZ1bmN0aW9uKCkge1xuXG4gIH07XG4gIF8uRGF0YU1hc2swMTEucHJvdG90eXBlLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF8uRGF0YU1hc2swMTEucHJvdG90eXBlLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiAoaSArIGopICUgMyA9PSAwO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXy5EYXRhTWFzazEwMCA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBfLkRhdGFNYXNrMTAwLnByb3RvdHlwZS51bm1hc2tCaXRNYXRyaXggPSBmdW5jdGlvbihiaXRzLCBkaW1lbnNpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfLkRhdGFNYXNrMTAwLnByb3RvdHlwZS5pc01hc2tlZCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICByZXR1cm4gKCgoVVJTaGlmdChpLCAxKSkgKyAoaiAvIDMpKSAmIDB4MDEpID09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXy5EYXRhTWFzazEwMSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuXG4gIF8uRGF0YU1hc2sxMDEucHJvdG90eXBlLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXy5EYXRhTWFzazEwMS5wcm90b3R5cGUuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgdmFyIHRlbXAgPSBpICogajtcbiAgICByZXR1cm4gKHRlbXAgJiAweDAxKSArICh0ZW1wICUgMykgPT0gMDtcbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBfLkRhdGFNYXNrMTEwID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIF8uRGF0YU1hc2sxMTAucHJvdG90eXBlLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF8uRGF0YU1hc2sxMTAucHJvdG90eXBlLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciB0ZW1wID0gaSAqIGo7XG4gICAgcmV0dXJuICgoKHRlbXAgJiAweDAxKSArICh0ZW1wICUgMykpICYgMHgwMSkgPT0gMDtcbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBfLkRhdGFNYXNrMTExID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIF8uRGF0YU1hc2sxMTEucHJvdG90eXBlLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF8uRGF0YU1hc2sxMTEucHJvdG90eXBlLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiAoKCgoaSArIGopICYgMHgwMSkgKyAoKGkgKiBqKSAlIDMpKSAmIDB4MDEpID09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48IV8uRGF0YU1hc2tJbnRlcmZhY2U+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgXy5EQVRBX01BU0tTXyA9IG5ldyBBcnJheShuZXcgXy5EYXRhTWFzazAwMCgpLCBuZXcgXy5EYXRhTWFzazAwMSgpLFxuICAgIG5ldyBfLkRhdGFNYXNrMDEwKCksIG5ldyBfLkRhdGFNYXNrMDExKCksIG5ldyBfLkRhdGFNYXNrMTAwKCksXG4gICAgbmV3IF8uRGF0YU1hc2sxMDEoKSxcbiAgICBuZXcgXy5EYXRhTWFzazExMCgpLCBuZXcgXy5EYXRhTWFzazExMSgpKTtcblxufSk7XG5cbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4gKi9cblxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLkJpdE1hdHJpeFBhcnNlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkRhdGFNYXNrJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRm9ybWF0RXJyb3InKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLlZlcnNpb24nKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIEZvcm1hdEluZm9ybWF0aW9uID0gdzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbjtcbiAgdmFyIFZlcnNpb24gPSB3NjliLnFyLlZlcnNpb247XG4gIHZhciBEYXRhTWFzayA9IHc2OWIucXIuRGF0YU1hc2s7XG4gIHZhciBGb3JtYXRFcnJvciA9IHc2OWIucXIuRm9ybWF0RXJyb3I7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5CaXRNYXRyaXh9IGJpdE1hdHJpeCBtYXRyaXguXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5CaXRNYXRyaXhQYXJzZXIgPSBmdW5jdGlvbihiaXRNYXRyaXgpIHtcbiAgICB2YXIgZGltZW5zaW9uID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgIGlmIChkaW1lbnNpb24gPCAyMSB8fCAoZGltZW5zaW9uICYgMHgwMykgIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuYml0TWF0cml4ID0gYml0TWF0cml4O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHt3NjliLnFyLlZlcnNpb259XG4gICAgICovXG4gICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7dzY5Yi5xci5Gb3JtYXRJbmZvcm1hdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlZEZvcm1hdEluZm8gPSBudWxsO1xuICB9O1xuICB2YXIgQml0TWF0cml4UGFyc2VyID0gdzY5Yi5xci5CaXRNYXRyaXhQYXJzZXI7XG4gIHZhciBwcm8gPSBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlO1xuXG4gIHByby5jb3B5Qml0ID0gZnVuY3Rpb24oaSwgaiwgdmVyc2lvbkJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRNYXRyaXguZ2V0KGksXG4gICAgICBqKSA/ICh2ZXJzaW9uQml0cyA8PCAxKSB8IDB4MSA6IHZlcnNpb25CaXRzIDw8IDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyF3NjliLnFyLkZvcm1hdEluZm9ybWF0aW9ufSBmb3JtYXQgaW5mb3JtYXRpb24uXG4gICAqL1xuICBwcm8ucmVhZEZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgIH1cblxuICAgIC8vIFJlYWQgdG9wLWxlZnQgZm9ybWF0IGluZm8gYml0c1xuICAgIHZhciBmb3JtYXRJbmZvQml0cyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGZvcm1hdEluZm9CaXRzID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzKTtcbiAgICB9XG4gICAgLy8gLi4gYW5kIHNraXAgYSBiaXQgaW4gdGhlIHRpbWluZyBwYXR0ZXJuIC4uLlxuICAgIGZvcm1hdEluZm9CaXRzID0gdGhpcy5jb3B5Qml0KDcsIDgsIGZvcm1hdEluZm9CaXRzKTtcbiAgICBmb3JtYXRJbmZvQml0cyA9IHRoaXMuY29weUJpdCg4LCA4LCBmb3JtYXRJbmZvQml0cyk7XG4gICAgZm9ybWF0SW5mb0JpdHMgPSB0aGlzLmNvcHlCaXQoOCwgNywgZm9ybWF0SW5mb0JpdHMpO1xuICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cbiAgICBmb3IgKHZhciBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGZvcm1hdEluZm9CaXRzID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlZEZvcm1hdEluZm8gPVxuICAgICAgRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24oZm9ybWF0SW5mb0JpdHMpO1xuICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcbiAgICB9XG5cbiAgICAvLyBIbW0sIGZhaWxlZC4gVHJ5IHRoZSB0b3AtcmlnaHQvYm90dG9tLWxlZnQgcGF0dGVyblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICBmb3JtYXRJbmZvQml0cyA9IDA7XG4gICAgdmFyIGlNaW4gPSBkaW1lbnNpb24gLSA4O1xuICAgIGZvciAodmFyIGkgPSBkaW1lbnNpb24gLSAxOyBpID49IGlNaW47IGktLSkge1xuICAgICAgZm9ybWF0SW5mb0JpdHMgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gNzsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICBmb3JtYXRJbmZvQml0cyA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID1cbiAgICAgIEZvcm1hdEluZm9ybWF0aW9uLmRlY29kZUZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm9CaXRzKTtcbiAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XG4gICAgfVxuICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLlZlcnNpb259IHZlcnNpb24uXG4gICAqL1xuICBwcm8ucmVhZFZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgfVxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuXG4gICAgdmFyIHByb3Zpc2lvbmFsVmVyc2lvbiA9IChkaW1lbnNpb24gLSAxNykgPj4gMjtcbiAgICBpZiAocHJvdmlzaW9uYWxWZXJzaW9uIDw9IDYpIHtcbiAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIocHJvdmlzaW9uYWxWZXJzaW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZWFkIHRvcC1yaWdodCB2ZXJzaW9uIGluZm86IDMgd2lkZSBieSA2IHRhbGxcbiAgICB2YXIgdmVyc2lvbkJpdHMgPSAwO1xuICAgIHZhciBpak1pbiA9IGRpbWVuc2lvbiAtIDExO1xuICAgIGZvciAodmFyIGogPSA1OyBqID49IDA7IGotLSkge1xuICAgICAgZm9yICh2YXIgaSA9IGRpbWVuc2lvbiAtIDk7IGkgPj0gaWpNaW47IGktLSkge1xuICAgICAgICB2ZXJzaW9uQml0cyA9IHRoaXMuY29weUJpdChpLCBqLCB2ZXJzaW9uQml0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gVmVyc2lvbi5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgIGlmICh0aGlzLnBhcnNlZFZlcnNpb24gIT0gbnVsbCAmJlxuICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PSBkaW1lbnNpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbFxuICAgIHZlcnNpb25CaXRzID0gMDtcbiAgICBmb3IgKHZhciBpID0gNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSA5OyBqID49IGlqTWluOyBqLS0pIHtcbiAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IFZlcnNpb24uZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uKHZlcnNpb25CaXRzKTtcbiAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9IG51bGwgJiZcbiAgICAgIHRoaXMucGFyc2VkVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgPT0gZGltZW5zaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZWRWZXJzaW9uO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTtcbiAgfTtcblxuICBwcm8ucmVhZENvZGV3b3JkcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGZvcm1hdEluZm8gPSB0aGlzLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xuICAgIHZhciB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbigpO1xuXG4gICAgLy8gR2V0IHRoZSBkYXRhIG1hc2sgZm9yIHRoZSBmb3JtYXQgdXNlZCBpbiB0aGlzIFFSIENvZGUuIFRoaXMgd2lsbCBleGNsdWRlXG4gICAgLy8gc29tZSBiaXRzIGZyb20gcmVhZGluZyBhcyB3ZSB3aW5kIHRocm91Z2ggdGhlIGJpdCBtYXRyaXguXG4gICAgdmFyIGRhdGFNYXNrID0gRGF0YU1hc2suZm9yUmVmZXJlbmNlKGZvcm1hdEluZm8uZGF0YU1hc2spO1xuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICBkYXRhTWFzay51bm1hc2tCaXRNYXRyaXgodGhpcy5iaXRNYXRyaXgsIGRpbWVuc2lvbik7XG5cbiAgICB2YXIgZnVuY3Rpb25QYXR0ZXJuID0gdmVyc2lvbi5idWlsZEZ1bmN0aW9uUGF0dGVybigpO1xuXG4gICAgdmFyIHJlYWRpbmdVcCA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2ZXJzaW9uLnRvdGFsQ29kZXdvcmRzKTtcbiAgICB2YXIgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgIHZhciBiaXRzUmVhZCA9IDA7XG4gICAgLy8gUmVhZCBjb2x1bW5zIGluIHBhaXJzLCBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gMTsgaiA+IDA7IGogLT0gMikge1xuICAgICAgaWYgKGogPT0gNikge1xuICAgICAgICAvLyBTa2lwIHdob2xlIGNvbHVtbiB3aXRoIHZlcnRpY2FsIGFsaWdubWVudCBwYXR0ZXJuO1xuICAgICAgICAvLyBzYXZlcyB0aW1lIGFuZCBtYWtlcyB0aGUgb3RoZXIgY29kZSBwcm9jZWVkIG1vcmUgY2xlYW5seVxuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBSZWFkIGFsdGVybmF0aW5nbHkgZnJvbSBib3R0b20gdG8gdG9wIHRoZW4gdG9wIHRvIGJvdHRvbVxuICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IGRpbWVuc2lvbjsgY291bnQrKykge1xuICAgICAgICB2YXIgaSA9IHJlYWRpbmdVcCA/IGRpbWVuc2lvbiAtIDEgLSBjb3VudCA6IGNvdW50O1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCAyOyBjb2wrKykge1xuICAgICAgICAgIC8vIElnbm9yZSBiaXRzIGNvdmVyZWQgYnkgdGhlIGZ1bmN0aW9uIHBhdHRlcm5cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUGF0dGVybi5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgIC8vIFJlYWQgYSBiaXRcbiAgICAgICAgICAgIGJpdHNSZWFkKys7XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpdE1hdHJpeC5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIG1hZGUgYSB3aG9sZSBieXRlLCBzYXZlIGl0IG9mZlxuICAgICAgICAgICAgaWYgKGJpdHNSZWFkID09IDgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IGN1cnJlbnRCeXRlO1xuICAgICAgICAgICAgICBiaXRzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWRpbmdVcCBePSB0cnVlOyAvLyByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyBzd2l0Y2ggZGlyZWN0aW9uc1xuICAgIH1cbiAgICBpZiAocmVzdWx0T2Zmc2V0ICE9IHZlcnNpb24udG90YWxDb2Rld29yZHMpIHtcbiAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSk7XG5cbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4gKi9cblxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRGF0YUJsb2NrJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5EYXRhQmxvY2sgPSBmdW5jdGlvbihudW1EYXRhQ29kZXdvcmRzLCBjb2Rld29yZHMpIHtcbiAgICB0aGlzLm51bURhdGFDb2Rld29yZHMgPSBudW1EYXRhQ29kZXdvcmRzO1xuICAgIHRoaXMuY29kZXdvcmRzID0gY29kZXdvcmRzO1xuICB9O1xuICB2YXIgRGF0YUJsb2NrID0gdzY5Yi5xci5EYXRhQmxvY2s7XG5cbiAgRGF0YUJsb2NrLmdldERhdGFCbG9ja3MgPSBmdW5jdGlvbihyYXdDb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpIHtcblxuICAgIGlmIChyYXdDb2Rld29yZHMubGVuZ3RoICE9IHZlcnNpb24udG90YWxDb2Rld29yZHMpIHtcbiAgICAgIHRocm93ICdBcmd1bWVudEV4Y2VwdGlvbic7XG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCB0aGUgbnVtYmVyIGFuZCBzaXplIG9mIGRhdGEgYmxvY2tzIHVzZWQgYnkgdGhpcyB2ZXJzaW9uIGFuZFxuICAgIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICB2YXIgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG5cbiAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXG4gICAgdmFyIHRvdGFsQmxvY2tzID0gMDtcbiAgICB2YXIgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjQmxvY2tBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9ja0FycmF5W2ldLmNvdW50O1xuICAgIH1cblxuICAgIC8vIE5vdyBlc3RhYmxpc2ggRGF0YUJsb2NrcyBvZiB0aGUgYXBwcm9wcmlhdGUgc2l6ZSBhbmQgbnVtYmVyIG9mIGRhdGFcbiAgICAvLyBjb2Rld29yZHNcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRvdGFsQmxvY2tzKTtcbiAgICB2YXIgbnVtUmVzdWx0QmxvY2tzID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVjQmxvY2tBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGVjQmxvY2sgPSBlY0Jsb2NrQXJyYXlbal07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjQmxvY2suY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZGF0YUNvZGV3b3JkcztcbiAgICAgICAgdmFyIG51bUJsb2NrQ29kZXdvcmRzID0gZWNCbG9ja3MuZWNDb2Rld29yZHNQZXJCbG9jayArIG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIHJlc3VsdFtudW1SZXN1bHRCbG9ja3MrK10gPSBuZXcgRGF0YUJsb2NrKG51bURhdGFDb2Rld29yZHMsXG4gICAgICAgICAgbmV3IEFycmF5KG51bUJsb2NrQ29kZXdvcmRzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBtb3JlIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuXG4gICAgdmFyIHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgIHZhciBsb25nZXJCbG9ja3NTdGFydEF0ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxvbmdlckJsb2Nrc1N0YXJ0QXQgPj0gMCkge1xuICAgICAgdmFyIG51bUNvZGV3b3JkcyA9IHJlc3VsdFtsb25nZXJCbG9ja3NTdGFydEF0XS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgaWYgKG51bUNvZGV3b3JkcyA9PSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsb25nZXJCbG9ja3NTdGFydEF0LS07XG4gICAgfVxuICAgIGxvbmdlckJsb2Nrc1N0YXJ0QXQrKztcblxuICAgIHZhciBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtXG4gICAgICBlY0Jsb2Nrcy5lY0NvZGV3b3Jkc1BlckJsb2NrO1xuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IGxvbmdlcjtcbiAgICAvLyBmaXJzdCBmaWxsIG91dCBhcyBtYW55IGVsZW1lbnRzIGFzIGFsbCBvZiB0aGVtIGhhdmVcbiAgICB2YXIgcmF3Q29kZXdvcmRzT2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbGwgb3V0IHRoZSBsYXN0IGRhdGEgYmxvY2sgaW4gdGhlIGxvbmdlciBvbmVzXG4gICAgZm9yICh2YXIgaiA9IGxvbmdlckJsb2Nrc1N0YXJ0QXQ7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3Jkc10gPVxuICAgICAgICByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgIH1cbiAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gICAgdmFyIG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgIHZhciBpT2Zmc2V0ID0gaiA8IGxvbmdlckJsb2Nrc1N0YXJ0QXQgPyBpIDogaSArIDE7XG4gICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaU9mZnNldF0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG59KTtcblxuIiwiLy8gQ29weXJpZ2h0IDIwMDYgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXR5IGZvciBmYXN0IHN0cmluZyBjb25jYXRlbmF0aW9uLlxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyJyk7XG5cblxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdG8gZmFjaWxpdGF0ZSBzdHJpbmcgY29uY2F0ZW5hdGlvbi5cbiAqXG4gKiBAcGFyYW0geyo9fSBvcHRfYTEgT3B0aW9uYWwgZmlyc3QgaW5pdGlhbCBpdGVtIHRvIGFwcGVuZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgT3RoZXIgaW5pdGlhbCBpdGVtcyB0b1xuICogICAgIGFwcGVuZCwgZS5nLiwgbmV3IGdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlcignZm9vJywgJ2JhcicpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uKG9wdF9hMSwgdmFyX2FyZ3MpIHtcbiAgaWYgKG9wdF9hMSAhPSBudWxsKSB7XG4gICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEludGVybmFsIGJ1ZmZlciBmb3IgdGhlIHN0cmluZyB0byBiZSBjb25jYXRlbmF0ZWQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5idWZmZXJfID0gJyc7XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGJ1ZmZlciBvYmplY3QsIHJlcGxhY2luZyB3aGF0J3MgY3VycmVudGx5XG4gKiB0aGVyZS5cbiAqXG4gKiBAcGFyYW0geyp9IHMgU3RyaW5nIHRvIHNldC5cbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzKSB7XG4gIHRoaXMuYnVmZmVyXyA9ICcnICsgcztcbn07XG5cblxuLyoqXG4gKiBBcHBlbmRzIG9uZSBvciBtb3JlIGl0ZW1zIHRvIHRoZSBidWZmZXIuXG4gKlxuICogQ2FsbGluZyB0aGlzIHdpdGggbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eSBhcmd1bWVudHMgaXMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHsqfSBhMSBSZXF1aXJlZCBmaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0geyo9fSBvcHRfYTIgT3B0aW9uYWwgc2Vjb25kIHN0cmluZy5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgT3RoZXIgaXRlbXMgdG8gYXBwZW5kLFxuICogICAgIGUuZy4sIHNiLmFwcGVuZCgnZm9vJywgJ2JhcicsICdiYXonKS5cbiAqIEByZXR1cm4geyFnb29nLnN0cmluZy5TdHJpbmdCdWZmZXJ9IFRoaXMgc2FtZSBTdHJpbmdCdWZmZXIgb2JqZWN0LlxuICogQHN1cHByZXNzIHtkdXBsaWNhdGV9XG4gKi9cbmdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oYTEsIG9wdF9hMiwgdmFyX2FyZ3MpIHtcbiAgLy8gVXNlIGExIGRpcmVjdGx5IHRvIGF2b2lkIGFyZ3VtZW50cyBpbnN0YW50aWF0aW9uIGZvciBzaW5nbGUtYXJnIGNhc2UuXG4gIHRoaXMuYnVmZmVyXyArPSBhMTtcbiAgaWYgKG9wdF9hMiAhPSBudWxsKSB7IC8vIHNlY29uZCBhcmd1bWVudCBpcyB1bmRlZmluZWQgKG51bGwgPT0gdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJ1ZmZlcl8gKz0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlcl8gPSAnJztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGJ1ZmZlci5cbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyXy5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZy5cbiAqIEBvdmVycmlkZVxuICovXG5nb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ1ZmZlcl87XG59O1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIFBvcnRlZCB0byBqcyBieSBNYW51ZWwgQnJhdW5cbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5CaXRTb3VyY2UnKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqIDxwPlRoaXMgcHJvdmlkZXMgYW4gZWFzeSBhYnN0cmFjdGlvbiB0byByZWFkIGJpdHMgYXQgYSB0aW1lIGZyb20gYVxuICAgKiBzZXF1ZW5jZSBvZiBieXRlcywgd2hlcmUgdGhlIG51bWJlciBvZiBiaXRzIHJlYWQgaXMgbm90IG9mdGVuIGEgbXVsdGlwbGVcbiAgICogb2YgOC48L3A+XG4gICAqXG4gICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQgLS0gdW5sZXNzIHRoZSBjYWxsZXJcbiAgICogbW9kaWZpZXMgdGhlIGJ5dGVzIGFycmF5IGl0IHBhc3NlZCBpbiwgaW4gd2hpY2ggY2FzZSBhbGwgYmV0cyBhcmUgb2ZmLjwvcD5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMgYnl0ZXMgYnl0ZXMgZnJvbSB3aGljaCB0aGlzIHdpbGwgcmVhZCBiaXRzLlxuICAgKiBCaXRzIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBmaXJzdCBieXRlIGZpcnN0LiAgQml0cyBhcmUgcmVhZCB3aXRoaW4gYSBieXRlXG4gICAqIGZyb20gbW9zdC1zaWduaWZpY2FudCB0byBsZWFzdC1zaWduaWZpY2FudCBiaXQuICBAY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB3NjliLnFyLkJpdFNvdXJjZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgdGhpcy5ieXRlc18gPSBieXRlcztcbiAgICB0aGlzLmJ5dGVPZmZzZXRfID0gMDtcbiAgICB0aGlzLmJpdE9mZnNldF8gPSAwO1xuICB9O1xuICB2YXIgQml0U291cmNlID0gdzY5Yi5xci5CaXRTb3VyY2U7XG4gIHZhciBwcm8gPSBCaXRTb3VyY2UucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZGV4IG9mIG5leHQgYml0IGluIGN1cnJlbnQgYnl0ZSB3aGljaCB3b3VsZCBiZSByZWFkIGJ5XG4gICAqIHRoZSBuZXh0IGNhbGwgdG8gcmVhZEJpdHMoKS5cbiAgICovXG4gIHByby5nZXRCaXRPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRPZmZzZXRfO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggb2YgbmV4dCBieXRlIGluIGlucHV0IGJ5dGUgYXJyYXkgd2hpY2ggd291bGQgYmUgcmVhZFxuICAqIGJ5IHRoZSBuZXh0IGNhbGwgdG8gcmVhZEJpdHMoKS5cbiAgICovXG4gIHByby5nZXRCeXRlT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWQuICBAcmV0dXJuIHtudW1iZXJ9IGludFxuICAgKiByZXByZXNlbnRpbmcgdGhlIGJpdHMgcmVhZC4gVGhlIGJpdHMgd2lsbCBhcHBlYXIgYXMgdGhlIGxlYXN0LXNpZ25pZmljYW50XG4gICAqIGJpdHMgb2YgdGhlIGludC5cbiAgICovXG4gIHByby5yZWFkQml0cyA9IGZ1bmN0aW9uKG51bUJpdHMpIHtcbiAgICBpZiAobnVtQml0cyA8IDEgfHwgbnVtQml0cyA+IDMyIHx8IG51bUJpdHMgPiB0aGlzLmF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgIC8vIEZpcnN0LCByZWFkIHJlbWFpbmRlciBmcm9tIGN1cnJlbnQgYnl0ZVxuICAgIGlmICh0aGlzLmJpdE9mZnNldF8gPiAwKSB7XG4gICAgICB2YXIgYml0c0xlZnQgPSA4IC0gdGhpcy5iaXRPZmZzZXRfO1xuICAgICAgdmFyIHRvUmVhZCA9IG51bUJpdHMgPCBiaXRzTGVmdCA/IG51bUJpdHMgOiBiaXRzTGVmdDtcbiAgICAgIHZhciBiaXRzVG9Ob3RSZWFkID0gYml0c0xlZnQgLSB0b1JlYWQ7XG4gICAgICB2YXIgbWFzayA9ICgweEZGID4+ICg4IC0gdG9SZWFkKSkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgIHJlc3VsdCA9ICh0aGlzLmJ5dGVzX1t0aGlzLmJ5dGVPZmZzZXRfXSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQ7XG4gICAgICBudW1CaXRzIC09IHRvUmVhZDtcbiAgICAgIHRoaXMuYml0T2Zmc2V0XyArPSB0b1JlYWQ7XG4gICAgICBpZiAodGhpcy5iaXRPZmZzZXRfID09IDgpIHtcbiAgICAgICAgdGhpcy5iaXRPZmZzZXRfID0gMDtcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0XysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5leHQgcmVhZCB3aG9sZSBieXRlc1xuICAgIGlmIChudW1CaXRzID4gMCkge1xuICAgICAgd2hpbGUgKG51bUJpdHMgPj0gOCkge1xuICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpIHwgKHRoaXMuYnl0ZXNfW3RoaXMuYnl0ZU9mZnNldF9dICYgMHhGRik7XG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldF8rKztcbiAgICAgICAgbnVtQml0cyAtPSA4O1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbGx5IHJlYWQgYSBwYXJ0aWFsIGJ5dGVcbiAgICAgIGlmIChudW1CaXRzID4gMCkge1xuICAgICAgICB2YXIgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzO1xuICAgICAgICB2YXIgbWFzayA9ICgweEZGID4+IGJpdHNUb05vdFJlYWQpIDw8IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgbnVtQml0cykgfFxuICAgICAgICAgICgodGhpcy5ieXRlc19bdGhpcy5ieXRlT2Zmc2V0X10gJiBtYXNrKSA+PiBiaXRzVG9Ob3RSZWFkKTtcbiAgICAgICAgdGhpcy5iaXRPZmZzZXRfICs9IG51bUJpdHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gYmUgcmVhZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBwcm8uYXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDggKiAodGhpcy5ieXRlc18ubGVuZ3RoIC0gdGhpcy5ieXRlT2Zmc2V0XykgLSB0aGlzLmJpdE9mZnNldF87XG4gIH07XG5cbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5DaGFyYWN0ZXJTZXRFQ0knKTtcbmdvb2cucmVxdWlyZSgnZ29vZy5vYmplY3QnKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcblxuICB2YXIgXyA9IHc2OWIucXIuQ2hhcmFjdGVyU2V0RUNJO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdH0gbWFwcGluZyBlY2kgY29kZXMgdG8gYXJyYXlzIG9mIGVuY29kaW5nIG5hbWVzLlxuICAgKi9cbiAgXy52YWx1ZXNUb05hbWVzID0ge1xuICAgIDA6IFsnQ1A0MzcnXSxcbiAgICAyOiBbJ0NQNDM3J10sXG4gICAgMTogWydJU08tODg1OS0xJ10sXG4gICAgMzogWydJU08tODg1OS0xJ10sXG4gICAgNDogWydJU08tODg1OS0yJ10sXG4gICAgNTogWydJU08tODg1OS0zJ10sXG4gICAgNjogWydJU08tODg1OS00J10sXG4gICAgNzogWydJU08tODg1OS01J10sXG4gICAgODogWydJU08tODg1OS02J10sXG4gICAgOTogWydJU08tODg1OS03J10sXG4gICAgMTA6IFsnSVNPLTg4NTktNyddLFxuICAgIDExOiBbJ0lTTy04ODU5LTknXSxcbiAgICAxMjogWydJU08tODg1OS0xMCddLFxuICAgIDEzOiBbJ0lTTy04ODU5LTExJ10sXG4gICAgMTQ6IFsnSVNPLTg4NTktMTInXSxcbiAgICAxNTogWydJU08tODg1OS0xMyddLFxuICAgIDE2OiBbJ0lTTy04ODU5LTE0J10sXG4gICAgMTc6IFsnSVNPLTg4NTktMTUnXSxcbiAgICAxODogWydJU08tODg1OS0xNiddLFxuICAgIDIwOiBbJ1NISUZUX0pJUyddLFxuICAgIDIxOiBbJ0lTTy04ODU5LTE2J10sXG4gICAgMjI6IFsnQ3AxMjUxJywgJ3dpbmRvd3MtMTI1MSddLFxuICAgIDIzOiBbJ0NwMTI1MicsICd3aW5kb3dzLTEyNTInXSxcbiAgICAyNDogWydDcDEyNTYnLCAnd2luZG93cy0xMjU2J10sXG4gICAgMjU6IFsnVVRGLTE2QkUnLCAnVW5pY29kZUJpZyddLFxuICAgIDI2OiBbJ1VURi04J10sXG4gICAgMjc6IFsnQVNDSUknLCAnVVMtQVNDSUknXSxcbiAgICAxNzA6IFsnQVNDSUknLCAnVVMtQVNDSUknXSxcbiAgICAyODogWydCaWc1J10sXG4gICAgMjk6IFsnR0IxODAzMCcsICdHQjIzMTInLCAnRVVDX0NOJywgJ0dCSyddLFxuICAgIDMwOiBbJ0VVQy1LUiddXG4gIH07XG4gIF8ubmFtZXNUb1ZhbHVlcyA9IHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF8uYnVpbGROYW1lc1RvVmFsdWVzXyA9IGZ1bmN0aW9uKCkge1xuICAgIGdvb2cub2JqZWN0LmZvckVhY2goXy52YWx1ZXNUb05hbWVzLCBmdW5jdGlvbihuYW1lcywgbnVtKSB7XG4gICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCFfLm5hbWVzVG9WYWx1ZXNbbmFtZV0pXG4gICAgICAgICAgXy5uYW1lc1RvVmFsdWVzW25hbWVdID0gbnVtO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF8uYnVpbGROYW1lc1RvVmFsdWVzXygpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBlbmNvZGluZy5cbiAgICogQHJldHVybiB7P251bWJlcn0gZWNpIHZhbHVlLlxuICAgKi9cbiAgXy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gTnVtYmVyKF8ubmFtZXNUb1ZhbHVlc1tuYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBlY2kgdmFsdWUuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IG1haW4gZW5jb2RpbmcgbmFtZS5cbiAgICovXG4gIF8uZ2V0TmFtZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG5hbWVzID0gXy52YWx1ZXNUb05hbWVzW3ZhbHVlXTtcbiAgICBpZiAobmFtZXMpXG4gICAgICByZXR1cm4gbmFtZXNbMF07XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5Nb2RlJyk7XG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuTW9kZUVudW0nKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjEsIFRhYmxlcyAyIGFuZCAzLiBUaGlzIGVudW0gZW5jYXBzdWxhdGVzIHRoZVxuICAgKiB2YXJpb3VzIG1vZGVzIGluIHdoaWNoIGRhdGEgY2FuIGJlIGVuY29kZWQgdG8gYml0cyBpbiB0aGUgUVIgY29kZVxuICAgKiBzdGFuZGFyZC48L3A+XG4gICAqXG4gICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAqL1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMgbm9kb2MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzIG5vZG9jLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9uYW1lIG5hbWUgZm9yIHRlc3RpbmcuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5Nb2RlID0gZnVuY3Rpb24oY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMsIGJpdHMsIG9wdF9uYW1lKSB7XG4gICAgdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucyA9IGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zO1xuICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgdGhpcy5uYW1lXyA9IG9wdF9uYW1lIHx8ICdOT05BTUUnO1xuICB9O1xuICB2YXIgTW9kZSA9IHc2OWIucXIuTW9kZTtcbiAgdmFyIHBybyA9IE1vZGUucHJvdG90eXBlO1xuXG5cbiAgLyoqIEBlbnVtIHtNb2RlfSAqL1xuXG4gIHc2OWIucXIuTW9kZUVudW0gPSB7XG4gICAgLy8gTm90IHJlYWxseSBhIG1vZGUuLi5cbiAgICBURVJNSU5BVE9SOiBuZXcgTW9kZShbMCwgMCwgMF0sIDB4MDAsICdURVJNSU5BVE9SJyksXG4gICAgTlVNRVJJQzogbmV3IE1vZGUoWzEwLCAxMiwgMTRdLCAweDAxLCAnTlVNRVJJQycpLFxuICAgIEFMUEhBTlVNRVJJQzogbmV3IE1vZGUoWzksIDExLCAxM10sIDB4MDIsICdBTFBIQU5VTUVSSUMnKSxcbiAgICAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgU1RSVUNUVVJFRF9BUFBFTkQ6IG5ldyBNb2RlKFswLCAwLCAwXSwgMHgwMywgJ1NUUlVDVFVSRURfQVBQRU5EJyksXG4gICAgQllURTogbmV3IE1vZGUoWzgsIDE2LCAxNl0sIDB4MDQsICdCWVRFJyksXG4gICAgRUNJOiBuZXcgTW9kZShbMCwgMCwgMF0sIDB4MDcsICdFQ0knKSwgLy8gY2hhcmFjdGVyIGNvdW50cyBkb24ndCBhcHBseVxuICAgIEtBTkpJOiBuZXcgTW9kZShbOCwgMTAsIDEyXSwgMHgwOCwgJ0tBTkpJJyksXG4gICAgRk5DMV9GSVJTVF9QT1NJVElPTjogbmV3IE1vZGUoWzAsIDAsIDBdLCAweDA1LCAnRk5DMV9GSVJTVF9QT1NJVElPTicpLFxuICAgIEZOQzFfU0VDT05EX1BPU0lUSU9OOiBuZXcgTW9kZShbMCwgMCwgMF0sIDB4MDksICdGTkMxX1NFQ09ORF9QT1NJVElPTicpLFxuICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7IFwiSGFuemlcIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi9cbiAgICBIQU5aSTogbmV3IE1vZGUoWzgsIDEwLCAxMl0sIDB4MEQsICdIQU5aSScpXG4gIH07XG4gIHZhciBNb2RlRW51bSA9IHc2OWIucXIuTW9kZUVudW07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHt3NjliLnFyLlZlcnNpb259IHZlcnNpb24gdmVyc2lvbiBpbiBxdWVzdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgYml0cyB1c2VkLCBpbiB0aGlzIFFSIENvZGUgc3ltYm9sIHtAbGluayBWZXJzaW9ufSAsIHRvXG4gICAqIGVuY29kZSB0aGUgY291bnQgb2YgY2hhcmFjdGVycyB0aGF0IHdpbGwgZm9sbG93IGVuY29kZWQgaW4gdGhpcyBNb2RlLlxuICAgKi9cbiAgcHJvLmdldENoYXJhY3RlckNvdW50Qml0cyA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICB2YXIgbnVtYmVyID0gdmVyc2lvbi52ZXJzaW9uTnVtYmVyO1xuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKG51bWJlciA8PSA5KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDw9IDI2KSB7XG4gICAgICBvZmZzZXQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9uc1tvZmZzZXRdO1xuICB9O1xuXG4gIHByby5nZXRCaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0cztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBkZWJ1ZyBzdHJpbmcuXG4gICAqL1xuICBwcm8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0cyBmb3VyIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlIGRhdGEgbW9kZS5cbiAgICogQHJldHVybiB7TW9kZX0gTW9kZSBlbmNvZGVkIGJ5IHRoZXNlIGJpdHMuXG4gICAqL1xuICBNb2RlLmZvckJpdHMgPSBmdW5jdGlvbihiaXRzKSB7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICBjYXNlIDB4MDpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLlRFUk1JTkFUT1I7XG4gICAgICBjYXNlIDB4MTpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLk5VTUVSSUM7XG4gICAgICBjYXNlIDB4MjpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkFMUEhBTlVNRVJJQztcbiAgICAgIGNhc2UgMHgzOlxuICAgICAgICByZXR1cm4gTW9kZUVudW0uU1RSVUNUVVJFRF9BUFBFTkQ7XG4gICAgICBjYXNlIDB4NDpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkJZVEU7XG4gICAgICBjYXNlIDB4NTpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkZOQzFfRklSU1RfUE9TSVRJT047XG4gICAgICBjYXNlIDB4NzpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkVDSTtcbiAgICAgIGNhc2UgMHg4OlxuICAgICAgICByZXR1cm4gTW9kZUVudW0uS0FOSkk7XG4gICAgICBjYXNlIDB4OTpcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkZOQzFfU0VDT05EX1BPU0lUSU9OO1xuICAgICAgY2FzZSAweEQ6XG4gICAgICAgIC8vIDB4RCBpcyBkZWZpbmVkIGluIEdCVCAxODI4NC0yMDAwLCBtYXkgbm90IGJlIHN1cHBvcnRlZCBpbiBmb3JlaWduXG4gICAgICAgIC8vIGNvdW50cnlcbiAgICAgICAgcmV0dXJuIE1vZGVFbnVtLkhBTlpJO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICB9O1xufSk7XG5cbiIsImdvb2cucHJvdmlkZSgndzY5Yi51dGY4Jyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiB1dGY4LmpzXG4gKiBMaWNlbnNlOiBBcGFjaGUyLCB2MiBzZWUgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pXG4gKi9cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIFNuaXBwZXQgZml4ZWRDaGFyQ29kZUF0IGJvcnJvd2VkIGZyb20gaHR0cDovL2dvby5nbC8zbFJwUi5cbiAgICogKGMpIHNlZSBjb250cmlidXRlcnMgb2Ygc2l0ZS5cbiAgICogTGljZW5zZTogTUlUXG4gICovXG4gIGZ1bmN0aW9uIGZpeGVkQ2hhckNvZGVBdChzdHIsIGlkeCkge1xuICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHgpO1xuICAgICAgdmFyIGhpLCBsb3c7XG4gICAgICAvLyBIaWdoIHN1cnJvZ2F0ZSAoY291bGQgY2hhbmdlIGxhc3QgaGV4IHRvIDB4REI3RiB0byB0cmVhdCBoaWdoIHByaXZhdGVcbiAgICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICBoaSA9IGNvZGU7XG4gICAgICAgICAgbG93ID0gc3RyLmNoYXJDb2RlQXQoaWR4ICsgMSk7XG4gICAgICAgICAgaWYgKGlzTmFOKGxvdykpIHtcbiAgICAgICAgICAgIHRocm93ICdmaXhlZENoYXJDb2RlQXQ6IEludmFsaWQgRW5jb2RpbmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKChoaSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICB9XG4gICAgICAvLyBXZSByZXR1cm4gZmFsc2UgdG8gYWxsb3cgbG9vcHMgdG8gc2tpcCB0aGlzIGl0ZXJhdGlvbiBzaW5jZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYWxyZWFkeSBoYW5kbGVkIGhpZ2ggc3Vycm9nYXRlIGFib3ZlIGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb25cbiAgICAgIC8vIExvdyBzdXJyb2dhdGVcbiAgICAgIGlmICgweERDMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIGZpeGVkRnJvbUNvZGVQb2ludFxuICAqIENvbnZlcnQgYXJyYXkgb2YgdW5pY29kZSBjb2RlIHBvaW50cyB0byBzdHJpbmcuXG4gICogT3JpZ2luYWxseSBmcm9tOlxuICAqIEVTNiBVbmljb2RlIFNoaW1zIDAuMVxuICAqIChjKSAyMDEyIFN0ZXZlbiBMZXZpdGhhbiA8aHR0cDovL3NsZXZpdGhhbi5jb20vPlxuICAqIE1JVCBMaWNlbnNlXG4gICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY29kZVBvaW50cyBjb2RlUG9pbnRzIHNlcXVlbmNlLlxuICAqIEByZXR1cm4ge3N0cmluZ30gcmVzdWx0aW5nIHN0cmluZy5cbiAgKi9cbiAgZnVuY3Rpb24gZml4ZWRGcm9tQ29kZVBvaW50KGNvZGVQb2ludHMpIHtcbiAgICB2YXIgY2hhcnMgPSBbXSwgcG9pbnQsIG9mZnNldCwgdW5pdHMsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBvaW50ID0gY29kZVBvaW50c1tpXTtcbiAgICAgIG9mZnNldCA9IHBvaW50IC0gMHgxMDAwMDtcbiAgICAgIHVuaXRzID0gcG9pbnQgPiAweEZGRkYgP1xuICAgICAgICBbMHhEODAwICsgKG9mZnNldCA+PiAxMCksIDB4REMwMCArIChvZmZzZXQgJiAweDNGRildIDogW3BvaW50XTtcbiAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1bml0cykpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzdHJpbmcgdG8gVVRGOCBieXRlIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIGphdmFzY3JpcHQgc3RyaW5nICh1bmljb2RlKS5cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGJ5dGUgc2VxdWVuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb1VURjhCeXRlcyhzdHIpIHtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IGZpeGVkQ2hhckNvZGVBdChzdHIsIGkpO1xuICAgICAgLy8gYWxyZWFkeSBoYW5kZWxlZFxuICAgICAgaWYgKCFjb2RlUG9pbnQpIGNvbnRpbnVlO1xuICAgICAgaWYgKGNvZGVQb2ludCA8PSAweDdGKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MDdGRikge1xuICAgICAgICBieXRlcy5wdXNoKDB4QzAgfCAoY29kZVBvaW50ID4+IDYpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKGNvZGVQb2ludCAmIDB4M0YpKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xuICAgICAgICBieXRlcy5wdXNoKDB4RTAgfCAoY29kZVBvaW50ID4+IDEyKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICgweDNGICYgKGNvZGVQb2ludCA+PiA2KSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoY29kZVBvaW50ICYgMHgzRikpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHgxRkZGRkYpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweEYwIHwgKGNvZGVQb2ludCA+PiAxOCkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoMHgzRiAmIChjb2RlUG9pbnQgPj4gMTIpKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICgweDNGICYgKGNvZGVQb2ludCA+PiA2KSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoY29kZVBvaW50ICYgMHgzRikpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHgzRkZGRkZGKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhGMCB8IChjb2RlUG9pbnQgPj4gMjQpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKDB4M0YgJiAoY29kZVBvaW50ID4+IDE4KSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoMHgzRiAmIChjb2RlUG9pbnQgPj4gMTIpKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICgweDNGICYgKGNvZGVQb2ludCA+PiA2KSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoY29kZVBvaW50ICYgMHgzRikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweEYwIHwgKDB4MDEgJiAoY29kZVBvaW50ID4+IDMwKSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoMHgzRiAmIChjb2RlUG9pbnQgPj4gMjQpKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICgweDNGICYgKGNvZGVQb2ludCA+PiAxOCkpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKDB4M0YgJiAoY29kZVBvaW50ID4+IDEyKSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAoMHgzRiAmIChjb2RlUG9pbnQgPj4gNikpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKGNvZGVQb2ludCAmIDB4M0YpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgVVRGOCBieXRlIHNlcXVlbmNlIHRvIHN0cmluZy5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMgVVRGOCBieXRlIHNlcXVlbmNlLlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSByZXN1bHQgc3RyaW5nIG9yIG51bGwgb24gZXJyb3IgKGludmFsaWQgaW5wdXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gVVRGOEJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIHZhciBnZXRDb250aW51YXRpb24gPSBmdW5jdGlvbihpZHgpIHtcbiAgICAgIGlmIChpZHggPiBsZW5ndGgpIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgdmFyIGIgPSBieXRlc1tpZHhdO1xuICAgICAgaWYgKChiICYgMHhDMCkgIT09IDB4ODApIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgcmV0dXJuIGIgJiAweDNGO1xuICAgIH07XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYiA9IGJ5dGVzW2ldO1xuICAgICAgICBpZiAoYiA+IDB4RkYpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAvLyBGaXJzdCBiaXQgbm90IHNldCwgc28gaXQgaXMgYSAxLWJ5dGUgY2hhci5cbiAgICAgICAgICBjb2RlID0gYjtcbiAgICAgICAgfSBlbHNlIGlmICgoYiAmIDB4RTApID09PSAweEMwKSB7XG4gICAgICAgICAgLy8gMiBieXRlcy5cbiAgICAgICAgICBjb2RlID0gKCgweDFGICYgYikgPDwgNikgfCBnZXRDb250aW51YXRpb24oaSArIDEpO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICgoYiAmIDB4RjApID09PSAweEUwKSB7XG4gICAgICAgICAgLy8gMyBieXRlcy5cbiAgICAgICAgICBjb2RlID0gKCgweDBGICYgYikgPDwgMTIpIHxcbiAgICAgICAgICAgIChnZXRDb250aW51YXRpb24oaSArIDEpIDw8IDYpIHxcbiAgICAgICAgICAgIGdldENvbnRpbnVhdGlvbihpICsgMik7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKChiICYgMHhGOCkgPT09IDB4RjApIHtcbiAgICAgICAgICAvLyA0IGJ5dGVzLlxuICAgICAgICAgIGNvZGUgPSAoKDB4MDcgJiBiKSA8PCAxOCkgfFxuICAgICAgICAgICAgKGdldENvbnRpbnVhdGlvbihpICsgMSkgPDwgMTIpIHxcbiAgICAgICAgICAgIChnZXRDb250aW51YXRpb24oaSArIDIpIDw8IDYpIHxcbiAgICAgICAgICAgIGdldENvbnRpbnVhdGlvbihpICsgMyk7XG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKChiICYgMHhGQykgPT09IDB4RjgpIHtcbiAgICAgICAgICAvLyA1IGJ5dGVzLlxuICAgICAgICAgIGNvZGUgPSAoKDB4MDMgJiBiKSA8PCAyNCkgfFxuICAgICAgICAgICAgKGdldENvbnRpbnVhdGlvbihpICsgMSkgPDwgMTgpIHxcbiAgICAgICAgICAgIChnZXRDb250aW51YXRpb24oaSArIDIpIDw8IDEyKSB8XG4gICAgICAgICAgICAoZ2V0Q29udGludWF0aW9uKGkgKyAzKSA8PCA2KSB8XG4gICAgICAgICAgICBnZXRDb250aW51YXRpb24oaSArIDQpO1xuICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgfSBlbHNlIGlmICgoYiAmIDB4RkUpID09PSAweEZDKSB7XG4gICAgICAgICAgLy8gNiBieXRlcy5cbiAgICAgICAgICBjb2RlID0gKCgweDAxICYgYikgPDwgMzApIHxcbiAgICAgICAgICAgIChnZXRDb250aW51YXRpb24oaSArIDEpIDw8IDI0KSB8XG4gICAgICAgICAgICAoZ2V0Q29udGludWF0aW9uKGkgKyAyKSA8PCAxOCkgfFxuICAgICAgICAgICAgKGdldENvbnRpbnVhdGlvbihpICsgMykgPDwgMTIpIHxcbiAgICAgICAgICAgIChnZXRDb250aW51YXRpb24oaSArIDQpIDw8IDYpIHxcbiAgICAgICAgICAgIGdldENvbnRpbnVhdGlvbihpICsgNSk7XG4gICAgICAgICAgaSArPSA1O1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludHMucHVzaChjb2RlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAvLyBPdXIgaW52YWxpZC1pbmNvZGluZyBleGNlcHRpb24gaXMgdGhlIG9ubHkgb25lIHRocm93blxuICAgICAgLy8gdGhpcyBibG9jaywgc28ganVzdCByZXR1cm4gbnVsbC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZml4ZWRGcm9tQ29kZVBvaW50KGNvZGVQb2ludHMpO1xuICB9XG5cbiAgLy8gUHVibGljIEFQSS5cbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgc3RyaW5nVG9VVEY4Qnl0ZXM6IHN0cmluZ1RvVVRGOEJ5dGVzLFxuICAgIFVURjhCeXRlc1RvU3RyaW5nOiBVVEY4Qnl0ZXNUb1N0cmluZ1xuICB9O1xuXG4gIGlmICh0eXBlb2YoZ29vZykgPT0gJ29iamVjdCcgJiYgZ29vZy5wcm92aWRlKSB7XG4gICAgLy8gR29vZ2xlIENsb3N1cmUgVG9vbHMgY29tcGF0aWJpbGl0eSBob29rLlxuICAgIHc2OWIudXRmOC5zdHJpbmdUb1VURjhCeXRlcyA9IHN0cmluZ1RvVVRGOEJ5dGVzO1xuICAgIHc2OWIudXRmOC5VVEY4Qnl0ZXNUb1N0cmluZyA9IFVURjhCeXRlc1RvU3RyaW5nO1xuICB9IGVsc2UgaWYgKHR5cGVvZihnbG9iYWwuZGVmaW5lKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gcmVxdWlyZSBqcyBjb21wYXRpYmlsaXR5IGhvb2suXG4gICAgZ2xvYmFsLmRlZmluZShleHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQbGFpbiBvbGQgZ2xvYmFsIGV4cG9ydCBmYWxsYmFjay5cbiAgICBnbG9iYWxbJ3V0ZjgnXSA9IGV4cG9ydHM7XG4gIH1cbn0pKHNlbGYpO1xuIiwiLypcbiBAbGljZW5zZVxuIFNpbmdsZWJ5dGUgZW5jb2RpbmdzIHZhbHVlcyBwb3J0ZWQgZnJvbSBpY29udi1saXRlIChmb3Igbm9kZWpzKS5cbiBnb29nbGUgY2xvc3VyZS9icm93c2VyIHBvcnQgMjAxMyBieSBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuXG4gTElDRU5TRSBvZiBpY29udmUtbGl0ZTpcblxuIENvcHlyaWdodCAoYykgMjAxMSBBbGV4YW5kZXIgU2h0dWNoa2luXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5pY29udmxpdGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi51dGY4Jyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cub2JqZWN0Jyk7XG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIF8gPSB3NjliLmljb252bGl0ZTtcbiAgXy5TSU5HTEVCWVRFUyA9IHtcbiAgICAnQ3AxMjUxJzogJ9CC0IPigJrRk+KAnuKApuKAoOKAoeKCrOKAsNCJ4oC50IrQjNCL0I/RkuKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEotGZ4oC60ZrRnNGb0Z9cXHhhMNCO0Z7QiMKk0pDCpsKn0IHCqdCEwqvCrMKtwq7Qh8KwwrHQhtGW0pHCtcK2wrfRkeKEltGUwrvRmNCF0ZXRl9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGPJyxcbiAgICAnQ3AxMjUyJzogJ+KCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+9xb3vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEosWh4oC6xZPvv73FvsW4XFx4YTDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/JyxcbiAgICAnQ3AxMjU2JzogJ+KCrNm+4oCaxpLigJ7igKbigKDigKHLhuKAsNm54oC5xZLahtqY2ojar+KAmOKAmeKAnOKAneKAouKAk+KAlNqp4oSi2pHigLrFk+KAjOKAjdq6XFx4YTDYjMKiwqPCpMKlwqbCp8KowqnavsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCudibwrvCvMK9wr7Yn9uB2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbDl9i32LjYudi62YDZgdmC2YPDoNmEw6LZhdmG2YfZiMOnw6jDqcOqw6vZidmKw67Dr9mL2YzZjdmOw7TZj9mQw7fZkcO52ZLDu8O84oCO4oCP25InLFxuICAgICdJU08tODg1OS0xJzogJ8KAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp9cXHhhMMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/DkMORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMOdw57Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvw7DDscOyw7PDtMO1w7bDt8O4w7nDusO7w7zDvcO+w78nLFxuICAgICdJU08tODg1OS0yJzogJ8KAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp9cXHhhMMSEy5jFgcKkxL3FmsKnwqjFoMWexaTFucKtxb3Fu8KwxIXLm8WCwrTEvsWby4fCuMWhxZ/FpcW6y53FvsW8xZTDgcOCxILDhMS5xIbDh8SMw4nEmMOLxJrDjcOOxI7EkMWDxYfDk8OUxZDDlsOXxZjFrsOaxbDDnMOdxaLDn8WVw6HDosSDw6TEusSHw6fEjcOpxJnDq8Sbw63DrsSPxJHFhMWIw7PDtMWRw7bDt8WZxa/DusWxw7zDvcWjy5knLFxuICAgICdJU08tODg1OS0zJzogJ8KAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp9cXHhhMMSmy5jCo8Kk77+9xKTCp8KoxLDFnsSexLTCre+/vcW7wrDEp8KywrPCtMK1xKXCt8K4xLHFn8SfxLXCve+/vcW8w4DDgcOC77+9w4TEisSIw4fDiMOJw4rDi8OMw43DjsOP77+9w5HDksOTw5TEoMOWw5fEnMOZw5rDm8OcxazFnMOfw6DDocOi77+9w6TEi8SJw6fDqMOpw6rDq8Osw63DrsOv77+9w7HDssOzw7TEocO2w7fEncO5w7rDu8O8xa3FncuZJyxcbiAgICAnSVNPLTg4NTktNCc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDEhMS4xZbCpMSoxLvCp8KoxaDEksSixabCrcW9wq/CsMSFy5vFl8K0xKnEvMuHwrjFocSTxKPFp8WKxb7Fi8SAw4HDgsODw4TDhcOGxK7EjMOJxJjDi8SWw43DjsSqxJDFhcWMxLbDlMOVw5bDl8OYxbLDmsObw5zFqMWqw5/EgcOhw6LDo8Okw6XDpsSvxI3DqcSZw6vEl8Otw67Eq8SRxYbFjcS3w7TDtcO2w7fDuMWzw7rDu8O8xanFq8uZJyxcbiAgICAnSVNPLTg4NTktNSc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDQgdCC0IPQhNCF0IbQh9CI0InQitCL0IzCrdCO0I/QkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj+KEltGR0ZLRk9GU0ZXRltGX0ZjRmdGa0ZvRnMKn0Z7RnycsXG4gICAgJ0lTTy04ODU5LTYnOiAnwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn1xceGEw77+977+977+9wqTvv73vv73vv73vv73vv73vv73vv73YjMKt77+977+977+977+977+977+977+977+977+977+977+977+977+92Jvvv73vv73vv73Yn++/vdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52Lrvv73vv73vv73vv73vv73ZgNmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZku+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vScsXG4gICAgJ0lTTy04ODU5LTcnOiAnwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn1xceGEw4oCY4oCZwqPigqzigq/CpsKnwqjCqc26wqvCrMKt77+94oCVwrDCscKywrPOhM6FzobCt86IzonOisK7zozCvc6Ozo/OkM6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHvv73Oo86kzqXOps6nzqjOqc6qzqvOrM6tzq7Or86wzrHOss6zzrTOtc62zrfOuM65zrrOu868zr3Ovs6/z4DPgc+Cz4PPhM+Fz4bPh8+Iz4nPis+Lz4zPjc+O77+9JyxcbiAgICAnSVNPLTg4NTktOCc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDvv73CosKjwqTCpcKmwqfCqMKpw5fCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnDt8K7wrzCvcK+77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94oCX15DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+977+94oCO4oCP77+9JyxcbiAgICAnSVNPLTg4NTktOSc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPxJ7DkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zEsMWew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Sfw7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8xLHFn8O/JyxcbiAgICAnSVNPLTg4NTktMTAnOiAnwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn1xceGEwxITEksSixKrEqMS2wqfEu8SQxaDFpsW9wq3FqsWKwrDEhcSTxKPEq8SpxLfCt8S8xJHFocWnxb7igJXFq8WLxIDDgcOCw4PDhMOFw4bErsSMw4nEmMOLxJbDjcOOw4/DkMWFxYzDk8OUw5XDlsWow5jFssOaw5vDnMOdw57Dn8SBw6HDosOjw6TDpcOmxK/EjcOpxJnDq8SXw63DrsOvw7DFhsWNw7PDtMO1w7bFqcO4xbPDusO7w7zDvcO+xLgnLFxuICAgICdJU08tODg1OS0xMSc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDguIHguILguIPguITguIXguIbguIfguIjguInguIrguIvguIzguI3guI7guI/guJDguJHguJLguJPguJTguJXguJbguJfguJjguJnguJrguJvguJzguJ3guJ7guJ/guKDguKHguKLguKPguKTguKXguKbguKfguKjguKnguKrguKvguKzguK3guK7guK/guLDguLHguLLguLPguLTguLXguLbguLfguLjguLnguLrvv73vv73vv73vv73guL/guYDguYHguYLguYPguYTguYXguYbguYfguYjguYnguYrguYvguYzguY3guY7guY/guZDguZHguZLguZPguZTguZXguZbguZfguZjguZnguZrguZvvv73vv73vv73vv70nLFxuICAgICdJU08tODg1OS0xMyc6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDigJ3CosKjwqTigJ7CpsKnw5jCqcWWwqvCrMKtwq7DhsKwwrHCssKz4oCcwrXCtsK3w7jCucWXwrvCvMK9wr7DpsSExK7EgMSGw4TDhcSYxJLEjMOJxbnElsSixLbEqsS7xaDFg8WFw5PFjMOVw5bDl8WyxYHFmsWqw5zFu8W9w5/EhcSvxIHEh8Okw6XEmcSTxI3DqcW6xJfEo8S3xKvEvMWhxYTFhsOzxY3DtcO2w7fFs8WCxZvFq8O8xbzFvuKAmScsXG4gICAgJ0lTTy04ODU5LTE0JzogJ8KAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp9cXHhhMOG4guG4g8KjxIrEi+G4isKn4bqAwqnhuoLhuIvhu7LCrcKuxbjhuJ7huJ/EoMSh4bmA4bmBwrbhuZbhuoHhuZfhuoPhuaDhu7PhuoThuoXhuaHDgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8W0w5HDksOTw5TDlcOW4bmqw5jDmcOaw5vDnMOdxbbDn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxbXDscOyw7PDtMO1w7bhuavDuMO5w7rDu8O8w73Ft8O/JyxcbiAgICAnSVNPLTg4NTktMTUnOiAnwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn1xceGEwwqHCosKj4oKswqXFoMKnxaHCqcKqwqvCrMKtwq7Cr8KwwrHCssKzxb3CtcK2wrfFvsK5wrrCu8WSxZPFuMK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/DkMORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMOdw57Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvw7DDscOyw7PDtMO1w7bDt8O4w7nDusO7w7zDvcO+w78nLFxuICAgICdJU08tODg1OS0xNic6ICfCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfXFx4YTDEhMSFxYHigqzigJ7FoMKnxaHCqciYwqvFucKtxbrFu8KwwrHEjMWCxb3igJ3CtsK3xb7EjciZwrvFksWTxbjFvMOAw4HDgsSCw4TEhsOGw4fDiMOJw4rDi8OMw43DjsOPxJDFg8OSw5PDlMWQw5bFmsWww5nDmsObw5zEmMiaw5/DoMOhw6LEg8OkxIfDpsOnw6jDqcOqw6vDrMOtw67Dr8SRxYTDssOzw7TFkcO2xZvFscO5w7rDu8O8xJnIm8O/J1xuICB9O1xuICBfLkFTQ0lJID0gJ1xceDAwXFx4MDFcXHgwMlxceDAzXFx4MDRcXHgwNVxceDA2XFx4MDdcXHgwOFxcdFxcblxceDBiXFx4MGNcXHJcXHgwZVxceDBmXFx4MTBcXHgxMVxceDEyXFx4MTNcXHgxNFxceDE1XFx4MTZcXHgxN1xceDE4XFx4MTlcXHgxYVxceDFiXFx4MWNcXHgxZFxceDFlXFx4MWYnICtcbiAgICAnICFcIiMkJSZcXCcoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5cXHg3Zic7XG5cbiAgXy5SRVZFUlNFX01BUFNfID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGJ5dGVzIHNlcXVlbmNlIG9mIGdpdmVuIGNoYXJzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyc2V0IG5hbWUgb2YgY2hhcnNldC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBkZWNvZGVkIHN0cmluZy5cbiAgICovXG4gIF8udG9TdHJpbmcgPSBmdW5jdGlvbihieXRlcywgY2hhcnNldCkge1xuICAgIHZhciBjaGFycyA9IF8uQVNDSUkgKyBfLlNJTkdMRUJZVEVTW2NoYXJzZXRdO1xuICAgIGlmICghY2hhcnMpIHRocm93IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBieXRlcy5tYXAoZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIGNoYXJzW2JdO1xuICAgIH0pLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNldCBuYW1lIGFzIHNwZWNpZmllZCBhYm92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgY2hhcnNldCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICBfLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oY2hhcnNldCkge1xuICAgIHJldHVybiAhIV8uU0lOR0xFQllURVNbY2hhcnNldF07XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgZW5jb2RlZCBpbiBjaGFyc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNldCBjaGFyc2V0IG5hbWVcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGJ5dGVzLlxuICAgKi9cbiAgXy50b0J5dGVzID0gZnVuY3Rpb24oc3RyaW5nLCBjaGFyc2V0KSB7XG4gICAgdmFyIG1hcCA9IF8uZ2V0UmV2ZXJzZU1hcF8oY2hhcnNldCk7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBiID0gbWFwW3N0cmluZ1tpXV07XG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICAgIGJ5dGVzLnB1c2goYik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzZXQgbmFtZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSByZXZlcnNlIG1hcCAobWFwcGluZyBzdHIgdG8gYnl0ZXMpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgXy5nZXRSZXZlcnNlTWFwXyA9IGZ1bmN0aW9uKGNoYXJzZXQpIHtcbiAgICB2YXIgbWFwID0gXy5SRVZFUlNFX01BUFNfW2NoYXJzZXRdO1xuICAgIGlmICghbWFwKSB7XG4gICAgICBtYXAgPSB7fTtcbiAgICAgIHZhciBjaGFycyA9IF8uQVNDSUkgKyBfLlNJTkdMRUJZVEVTW2NoYXJzZXRdO1xuICAgICAgaWYgKCFjaGFycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1hcFtjaGFyc1tpXV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBfLlJFVkVSU0VfTUFQU19bY2hhcnNldF0gPSBtYXA7XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IHN1cHBvcnRlZCBjaGFyc2V0cy5cbiAgICovXG4gIF8uZ2V0U3VwcG9ydGVkQ2hhcnNldHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ29vZy5vYmplY3QuZ2V0S2V5cyhfLlNJTkdMRUJZVEVTKTtcbiAgfTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuc3RyaW5ndXRpbHMnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pY29udmxpdGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5EZWNvZGVIaW50VHlwZScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkludmFsaWRDaGFyc2V0RXJyb3InKTtcbmdvb2cucmVxdWlyZSgndzY5Yi51dGY4Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBfID0gdzY5Yi5xci5zdHJpbmd1dGlscztcbiAgdmFyIHV0ZjggPSB3NjliLnV0Zjg7XG4gIHZhciBpY29udiA9IHNlbGYuaWNvbnY7XG4gIHZhciBpY29udmxpdGUgPSB3NjliLmljb252bGl0ZTtcbiAgdmFyIEludmFsaWRDaGFyc2V0RXJyb3IgPSB3NjliLnFyLkludmFsaWRDaGFyc2V0RXJyb3I7XG5cbiAgXy5TSElGVF9KSVMgPSAnU0hJRlRfSklTJztcbiAgXy5HQjIzMTIgPSAnR0IxODAzMCc7XG4gIF8uRVVDX0pQID0gJ0VVQy1KUCc7XG4gIF8uVVRGOCA9ICdVVEYtOCc7XG4gIF8uSVNPODg1OTEgPSAnSVNPLTg4NTktMSc7XG4gIF8uUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyA9IF8uVVRGODtcbiAgXy5BU1NVTUVfU0hJRlRfSklTID0gZmFsc2U7XG4gIC8vIFNISUZUX0pJUy5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpIHx8XG4gIC8vIEVVQ19KUC5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpO1xuXG5cbiAgLyoqXG4gICAqIERlY29kZXMgYnl0ZXMgYnl0ZXMgYXJyYXkgYXMgcmV0dXJuZWQgYnkgZ2V0Qnl0ZXMoKS5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMgc2VxdWVuY2Ugb2YgZ2l2ZW4gY2hhcnNldC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfY2hhcnNldCBuYW1lIG9mIGNoYXJzZXQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gZGVjb2RlZCBzdHJpbmcuXG4gICAqL1xuICBfLmJ5dGVzVG9TdHJpbmcgPSBmdW5jdGlvbihieXRlcywgb3B0X2NoYXJzZXQpIHtcbiAgICB2YXIgY2hhcnNldCA9IG9wdF9jaGFyc2V0IHx8ICdVVEYtOCc7XG4gICAgdmFyIHN0ciA9IG51bGw7XG5cbiAgICAvLyB0cnkgbmF0aXZlIFRleHREZWNvZGVyIGZpcnN0XG4gICAgaWYgKHNlbGYuVGV4dERlY29kZXIgJiYgc2VsZi5VaW50OEFycmF5ICYmIHNlbGYuVWludDhBcnJheVsnZnJvbSddKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKGNoYXJzZXQpO1xuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoc2VsZi5VaW50OEFycmF5Wydmcm9tJ10oYnl0ZXMpKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgLy8gdHJ5IG90aGVyIG1ldGhvZHMgaWYgY2hhcnNldCBpcyBub3Qgc3VwcG9ydGVkIGJ5IG5hdGl2ZSBkZWNvZGVyIChlZy4gQ1A0Mzcgb24gQ2hyb21lKS5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYXJzZXQgPT0gJ1VURi04Jykge1xuICAgICAgc3RyID0gdXRmOC5VVEY4Qnl0ZXNUb1N0cmluZyhieXRlcyk7XG4gICAgfSBlbHNlIGlmIChpY29udmxpdGUuaXNTdXBwb3J0ZWQoY2hhcnNldCkpIHtcbiAgICAgIHN0ciA9IGljb252bGl0ZS50b1N0cmluZyhieXRlcywgY2hhcnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaWNvbnYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcnNldEVycm9yKFxuICAgICAgICAgICdpY29udiBub3QgbG9hZGVkLCBjYW5ub3QgaGFuZGxlICcgKyBjaGFyc2V0KTtcbiAgICAgIHZhciB1dGY4Qnl0ZXMgPSBpY29udi5jb252ZXJ0KGJ5dGVzLCBjaGFyc2V0LCAnVVRGLTgnKTtcbiAgICAgIGlmICh1dGY4Qnl0ZXMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcnNldEVycm9yKFxuICAgICAgICAgICd0b1N0ciAnICsgY2hhcnNldCArICcgdG8gVVRGLTggJyArIGJ5dGVzKTtcbiAgICAgIGJ5dGVzID0gdXRmOEJ5dGVzO1xuICAgICAgc3RyID0gdXRmOC5VVEY4Qnl0ZXNUb1N0cmluZyhieXRlcyk7XG4gICAgfVxuICAgIGlmIChzdHIgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJzZXRFcnJvcigpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vdGU6IGNoYXJzZXQgaXMgY3VycmVudGx5IGlnbm9yZWQuXG4gICAqIERlY29kZXMgYnl0ZXMgYnl0ZXMgYXJyYXkgYXMgcmV0dXJuZWQgYnkgZ2V0Qnl0ZXMoKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2NoYXJzZXQgbmFtZSBvZiBjaGFyc2V0LlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMuXG4gICAqL1xuICBfLnN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbihzdHIsIG9wdF9jaGFyc2V0KSB7XG4gICAgdmFyIGNoYXJzZXQgPSBvcHRfY2hhcnNldCB8fCAnVVRGLTgnO1xuICAgIHZhciBieXRlcyA9IG51bGw7XG4gICAgaWYgKGNoYXJzZXQgPT0gJ1VURi04Jykge1xuICAgICAgYnl0ZXMgPSB1dGY4LnN0cmluZ1RvVVRGOEJ5dGVzKHN0cik7XG4gICAgICBpZiAoYnl0ZXMgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcnNldEVycm9yKCk7XG4gICAgfSBlbHNlIGlmIChpY29udmxpdGUuaXNTdXBwb3J0ZWQoY2hhcnNldCkpIHtcbiAgICAgIGJ5dGVzID0gaWNvbnZsaXRlLnRvQnl0ZXMoc3RyLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMgPSB1dGY4LnN0cmluZ1RvVVRGOEJ5dGVzKHN0cik7XG4gICAgICBpZiAoIWljb252KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJzZXRFcnJvcignaWNvbnYgbm90IGxvYWRlZCcpO1xuICAgICAgYnl0ZXMgPSBpY29udi5jb252ZXJ0KGJ5dGVzLCAnVVRGLTgnLCBjaGFyc2V0KTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyc2V0RXJyb3IoY2hhcnNldCArICcgdG8gYnl0ZXM6ICcgKyBzdHIpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMgYnl0ZXMgZW5jb2RpbmcgYSBzdHJpbmcsIHdob3NlIGVuY29kaW5nXG4gICAqIHNob3VsZCBiZSBndWVzc2VkLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9oaW50cyBkZWNvZGUgaGludHMgaWYgYXBwbGljYWJsZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBuYW1lIG9mIGd1ZXNzZWQgZW5jb2Rpbmc7IGF0IHRoZSBtb21lbnQgd2lsbCBvbmx5XG4gICAqIGd1ZXNzIG9uZSBvZjpcbiAgICogIHtAbGluayAjU0hJRlRfSklTfSwge0BsaW5rICNVVEY4fSwge0BsaW5rICNJU084ODU5MX0sIG9yIHRoZSBwbGF0Zm9ybVxuICAgKiAgZGVmYXVsdCBlbmNvZGluZyBpZiBub25lIG9mIHRoZXNlIGNhbiBwb3NzaWJseSBiZSBjb3JyZWN0LlxuICAgKi9cbiAgXy5ndWVzc0VuY29kaW5nID0gZnVuY3Rpb24oYnl0ZXMsIG9wdF9oaW50cykge1xuICAgIGlmIChvcHRfaGludHMpIHtcbiAgICAgIHZhciBjaGFyYWN0ZXJTZXQgPSBvcHRfaGludHMuZ2V0KHc2OWIucXIuRGVjb2RlSGludFR5cGUuQ0hBUkFDVEVSX1NFVCk7XG4gICAgICBpZiAoY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZvciBub3csIG1lcmVseSB0cmllcyB0byBkaXN0aW5ndWlzaCBJU08tODg1OS0xLCBVVEYtOCBhbmQgU2hpZnRfSklTLFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBieSBmYXIgdGhlIG1vc3QgY29tbW9uIGVuY29kaW5ncy5cbiAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIHZhciBjYW5CZUlTTzg4NTkxID0gdHJ1ZTtcbiAgICB2YXIgY2FuQmVTaGlmdEpJUyA9IHRydWU7XG4gICAgdmFyIGNhbkJlVVRGOCA9IHRydWU7XG4gICAgdmFyIHV0ZjhCeXRlc0xlZnQgPSAwO1xuICAgIC8vdmFyIHV0ZjhMb3dDaGFycyA9IDA7XG4gICAgdmFyIHV0ZjJCeXRlc0NoYXJzID0gMDtcbiAgICB2YXIgdXRmM0J5dGVzQ2hhcnMgPSAwO1xuICAgIHZhciB1dGY0Qnl0ZXNDaGFycyA9IDA7XG4gICAgdmFyIHNqaXNCeXRlc0xlZnQgPSAwO1xuICAgIC8vdmFyIHNqaXNMb3dDaGFycyA9IDA7XG4gICAgdmFyIHNqaXNLYXRha2FuYUNoYXJzID0gMDtcbiAgICAvL3ZhciBzamlzRG91YmxlQnl0ZXNDaGFycyA9IDA7XG4gICAgdmFyIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgIHZhciBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICB2YXIgc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgdmFyIHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgIC8vdmFyIGlzb0xvd0NoYXJzID0gMDtcbiAgICAvL3ZhciBpc29IaWdoQ2hhcnMgPSAwO1xuICAgIHZhciBpc29IaWdoT3RoZXIgPSAwO1xuXG4gICAgdmFyIHV0Zjhib20gPSBieXRlcy5sZW5ndGggPiAzICYmXG4gICAgICBieXRlc1swXSA9PSAweEVGICYmXG4gICAgICBieXRlc1sxXSA9PSAweEJCICYmXG4gICAgICBieXRlc1syXSA9PSAweEJGO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7XG4gICAgICAgICBpIDwgbGVuZ3RoICYmIChjYW5CZUlTTzg4NTkxIHx8IGNhbkJlU2hpZnRKSVMgfHwgY2FuQmVVVEY4KTtcbiAgICAgICAgIGkrKykge1xuXG4gICAgICB2YXIgdmFsdWUgPSBieXRlc1tpXSAmIDB4RkY7XG5cbiAgICAgIC8vIFVURi04IHN0dWZmXG4gICAgICBpZiAoY2FuQmVVVEY4KSB7XG4gICAgICAgIGlmICh1dGY4Qnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgodmFsdWUgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4NDApID09IDApIHtcbiAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgyMCkgPT0gMCkge1xuICAgICAgICAgICAgICB1dGYyQnl0ZXNDaGFycysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHgxMCkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHV0ZjNCeXRlc0NoYXJzKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRmOEJ5dGVzTGVmdCsrO1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDA4KSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB1dGY0Qnl0ZXNDaGFycysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9lbHNlIHtcbiAgICAgICAgLy91dGY4TG93Q2hhcnMrKztcbiAgICAgICAgLy99XG4gICAgICB9XG5cbiAgICAgIC8vIElTTy04ODU5LTEgc3R1ZmZcbiAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDB4N0YgJiYgdmFsdWUgPCAweEEwKSB7XG4gICAgICAgICAgY2FuQmVJU084ODU5MSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDB4QzAgfHwgdmFsdWUgPT0gMHhENyB8fCB2YWx1ZSA9PSAweEY3KSB7XG4gICAgICAgICAgICBpc29IaWdoT3RoZXIrKztcbiAgICAgICAgICB9IC8vZWxzZSB7XG4gICAgICAgICAgLy9pc29IaWdoQ2hhcnMrKztcbiAgICAgICAgICAvL31cbiAgICAgICAgfSAvL2Vsc2Uge1xuICAgICAgICAvL2lzb0xvd0NoYXJzKys7XG4gICAgICAgIC8vfVxuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdF9KSVMgc3R1ZmZcbiAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgIGlmIChzamlzQnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDB4NDAgfHwgdmFsdWUgPT0gMHg3RiB8fCB2YWx1ZSA+IDB4RkMpIHtcbiAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2ppc0J5dGVzTGVmdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSAweDgwIHx8IHZhbHVlID09IDB4QTAgfHwgdmFsdWUgPiAweEVGKSB7XG4gICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMHhBMCAmJiB2YWx1ZSA8IDB4RTApIHtcbiAgICAgICAgICBzamlzS2F0YWthbmFDaGFycysrO1xuICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGgrKztcbiAgICAgICAgICBpZiAoc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA+IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IDB4N0YpIHtcbiAgICAgICAgICBzamlzQnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgLy9zamlzRG91YmxlQnl0ZXNDaGFycysrO1xuICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGgrKztcbiAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPSBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3NqaXNMb3dDaGFycysrO1xuICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbkJlVVRGOCAmJiB1dGY4Qnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRWFzeSAtLSBpZiB0aGVyZSBpcyBCT00gb3IgYXQgbGVhc3QgMSB2YWxpZCBub3Qtc2luZ2xlIGJ5dGUgY2hhcmFjdGVyXG4gICAgLy8gKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSBVVEYtOCksIGRvbmVcbiAgICBpZiAoY2FuQmVVVEY4ICYmXG4gICAgICAodXRmOGJvbSB8fCB1dGYyQnl0ZXNDaGFycyArIHV0ZjNCeXRlc0NoYXJzICsgdXRmNEJ5dGVzQ2hhcnMgPiAwKSkge1xuICAgICAgcmV0dXJuIF8uVVRGODtcbiAgICB9XG4gICAgLy8gRWFzeSAtLSBpZiBhc3N1bWluZyBTaGlmdF9KSVMgb3IgYXQgbGVhc3QgMyB2YWxpZCBjb25zZWN1dGl2ZSBub3QtYXNjaWlcbiAgICAvLyBjaGFyYWN0ZXJzIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUpLCBkb25lXG4gICAgaWYgKGNhbkJlU2hpZnRKSVMgJiZcbiAgICAgIChfLkFTU1VNRV9TSElGVF9KSVMgfHwgc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA+PSAzIHx8XG4gICAgICAgIHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGggPj0gMykpIHtcbiAgICAgIHJldHVybiBfLlNISUZUX0pJUztcbiAgICB9XG4gICAgLy8gRGlzdGluZ3Vpc2hpbmcgU2hpZnRfSklTIGFuZCBJU08tODg1OS0xIGNhbiBiZSBhIGxpdHRsZSB0b3VnaCBmb3Igc2hvcnRcbiAgICAvLyB3b3Jkcy4gVGhlIGNydWRlIGhldXJpc3RpYyBpczpcbiAgICAvLyAtIElmIHdlIHNhd1xuICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcbiAgICAvLyAgIC0gYXQgbGVhc3QgMTAlIG9mIGJ5dGVzIHRoYXQgY291bGQgYmUgXCJ1cHBlclwiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLFxuICAgIC8vIC0gdGhlbiB3ZSBjb25jbHVkZSBTaGlmdF9KSVMsIGVsc2UgSVNPLTg4NTktMVxuICAgIGlmIChjYW5CZUlTTzg4NTkxICYmIGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgIHJldHVybiAoc2ppc01heEthdGFrYW5hV29yZExlbmd0aCA9PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09IDIpIHx8XG4gICAgICAgIGlzb0hpZ2hPdGhlciAqIDEwID49IGxlbmd0aCA/IF8uU0hJRlRfSklTIDogXy5JU084ODU5MTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHRyeSBpbiBvcmRlciBJU08tODg1OS0xLCBTaGlmdCBKSVMsIFVURi04IGFuZCBmYWxsIGJhY2sgdG9cbiAgICAvLyBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nXG4gICAgaWYgKGNhbkJlSVNPODg1OTEpIHtcbiAgICAgIHJldHVybiBfLklTTzg4NTkxO1xuICAgIH1cbiAgICBpZiAoY2FuQmVTaGlmdEpJUykge1xuICAgICAgcmV0dXJuIF8uU0hJRlRfSklTO1xuICAgIH1cbiAgICBpZiAoY2FuQmVVVEY4KSB7XG4gICAgICByZXR1cm4gXy5VVEY4O1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHdlIHRha2UgYSB3aWxkIGd1ZXNzIHdpdGggcGxhdGZvcm0gZW5jb2RpbmdcbiAgICByZXR1cm4gXy5QTEFURk9STV9ERUZBVUxUX0VOQ09ESU5HO1xuICB9O1xuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuRGVjb2RlZEJpdFN0cmVhbVBhcnNlcicpO1xuZ29vZy5yZXF1aXJlKCdnb29nLnN0cmluZy5TdHJpbmdCdWZmZXInKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5CaXRTb3VyY2UnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5DaGFyYWN0ZXJTZXRFQ0knKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Gb3JtYXRFcnJvcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLk1vZGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Nb2RlRW51bScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLnN0cmluZ3V0aWxzJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBfID0gdzY5Yi5xci5EZWNvZGVkQml0U3RyZWFtUGFyc2VyO1xuICB2YXIgQml0U291cmNlID0gdzY5Yi5xci5CaXRTb3VyY2U7XG4gIHZhciBNb2RlID0gdzY5Yi5xci5Nb2RlO1xuICB2YXIgTW9kZUVudW0gPSB3NjliLnFyLk1vZGVFbnVtO1xuICB2YXIgU3RyaW5nQnVmZmVyID0gZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyO1xuICB2YXIgc3RyaW5ndXRpbHMgPSB3NjliLnFyLnN0cmluZ3V0aWxzO1xuICB2YXIgRm9ybWF0RXJyb3IgPSB3NjliLnFyLkZvcm1hdEVycm9yO1xuICB2YXIgQ2hhcmFjdGVyU2V0RUNJID0gdzY5Yi5xci5DaGFyYWN0ZXJTZXRFQ0k7XG5cbiAgLyoqXG4gICAqIDxwPlFSIENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZVxuICAgKiBtdWx0aXBsZSBtb2RlcyBpbiBvbmUgUVIgQ29kZS4gVGhpcyBjbGFzcyBkZWNvZGVzIHRoZSBiaXRzIGJhY2sgaW50b1xuICAgKiB0ZXh0LjwvcD5cbiAgICpcbiAgICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjQuMyAtIDYuNC43PC9wPlxuICAgKlxuICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgKi9cblxuICAvKipcbiAgICogU2VlIElTTyAxODAwNDoyMDA2LCA2LjQuNCBUYWJsZSA1XG4gICAqL1xuICBfLkFMUEhBTlVNRVJJQ19DSEFSUyA9IFtcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICdBJywgJ0InLFxuICAgICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsXG4gICAgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJyxcbiAgICAnICcsICckJywgJyUnLCAnKicsICcrJywgJy0nLCAnLicsICcvJywgJzonXG4gIF07XG4gIF8uR0IyMzEyX1NVQlNFVCA9IDE7XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMgYnl0ZSBibG9ja3MuXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5WZXJzaW9ufSB2ZXJzaW9uIHFyIGNvZGUgdmVyc2lvbi5cbiAgICogQHBhcmFtIHt3NjliLnFyLkVycm9yQ29ycmVjdGlvbkxldmVsfSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gZGVjb2RlZCBzdHJpbmcuXG4gICAqL1xuICBfLmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgdmFyIGJpdHMgPSBuZXcgQml0U291cmNlKGJ5dGVzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB2YXIgYnl0ZVNlZ21lbnRzID0gW107XG4gICAgdmFyIGZjMUluRWZmZWN0ID0gZmFsc2U7XG4gICAgdmFyIG1vZGU7XG4gICAgdmFyIGN1cnJlbnRDaGFyYWN0ZXJTZXQgPSBudWxsO1xuICAgIGRvIHtcbiAgICAgIC8vIFdoaWxlIHN0aWxsIGFub3RoZXIgc2VnbWVudCB0byByZWFkLi4uXG4gICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcbiAgICAgICAgLy8gT0ssIGFzc3VtZSB3ZSdyZSBkb25lLiBSZWFsbHksIGEgVEVSTUlOQVRPUiBtb2RlIHNob3VsZCBoYXZlIGJlZW5cbiAgICAgICAgLy8gcmVjb3JkZWQgaGVyZVxuICAgICAgICBtb2RlID0gTW9kZUVudW0uVEVSTUlOQVRPUjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGUgPSBNb2RlLmZvckJpdHMoYml0cy5yZWFkQml0cyg0KSk7IC8vIG1vZGUgaXMgZW5jb2RlZCBieSA0IGJpdHNcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlICE9IE1vZGVFbnVtLlRFUk1JTkFUT1IpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gTW9kZUVudW0uRk5DMV9GSVJTVF9QT1NJVElPTiB8fFxuICAgICAgICAgIG1vZGUgPT0gTW9kZUVudW0uRk5DMV9TRUNPTkRfUE9TSVRJT04pIHtcbiAgICAgICAgICAvLyBXZSBkbyBsaXR0bGUgd2l0aCBGTkMxIGV4Y2VwdCBhbHRlciB0aGUgcGFyc2VkIHJlc3VsdCBhIGJpdFxuICAgICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAgIGZjMUluRWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IE1vZGVFbnVtLlNUUlVDVFVSRURfQVBQRU5EKSB7XG4gICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvLyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm90IHJlYWxseSBzdXBwb3J0ZWQ7IGFsbCB3ZSBkbyBpcyBpZ25vcmUgaXQgUmVhZCBuZXh0IDggYml0c1xuICAgICAgICAgIC8vIChzeW1ib2wgc2VxdWVuY2UgIykgYW5kIDggYml0cyAocGFyaXR5IGRhdGEpLCB0aGVuIGNvbnRpbnVlXG4gICAgICAgICAgYml0cy5yZWFkQml0cygxNik7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBNb2RlRW51bS5FQ0kpIHtcbiAgICAgICAgICAvLyBDb3VudCBkb2Vzbid0IGFwcGx5IHRvIEVDSVxuICAgICAgICAgIHZhciB2YWx1ZSA9IF8ucGFyc2VFQ0lWYWx1ZShiaXRzKTtcbiAgICAgICAgICBjdXJyZW50Q2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLmdldE5hbWUodmFsdWUpO1xuICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyU2V0ID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJzdCBoYW5kbGUgSGFuemkgbW9kZSB3aGljaCBkb2VzIG5vdCBzdGFydCB3aXRoIGNoYXJhY3RlciBjb3VudFxuICAgICAgICAgIGlmIChtb2RlID09IE1vZGVFbnVtLkhBTlpJKSB7XG4gICAgICAgICAgICAvL2NoaW5lc2UgbW9kZSBjb250YWlucyBhIHN1YiBzZXQgaW5kaWNhdG9yIHJpZ2h0IGFmdGVyIG1vZGVcbiAgICAgICAgICAgIC8vaW5kaWNhdG9yXG4gICAgICAgICAgICB2YXIgc3Vic2V0ID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgICAgICAgIHZhciBjb3VudEhhbnppID0gYml0cy5yZWFkQml0cyhcbiAgICAgICAgICAgICAgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikpO1xuICAgICAgICAgICAgaWYgKHN1YnNldCA9PSBfLkdCMjMxMl9TVUJTRVQpIHtcbiAgICAgICAgICAgICAgXy5kZWNvZGVIYW56aVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudEhhbnppKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJOb3JtYWxcIiBRUiBjb2RlIG1vZGVzOlxuICAgICAgICAgICAgLy8gSG93IG1hbnkgY2hhcmFjdGVycyB3aWxsIGZvbGxvdywgZW5jb2RlZCBpbiB0aGlzIG1vZGU/XG4gICAgICAgICAgICB2YXIgY291bnQgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09IE1vZGVFbnVtLk5VTUVSSUMpIHtcbiAgICAgICAgICAgICAgXy5kZWNvZGVOdW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBNb2RlRW51bS5BTFBIQU5VTUVSSUMpIHtcbiAgICAgICAgICAgICAgXy5kZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQsIGZjMUluRWZmZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBNb2RlRW51bS5CWVRFKSB7XG4gICAgICAgICAgICAgIF8uZGVjb2RlQnl0ZVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hhcmFjdGVyU2V0LCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IE1vZGVFbnVtLktBTkpJKSB7XG4gICAgICAgICAgICAgIF8uZGVjb2RlS2FuamlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvL0Zvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG1vZGUgIT0gTW9kZUVudW0uVEVSTUlOQVRPUik7XG5cbiAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlZSBzcGVjaWZpY2F0aW9uIEdCVCAxODI4NC0yMDAwXG4gICAqIEBwYXJhbSB7Qml0U291cmNlfSBiaXRzIGJpdHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nQnVmZmVyfSByZXN1bHQgc3RyaW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IGJ5dGVzIHRvIGRlY29kZS5cbiAgICovXG4gIF8uZGVjb2RlSGFuemlTZWdtZW50ID0gZnVuY3Rpb24oYml0cywgcmVzdWx0LCBjb3VudCkge1xuICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxuICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvLyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcbiAgICAvLyBhbmQgZGVjb2RlIGFzIEdCMjMxMiBhZnRlcndhcmRzXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheSgyICogY291bnQpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgdmFyIHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICB2YXIgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKHR3b0J5dGVzIC8gMHgwNjApIDw8IDgpIHwgKHR3b0J5dGVzICUgMHgwNjApO1xuICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMDNCRikge1xuICAgICAgICAvLyBJbiB0aGUgMHhBMUExIHRvIDB4QUFGRSByYW5nZVxuICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBBMUExO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gdGhlIDB4QjBBMSB0byAweEZBRkUgcmFuZ2VcbiAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTZBMTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlcltvZmZzZXRdID0gKChhc3NlbWJsZWRUd29CeXRlcyA+PiA4KSAmIDB4RkYpO1xuICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gKGFzc2VtYmxlZFR3b0J5dGVzICYgMHhGRik7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIGNvdW50LS07XG4gICAgfVxuXG4gICAgcmVzdWx0LmFwcGVuZChzdHJpbmd1dGlscy5ieXRlc1RvU3RyaW5nKGJ1ZmZlciwgJ0dCMjMxMicpKTtcbiAgICAvLyByZXN1bHQuYXBwZW5kKG5ldyBTdHJpbmcoYnVmZmVyLCBTdHJpbmdVdGlscy5HQjIzMTIpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtCaXRTb3VyY2V9IGJpdHMgYml0cy5cbiAgICogQHBhcmFtIHtTdHJpbmdCdWZmZXJ9IHJlc3VsdCBzdHJpbmcgYnVmZmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgYnl0ZXMgdG8gZGVjb2RlLlxuICAgKi9cbiAgXy5kZWNvZGVLYW5qaVNlZ21lbnQgPSBmdW5jdGlvbihiaXRzLCByZXN1bHQsIGNvdW50KSB7XG4gICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcbiAgICAvLyBhbmQgZGVjb2RlIGFzIFNoaWZ0X0pJUyBhZnRlcndhcmRzXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheSgyICogY291bnQpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgdmFyIHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICB2YXIgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKHR3b0J5dGVzIC8gMHgwQzApIDw8IDgpIHwgKHR3b0J5dGVzICUgMHgwQzApO1xuICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMUYwMCkge1xuICAgICAgICAvLyBJbiB0aGUgMHg4MTQwIHRvIDB4OUZGQyByYW5nZVxuICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDA4MTQwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gdGhlIDB4RTA0MCB0byAweEVCQkYgcmFuZ2VcbiAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQzE0MDtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlcltvZmZzZXRdID0gKGFzc2VtYmxlZFR3b0J5dGVzID4+IDgpO1xuICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gYXNzZW1ibGVkVHdvQnl0ZXM7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIGNvdW50LS07XG4gICAgfVxuICAgIC8vIFNoaWZ0X0pJUyBtYXkgbm90IGJlIHN1cHBvcnRlZCBpbiBzb21lIGVudmlyb25tZW50czpcbiAgICByZXN1bHQuYXBwZW5kKHN0cmluZ3V0aWxzLmJ5dGVzVG9TdHJpbmcoYnVmZmVyLCAnU0pJUycpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtCaXRTb3VyY2V9IGJpdHMgYml0cy5cbiAgICogQHBhcmFtIHtTdHJpbmdCdWZmZXJ9IHJlc3VsdCBzdHJpbmcgYnVmZmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgYnl0ZXMgdG8gZGVjb2RlLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNoYXJhY3RlclNldEVjaU5hbWUgY2hhcmFjdGVyIHNldCBlY2kgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnl0ZVNlZ21lbnRzIHJhdyBieXRlcy5cbiAgICovXG4gIF8uZGVjb2RlQnl0ZVNlZ21lbnQgPSBmdW5jdGlvbihiaXRzLCByZXN1bHQsIGNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyU2V0RWNpTmFtZSwgYnl0ZVNlZ21lbnRzKSB7XG4gICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgaWYgKGNvdW50IDw8IDMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTsgIC8vRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlYWRCeXRlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICByZWFkQnl0ZXNbaV0gPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgIH1cbiAgICAvLyB2YXIgZW5jb2RpbmcgPSBzdHJpbmd1dGlscy5ndWVzc0VuY29kaW5nKHJlYWRCeXRlcyk7XG4gICAgLy8gVE9ETzogV2UgY2Fubm90IGRlY29kZSBub24tdW5pY29kZSBzdHJpbmdzIHlldC5cbiAgICB2YXIgZW5jb2Rpbmc7XG4gICAgaWYgKCFjaGFyYWN0ZXJTZXRFY2lOYW1lKSB7XG4gICAgICAvLyBUaGUgc3BlYyBpc24ndCBjbGVhciBvbiB0aGlzIG1vZGU7IHNlZVxuICAgICAgLy8gc2VjdGlvbiA2LjQuNTogdCBkb2VzIG5vdCBzYXkgd2hpY2ggZW5jb2RpbmcgdG8gYXNzdW1pbmdcbiAgICAgIC8vIHVwb24gZGVjb2RpbmcuIEkgaGF2ZSBzZWVuIElTTy04ODU5LTEgdXNlZCBhcyB3ZWxsIGFzXG4gICAgICAvLyBTaGlmdF9KSVMgLS0gd2l0aG91dCBhbnl0aGluZyBsaWtlIGFuIEVDSSBkZXNpZ25hdG9yIHRvXG4gICAgICAvLyBnaXZlIGEgaGludC5cbiAgICAgIGVuY29kaW5nID0gc3RyaW5ndXRpbHMuZ3Vlc3NFbmNvZGluZyhyZWFkQnl0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGNoYXJhY3RlclNldEVjaU5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5hcHBlbmQoc3RyaW5ndXRpbHMuYnl0ZXNUb1N0cmluZyhyZWFkQnl0ZXMsIGVuY29kaW5nKSk7XG4gICAgYnl0ZVNlZ21lbnRzLnB1c2gocmVhZEJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGNoYXJhY3Rlci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBjaGFyLlxuICAgKi9cbiAgXy50b0FscGhhTnVtZXJpY0NoYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA+PSBfLkFMUEhBTlVNRVJJQ19DSEFSUy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpOyAgLy8gRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBfLkFMUEhBTlVNRVJJQ19DSEFSU1tNYXRoLmZsb29yKHZhbHVlKV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qml0U291cmNlfSBiaXRzIGJpdHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nQnVmZmVyfSByZXN1bHQgc3RyaW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBmYzFJbkVmZmVjdCBmbGFnLlxuICAgKi9cbiAgXy5kZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50ID0gZnVuY3Rpb24oYml0cywgcmVzdWx0LCBjb3VudCwgZmMxSW5FZmZlY3QpIHtcbiAgICAvLyBSZWFkIHR3byBjaGFyYWN0ZXJzIGF0IGEgdGltZVxuICAgIHZhciBzdGFydCA9IHJlc3VsdC5nZXRMZW5ndGgoKTtcbiAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDExKSB7XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpOyAgLy8gdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFR3b0NoYXJzQml0cyA9IGJpdHMucmVhZEJpdHMoMTEpO1xuICAgICAgcmVzdWx0LmFwcGVuZChfLnRvQWxwaGFOdW1lcmljQ2hhcihuZXh0VHdvQ2hhcnNCaXRzIC8gNDUpKTtcbiAgICAgIHJlc3VsdC5hcHBlbmQoXy50b0FscGhhTnVtZXJpY0NoYXIobmV4dFR3b0NoYXJzQml0cyAlIDQ1KSk7XG4gICAgICBjb3VudCAtPSAyO1xuICAgIH1cbiAgICBpZiAoY291bnQgPT0gMSkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbmUgY2hhcmFjdGVyIGxlZnRcbiAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNikge1xuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTsgIC8vIEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmFwcGVuZChfLnRvQWxwaGFOdW1lcmljQ2hhcihiaXRzLnJlYWRCaXRzKDYpKSk7XG4gICAgfVxuICAgIC8vIFNlZSBzZWN0aW9uIDYuNC44LjEsIDYuNC44LjJcbiAgICAvLyBpZiAoZmMxSW5FZmZlY3QpIHtcbiAgICAvLyAgIC8vIFdlIG5lZWQgdG8gbWFzc2FnZSB0aGUgcmVzdWx0IGEgYml0IGlmIGluIGFuIEZOQzEgbW9kZTpcbiAgICAvLyAgIC8vIFRPRE86IHN1YmNsYXNzIHN0cmluZ2J1ZmZlciBhbmQgYWRkIHJlcXVpcmVkIG1ldGhvZHMuXG4gICAgLy8gICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCByZXN1bHQuZ2V0TGVuZ3RoKCk7IGkrKykge1xuICAgIC8vICAgICBpZiAocmVzdWx0LmNoYXJBdChpKSA9PSAnJScpIHtcbiAgICAvLyAgICAgICBpZiAoaSA8IHJlc3VsdC5sZW5ndGgoKSAtIDEgJiYgcmVzdWx0LmNoYXJBdChpICsgMSkgPT0gJyUnKSB7XG4gICAgLy8gICAgICAgICAvLyAlJSBpcyByZW5kZXJlZCBhcyAlXG4gICAgLy8gICAgICAgICByZXN1bHQuZGVsZXRlQ2hhckF0KGkgKyAxKTtcbiAgICAvLyAgICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgICAgLy8gSW4gYWxwaGEgbW9kZSwgJSBzaG91bGQgYmUgY29udmVydGVkIHRvIEZOQzEgc2VwYXJhdG9yIDB4MURcbiAgICAvLyAgICAgICAgIHJlc3VsdC5zZXRDaGFyQXQoaSwgMHgxRCk7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0JpdFNvdXJjZX0gYml0cyBiaXRzLlxuICAgKiBAcGFyYW0ge1N0cmluZ0J1ZmZlcn0gcmVzdWx0IHN0cmluZyBidWZmZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBieXRlcyB0byBkZWNvZGUuXG4gICAqL1xuICBfLmRlY29kZU51bWVyaWNTZWdtZW50ID0gZnVuY3Rpb24oYml0cywgcmVzdWx0LCBjb3VudCkge1xuICAgIC8vIFJlYWQgdGhyZWUgZGlnaXRzIGF0IGEgdGltZVxuICAgIHdoaWxlIChjb3VudCA+PSAzKSB7XG4gICAgICAvLyBFYWNoIDEwIGJpdHMgZW5jb2RlcyB0aHJlZSBkaWdpdHNcbiAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvLyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aHJlZURpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDEwKTtcbiAgICAgIGlmICh0aHJlZURpZ2l0c0JpdHMgPj0gMTAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTsgIC8vIEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmFwcGVuZChfLnRvQWxwaGFOdW1lcmljQ2hhcih0aHJlZURpZ2l0c0JpdHMgLyAxMDApKTtcbiAgICAgIHJlc3VsdC5hcHBlbmQoXy50b0FscGhhTnVtZXJpY0NoYXIoKHRocmVlRGlnaXRzQml0cyAvIDEwKSAlIDEwKSk7XG4gICAgICByZXN1bHQuYXBwZW5kKF8udG9BbHBoYU51bWVyaWNDaGFyKHRocmVlRGlnaXRzQml0cyAlIDEwKSk7XG4gICAgICBjb3VudCAtPSAzO1xuICAgIH1cbiAgICBpZiAoY291bnQgPT0gMikge1xuICAgICAgLy8gVHdvIGRpZ2l0cyBsZWZ0IG92ZXIgdG8gcmVhZCwgZW5jb2RlZCBpbiA3IGJpdHNcbiAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNykge1xuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoKTsgIC8vIEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHR3b0RpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDcpO1xuICAgICAgaWYgKHR3b0RpZ2l0c0JpdHMgPj0gMTAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpOyAgLy8gRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQuYXBwZW5kKF8udG9BbHBoYU51bWVyaWNDaGFyKHR3b0RpZ2l0c0JpdHMgLyAxMCkpO1xuICAgICAgcmVzdWx0LmFwcGVuZChfLnRvQWxwaGFOdW1lcmljQ2hhcih0d29EaWdpdHNCaXRzICUgMTApKTtcbiAgICB9IGVsc2UgaWYgKGNvdW50ID09IDEpIHtcbiAgICAgIC8vIE9uZSBkaWdpdCBsZWZ0IG92ZXIgdG8gcmVhZFxuICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFcnJvcigpOyAgLy8gRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgZGlnaXRCaXRzID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgIGlmIChkaWdpdEJpdHMgPj0gMTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvLyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5hcHBlbmQoXy50b0FscGhhTnVtZXJpY0NoYXIoZGlnaXRCaXRzKSk7XG4gICAgfVxuICB9O1xuXG4gIF8ucGFyc2VFQ0lWYWx1ZSA9IGZ1bmN0aW9uKGJpdHMpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgIC8vIGp1c3Qgb25lIGJ5dGVcbiAgICAgIHJldHVybiBmaXJzdEJ5dGUgJiAweDdGO1xuICAgIH1cbiAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4QzApID09IDB4ODApIHtcbiAgICAgIC8vIHR3byBieXRlc1xuICAgICAgdmFyIHNlY29uZEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgcmV0dXJuICgoZmlyc3RCeXRlICYgMHgzRikgPDwgOCkgfCBzZWNvbmRCeXRlO1xuICAgIH1cbiAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4RTApID09IDB4QzApIHtcbiAgICAgIC8vIHRocmVlIGJ5dGVzXG4gICAgICB2YXIgc2Vjb25kVGhpcmRCeXRlcyA9IGJpdHMucmVhZEJpdHMoMTYpO1xuICAgICAgcmV0dXJuICgoZmlyc3RCeXRlICYgMHgxRikgPDwgMTYpIHwgc2Vjb25kVGhpcmRCeXRlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKCk7ICAvLyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgfTtcblxufSk7XG5cbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4gKi9cblxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuR0YyNTZQb2x5Jyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xuXG4vKipcbiAqIDxwPlJlcHJlc2VudHMgYSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgZWxlbWVudHMgb2YgYSBHRi5cbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbW11dGFibGUuPC9wPlxuICpcbiAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGVcbiAqIGFyZSBhbiBpbmRpcmVjdCBwb3J0IG9mIGhpcyBDKysgUmVlZC1Tb2xvbW9uIGltcGxlbWVudGF0aW9uLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICovXG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogR0YyNTZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdGMjU2IGZpZWxkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEFkZGl0aW9uYWwgbWVzc2FnZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cbiAgICovXG4gIHc2OWIucXIuV3JvbmdGaWVsZEVycm9yID0gZnVuY3Rpb24ob3B0X21lc3NhZ2UpIHtcbiAgICBnb29nLmJhc2UodGhpcywgb3B0X21lc3NhZ2UpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKHc2OWIucXIuV3JvbmdGaWVsZEVycm9yLCBFcnJvcik7XG4gIHZhciBXcm9uZ0ZpZWxkRXJyb3IgPSB3NjliLnFyLldyb25nRmllbGRFcnJvcjtcblxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXc2OWIucXIuR0YyNTZ9IGZpZWxkIGZpZWxkLlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb2VmZmljaWVudHMgY29lZmZpY2llbnRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuR0YyNTZQb2x5ID0gZnVuY3Rpb24oZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoY29lZmZpY2llbnRzICE9IG51bGwgJiYgY29lZmZpY2llbnRzLmxlbmd0aCAhPSAwKTtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgdmFyIGNvZWZmaWNpZW50c0xlbmd0aCA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09IDApIHtcbiAgICAgIC8vIExlYWRpbmcgdGVybSBtdXN0IGJlIG5vbi16ZXJvIGZvciBhbnl0aGluZyBleGNlcHQgdGhlIGNvbnN0YW50XG4gICAgICAvLyBwb2x5bm9taWFsIFwiMFwiXG4gICAgICB2YXIgZmlyc3ROb25aZXJvID0gMTtcbiAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiZcbiAgICAgICAgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT0gMCkge1xuICAgICAgICBmaXJzdE5vblplcm8rKztcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdE5vblplcm8gPT0gY29lZmZpY2llbnRzTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gZmllbGQuemVyby5jb2VmZmljaWVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBBcnJheShjb2VmZmljaWVudHNMZW5ndGggLSBmaXJzdE5vblplcm8pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKXRoaXMuY29lZmZpY2llbnRzW2ldID1cbiAgICAgICAgICAwO1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDxcbiAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7IGNpKyspdGhpcy5jb2VmZmljaWVudHNbY2ldID1cbiAgICAgICAgICBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvICsgY2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbiAgICB9XG4gIH07XG4gIHZhciBHRjI1NlBvbHkgPSB3NjliLnFyLkdGMjU2UG9seTtcbiAgdmFyIHBybyA9IEdGMjU2UG9seS5wcm90b3R5cGU7XG5cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhIF4gYi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGEgbnVtYmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYiBudW1iZXIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LlxuICAgKi9cbiAgR0YyNTZQb2x5LmFkZE9yU3VidHJhY3RTY2FsYXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgXiBiO1xuICB9O1xuXG4gIHByby5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT0gMDtcbiAgfTtcblxuICBwcm8uZ2V0RGVncmVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDE7XG4gIH07XG5cbiAgcHJvLmdldENvZWZmaWNpZW50ID0gZnVuY3Rpb24oZGVncmVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICB9O1xuXG4gIHByby5ldmFsdWF0ZUF0ID0gZnVuY3Rpb24oYSkge1xuICAgIGlmIChhID09IDApIHtcbiAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgIHJldHVybiB0aGlzLmdldENvZWZmaWNpZW50KDApO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICBpZiAoYSA9PSAxKSB7XG4gICAgICAvLyBKdXN0IHRoZSBzdW0gb2YgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICByZXN1bHQgPSBHRjI1NlBvbHkuYWRkT3JTdWJ0cmFjdFNjYWxhcihyZXN1bHQsIHRoaXMuY29lZmZpY2llbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciByZXN1bHQyID0gdGhpcy5jb2VmZmljaWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHJlc3VsdDIgPSBHRjI1NlBvbHkuYWRkT3JTdWJ0cmFjdFNjYWxhcih0aGlzLmZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdDIpLFxuICAgICAgICB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgb3Igc3Vic3RyYWN0IG90aGVyICBwb2x5LlxuICAgKiBAcGFyYW0geyF3NjliLnFyLkdGMjU2UG9seX0gb3RoZXIgb3RoZXIgcG9seS5cbiAgICogQHJldHVybiB7IXc2OWIucXIuR0YyNTZQb2x5fSByZXN1bHQuXG4gICAqL1xuICBwcm8uYWRkT3JTdWJ0cmFjdCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuZmllbGQgIT0gb3RoZXIuZmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBXcm9uZ0ZpZWxkRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc21hbGxlckNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgIHZhciBsYXJnZXJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xuICAgICAgc21hbGxlckNvZWZmaWNpZW50cyA9IGxhcmdlckNvZWZmaWNpZW50cztcbiAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBzdW1EaWZmID0gbmV3IEFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgIHZhciBsZW5ndGhEaWZmID0gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzXG4gICAgLy8gY29lZmZpY2llbnRzXG4gICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGxlbmd0aERpZmY7IGNpKyspc3VtRGlmZltjaV0gPVxuICAgICAgbGFyZ2VyQ29lZmZpY2llbnRzW2NpXTtcblxuICAgIGZvciAodmFyIGkgPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1EaWZmW2ldID0gR0YyNTZQb2x5LmFkZE9yU3VidHJhY3RTY2FsYXIoXG4gICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLFxuICAgICAgICBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgR0YyNTZQb2x5KHRoaXMuZmllbGQsIHN1bURpZmYpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIHBvbHkuXG4gICAqIEBwYXJhbSB7IXc2OWIucXIuR0YyNTZQb2x5fSBvdGhlciBvdGhlciBwb2x5LlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLkdGMjU2UG9seX0gcmVzdWx0LlxuICAgKi9cbiAgcHJvLm11bHRpcGx5MSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuZmllbGQgIT0gb3RoZXIuZmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBXcm9uZ0ZpZWxkRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkgfHwgb3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkLnplcm87XG4gICAgfVxuICAgIHZhciBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgdmFyIGFMZW5ndGggPSBhQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICB2YXIgYkNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICB2YXIgYkxlbmd0aCA9IGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgIHZhciBwcm9kdWN0ID0gbmV3IEFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhQ29lZmYgPSBhQ29lZmZpY2llbnRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcHJvZHVjdFtpICsgal0gPSBHRjI1NlBvbHkuYWRkT3JTdWJ0cmFjdFNjYWxhcihwcm9kdWN0W2kgKyBqXSxcbiAgICAgICAgICB0aGlzLmZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgfTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgd2l0aCBzY2FsYXIuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gc2NhbGFyIG90aGVyIHBvbHkuXG4gICAqIEByZXR1cm4ge3c2OWIucXIuR0YyNTZQb2x5fSByZXN1bHQuXG4gICAqL1xuICBwcm8ubXVsdGlwbHkyID0gZnVuY3Rpb24oc2NhbGFyKSB7XG4gICAgaWYgKHNjYWxhciA9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZC56ZXJvO1xuICAgIH1cbiAgICBpZiAoc2NhbGFyID09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICB2YXIgcHJvZHVjdCA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIHNjYWxhcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR0YyNTZQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICB9O1xuICAvKipcbiAgICogVE9ETy5cbiAgICogQHJldHVybiB7IXc2OWIucXIuR0YyNTZQb2x5fSByZXN1bHQuXG4gICAqL1xuICBwcm8ubXVsdGlwbHlCeU1vbm9taWFsID0gZnVuY3Rpb24oZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoZGVncmVlID49IDApO1xuICAgIGlmIChjb2VmZmljaWVudCA9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZC56ZXJvO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICB2YXIgcHJvZHVjdCA9IG5ldyBBcnJheShzaXplICsgZGVncmVlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2R1Y3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2R1Y3RbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIGNvZWZmaWNpZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHRjI1NlBvbHkodGhpcy5maWVsZCwgcHJvZHVjdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpdmlkZSBieSBvdGhlciBwb2x5LlxuICAgKiBAcGFyYW0geyF3NjliLnFyLkdGMjU2UG9seX0gb3RoZXIgb3RoZXIgcG9seS5cbiAgICogQHJldHVybiB7QXJyYXkuPHc2OWIucXIuR0YyNTZQb2x5Pn0gcmVzdWx0IChxdW90aWVudCwgcmVtYWluZGVyKS5cbiAgICovXG4gIHByby5kaXZpZGUgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzLmZpZWxkICE9IG90aGVyLmZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgV3JvbmdGaWVsZEVycm9yKCk7XG4gICAgfVxuICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQoIW90aGVyLmlzWmVybygpKTtcblxuICAgIHZhciBxdW90aWVudCA9IHRoaXMuZmllbGQuemVybztcbiAgICB2YXIgcmVtYWluZGVyID0gdGhpcztcblxuICAgIHZhciBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gb3RoZXIuZ2V0Q29lZmZpY2llbnQob3RoZXIuZ2V0RGVncmVlKCkpO1xuICAgIHZhciBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHRoaXMuZmllbGQuaW52ZXJzZShcbiAgICAgIGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuXG4gICAgd2hpbGUgKHJlbWFpbmRlci5nZXREZWdyZWUoKSA+PSBvdGhlci5nZXREZWdyZWUoKSAmJiAhcmVtYWluZGVyLmlzWmVybygpKSB7XG4gICAgICB2YXIgZGVncmVlRGlmZmVyZW5jZSA9IHJlbWFpbmRlci5nZXREZWdyZWUoKSAtIG90aGVyLmdldERlZ3JlZSgpO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5maWVsZC5tdWx0aXBseShcbiAgICAgICAgcmVtYWluZGVyLmdldENvZWZmaWNpZW50KHJlbWFpbmRlci5nZXREZWdyZWUoKSksXG4gICAgICAgIGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgIHZhciB0ZXJtID0gb3RoZXIubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmZlcmVuY2UsIHNjYWxlKTtcbiAgICAgIHZhciBpdGVyYXRpb25RdW90aWVudCA9IHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLFxuICAgICAgICBzY2FsZSk7XG4gICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpO1xuICAgICAgcmVtYWluZGVyID0gcmVtYWluZGVyLmFkZE9yU3VidHJhY3QodGVybSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBcnJheShxdW90aWVudCwgcmVtYWluZGVyKTtcbiAgfTtcblxuICBwcm8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgZGVncmVlID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XG4gICAgICB2YXIgY29lZmZpY2llbnQgPSB0aGlzLmdldENvZWZmaWNpZW50KGRlZ3JlZSk7XG4gICAgICBpZiAoY29lZmZpY2llbnQgIT0gMCkge1xuICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJyAtICcpO1xuICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyArICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVncmVlID09IDAgfHwgY29lZmZpY2llbnQgIT0gMSkge1xuICAgICAgICAgIHZhciBhbHBoYVBvd2VyID0gdGhpcy5maWVsZC5sb2coY29lZmZpY2llbnQpO1xuICAgICAgICAgIGlmIChhbHBoYVBvd2VyID09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcxJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbHBoYVBvd2VyID09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdhJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdhXicpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxwaGFQb3dlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWdyZWUgIT0gMCkge1xuICAgICAgICAgIGlmIChkZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ3gnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ3heJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWdyZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9O1xuXG5cbn0pO1xuXG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuICovXG5cbi8qXG4gKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkdGMjU2Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR0YyNTZQb2x5Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBHRjI1NlBvbHkgPSB3NjliLnFyLkdGMjU2UG9seTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaW1pdGl2ZSBudW1iZXIuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5HRjI1NiA9IGZ1bmN0aW9uKHByaW1pdGl2ZSkge1xuICAgIHRoaXMuZXhwVGFibGUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICB0aGlzLmxvZ1RhYmxlID0gbmV3IEFycmF5KDI1Nik7XG4gICAgdmFyIHggPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHRoaXMuZXhwVGFibGVbaV0gPSB4O1xuICAgICAgeCA8PD0gMTsgLy8geCA9IHggKiAyOyB3ZSdyZSBhc3N1bWluZyB0aGUgZ2VuZXJhdG9yIGFscGhhIGlzIDJcbiAgICAgIGlmICh4ID49IDB4MTAwKSB7XG4gICAgICAgIHggXj0gcHJpbWl0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgICB0aGlzLmxvZ1RhYmxlW3RoaXMuZXhwVGFibGVbaV1dID0gaTtcbiAgICB9XG4gICAgLy8gbG9nVGFibGVbMF0gPT0gMCBidXQgdGhpcyBzaG91bGQgbmV2ZXIgYmUgdXNlZFxuICAgIHZhciBhdDAgPSBuZXcgQXJyYXkoMSk7XG4gICAgYXQwWzBdID0gMDtcbiAgICB0aGlzLnplcm8gPSBuZXcgR0YyNTZQb2x5KHRoaXMsIG5ldyBBcnJheShhdDApKTtcbiAgICB2YXIgYXQxID0gbmV3IEFycmF5KDEpO1xuICAgIGF0MVswXSA9IDE7XG4gICAgdGhpcy5vbmUgPSBuZXcgR0YyNTZQb2x5KHRoaXMsIG5ldyBBcnJheShhdDEpKTtcbiAgfTtcbiAgdmFyIEdGMjU2ID0gdzY5Yi5xci5HRjI1NjtcbiAgdmFyIHBybyA9IEdGMjU2LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQHJldHVybiB7IUdGMjU2UG9seX0gcG9seS5cbiAgICovXG4gIHByby5idWlsZE1vbm9taWFsID0gZnVuY3Rpb24oZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH1cbiAgICBpZiAoY29lZmZpY2llbnQgPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICB9XG4gICAgdmFyIGNvZWZmaWNpZW50cyA9IG5ldyBBcnJheShkZWdyZWUgKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKyljb2VmZmljaWVudHNbaV0gPSAwO1xuICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgIHJldHVybiBuZXcgR0YyNTZQb2x5KHRoaXMsIGNvZWZmaWNpZW50cyk7XG4gIH07XG4gIHByby5leHAgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gIH07XG4gIHByby5sb2cgPSBmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEgPT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XG4gIH07XG4gIHByby5pbnZlcnNlID0gZnVuY3Rpb24oYSkge1xuICAgIGlmIChhID09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cFRhYmxlWzI1NSAtIHRoaXMubG9nVGFibGVbYV1dO1xuICB9O1xuICBwcm8ubXVsdGlwbHkgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPT0gMCB8fCBiID09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYSA9PSAxKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgaWYgKGIgPT0gMSkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cFRhYmxlWyh0aGlzLmxvZ1RhYmxlW2FdICsgdGhpcy5sb2dUYWJsZVtiXSkgJSAyNTVdO1xuICB9O1xuXG4gIEdGMjU2LlFSX0NPREVfRklFTEQgPSBuZXcgR0YyNTYoMHgwMTFEKTtcbiAgR0YyNTYuREFUQV9NQVRSSVhfRklFTEQgPSBuZXcgR0YyNTYoMHgwMTJEKTtcblxufSk7XG5cbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4gKi9cblxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuUmVlZFNvbG9tb25EZWNvZGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR0YyNTZQb2x5Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUmVhZGVyRXJyb3InKTtcblxuLyoqXG4gKiA8cD5JbXBsZW1lbnRzIFJlZWQtU29sb21vbiBkZWNvZGluZywgYXMgdGhlIG5hbWUgaW1wbGllcy48L3A+XG4gKlxuICogPHA+VGhlIGFsZ29yaXRobSB3aWxsIG5vdCBiZSBleHBsYWluZWQgaGVyZSwgYnV0IHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlc1xuICogd2VyZSBoZWxwZnVsXG4gKiBpbiBjcmVhdGluZyB0aGlzIGltcGxlbWVudGF0aW9uOjwvcD5cbiAqXG4gKiA8dWw+XG4gKiA8bGk+QnJ1Y2UgTWFnZ3MuXG4gKiA8YSBocmVmPVwiaHR0cDovL3d3dy5jcy5jbXUuZWR1L2Fmcy9jcy5jbXUuZWR1L3Byb2plY3QvcHNjaWNvLWd1eWIvcmVhbHdvcmxkXG4gKiAvd3d3L3JzX2RlY29kZS5wc1wiPlxuICogXCJEZWNvZGluZyBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT4gKHNlZSBkaXNjdXNzaW9uIG9mIEZvcm5leSdzIEZvcm11bGEpPC9saT5cbiAqIDxsaT5KLkkuIEhhbGwuIDxhIGhyZWY9XCJ3d3cubXRoLm1zdS5lZHUvfmpoYWxsL2NsYXNzZXMvY29kZW5vdGVzL0dSUy5wZGZcIj5cbiAqIFwiQ2hhcHRlciA1LiBHZW5lcmFsaXplZCBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT5cbiAqIChzZWUgZGlzY3Vzc2lvbiBvZiBFdWNsaWRlYW4gYWxnb3JpdGhtKTwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlXG4gKiBhbiBpbmRpcmVjdCBwb3J0IG9mIGhpcyBDKysgUmVlZC1Tb2xvbW9uIGltcGxlbWVudGF0aW9uLjwvcD5cbiAqXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxuICogQGF1dGhvciBXaWxsaWFtIFJ1Y2tsaWRnZVxuICogQGF1dGhvciBzYW5mb3Jkc3F1aXJlc1xuICovXG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIEdGMjU2UG9seSA9IHc2OWIucXIuR0YyNTZQb2x5O1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbXNnIG1lc3NhZ2UuXG4gICAqIEBleHRlbmRzIHt3NjliLnFyLlJlYWRlckVycm9yfVxuICAgKi9cbiAgdzY5Yi5xci5SZWVkU29sb21vbkVycm9yID0gZnVuY3Rpb24ob3B0X21zZykge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBvcHRfbXNnKTtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyh3NjliLnFyLlJlZWRTb2xvbW9uRXJyb3IsIHc2OWIucXIuUmVhZGVyRXJyb3IpO1xuICB2YXIgUmVlZFNvbG9tb25FcnJvciA9IHc2OWIucXIuUmVlZFNvbG9tb25FcnJvcjtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyF3NjliLnFyLkdGMjU2fSBmaWVsZCBmaWVsZC5cbiAgICovXG4gIHc2OWIucXIuUmVlZFNvbG9tb25EZWNvZGVyID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gIH07XG4gIHZhciBSZWVkU29sb21vbkRlY29kZXIgPSB3NjliLnFyLlJlZWRTb2xvbW9uRGVjb2RlcjtcbiAgdmFyIHBybyA9IFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIDxwPkRlY29kZXMgZ2l2ZW4gc2V0IG9mIHJlY2VpdmVkIGNvZGV3b3Jkcywgd2hpY2ggaW5jbHVkZSBib3RoIGRhdGEgYW5kXG4gICAqIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLlxuICAgKiBSZWFsbHksIHRoaXMgbWVhbnMgaXQgdXNlcyBSZWVkLVNvbG9tb24gdG8gZGV0ZWN0IGFuZCBjb3JyZWN0ICBlcnJvcnMsXG4gICAqIGluLXBsYWNlLCBpbiB0aGUgaW5wdXQuPC9wPlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZWNlaXZlZCBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR3b1MgbnVtYmVyIG9mIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIGF2YWlsYWJsZS5cbiAgICovXG4gIHByby5kZWNvZGUgPSBmdW5jdGlvbihyZWNlaXZlZCwgdHdvUykge1xuICAgIHZhciBwb2x5ID0gbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkLCByZWNlaXZlZCk7XG4gICAgdmFyIHN5bmRyb21lQ29lZmZpY2llbnRzID0gbmV3IEFycmF5KHR3b1MpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDxcbiAgICAgIHN5bmRyb21lQ29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKXN5bmRyb21lQ29lZmZpY2llbnRzW2ldID0gMDtcbiAgICB2YXIgZGF0YU1hdHJpeCA9IGZhbHNlOy8vdGhpcy5maWVsZC5FcXVhbHMoR0YyNTYuREFUQV9NQVRSSVhfRklFTEQpO1xuICAgIHZhciBub0Vycm9yID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3b1M7IGkrKykge1xuICAgICAgLy8gVGhhbmtzIHRvIHNhbmZvcmRzcXVpcmVzIGZvciB0aGlzIGZpeDpcbiAgICAgIHZhciB2YWwgPSBwb2x5LmV2YWx1YXRlQXQodGhpcy5maWVsZC5leHAoZGF0YU1hdHJpeCA/IGkgKyAxIDogaSkpO1xuICAgICAgc3luZHJvbWVDb2VmZmljaWVudHNbc3luZHJvbWVDb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGldID0gdmFsO1xuICAgICAgaWYgKHZhbCAhPSAwKSB7XG4gICAgICAgIG5vRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vRXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN5bmRyb21lID0gbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkLCBzeW5kcm9tZUNvZWZmaWNpZW50cyk7XG4gICAgdmFyIHNpZ21hT21lZ2EgPSB0aGlzLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobSh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwodHdvUyxcbiAgICAgIDEpLCBzeW5kcm9tZSwgdHdvUyk7XG4gICAgdmFyIHNpZ21hID0gc2lnbWFPbWVnYVswXTtcbiAgICB2YXIgb21lZ2EgPSBzaWdtYU9tZWdhWzFdO1xuICAgIHZhciBlcnJvckxvY2F0aW9ucyA9IHRoaXMuZmluZEVycm9yTG9jYXRpb25zKHNpZ21hKTtcbiAgICB2YXIgZXJyb3JNYWduaXR1ZGVzID0gdGhpcy5maW5kRXJyb3JNYWduaXR1ZGVzKG9tZWdhLCBlcnJvckxvY2F0aW9ucyxcbiAgICAgIGRhdGFNYXRyaXgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHJlY2VpdmVkLmxlbmd0aCAtIDEgLSB0aGlzLmZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkVycm9yKCdiYWQgZXJyb3IgbG9jYXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IEdGMjU2UG9seS5hZGRPclN1YnRyYWN0U2NhbGFyKHJlY2VpdmVkW3Bvc2l0aW9uXSxcbiAgICAgICAgZXJyb3JNYWduaXR1ZGVzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobSA9IGZ1bmN0aW9uKGEsIGIsIFIpIHtcbiAgICAvLyBBc3N1bWUgYSdzIGRlZ3JlZSBpcyA+PSBiJ3NcbiAgICBpZiAoYS5nZXREZWdyZWUoKSA8IGIuZ2V0RGVncmVlKCkpIHtcbiAgICAgIHZhciB0ZW1wID0gYTtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHRlbXA7XG4gICAgfVxuXG4gICAgdmFyIHJMYXN0ID0gYTtcbiAgICB2YXIgciA9IGI7XG4gICAgdmFyIHNMYXN0ID0gdGhpcy5maWVsZC5vbmU7XG4gICAgdmFyIHMgPSB0aGlzLmZpZWxkLnplcm87XG4gICAgdmFyIHRMYXN0ID0gdGhpcy5maWVsZC56ZXJvO1xuICAgIHZhciB0ID0gdGhpcy5maWVsZC5vbmU7XG5cbiAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSBNYXRoLmZsb29yKFIgLyAyKSkge1xuICAgICAgdmFyIHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgdmFyIHNMYXN0TGFzdCA9IHNMYXN0O1xuICAgICAgdmFyIHRMYXN0TGFzdCA9IHRMYXN0O1xuICAgICAgckxhc3QgPSByO1xuICAgICAgc0xhc3QgPSBzO1xuICAgICAgdExhc3QgPSB0O1xuXG4gICAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByXG4gICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHtcbiAgICAgICAgLy8gT29wcywgRXVjbGlkZWFuIGFsZ29yaXRobSBhbHJlYWR5IHRlcm1pbmF0ZWQ/XG4gICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkVycm9yKCdyX3tpLTF9IHdhcyB6ZXJvJyk7XG4gICAgICB9XG4gICAgICByID0gckxhc3RMYXN0O1xuICAgICAgdmFyIHEgPSB0aGlzLmZpZWxkLnplcm87XG4gICAgICB2YXIgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHJMYXN0LmdldENvZWZmaWNpZW50KHJMYXN0LmdldERlZ3JlZSgpKTtcbiAgICAgIHZhciBkbHRJbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSxcbiAgICAgICAgICBkbHRJbnZlcnNlKTtcbiAgICAgICAgcSA9IHEuYWRkT3JTdWJ0cmFjdCh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgciA9IHIuYWRkT3JTdWJ0cmFjdChyTGFzdC5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgLy9yLkVYRSgpO1xuICAgICAgfVxuXG4gICAgICBzID0gcS5tdWx0aXBseTEoc0xhc3QpLmFkZE9yU3VidHJhY3Qoc0xhc3RMYXN0KTtcbiAgICAgIHQgPSBxLm11bHRpcGx5MSh0TGFzdCkuYWRkT3JTdWJ0cmFjdCh0TGFzdExhc3QpO1xuICAgIH1cblxuICAgIHZhciBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTtcbiAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FcnJvcignc2lnbWFUaWxkZSgwKSB3YXMgemVybycpO1xuICAgIH1cblxuICAgIHZhciBpbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKHNpZ21hVGlsZGVBdFplcm8pO1xuICAgIHZhciBzaWdtYSA9IHQubXVsdGlwbHkyKGludmVyc2UpO1xuICAgIHZhciBvbWVnYSA9IHIubXVsdGlwbHkyKGludmVyc2UpO1xuICAgIHJldHVybiBuZXcgQXJyYXkoc2lnbWEsIG9tZWdhKTtcbiAgfTtcbiAgcHJvLmZpbmRFcnJvckxvY2F0aW9ucyA9IGZ1bmN0aW9uKGVycm9yTG9jYXRvcikge1xuICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcbiAgICB2YXIgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgIGlmIChudW1FcnJvcnMgPT0gMSkge1xuICAgICAgLy8gc2hvcnRjdXRcbiAgICAgIHJldHVybiBbZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KDEpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShudW1FcnJvcnMpO1xuICAgIHZhciBlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDI1NiAmJiBlIDwgbnVtRXJyb3JzOyBpKyspIHtcbiAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PSAwKSB7XG4gICAgICAgIHJlc3VsdFtlXSA9IHRoaXMuZmllbGQuaW52ZXJzZShpKTtcbiAgICAgICAgZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZSAhPSBudW1FcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkVycm9yKCdsb2NhdG9yIGRlZ3JlZSBkb2VzIG5vdCBtYXRjaCAnICtcbiAgICAgICAgJ251bWJlciBvZiByb290cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm8uZmluZEVycm9yTWFnbml0dWRlcyA9XG4gICAgZnVuY3Rpb24oZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRpb25zLCBkYXRhTWF0cml4KSB7XG4gICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgIHZhciBzID0gZXJyb3JMb2NhdGlvbnMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHZhciB4aUludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZXJyb3JMb2NhdGlvbnNbaV0pO1xuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIGlmIChpICE9IGopIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID1cbiAgICAgICAgICAgICAgdGhpcy5maWVsZC5tdWx0aXBseShkZW5vbWluYXRvciwgR0YyNTZQb2x5LmFkZE9yU3VidHJhY3RTY2FsYXIoMSxcbiAgICAgICAgICAgICAgICB0aGlzLmZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkoZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpLFxuICAgICAgICAgIHRoaXMuZmllbGQuaW52ZXJzZShkZW5vbWluYXRvcikpO1xuICAgICAgICAvLyBUaGFua3MgdG8gc2FuZm9yZHNxdWlyZXMgZm9yIHRoaXMgZml4OlxuICAgICAgICBpZiAoZGF0YU1hdHJpeCkge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkocmVzdWx0W2ldLCB4aUludmVyc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiAqL1xuXG4vKlxuICpcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5kZWNvZGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQml0TWF0cml4UGFyc2VyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRGF0YUJsb2NrJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRGVjb2RlZEJpdFN0cmVhbVBhcnNlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkdGMjU2Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUmVlZFNvbG9tb25EZWNvZGVyJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBHRjI1NiA9IHc2OWIucXIuR0YyNTY7XG4gIHZhciBEYXRhQmxvY2sgPSB3NjliLnFyLkRhdGFCbG9jaztcblxuICB2YXIgXyA9IHc2OWIucXIuZGVjb2RlcjtcbiAgXy5yc0RlY29kZXIgPSBuZXcgdzY5Yi5xci5SZWVkU29sb21vbkRlY29kZXIoR0YyNTYuUVJfQ09ERV9GSUVMRCk7XG5cbiAgXy5jb3JyZWN0RXJyb3JzID0gZnVuY3Rpb24oY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcykge1xuICAgIHZhciBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDtcbiAgICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgIHZhciBjb2Rld29yZHNJbnRzID0gbmV3IEFycmF5KG51bUNvZGV3b3Jkcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKykge1xuICAgICAgY29kZXdvcmRzSW50c1tpXSA9IGNvZGV3b3JkQnl0ZXNbaV0gJiAweEZGO1xuICAgIH1cbiAgICB2YXIgbnVtRUNDb2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aCAtIG51bURhdGFDb2Rld29yZHM7XG4gICAgXy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgIC8vdmFyIGNvcnJlY3RvciA9IG5ldyBSZWVkU29sb21vbihjb2Rld29yZHNJbnRzLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAvL2NvcnJlY3Rvci5jb3JyZWN0KCk7XG4gICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0XG4gICAgLy8gd2VyZSBkYXRhIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICBjb2Rld29yZEJ5dGVzW2ldID0gY29kZXdvcmRzSW50c1tpXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5CaXRNYXRyaXh9IGJpdHMgbWF0cml4LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlYWRlciBpbnN0bmFuY2UuXG4gICAqL1xuICBfLmRlY29kZSA9IGZ1bmN0aW9uKGJpdHMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHc2OWIucXIuQml0TWF0cml4UGFyc2VyKGJpdHMpO1xuICAgIHZhciB2ZXJzaW9uID0gcGFyc2VyLnJlYWRWZXJzaW9uKCk7XG4gICAgdmFyIGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG5cbiAgICAvLyBSZWFkIGNvZGV3b3Jkc1xuICAgIHZhciBjb2Rld29yZHMgPSBwYXJzZXIucmVhZENvZGV3b3JkcygpO1xuXG4gICAgLy8gU2VwYXJhdGUgaW50byBkYXRhIGJsb2Nrc1xuICAgIHZhciBkYXRhQmxvY2tzID0gRGF0YUJsb2NrLmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKTtcblxuICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXG4gICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxCeXRlcyArPSBkYXRhQmxvY2tzW2ldLm51bURhdGFDb2Rld29yZHM7XG4gICAgfVxuICAgIHZhciByZXN1bHRCeXRlcyA9IG5ldyBBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICB2YXIgcmVzdWx0T2Zmc2V0ID0gMDtcblxuICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YUJsb2Nrcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3Nbal07XG4gICAgICB2YXIgY29kZXdvcmRCeXRlcyA9IGRhdGFCbG9jay5jb2Rld29yZHM7XG4gICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5udW1EYXRhQ29kZXdvcmRzO1xuICAgICAgXy5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgcmVzdWx0Qnl0ZXNbcmVzdWx0T2Zmc2V0KytdID0gY29kZXdvcmRCeXRlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgdGhlIGNvbnRlbnRzIG9mIHRoYXQgc3RyZWFtIG9mIGJ5dGVzXG4gICAgcmV0dXJuIHc2OWIucXIuRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUocmVzdWx0Qnl0ZXMsXG4gICAgICB2ZXJzaW9uLCBlY0xldmVsLmJpdHMpO1xuICAgIC8vcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXJPbGQuZGVjb2RlKHJlc3VsdEJ5dGVzLCB2ZXJzaW9uLCBlY0xldmVsKTtcbiAgfTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkJpdEFycmF5Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4vKipcbiAgICogPHA+QSBzaW1wbGUsIGZhc3QgYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgY29tcGFjdGx5IGJ5IGFuIGFycmF5IG9mIGludHNcbiAgICogaW50ZXJuYWxseS48L3A+XG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3NpemUgc2l6ZSwgZGVmYXVsdHMgdG8gMC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAqL1xuICB3NjliLnFyLkJpdEFycmF5ID0gZnVuY3Rpb24ob3B0X3NpemUpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdF9zaXplIHx8IDA7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0ludDMyQXJyYXl9IGJpdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJpdHNfID0gdzY5Yi5xci5CaXRBcnJheS5tYWtlQXJyYXkodGhpcy5zaXplXyk7XG4gIH07XG4gIHZhciBfID0gdzY5Yi5xci5CaXRBcnJheTtcbiAgdmFyIHBybyA9IF8ucHJvdG90eXBlO1xuXG4gIF8ubnVtYmVyT2ZUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24oaSkge1xuICAgIC8vIEhELCBGaWd1cmUgNS0xNFxuICAgIHZhciB5O1xuICAgIGlmIChpID09IDApIHJldHVybiAzMjtcbiAgICB2YXIgbiA9IDMxO1xuICAgIHkgPSBpIDw8IDE2OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gMTY7IGkgPSB5OyB9XG4gICAgeSA9IGkgPDwgODsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IGkgPSB5OyB9XG4gICAgeSA9IGkgPDwgNDsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDQ7IGkgPSB5OyB9XG4gICAgeSA9IGkgPDwgMjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IGkgPSB5OyB9XG4gICAgcmV0dXJuIG4gLSAoKGkgPDwgMSkgPj4+IDMxKTtcbiAgfTtcblxuICBwcm8uZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9O1xuXG4gIHByby5nZXRTaXplSW5CeXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5zaXplXyArIDcpID4+IDM7XG4gIH07XG5cbiAgcHJvLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChzaXplID4gdGhpcy5iaXRzXy5sZW5ndGggPDwgNSkge1xuICAgICAgdmFyIG5ld0JpdHMgPSBfLm1ha2VBcnJheShzaXplKTtcbiAgICAgIG5ld0JpdHMuc2V0KHRoaXMuYml0c18sIDApO1xuICAgICAgdGhpcy5iaXRzXyA9IG5ld0JpdHM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBiaXQgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmZiBiaXQgaSBpcyBzZXQuXG4gICAqL1xuICBwcm8uZ2V0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiAodGhpcy5iaXRzX1tpID4+IDVdICYgKDEgPDwgKGkgJiAweDFGKSkpICE9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYml0IGkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIGJpdCB0byBzZXQuXG4gICAqL1xuICBwcm8uc2V0ID0gZnVuY3Rpb24oaSkge1xuICAgIHRoaXMuYml0c19baSA+PiA1XSB8PSAxIDw8IChpICYgMHgxRik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZsaXBzIGJpdCBpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBiaXQgdG8gc2V0LlxuICAgKi9cbiAgcHJvLmZsaXAgPSBmdW5jdGlvbihpKSB7XG4gICAgdGhpcy5iaXRzX1tpID4+IDVdIF49IDEgPDwgKGkgJiAweDFGKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gZmlyc3QgYml0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZGV4IG9mIGZpcnN0IGJpdCB0aGF0IGlzIHNldCwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW5cbiAgICogaW5kZXgsIG9yIHNpemUgaWYgbm9uZSBhcmUgc2V0IGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4LlxuICAgKiBAc2VlICNnZXROZXh0VW5zZXQoaW50KVxuICAgKi9cbiAgcHJvLmdldE5leHRTZXQgPSBmdW5jdGlvbihmcm9tKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemVfO1xuICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICB2YXIgYml0c09mZnNldCA9IGZyb20gPj4gNTtcbiAgICB2YXIgY3VycmVudEJpdHMgPSB0aGlzLmJpdHNfW2JpdHNPZmZzZXRdO1xuICAgIC8vIG1hc2sgb2ZmIGxlc3NlciBiaXRzIGZpcnN0XG4gICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xuICAgIHdoaWxlIChjdXJyZW50Qml0cyA9PSAwKSB7XG4gICAgICBpZiAoKytiaXRzT2Zmc2V0ID09IHRoaXMuYml0c18ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgICAgfVxuICAgICAgY3VycmVudEJpdHMgPSB0aGlzLmJpdHNfW2JpdHNPZmZzZXRdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gKGJpdHNPZmZzZXQgPDwgNSkgKyBfLm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAc2VlICNnZXROZXh0U2V0KGludClcbiAgICovXG4gIHByby5nZXROZXh0VW5zZXQgPSBmdW5jdGlvbihmcm9tKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemVfO1xuICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICB2YXIgYml0c09mZnNldCA9IGZyb20gPj4gNTtcbiAgICB2YXIgY3VycmVudEJpdHMgPSB+dGhpcy5iaXRzX1tiaXRzT2Zmc2V0XTtcbiAgICAvLyBtYXNrIG9mZiBsZXNzZXIgYml0cyBmaXJzdFxuICAgIGN1cnJlbnRCaXRzICY9IH4oKDEgPDwgKGZyb20gJiAweDFGKSkgLSAxKTtcbiAgICB3aGlsZSAoY3VycmVudEJpdHMgPT0gMCkge1xuICAgICAgaWYgKCsrYml0c09mZnNldCA9PSB0aGlzLmJpdHNfLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRCaXRzID0gfnRoaXMuYml0c19bYml0c09mZnNldF07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAoYml0c09mZnNldCA8PCA1KSArIF8ubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID4gc2l6ZSA/IHNpemUgOiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBibG9jayBvZiAzMiBiaXRzLCBzdGFydGluZyBhdCBiaXQgaS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgZmlyc3QgYml0IHRvIHNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0JpdHMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgbmV4dCAzMiBiaXRzLiBOb3RlIGFnYWluIHRoYXRcbiAgICogdGhlIGxlYXN0LXNpZ25pZmljYW50IGJpdCBjb3JyZXNwb25kcyB0byBiaXQgaSwgdGhlIG5leHQtbGVhc3Qtc2lnbmlmaWNhbnRcbiAgICogdG8gaSsxLCBhbmQgc28gb24uXG4gICAqL1xuICBwcm8uc2V0QnVsayA9IGZ1bmN0aW9uKGksIG5ld0JpdHMpIHtcbiAgICB0aGlzLmJpdHNfW2kgPj4gNV0gPSBuZXdCaXRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgcmFuZ2Ugb2YgYml0cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0IG9mIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmUuXG4gICAqL1xuICBwcm8uc2V0UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKGVuZCA9PSBzdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgZW5kLS07XG4gICAgdmFyIGZpcnN0SW50ID0gc3RhcnQgPj4gNTtcbiAgICB2YXIgbGFzdEludCA9IGVuZCA+PiA1O1xuICAgIGZvciAodmFyIGkgPSBmaXJzdEludDsgaSA8PSBsYXN0SW50OyBpKyspIHtcbiAgICAgIHZhciBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XG4gICAgICB2YXIgbGFzdEJpdCA9IGkgPCBsYXN0SW50ID8gMzEgOiBlbmQgJiAweDFGO1xuICAgICAgdmFyIG1hc2s7XG4gICAgICBpZiAoZmlyc3RCaXQgPT0gMCAmJiBsYXN0Qml0ID09IDMxKSB7XG4gICAgICAgIG1hc2sgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2sgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gZmlyc3RCaXQ7IGogPD0gbGFzdEJpdDsgaisrKSB7XG4gICAgICAgICAgbWFzayB8PSAxIDw8IGo7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYml0c19baV0gfD0gbWFzaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAqL1xuICBwcm8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF4ID0gdGhpcy5iaXRzXy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgdGhpcy5iaXRzX1tpXSA9IDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFZmZpY2llbnQgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcmFuZ2Ugb2YgYml0cyBpcyBzZXQsIG9yIG5vdCBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIGlmIHRydWUsIGNoZWNrcyB0aGF0IGJpdHMgaW4gcmFuZ2UgYXJlIHNldCxcbiAgICogb3RoZXJ3aXNlIGNoZWNrcyB0aGF0IHRoZXkgYXJlIG5vdCBzZXQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nXG4gICAqIHRvIHZhbHVlIGFyZ3VtZW50LlxuICAgKi9cbiAgcHJvLmlzUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChlbmQgPT0gc3RhcnQpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSByYW5nZSBtYXRjaGVzXG4gICAgfVxuICAgIC8vIHdpbGwgYmUgZWFzaWVyIHRvIHRyZWF0IHRoaXMgYXMgdGhlIGxhc3QgYWN0dWFsbHkgc2V0IGJpdCAtLSBpbmNsdXNpdmVcbiAgICBlbmQtLTtcbiAgICB2YXIgZmlyc3RJbnQgPSBzdGFydCA+PiA1O1xuICAgIHZhciBsYXN0SW50ID0gZW5kID4+IDU7XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykge1xuICAgICAgdmFyIGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjtcbiAgICAgIHZhciBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XG4gICAgICB2YXIgbWFzaztcbiAgICAgIGlmIChmaXJzdEJpdCA9PSAwICYmIGxhc3RCaXQgPT0gMzEpIHtcbiAgICAgICAgbWFzayA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFzayA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSBmaXJzdEJpdDsgaiA8PSBsYXN0Qml0OyBqKyspIHtcbiAgICAgICAgICBtYXNrIHw9IDEgPDwgajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gZmFsc2UgaWYgd2UncmUgbG9va2luZyBmb3IgMXMgYW5kIHRoZSBtYXNrZWQgYml0c1tpXSBpc24ndCBhbGxcbiAgICAgIC8vIDFzICh0aGF0IGlzLCBlcXVhbHMgdGhlIG1hc2ssIG9yIHdlJ3JlIGxvb2tpbmcgZm9yIDBzIGFuZCB0aGUgbWFza2VkXG4gICAgICAvLyBwb3J0aW9uIGlzIG5vdCBhbGwgMHNcbiAgICAgIGlmICgodGhpcy5iaXRzX1tpXSAmIG1hc2spICE9ICh2YWx1ZSA/IG1hc2sgOiAwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHByby5hcHBlbmRCaXQgPSBmdW5jdGlvbihiaXQpIHtcbiAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZV8gKyAxKTtcbiAgICBpZiAoYml0KSB7XG4gICAgICB0aGlzLmJpdHNfW3RoaXMuc2l6ZV8gPj4gNV0gfD0gMSA8PCAodGhpcy5zaXplXyAmIDB4MUYpO1xuICAgIH1cbiAgICB0aGlzLnNpemVfKys7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGxlYXN0LXNpZ25pZmljYW50IHRoaXMuYml0c18sIGZyb20gdmFsdWUsIGluIG9yZGVyIGZyb21cbiAgICogbW9zdC1zaWduaWZpY2FudCB0byBsZWFzdC1zaWduaWZpY2FudC4gRm9yIGV4YW1wbGUsIGFwcGVuZGluZyA2IHRoaXMuYml0c19cbiAgICogZnJvbSAweDAwMDAwMUUgd2lsbCBhcHBlbmQgdGhlIHRoaXMuYml0c18gMCwgMSwgMSwgMSwgMSwgMCBpbiB0aGF0IG9yZGVyLlxuICAgKi9cbiAgcHJvLmFwcGVuZEJpdHMgPSBmdW5jdGlvbih2YWx1ZSwgbnVtQml0cykge1xuICAgIGlmIChudW1CaXRzIDwgMCB8fCBudW1CaXRzID4gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZV8gKyBudW1CaXRzKTtcbiAgICBmb3IgKHZhciBudW1CaXRzTGVmdCA9IG51bUJpdHM7IG51bUJpdHNMZWZ0ID4gMDsgbnVtQml0c0xlZnQtLSkge1xuICAgICAgdGhpcy5hcHBlbmRCaXQoKCh2YWx1ZSA+PiAobnVtQml0c0xlZnQgLSAxKSkgJiAweDAxKSA9PSAxKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvLmFwcGVuZEJpdEFycmF5ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2YXIgb3RoZXJTaXplID0gb3RoZXIuc2l6ZV87XG4gICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemVfICsgb3RoZXJTaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLmFwcGVuZEJpdChvdGhlci5nZXQoaSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHt3NjliLnFyLkJpdEFycmF5fSBvdGhlciBvdGhlci5cbiAgICovXG4gIHByby54b3IgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzLmJpdHNfLmxlbmd0aCAhPSBvdGhlci5iaXRzXy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYml0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFRoZSBsYXN0IGJ5dGUgY291bGQgYmUgaW5jb21wbGV0ZSAoaS5lLiBub3QgaGF2ZSA4IHRoaXMuYml0c18gaW5cbiAgICAgIC8vIGl0KSBidXQgdGhlcmUgaXMgbm8gcHJvYmxlbSBzaW5jZSAwIFhPUiAwID09IDAuXG4gICAgICB0aGlzLmJpdHNfW2ldIF49IG90aGVyLmJpdHNfW2ldO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdE9mZnNldCBmaXJzdCBiaXQgdG8gc3RhcnQgd3JpdGluZy5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgdG8gd3JpdGUgdmFyby4gQnl0ZXMgYXJlIHdyaXR0ZW5cbiAgICogbW9zdC1zaWduaWZpY2FudCBieXRlIGZpcnN0LiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiB0aGUgdmFyZXJuYWxcbiAgICogcmVwcmVzZW50YXRpb24sIHdoaWNoIGlzICogZXhwb3NlZCBieSB7QGxpbmsgI2dldEJpdEFycmF5KCl9LlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHBvc2l0aW9uIGluIGFycmF5IHRvIHN0YXJ0IHdyaXRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlcyBob3cgbWFueSBieXRlcyB0byB3cml0ZS5cbiAgICovXG4gIHByby50b0J5dGVzID0gZnVuY3Rpb24oYml0T2Zmc2V0LCBhcnJheSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQnl0ZXM7IGkrKykge1xuICAgICAgdmFyIHRoZUJ5dGUgPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KGJpdE9mZnNldCkpIHtcbiAgICAgICAgICB0aGVCeXRlIHw9IDEgPDwgKDcgLSBqKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRPZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGFycmF5W29mZnNldCArIGldID0gdGhlQnl0ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0ludDMyQXJyYXl9IGFycmF5IG9mIHZhcnMuIFRoZSBmaXJzdCBlbGVtZW50IGhvbGRzIHRoZSBmaXJzdCAzMlxuICAgKiBiaXRzLCBhbmQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBpcyBiaXQgMC5cbiAgICovXG4gIHByby5nZXRCaXRBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJpdHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXZlcnNlcyBhbGwgYml0cyBpbiB0aGUgYXJyYXkuXG4gICAqL1xuICBwcm8ucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdCaXRzID0gbmV3IEludDMyQXJyYXkodGhpcy5iaXRzXy5sZW5ndGgpO1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplXztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KHNpemUgLSBpIC0gMSkpIHtcbiAgICAgICAgbmV3Qml0c1tpID4+IDVdIHw9IDEgPDwgKGkgJiAweDFGKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5iaXRzXyA9IG5ld0JpdHM7XG4gIH07XG5cbiAgXy5tYWtlQXJyYXkgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KChzaXplICsgMzEpID4+IDUpO1xuICB9O1xuXG4gIHByby50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZV87IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwNykgPT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godGhpcy5nZXQoaSkgPyAnWCcgOiAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9O1xuXG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZ29vZy5wcm92aWRlKCd3NjliLnFyLkVuY29kZUhpbnRUeXBlJyk7XG5cbi8qKlxuICogRW5jb2RlIGhpbnQga2V5IGNvbnN0YW50cy5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnc2OWIucXIuRW5jb2RlSGludFR5cGUgPSB7XG4gIENIQVJBQ1RFUl9TRVQ6IDEsXG4gIEZPUkNFX0FERF9FQ0k6IDJcbn07XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLlJlZWRTb2xvbW9uRW5jb2RlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkdGMjU2Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR0YyNTZQb2x5Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBHRjI1NiA9IHc2OWIucXIuR0YyNTY7XG4gIHZhciBHRjI1NlBvbHkgPSB3NjliLnFyLkdGMjU2UG9seTtcblxuICAvKipcbiAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZW5iY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAgICpcbiAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICogQGF1dGhvciBXaWxsaWFtIFJ1Y2tsaWRnZVxuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYWh1ZWwgQnJhdW4pIHBvcnRlZCB0byBqcy5cbiAgICovXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7IUdGMjU2fSBmaWVsZCB0byB1c2UuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5SZWVkU29sb21vbkVuY29kZXIgPSBmdW5jdGlvbihmaWVsZCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFHRjI1Nn1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkXyA9IGZpZWxkO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjwhR0YyNTZQb2x5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlZEdlbmVyYXRvcnNfID0gW25ldyBHRjI1NlBvbHkoZmllbGQsIFsxXSldO1xuICB9O1xuICB2YXIgcHJvID0gdzY5Yi5xci5SZWVkU29sb21vbkVuY29kZXIucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIGRlZ3JlZS5cbiAgICogQHJldHVybiB7IUdGMjU2UG9seX0gZ2VuZXJhdG9yLlxuICAgKi9cbiAgcHJvLmJ1aWxkR2VuZXJhdG9yID0gZnVuY3Rpb24oZGVncmVlKSB7XG4gICAgdmFyIGNhY2hlZEdlbmVyYXRvcnMgPSB0aGlzLmNhY2hlZEdlbmVyYXRvcnNfO1xuICAgIGlmIChkZWdyZWUgPj0gY2FjaGVkR2VuZXJhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHZhciBsYXN0R2VuZXJhdG9yID0gY2FjaGVkR2VuZXJhdG9yc1tjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgZm9yICh2YXIgZCA9IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoOyBkIDw9IGRlZ3JlZTsgZCsrKSB7XG4gICAgICAgIHZhciBuZXh0R2VuZXJhdG9yID0gbGFzdEdlbmVyYXRvci5tdWx0aXBseTEoXG4gICAgICAgICAgbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkXywgWzEsIHRoaXMuZmllbGRfLmV4cChkIC0gMSldKSk7XG4gICAgICAgIGNhY2hlZEdlbmVyYXRvcnMucHVzaChuZXh0R2VuZXJhdG9yKTtcbiAgICAgICAgbGFzdEdlbmVyYXRvciA9IG5leHRHZW5lcmF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRHZW5lcmF0b3JzW2RlZ3JlZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRvRW5jb2RlIGRhdGEgdG8gZW5jb2RlLCBpbmNsdWRpbmcgcHJlLWFsbG9jYXRlZFxuICAgKiBzcGFjZSBmb3IgZWNjIGJ5dGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZWNCeXRlcyBudW1iZXIgb2YgZWMgYnl0ZXMuXG4gICAqL1xuICBwcm8uZW5jb2RlID0gZnVuY3Rpb24odG9FbmNvZGUsIGVjQnl0ZXMpIHtcbiAgICBpZiAoZWNCeXRlcyA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMnKTtcbiAgICB9XG4gICAgdmFyIGRhdGFCeXRlcyA9IHRvRW5jb2RlLmxlbmd0aCAtIGVjQnl0ZXM7XG4gICAgaWYgKGRhdGFCeXRlcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgYnl0ZXMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuYnVpbGRHZW5lcmF0b3IoZWNCeXRlcyk7XG4gICAgdmFyIGluZm9Db2VmZmljaWVudHMgPSB0b0VuY29kZS5zbGljZSgwLCBkYXRhQnl0ZXMpO1xuICAgIHZhciBpbmZvID0gbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkXywgaW5mb0NvZWZmaWNpZW50cyk7XG4gICAgaW5mbyA9IGluZm8ubXVsdGlwbHlCeU1vbm9taWFsKGVjQnl0ZXMsIDEpO1xuICAgIHZhciByZW1haW5kZXIgPSBpbmZvLmRpdmlkZShnZW5lcmF0b3IpWzFdO1xuICAgIHZhciBjb2VmZmljaWVudHMgPSByZW1haW5kZXIuY29lZmZpY2llbnRzO1xuICAgIHZhciBudW1aZXJvQ29lZmZpY2llbnRzID0gZWNCeXRlcyAtIGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVplcm9Db2VmZmljaWVudHM7IGkrKykge1xuICAgICAgdG9FbmNvZGVbZGF0YUJ5dGVzICsgaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29lZmZpY2llbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0b0VuY29kZVtkYXRhQnl0ZXMgKyBudW1aZXJvQ29lZmZpY2llbnRzICsgaV0gPSBjb2VmZmljaWVudHNbaV07XG4gICAgfVxuICAgIC8vIFN5c3RlbS5hcnJheWNvcHkoY29lZmZpY2llbnRzLCAwLCB0b0VuY29kZSxcbiAgICAvLyAgIGRhdGFCeXRlcyArIG51bVplcm9Db2VmZmljaWVudHMsIGNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICB9O1xuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuZW5jb2Rlci5CbG9ja1BhaXInKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdzY5Yi5xci5lbmNvZGVyLkJsb2NrUGFpciA9IGZ1bmN0aW9uKGRhdGEsIGVycm9yQ29ycmVjdGlvbikge1xuICAgIHRoaXMuZGF0YUJ5dGVzID0gZGF0YTtcbiAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkJ5dGVzID0gZXJyb3JDb3JyZWN0aW9uO1xuICB9O1xuICB2YXIgcHJvID0gdzY5Yi5xci5lbmNvZGVyLkJsb2NrUGFpci5wcm90b3R5cGU7XG5cbiAgcHJvLmdldERhdGFCeXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFCeXRlcztcbiAgfTtcblxuICBwcm8uZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgfTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLmVuY29kZXIuQnl0ZU1hdHJpeCcpO1xuXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggd3JhcHMgYSAyRCBhcnJheSBvZiBieXRlcy4gVGhlIGRlZmF1bHQgdXNhZ2UgaXMgc2lnbmVkLlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGl0IGFzIGFcbiAqIHVuc2lnbmVkIGNvbnRhaW5lciwgaXQncyB1cCB0byB5b3UgdG8gZG8gYnl0ZVZhbHVlICYgMHhmZiBhdCBlYWNoIGxvY2F0aW9uLlxuICpcbiAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyXG4gKiBnZXRzIGFzc2lnbmVkXG4gKiAtMSwgMCwgYW5kIDEsIEknbSBnb2luZyB0byB1c2UgbGVzcyBtZW1vcnkgYW5kIGdvIHdpdGggYnl0ZXMuXG4gKlxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqIEBhdXRob3IgbWJAdzY5Yi5jb20gKE1hbnVlbCBCcmF1bikgLSBwb3J0ZWQgdG8ganMuXG4gKi9cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIFJvdyAoeSkgZmlyc3QgYnl0ZSBtYXRyaXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aXRoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB3NjliLnFyLmVuY29kZXIuQnl0ZU1hdHJpeCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSB3aWR0aDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHRfID0gaGVpZ2h0O1xuICAgIHRoaXMuYnl0ZXNfID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLnFyLmVuY29kZXIuQnl0ZU1hdHJpeC5wcm90b3R5cGU7XG5cbiAgcHJvLmdldEJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXNfO1xuICB9O1xuXG4gIHByby5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHRfO1xuICB9O1xuXG4gIHByby5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoXztcbiAgfTtcblxuICBwcm8uZ2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzX1t0aGlzLndpZHRoXyAqIHkgKyB4XTtcbiAgfTtcblxuICBwcm8uc2V0ID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICB0aGlzLmJ5dGVzX1t0aGlzLndpZHRoXyAqIHkgKyB4XSA9IHZhbHVlO1xuICB9O1xuXG4gIHByby5jbGVhciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ5dGVzXy5sZW5ndGg7ICsraSlcbiAgICAgIHRoaXMuYnl0ZXNfW2ldID0gdmFsdWU7XG4gIH07XG5cbiAgcHJvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHRfOyArK3kpIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aF87ICsreCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0KHgsIHkpKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAwJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnIDEnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnICAnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH07XG5cbn0pO1xuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5lbmNvZGVyLk1hc2tVdGlsJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5CeXRlTWF0cml4Jyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBCeXRlTWF0cml4ID0gdzY5Yi5xci5lbmNvZGVyLkJ5dGVNYXRyaXg7XG5cbi8qKlxuICogQGF1dGhvciBTYXRvcnUgVGFrYWJheWFzaGlcbiAqIEBhdXRob3IgRGFuaWVsIFN3aXRraW5cbiAqIEBhdXRob3IgU2VhbiBPd2VuXG4gKiBAYXV0aG9yIG1iQDY5Yi5jb20gKE1hbnVlbCBCcmF1bikgcG9ydGVkIHRvIGpzXG4gKi9cbnZhciBfID0gdzY5Yi5xci5lbmNvZGVyLk1hc2tVdGlsO1xuXG4gIC8vIFBlbmFsdHkgd2VpZ2h0cyBmcm9tIHNlY3Rpb24gNi44LjIuMVxuICBfLk4xID0gMztcbiAgXy5OMiA9IDM7XG4gIF8uTjMgPSA0MDtcbiAgXy5ONCA9IDEwO1xuXG4gIC8qKlxuICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAxIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuXG4gICAqIEZpbmQgcmVwZXRpdGl2ZSBjZWxscyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZFxuICAgKiBnaXZlIHBlbmFsdHkgdG8gdGhlbS4gRXhhbXBsZTogMDAwMDAgb3IgMTExMTEuXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IHdvcmtpbmcgbWF0cml4LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJlc3VsdC5cbiAgICovXG4gIF8uYXBwbHlNYXNrUGVuYWx0eVJ1bGUxID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgcmV0dXJuIF8uYXBwbHlNYXNrUGVuYWx0eVJ1bGUxSW50ZXJuYWwobWF0cml4LCB0cnVlKSArXG4gICAgICBfLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAyIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuXG4gICAqIEZpbmQgMngyIGJsb2NrcyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZCBnaXZlXG4gICAqIHBlbmFsdHkgdG8gdGhlbS4gVGhpcyBpcyBhY3R1YWxseSBlcXVpdmFsZW50IHRvIHRoZSBzcGVjJ3MgcnVsZSxcbiAgICogd2hpY2ggaXMgdG8gZmluZCBNeE4gYmxvY2tzIGFuZCBnaXZlIGFcbiAgICogcGVuYWx0eSBwcm9wb3J0aW9uYWwgdG8gKE0tMSl4KE4tMSksIGJlY2F1c2UgdGhpcyBpcyB0aGUgbnVtYmVyIG9mXG4gICAqIDJ4MiBibG9ja3MgaW5zaWRlIHN1Y2ggYSBibG9jay5cbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSBtYXRyaXggd29ya2luZyBtYXRyaXguXG4gICAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LlxuICAgKi9cbiAgXy5hcHBseU1hc2tQZW5hbHR5UnVsZTIgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICB2YXIgcGVuYWx0eSA9IDA7XG4gICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aCAtIDE7IHgrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBtYXRyaXguZ2V0KHgsIHkpO1xuICAgICAgICBpZiAodmFsdWUgPT0gbWF0cml4LmdldCh4ICsgMSwgeSkgJiYgdmFsdWUgPT0gbWF0cml4LmdldCh4LCB5ICsgMSkgJiZcbiAgICAgICAgICB2YWx1ZSA9PSBtYXRyaXguZ2V0KHggKyAxLCB5ICsgMSkpIHtcbiAgICAgICAgICBwZW5hbHR5Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF8uTjIgKiBwZW5hbHR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmVcbiAgICogY2VsbHMgb2YgMDAwMDEwMTExMDEgb3JcbiAgICogMTAxMTEwMTAwMDAsIGFuZCBnaXZlIHBlbmFsdHkgdG8gdGhlbS5cbiAgICogSWYgd2UgZmluZCBwYXR0ZXJucyBsaWtlIDAwMDAxMDExMTAxMDAwMCwgd2UgZ2l2ZVxuICAgKiBwZW5hbHRpZXMgdHdpY2UgKGkuZS4gNDAgKiAyKS5cbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSBtYXRyaXggd29ya2luZyBtYXRyaXguXG4gICAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LlxuICAgKi9cbiAgXy5hcHBseU1hc2tQZW5hbHR5UnVsZTMgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICB2YXIgcGVuYWx0eSA9IDA7XG4gICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICB2YXIgYnl0ZXMgPSBtYXRyaXguZ2V0Qnl0ZXMoKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICB2YXIgeU9mZnNldCA9IHdpZHRoICogeTtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAvLyBUcmllZCB0byBzaW1wbGlmeSBmb2xsb3dpbmcgY29uZGl0aW9ucyBidXQgZmFpbGVkLlxuICAgICAgICBpZiAoeCArIDYgPCB3aWR0aCAmJlxuICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHhdID09IDEgJiZcbiAgICAgICAgICAgIGJ5dGVzW3lPZmZzZXQgKyB4ICsgMV0gPT0gMCAmJlxuICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggKyAyXSA9PSAxICYmXG4gICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDNdID09IDEgJiZcbiAgICAgICAgICAgIGJ5dGVzW3lPZmZzZXQgKyB4ICsgNF0gPT0gMSAmJlxuICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggKyA1XSA9PSAwICYmXG4gICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDZdID09IDEgJiZcbiAgICAgICAgICAgICgoeCArIDEwIDwgd2lkdGggJiZcbiAgICAgICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDddID09IDAgJiZcbiAgICAgICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDhdID09IDAgJiZcbiAgICAgICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDldID09IDAgJiZcbiAgICAgICAgICAgICAgICBieXRlc1t5T2Zmc2V0ICsgeCArIDEwXSA9PSAwKSB8fFxuICAgICAgICAgICAgICh4IC0gNCA+PSAwICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggLSAxXSA9PSAwICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggLSAyXSA9PSAwICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggLSAzXSA9PSAwICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbeU9mZnNldCArIHggLSA0XSA9PSAwKSkpIHtcbiAgICAgICAgICBwZW5hbHR5ICs9IF8uTjM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgKyA2IDwgaGVpZ2h0ICYmXG4gICAgICAgICAgICBtYXRyaXguZ2V0KHgsIHkpID09IDEgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDEpID09IDAgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDIpID09IDEgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDMpID09IDEgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDQpID09IDEgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDUpID09IDAgJiZcbiAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDYpID09IDEgJiZcbiAgICAgICAgICAgICgoeSArIDEwIDwgaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgbWF0cml4LmdldCh4LCB5ICsgNykgPT0gMCAmJlxuICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSArIDgpID09IDAgJiZcbiAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KHgsIHkgKyA5KSA9PSAwICYmXG4gICAgICAgICAgICAgICAgbWF0cml4LmdldCh4LCB5ICsgMTApID09IDApIHx8XG4gICAgICAgICAgICAgKHkgLSA0ID49IDAgJiZcbiAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KHgsIHkgLSAxKSA9PSAwICYmXG4gICAgICAgICAgICAgICAgbWF0cml4LmdldCh4LCB5IC0gMikgPT0gMCAmJlxuICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoeCwgeSAtIDMpID09IDAgJiZcbiAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KHgsIHkgLSA0KSA9PSAwKSkpIHtcbiAgICAgICAgICBwZW5hbHR5ICs9IF8uTjM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlbmFsdHk7XG4gIH07XG5cbiAgLyoqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDQgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gQ2FsY3VsYXRlIHRoZSByYXRpbyBvZlxuICAgKiBkYXJrIGNlbGxzIGFuZCBnaXZlIHBlbmFsdHkgaWYgdGhlIHJhdGlvIGlzIGZhciBmcm9tIDUwJS4gSXQgZ2l2ZXMgMTBcbiAgICogcGVuYWx0eSBmb3IgNSUgZGlzdGFuY2UuXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IHdvcmtpbmcgbWF0cml4LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJlc3VsdC5cbiAgICovXG4gIF8uYXBwbHlNYXNrUGVuYWx0eVJ1bGU0ID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgdmFyIG51bURhcmtDZWxscyA9IDA7XG4gICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgaWYgKG1hdHJpeC5nZXQoeCwgeSkgPT0gMSkge1xuICAgICAgICAgIG51bURhcmtDZWxscysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBudW1Ub3RhbENlbGxzID0gbWF0cml4LmdldEhlaWdodCgpICogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgdmFyIGRhcmtSYXRpbyA9IG51bURhcmtDZWxscyAvIG51bVRvdGFsQ2VsbHM7XG4gICAgLy8gKiAxMDAuMCAvIDUuMFxuICAgIHZhciBmaXZlUGVyY2VudFZhcmlhbmNlcyA9IE1hdGguZmxvb3IoTWF0aC5hYnMoZGFya1JhdGlvIC0gMC41KSAqIDIwLjApO1xuICAgIHJldHVybiBmaXZlUGVyY2VudFZhcmlhbmNlcyAqIF8uTjQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWFzayBiaXQgZm9yIFwiZ2V0TWFza1BhdHRlcm5cIiBhdCBcInhcIiBhbmQgXCJ5XCIuIFNlZSA4Ljggb2ZcbiAgICogSklTWDA1MTA6MjAwNCBmb3IgbWFza1xuICAgKiBwYXR0ZXJuIGNvbmRpdGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNrUGF0dGVybiBwYXR0ZXJuLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBwb3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHBvcy5cbiAgICovXG4gIF8uZ2V0RGF0YU1hc2tCaXQgPSBmdW5jdGlvbihtYXNrUGF0dGVybiwgeCwgeSkge1xuICAgIHZhciBpbnRlcm1lZGlhdGU7XG4gICAgdmFyIHRlbXA7XG4gICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpbnRlcm1lZGlhdGUgPSAoeSArIHgpICYgMHgxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaW50ZXJtZWRpYXRlID0geSAmIDB4MTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGludGVybWVkaWF0ZSA9IHggJSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAlIDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBpbnRlcm1lZGlhdGUgPSAoKHkgPj4+IDEpICsgKHggLyAzKSkgJiAweDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgIGludGVybWVkaWF0ZSA9ICh0ZW1wICYgMHgxKSArICh0ZW1wICUgMyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHRlbXAgPSB5ICogeDtcbiAgICAgICAgaW50ZXJtZWRpYXRlID0gKCh0ZW1wICUgMykgKyAoKHkgKyB4KSAmIDB4MSkpICYgMHgxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXNrIHBhdHRlcm46ICcgKyBtYXNrUGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBpbnRlcm1lZGlhdGUgPT0gMDtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBhcHBseU1hc2tQZW5hbHR5UnVsZTEuIFdlIG5lZWQgdGhpcyBmb3IgZG9pbmcgdGhpc1xuICAgKiBjYWxjdWxhdGlvbiBpbiBib3RoIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIG9yZGVycyByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IHdvcmtpbmcgbWF0cml4LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSG9yaXpvbnRhbCBob3Jpem9udGFsIHN3aXRjaC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBwZW5hbHR5LlxuICAgKi9cbiAgXy5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbCA9IGZ1bmN0aW9uKG1hdHJpeCwgaXNIb3Jpem9udGFsKSB7XG4gICAgdmFyIHBlbmFsdHkgPSAwO1xuICAgIHZhciBpTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0SGVpZ2h0KCkgOiBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICB2YXIgakxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldFdpZHRoKCkgOiBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGltaXQ7IGkrKykge1xuICAgICAgdmFyIG51bVNhbWVCaXRDZWxscyA9IDA7XG4gICAgICB2YXIgcHJldkJpdCA9IC0xO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqTGltaXQ7IGorKykge1xuICAgICAgICB2YXIgYml0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldChqLCBpKSA6IG1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgIGlmIChiaXQgPT0gcHJldkJpdCkge1xuICAgICAgICAgIG51bVNhbWVCaXRDZWxscysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudW1TYW1lQml0Q2VsbHMgPj0gNSkge1xuICAgICAgICAgICAgcGVuYWx0eSArPSBfLk4xICsgKG51bVNhbWVCaXRDZWxscyAtIDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1TYW1lQml0Q2VsbHMgPSAxOyAgLy8gSW5jbHVkZSB0aGUgY2VsbCBpdHNlbGYuXG4gICAgICAgICAgcHJldkJpdCA9IGJpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+IDUpIHtcbiAgICAgICAgcGVuYWx0eSArPSBfLk4xICsgKG51bVNhbWVCaXRDZWxscyAtIDUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGVuYWx0eTtcbiAgfTtcblxufSk7XG4iLCIvLyAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuZ29vZy5wcm92aWRlKCd3NjliLnFyLldyaXRlckVycm9yJyk7XG5nb29nLnJlcXVpcmUoJ2dvb2cuZGVidWcuRXJyb3InKTtcblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tc2cgbWVzc2FnZS5cbiAgICogQGV4dGVuZHMge2dvb2cuZGVidWcuRXJyb3J9XG4gICAqL1xuICB3NjliLnFyLldyaXRlckVycm9yID0gZnVuY3Rpb24ob3B0X21zZykge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBvcHRfbXNnKTtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyh3NjliLnFyLldyaXRlckVycm9yLCBnb29nLmRlYnVnLkVycm9yKTtcblxufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLmVuY29kZXIuUVJDb2RlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWwnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Nb2RlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuVmVyc2lvbicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLmVuY29kZXIuQnl0ZU1hdHJpeCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHc2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gIHZhciBNb2RlID0gdzY5Yi5xci5Nb2RlO1xuICB2YXIgVmVyc2lvbiA9IHc2OWIucXIuVmVyc2lvbjtcbiAgdmFyIEJ5dGVNYXRyaXggPSB3NjliLnFyLmVuY29kZXIuQnl0ZU1hdHJpeDtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pIC0gcG9ydGVkIHRvIGpzLlxuICAgKi9cbiAgdzY5Yi5xci5lbmNvZGVyLlFSQ29kZSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICB2YXIgXyA9IHc2OWIucXIuZW5jb2Rlci5RUkNvZGU7XG4gIHZhciBwcm8gPSBfLnByb3RvdHlwZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtNb2RlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvLm1vZGVfID0gbnVsbDtcbiAgLyoqXG4gICAqXG4gICAqIEB0eXBlIHtFcnJvckNvcnJlY3Rpb25MZXZlbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByby5lY0xldmVsXyA9IG51bGw7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7VmVyc2lvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByby52ZXJzaW9uXyA9IG51bGw7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvLm1hc2tQYXR0ZXJuXyA9IC0xO1xuICAvKipcbiAgICpcbiAgICogQHR5cGUge0J5dGVNYXRyaXh9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm8ubWF0cml4XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBfLk5VTV9NQVNLX1BBVFRFUk5TID0gODtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNb2RlfSBtb2RlLlxuICAgKi9cbiAgcHJvLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7RXJyb3JDb3JyZWN0aW9uTGV2ZWx9IGVjIGxldmVsLlxuICAgKi9cbiAgcHJvLmdldEVDTGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lY0xldmVsXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7VmVyc2lvbn0gdmVyc2lvbi5cbiAgICovXG4gIHByby5nZXRWZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gbWFzayBwYXR0ZXJuLlxuICAgKi9cbiAgcHJvLmdldE1hc2tQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWFza1BhdHRlcm5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCeXRlTWF0cml4fSBtYXRyaXguXG4gICAqL1xuICBwcm8uZ2V0TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4XztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGRlYnVnIHN0cmluZy5cbiAgICovXG4gIHByby50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQucHVzaCgnPDxcXG4nKTtcbiAgICByZXN1bHQucHVzaCgnIG1vZGU6ICcpO1xuICAgIHJlc3VsdC5wdXNoKHRoaXMubW9kZV8udG9TdHJpbmcoKSk7XG4gICAgcmVzdWx0LnB1c2goJ1xcbiBlY0xldmVsOiAnKTtcbiAgICByZXN1bHQucHVzaCh0aGlzLmVjTGV2ZWxfLnRvU3RyaW5nKCkpO1xuICAgIHJlc3VsdC5wdXNoKCdcXG4gdmVyc2lvbjogJyk7XG4gICAgcmVzdWx0LnB1c2godGhpcy52ZXJzaW9uXy50b1N0cmluZygpKTtcbiAgICByZXN1bHQucHVzaCgnXFxuIG1hc2tQYXR0ZXJuOiAnKTtcbiAgICByZXN1bHQucHVzaCh0aGlzLm1hc2tQYXR0ZXJuXyk7XG4gICAgaWYgKHRoaXMubWF0cml4XyA9PSBudWxsKSB7XG4gICAgICByZXN1bHQucHVzaCgnXFxuIG1hdHJpeDogbnVsbFxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCgnXFxuIG1hdHJpeDpcXG4nKTtcbiAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF0cml4Xy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goJz4+XFxuJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtNb2RlfSB2YWx1ZSBtb2RlLlxuICAgKi9cbiAgcHJvLnNldE1vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMubW9kZV8gPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvckNvcnJlY3Rpb25MZXZlbH0gdmFsdWUgZWMgbGV2ZWwuXG4gICAqL1xuICBwcm8uc2V0RUNMZXZlbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5lY0xldmVsXyA9IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZlcnNpb259IHZlcnNpb24gdmVyc2lvbi5cbiAgICovXG4gIHByby5zZXRWZXJzaW9uID0gZnVuY3Rpb24odmVyc2lvbikge1xuICAgIHRoaXMudmVyc2lvbl8gPSB2ZXJzaW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcGF0dGVybi5cbiAgICovXG4gIHByby5zZXRNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5tYXNrUGF0dGVybl8gPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSB2YWx1ZSBtYXRyaXguXG4gICAqL1xuICBwcm8uc2V0TWF0cml4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeF8gPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hc2tQYXR0ZXJuIHBhdHRlcm4uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdlYXRoZXIgaXQgaXMgdmFsaWQuXG4gICAqL1xuICBfLmlzVmFsaWRNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKG1hc2tQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIG1hc2tQYXR0ZXJuID49IDAgJiYgbWFza1BhdHRlcm4gPCBfLk5VTV9NQVNLX1BBVFRFUk5TO1xuICB9O1xuXG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuLypcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5lbmNvZGVyLk1hdHJpeFV0aWwnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5CaXRBcnJheScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkVycm9yQ29ycmVjdGlvbkxldmVsJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuVmVyc2lvbicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLldyaXRlckVycm9yJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5CeXRlTWF0cml4Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5NYXNrVXRpbCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLmVuY29kZXIuUVJDb2RlJyk7XG5cbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIHZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHc2OWIucXIuRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gIHZhciBCaXRBcnJheSA9IHc2OWIucXIuQml0QXJyYXk7XG4gIHZhciBCeXRlTWF0cml4ID0gdzY5Yi5xci5lbmNvZGVyLkJ5dGVNYXRyaXg7XG4gIHZhciBWZXJzaW9uID0gdzY5Yi5xci5WZXJzaW9uO1xuICB2YXIgV3JpdGVyRXJyb3IgPSB3NjliLnFyLldyaXRlckVycm9yO1xuICB2YXIgUVJDb2RlID0gdzY5Yi5xci5lbmNvZGVyLlFSQ29kZTtcbiAgdmFyIE1hc2tVdGlsID0gdzY5Yi5xci5lbmNvZGVyLk1hc2tVdGlsO1xuXG5cbiAgLyoqXG4gICAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pIC0gcG9ydGVkIHRvIGpzLlxuICAgKi9cbiAgdmFyIF8gPSB3NjliLnFyLmVuY29kZXIuTWF0cml4VXRpbDtcblxuICBfLlBPU0lUSU9OX0RFVEVDVElPTl9QQVRURVJOID0gW1xuICAgIFsxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBbMSwgMCwgMCwgMCwgMCwgMCwgMV0sXG4gICAgWzEsIDAsIDEsIDEsIDEsIDAsIDFdLFxuICAgIFsxLCAwLCAxLCAxLCAxLCAwLCAxXSxcbiAgICBbMSwgMCwgMSwgMSwgMSwgMCwgMV0sXG4gICAgWzEsIDAsIDAsIDAsIDAsIDAsIDFdLFxuICAgIFsxLCAxLCAxLCAxLCAxLCAxLCAxXVxuICBdO1xuXG4gIF8uUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOID0gW1xuICAgIFsxLCAxLCAxLCAxLCAxXSxcbiAgICBbMSwgMCwgMCwgMCwgMV0sXG4gICAgWzEsIDAsIDEsIDAsIDFdLFxuICAgIFsxLCAwLCAwLCAwLCAxXSxcbiAgICBbMSwgMSwgMSwgMSwgMV1cbiAgXTtcblxuICAvLyBGcm9tIEFwcGVuZGl4IEUuIFRhYmxlIDEsIEpJUzA1MTBYOjIwMDQgKHAgNzEpLiBUaGUgdGFibGUgd2FzXG4gIC8vIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXG4gIF8uUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOX0NPT1JESU5BVEVfVEFCTEUgPSBbXG4gICAgWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMVxuICAgIFs2LCAxOCwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMlxuICAgIFs2LCAyMiwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gM1xuICAgIFs2LCAyNiwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gNFxuICAgIFs2LCAzMCwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gNVxuICAgIFs2LCAzNCwgLTEsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gNlxuICAgIFs2LCAyMiwgMzgsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gN1xuICAgIFs2LCAyNCwgNDIsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gOFxuICAgIFs2LCAyNiwgNDYsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gOVxuICAgIFs2LCAyOCwgNTAsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMTBcbiAgICBbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDExXG4gICAgWzYsIDMyLCA1OCwgLTEsIC0xLCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAxMlxuICAgIFs2LCAzNCwgNjIsIC0xLCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMTNcbiAgICBbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDE0XG4gICAgWzYsIDI2LCA0OCwgNzAsIC0xLCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAxNVxuICAgIFs2LCAyNiwgNTAsIDc0LCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMTZcbiAgICBbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDE3XG4gICAgWzYsIDMwLCA1NiwgODIsIC0xLCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAxOFxuICAgIFs2LCAzMCwgNTgsIDg2LCAtMSwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMTlcbiAgICBbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDIwXG4gICAgWzYsIDI4LCA1MCwgNzIsIDk0LCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAyMVxuICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMjJcbiAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAyM1xuICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDI0XG4gICAgWzYsIDMyLCA1OCwgODQsIDExMCwgLTEsIC0xXSwgIC8vIFZlcnNpb24gMjVcbiAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdLCAgLy8gVmVyc2lvbiAyNlxuICAgIFs2LCAzNCwgNjIsIDkwLCAxMTgsIC0xLCAtMV0sICAvLyBWZXJzaW9uIDI3XG4gICAgWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjIsIC0xXSwgIC8vIFZlcnNpb24gMjhcbiAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSwgIC8vIFZlcnNpb24gMjlcbiAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzAsIC0xXSwgIC8vIFZlcnNpb24gMzBcbiAgICBbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzQsIC0xXSwgIC8vIFZlcnNpb24gMzFcbiAgICBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSwgIC8vIFZlcnNpb24gMzJcbiAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIC0xXSwgIC8vIFZlcnNpb24gMzNcbiAgICBbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYsIC0xXSwgIC8vIFZlcnNpb24gMzRcbiAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sICAvLyBWZXJzaW9uIDM1XG4gICAgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLCAgLy8gVmVyc2lvbiAzNlxuICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSwgIC8vIFZlcnNpb24gMzdcbiAgICBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sICAvLyBWZXJzaW9uIDM4XG4gICAgWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdLCAgLy8gVmVyc2lvbiAzOVxuICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSAgLy8gVmVyc2lvbiA0MFxuICBdO1xuXG4gIC8vIFR5cGUgaW5mbyBjZWxscyBhdCB0aGUgbGVmdCB0b3AgY29ybmVyLlxuICBfLlRZUEVfSU5GT19DT09SRElOQVRFUyA9IFtcbiAgICBbOCwgMF0sXG4gICAgWzgsIDFdLFxuICAgIFs4LCAyXSxcbiAgICBbOCwgM10sXG4gICAgWzgsIDRdLFxuICAgIFs4LCA1XSxcbiAgICBbOCwgN10sXG4gICAgWzgsIDhdLFxuICAgIFs3LCA4XSxcbiAgICBbNSwgOF0sXG4gICAgWzQsIDhdLFxuICAgIFszLCA4XSxcbiAgICBbMiwgOF0sXG4gICAgWzEsIDhdLFxuICAgIFswLCA4XVxuICBdO1xuXG4gIC8vIEZyb20gQXBwZW5kaXggRCBpbiBKSVNYMDUxMDoyMDA0IChwLiA2NylcbiAgXy5WRVJTSU9OX0lORk9fUE9MWSA9IDB4MWYyNTsgIC8vIDEgMTExMSAwMDEwIDAxMDFcblxuICAvLyBGcm9tIEFwcGVuZGl4IEMgaW4gSklTWDA1MTA6MjAwNCAocC42NSkuXG4gIF8uVFlQRV9JTkZPX1BPTFkgPSAweDUzNztcbiAgXy5UWVBFX0lORk9fTUFTS19QQVRURVJOID0gMHg1NDEyO1xuXG4gIC8vIFNldCBhbGwgY2VsbHMgdG8gLTEuICAtMSBtZWFucyB0aGF0IHRoZSBjZWxsIGlzIGVtcHR5IChub3Qgc2V0IHlldCkuXG4gIC8vXG4gIC8vIEpBVkFQT1JUOiBXZSBzaG91bGRuJ3QgbmVlZCB0byBkbyB0aGlzIGF0IGFsbC4gVGhlIGNvZGUgc2hvdWxkIGJlXG4gIC8vIHJld3JpdHRlbiB0byBiZWdpbiBlbmNvZGluZyB3aXRoIHRoZSBCeXRlTWF0cml4IGluaXRpYWxpemVkIGFsbCB0byB6ZXJvLlxuICAvKipcbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSBtYXRyaXggbWF0cml4LlxuICAgKi9cbiAgXy5jbGVhck1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIG1hdHJpeC5jbGVhcigtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkIDJEIG1hdHJpeCBvZiBRUiBDb2RlIGZyb20gXCJkYXRhQml0c1wiIHdpdGggXCJlY0xldmVsXCIsIFwidmVyc2lvblwiIGFuZFxuICAgKiBcImdldE1hc2tQYXR0ZXJuXCIuIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJtYXRyaXhcIiAuXG4gICAqIEBwYXJhbSB7Qml0QXJyYXl9IGRhdGFCaXRzIGJpdHMuXG4gICAqIEBwYXJhbSB7RXJyb3JDb3JyZWN0aW9uTGV2ZWx9IGVjTGV2ZWwgZXJyb3IgY29ycmVjdGlvbiBsZXZhbC5cbiAgICogQHBhcmFtIHtWZXJzaW9ufSB2ZXJzaW9uIHZlcnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNrUGF0dGVybiBtYXNrLlxuICAgKiBAcGFyYW0ge0J5dGVNYXRyaXh9IG1hdHJpeCByZXN1bHQgbWF0cml4LlxuICAgKi9cbiAgXy5idWlsZE1hdHJpeCA9IGZ1bmN0aW9uKGRhdGFCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KSB7XG4gICAgXy5jbGVhck1hdHJpeChtYXRyaXgpO1xuICAgIF8uZW1iZWRCYXNpY1BhdHRlcm5zKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgLy8gVHlwZSBpbmZvcm1hdGlvbiBhcHBlYXIgd2l0aCBhbnkgdmVyc2lvbi5cbiAgICBfLmVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgLy8gVmVyc2lvbiBpbmZvIGFwcGVhciBpZiB2ZXJzaW9uID49IDcuXG4gICAgXy5tYXliZUVtYmVkVmVyc2lvbkluZm8odmVyc2lvbiwgbWF0cml4KTtcbiAgICAvLyBEYXRhIHNob3VsZCBiZSBlbWJlZGRlZCBhdCBlbmQuXG4gICAgXy5lbWJlZERhdGFCaXRzKGRhdGFCaXRzLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogRW1iZWQgYmFzaWMgcGF0dGVybnMuIE9uIHN1Y2Nlc3MsIG1vZGlmeSB0aGUgbWF0cml4IGFuZCByZXR1cm4gdHJ1ZS5cbiAgICogVGhlIGJhc2ljIHBhdHRlcm5zIGFyZTpcbiAgICogLSBQb3NpdGlvbiBkZXRlY3Rpb24gcGF0dGVybnNcbiAgICogLSBUaW1pbmcgcGF0dGVybnNcbiAgICogLSBEYXJrIGRvdCBhdCB0aGUgbGVmdCBib3R0b20gY29ybmVyXG4gICAqIC0gUG9zaXRpb24gYWRqdXN0bWVudCBwYXR0ZXJucywgaWYgbmVlZGVkXG4gICAqIEBwYXJhbSB7VmVyc2lvbn0gdmVyc2lvbiB2ZXJzaW9uLlxuICAgKiBAcGFyYW0ge0J5dGVNYXRyaXh9IG1hdHJpeCByZXN1bHQuXG4gICAqL1xuICBfLmVtYmVkQmFzaWNQYXR0ZXJucyA9IGZ1bmN0aW9uKHZlcnNpb24sIG1hdHJpeCkge1xuICAgIC8vIExldCdzIGdldCBzdGFydGVkIHdpdGggZW1iZWRkaW5nIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgXy5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzKG1hdHJpeCk7XG4gICAgLy8gVGhlbiwgZW1iZWQgdGhlIGRhcmsgZG90IGF0IHRoZSBsZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgXy5lbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KTtcblxuICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cbiAgICBfLm1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpO1xuICAgIC8vIFRpbWluZyBwYXR0ZXJucyBzaG91bGQgYmUgZW1iZWRkZWQgYWZ0ZXIgcG9zaXRpb24gYWRqLiBwYXR0ZXJucy5cbiAgICBfLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcbiAgfTtcblxuICAvKipcbiAgICogRW1iZWQgdHlwZSBpbmZvcm1hdGlvbi4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSB7RXJyb3JDb3JyZWN0aW9uTGV2ZWx9IGVjTGV2ZWwgZXJyb3IgY29ycmVjaXRvbiBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hc2tQYXR0ZXJuIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IHJlc3VsdC5cbiAgICovXG4gIF8uZW1iZWRUeXBlSW5mbyA9IGZ1bmN0aW9uKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpIHtcbiAgICB2YXIgdHlwZUluZm9CaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgXy5tYWtlVHlwZUluZm9CaXRzKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuLCB0eXBlSW5mb0JpdHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlSW5mb0JpdHMuZ2V0U2l6ZSgpOyArK2kpIHtcbiAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIHRvIE1TQiBvcmRlci4gIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyB0aGVcbiAgICAgIC8vIGxhc3QgdmFsdWUgaW4gXCJ0eXBlSW5mb0JpdHNcIi5cbiAgICAgIHZhciBiaXQgPSB0eXBlSW5mb0JpdHMuZ2V0KHR5cGVJbmZvQml0cy5nZXRTaXplKCkgLSAxIC0gaSk7XG5cbiAgICAgIC8vIFR5cGUgaW5mbyBiaXRzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuIFNlZSA4Ljkgb2YgSklTWDA1MTA6MjAwNCAocC40NikuXG4gICAgICB2YXIgeDEgPSBfLlRZUEVfSU5GT19DT09SRElOQVRFU1tpXVswXTtcbiAgICAgIHZhciB5MSA9IF8uVFlQRV9JTkZPX0NPT1JESU5BVEVTW2ldWzFdO1xuICAgICAgbWF0cml4LnNldCh4MSwgeTEsIGJpdCk7XG5cbiAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICB2YXIgeDIgPSBtYXRyaXguZ2V0V2lkdGgoKSAtIGkgLSAxO1xuICAgICAgICB2YXIgeTIgPSA4O1xuICAgICAgICBtYXRyaXguc2V0KHgyLCB5MiwgYml0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgdmFyIHgyID0gODtcbiAgICAgICAgdmFyIHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XG4gICAgICAgIG1hdHJpeC5zZXQoeDIsIHkyLCBiaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBuZWVkIGJlLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeC5cbiAgICogU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NykgZm9yIGhvdyB0byBlbWJlZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge1ZlcnNpb259IHZlcnNpb24gdmVyc2lvbi5cbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSBtYXRyaXggcmVzdWx0LlxuICAgKi9cbiAgXy5tYXliZUVtYmVkVmVyc2lvbkluZm8gPSBmdW5jdGlvbih2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAvLyBWZXJzaW9uIGluZm8gaXMgbmVjZXNzYXJ5IGlmIHZlcnNpb24gPj0gNy5cbiAgICBpZiAodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPCA3KSB7XG4gICAgICByZXR1cm47ICAvLyBEb24ndCBuZWVkIHZlcnNpb24gaW5mby5cbiAgICB9XG4gICAgdmFyIHZlcnNpb25JbmZvQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgIF8ubWFrZVZlcnNpb25JbmZvQml0cyh2ZXJzaW9uLCB2ZXJzaW9uSW5mb0JpdHMpO1xuXG4gICAgdmFyIGJpdEluZGV4ID0gNiAqIDMgLSAxOyAgLy8gSXQgd2lsbCBkZWNyZWFzZSBmcm9tIDE3IHRvIDAuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgKytqKSB7XG4gICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIChsZWFzdCBzaWduaWZpY2FudCBiaXQpIHRvIE1TQiBvcmRlci5cbiAgICAgICAgdmFyIGJpdCA9IHZlcnNpb25JbmZvQml0cy5nZXQoYml0SW5kZXgpO1xuICAgICAgICBiaXRJbmRleC0tO1xuICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgIG1hdHJpeC5zZXQoaSwgbWF0cml4LmdldEhlaWdodCgpIC0gMTEgKyBqLCBiaXQpO1xuICAgICAgICAvLyBSaWdodCBib3R0b20gY29ybmVyLlxuICAgICAgICBtYXRyaXguc2V0KG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgaSwgYml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtYmVkIFwiZGF0YUJpdHNcIiB1c2luZyBcImdldE1hc2tQYXR0ZXJuXCIuIE9uIHN1Y2Nlc3MsIG1vZGlmeSB0aGUgbWF0cml4IGFuZFxuICAgKiByZXR1cm4gdHJ1ZS4gIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZlxuICAgKiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEuICBTZWUgOC43IG9mIEpJU1gwNTEwOjIwMDQgKHAuMzgpIGZvciBob3cgdG8gZW1iZWRcbiAgICogZGF0YSBiaXRzLlxuICAgKiBAcGFyYW0ge0JpdEFycmF5fSBkYXRhQml0cyBiaXRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWFza1BhdHRlcm4gbWFzay5cbiAgICogQHBhcmFtIHtCeXRlTWF0cml4fSBtYXRyaXggcmVzdWx0Li5cbiAgICovXG4gIF8uZW1iZWREYXRhQml0cyA9IGZ1bmN0aW9uKGRhdGFCaXRzLCBtYXNrUGF0dGVybiwgbWF0cml4KSB7XG4gICAgdmFyIGJpdEluZGV4ID0gMDtcbiAgICB2YXIgZGlyZWN0aW9uID0gLTE7XG4gICAgLy8gU3RhcnQgZnJvbSB0aGUgcmlnaHQgYm90dG9tIGNlbGwuXG4gICAgdmFyIHggPSBtYXRyaXguZ2V0V2lkdGgoKSAtIDE7XG4gICAgdmFyIHkgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxO1xuICAgIHdoaWxlICh4ID4gMCkge1xuICAgICAgLy8gU2tpcCB0aGUgdmVydGljYWwgdGltaW5nIHBhdHRlcm4uXG4gICAgICBpZiAoeCA9PSA2KSB7XG4gICAgICAgIHggLT0gMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh5ID49IDAgJiYgeSA8IG1hdHJpeC5nZXRIZWlnaHQoKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgIHZhciB4eCA9IHggLSBpO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGNlbGwgaWYgaXQncyBub3QgZW1wdHkuXG4gICAgICAgICAgaWYgKCFfLmlzRW1wdHkobWF0cml4LmdldCh4eCwgeSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJpdDtcbiAgICAgICAgICBpZiAoYml0SW5kZXggPCBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgIGJpdCA9IGRhdGFCaXRzLmdldChiaXRJbmRleCk7XG4gICAgICAgICAgICArK2JpdEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYWRkaW5nIGJpdC4gSWYgdGhlcmUgaXMgbm8gYml0IGxlZnQsIHdlJ2xsIGZpbGwgdGhlIGxlZnQgY2VsbHNcbiAgICAgICAgICAgIC8vIHdpdGggMCwgYXMgZGVzY3JpYmVkIGluIDguNC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuIDI0KS5cbiAgICAgICAgICAgIGJpdCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNraXAgbWFza2luZyBpZiBtYXNrX3BhdHRlcm4gaXMgLTEuXG4gICAgICAgICAgaWYgKG1hc2tQYXR0ZXJuICE9IC0xICYmIE1hc2tVdGlsLmdldERhdGFNYXNrQml0KG1hc2tQYXR0ZXJuLCB4eCxcbiAgICAgICAgICAgIHkpKSB7XG4gICAgICAgICAgICBiaXQgPSAhYml0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRyaXguc2V0KHh4LCB5LCBiaXQpO1xuICAgICAgICB9XG4gICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgZGlyZWN0aW9uID0gLWRpcmVjdGlvbjsgIC8vIFJldmVyc2UgdGhlIGRpcmVjdGlvbi5cbiAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgeCAtPSAyOyAgLy8gTW92ZSB0byB0aGUgbGVmdC5cbiAgICB9XG4gICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxuICAgIGlmIChiaXRJbmRleCAhPSBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignTm90IGFsbCBiaXRzIGNvbnN1bWVkOiAnICtcbiAgICAgICAgYml0SW5kZXggKyAnLycgKyBkYXRhQml0cy5nZXRTaXplKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0ICh0byBvbmUpIGluIHRoZVxuICAgKiBcInZhbHVlXCIuIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyBwb3NpdGlvbiAzMi4gSWYgdGhlcmUgaXMgbm8gYml0IHNldCxcbiAgICogcmV0dXJuIDAuIEV4YW1wbGVzOlxuICAgKiAtIGZpbmRNU0JTZXQoMCkgPT4gMFxuICAgKiAtIGZpbmRNU0JTZXQoMSkgPT4gMVxuICAgKiAtIGZpbmRNU0JTZXQoMjU1KSA9PiA4XG4gICAqL1xuICBfLmZpbmRNU0JTZXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBudW1EaWdpdHMgPSAwO1xuICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICB2YWx1ZSA+Pj49IDE7XG4gICAgICArK251bURpZ2l0cztcbiAgICB9XG4gICAgcmV0dXJuIG51bURpZ2l0cztcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQ2FsY3VsYXRlIEJDSCAoQm9zZS1DaGF1ZGh1cmktSG9jcXVlbmdoZW0pIGNvZGUgZm9yIFwidmFsdWVcIiB1c2luZ1xuICAgKiBwb2x5bm9taWFsIFwicG9seVwiLiBUaGUgQkNIXG4gICAqIGNvZGUgaXMgdXNlZCBmb3IgZW5jb2RpbmcgdHlwZSBpbmZvcm1hdGlvbiBhbmQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICogRXhhbXBsZTogQ2FsY3VsYXRpb24gb2YgdmVyc2lvbiBpbmZvcm1hdGlvbiBvZiA3LlxuICAgKiBmKHgpIGlzIGNyZWF0ZWQgZnJvbSA3LlxuICAgKiAgIC0gNyA9IDAwMDExMSBpbiA2IGJpdHNcbiAgICogICAtIGYoeCkgPSB4XjIgKyB4XjEgKyB4XjBcbiAgICogZyh4KSBpcyBnaXZlbiBieSB0aGUgc3RhbmRhcmQgKHAuIDY3KVxuICAgKiAgIC0gZyh4KSA9IHheMTIgKyB4XjExICsgeF4xMCArIHheOSArIHheOCArIHheNSArIHheMiArIDFcbiAgICogTXVsdGlwbHkgZih4KSBieSB4XigxOCAtIDYpXG4gICAqICAgLSBmJyh4KSA9IGYoeCkgKiB4XigxOCAtIDYpXG4gICAqICAgLSBmJyh4KSA9IHheMTQgKyB4XjEzICsgeF4xMlxuICAgKiBDYWxjdWxhdGUgdGhlIHJlbWFpbmRlciBvZiBmJyh4KSAvIGcoeClcbiAgICogICAgICAgICB4XjJcbiAgICogICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICAgKiAgIGcoeCkgKXheMTQgKyB4XjEzICsgeF4xMlxuICAgKiAgICAgICAgIHheMTQgKyB4XjEzICsgeF4xMiArIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAqICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XjExICsgeF4xMCArIHheNyArIHheNCArIHheMlxuICAgKlxuICAgKiBUaGUgcmVtYWluZGVyIGlzIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAqIEVuY29kZSBpdCBpbiBiaW5hcnk6IDExMDAxMDAxMDEwMFxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIDB4Yzk0ICgxMTAwIDEwMDEgMDEwMClcbiAgICpcbiAgICogU2luY2UgYWxsIGNvZWZmaWNpZW50cyBpbiB0aGUgcG9seW5vbWlhbHMgYXJlIDEgb3IgMCwgd2UgY2FuIGRvIHRoZVxuICAgKiBjYWxjdWxhdGlvbiBieSBiaXRcbiAgICogb3BlcmF0aW9ucy4gV2UgZG9uJ3QgY2FyZSBpZiBjb2ZmaWNpZW50cyBhcmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBzZWUgYWJvdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb2x5IHNlZSBhYm92ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBzZWUgYWJvdmUuXG4gICAqL1xuICBfLmNhbGN1bGF0ZUJDSENvZGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9seSkge1xuICAgIC8vIElmIHBvbHkgaXMgXCIxIDExMTEgMDAxMCAwMTAxXCIgKHZlcnNpb24gaW5mbyBwb2x5KSwgbXNiU2V0SW5Qb2x5IGlzIDEzLlxuICAgIC8vIFdlJ2xsIHN1YnRyYWN0IDEgZnJvbSAxMyB0byBtYWtlIGl0IDEyLlxuICAgIHZhciBtc2JTZXRJblBvbHkgPSBfLmZpbmRNU0JTZXQocG9seSk7XG4gICAgdmFsdWUgPDw9IG1zYlNldEluUG9seSAtIDE7XG4gICAgLy8gRG8gdGhlIGRpdmlzaW9uIGJ1c2luZXNzIHVzaW5nIGV4Y2x1c2l2ZS1vciBvcGVyYXRpb25zLlxuICAgIHdoaWxlIChfLmZpbmRNU0JTZXQodmFsdWUpID49IG1zYlNldEluUG9seSkge1xuICAgICAgdmFsdWUgXj0gcG9seSA8PCAoXy5maW5kTVNCU2V0KHZhbHVlKSAtIG1zYlNldEluUG9seSk7XG4gICAgfVxuICAgIC8vIE5vdyB0aGUgXCJ2YWx1ZVwiIGlzIHRoZSByZW1haW5kZXIgKGkuZS4gdGhlIEJDSCBjb2RlKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBiaXQgdmVjdG9yIG9mIHR5cGUgaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAgICogXCJiaXRzXCIgYW5kIHJldHVybiB0cnVlLiAgRW5jb2RlIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgYW5kIG1hc2sgcGF0dGVybi5cbiAgICogU2VlIDguOSBvZiBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtFcnJvckNvcnJlY3Rpb25MZXZlbH0gZWNMZXZlbCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWFza1BhdHRlcm4gcGF0dGVybi5cbiAgICogQHBhcmFtIHtCaXRBcnJheX0gYml0cyByZXN1bHQgYXJyYXkuXG4gICAqL1xuICBfLm1ha2VUeXBlSW5mb0JpdHMgPSBmdW5jdGlvbihlY0xldmVsLCBtYXNrUGF0dGVybiwgYml0cykge1xuICAgIGlmICghUVJDb2RlLmlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignSW52YWxpZCBtYXNrIHBhdHRlcm4nKTtcbiAgICB9XG4gICAgdmFyIHR5cGVJbmZvID0gKGVjTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgbWFza1BhdHRlcm47XG4gICAgYml0cy5hcHBlbmRCaXRzKHR5cGVJbmZvLCA1KTtcblxuICAgIHZhciBiY2hDb2RlID0gXy5jYWxjdWxhdGVCQ0hDb2RlKHR5cGVJbmZvLCBfLlRZUEVfSU5GT19QT0xZKTtcbiAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTApO1xuXG4gICAgdmFyIG1hc2tCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgbWFza0JpdHMuYXBwZW5kQml0cyhfLlRZUEVfSU5GT19NQVNLX1BBVFRFUk4sIDE1KTtcbiAgICBiaXRzLnhvcihtYXNrQml0cyk7XG5cbiAgICBpZiAoYml0cy5nZXRTaXplKCkgIT0gMTUpIHsgIC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignc2hvdWxkIG5vdCBoYXBwZW4gYnV0IHdlIGdvdDogJyArXG4gICAgICAgIGJpdHMuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYml0IHZlY3RvciBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAqIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS4gIFNlZSA4LjEwIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge1ZlcnNpb259IHZlcnNpb24gdmVyc2lvbi5cbiAgICogQHBhcmFtIHtCaXRBcnJheX0gYml0cyByZXN1bHQgYXJyYXkuXG4gICAqL1xuICBfLm1ha2VWZXJzaW9uSW5mb0JpdHMgPSBmdW5jdGlvbih2ZXJzaW9uLCBiaXRzKSB7XG4gICAgYml0cy5hcHBlbmRCaXRzKHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpLCA2KTtcbiAgICB2YXIgYmNoQ29kZSA9IF8uY2FsY3VsYXRlQkNIQ29kZSh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSxcbiAgICAgIF8uVkVSU0lPTl9JTkZPX1BPTFkpO1xuICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMik7XG5cbiAgICBpZiAoYml0cy5nZXRTaXplKCkgIT0gMTgpIHsgIC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignc2hvdWxkIG5vdCBoYXBwZW4gYnV0IHdlIGdvdDogJyArXG4gICAgICAgIGJpdHMuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIHZhbHVlIGlzIGVtcHR5LlxuICAgKi9cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IG1hdHJpeCB0byBhZGQgdGltaW5nIHBhdHRlcm5zIHRvLlxuICAgKi9cbiAgXy5lbWJlZFRpbWluZ1BhdHRlcm5zID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgLy8gLTggaXMgZm9yIHNraXBwaW5nIHBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJucyAoc2l6ZSA3KSwgYW5kIHR3b1xuICAgIC8vIGhvcml6b250YWwvdmVydGljYWwgc2VwYXJhdGlvbiBwYXR0ZXJucyAoc2l6ZSAxKS4gVGh1cywgOCA9IDcgKyAxLlxuICAgIGZvciAodmFyIGkgPSA4OyBpIDwgbWF0cml4LmdldFdpZHRoKCkgLSA4OyArK2kpIHtcbiAgICAgIHZhciBiaXQgPSAoaSArIDEpICUgMjtcbiAgICAgIC8vIEhvcml6b250YWwgbGluZS5cbiAgICAgIGlmIChfLmlzRW1wdHkobWF0cml4LmdldChpLCA2KSkpIHtcbiAgICAgICAgbWF0cml4LnNldChpLCA2LCBiaXQpO1xuICAgICAgfVxuICAgICAgLy8gVmVydGljYWwgbGluZS5cbiAgICAgIGlmIChfLmlzRW1wdHkobWF0cml4LmdldCg2LCBpKSkpIHtcbiAgICAgICAgbWF0cml4LnNldCg2LCBpLCBiaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW1iZWQgdGhlIGxvbmVseSBkYXJrIGRvdCBhdCBsZWZ0IGJvdHRvbSBjb3JuZXIuIEpJU1gwNTEwOjIwMDQgKHAuNDYpXG4gICAqIEBwYXJhbSB7Qnl0ZU1hdHJpeH0gbWF0cml4IHRoZSBtYXRyaXguXG4gICAqL1xuICBfLmVtYmVkRGFya0RvdEF0TGVmdEJvdHRvbUNvcm5lciA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIGlmIChtYXRyaXguZ2V0KDgsIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDgpID09IDApIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcigpO1xuICAgIH1cbiAgICBtYXRyaXguc2V0KDgsIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDgsIDEpO1xuICB9O1xuXG4gIF8uZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4gPSBmdW5jdGlvbih4U3RhcnQsIHlTdGFydCwgbWF0cml4KSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCA4OyArK3gpIHtcbiAgICAgIGlmICghXy5pc0VtcHR5KG1hdHJpeC5nZXQoeFN0YXJ0ICsgeCwgeVN0YXJ0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCk7XG4gICAgICB9XG4gICAgICBtYXRyaXguc2V0KHhTdGFydCArIHgsIHlTdGFydCwgMCk7XG4gICAgfVxuICB9O1xuXG4gIF8uZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuID0gZnVuY3Rpb24oeFN0YXJ0LCB5U3RhcnQsIG1hdHJpeCkge1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNzsgKyt5KSB7XG4gICAgICBpZiAoIV8uaXNFbXB0eShtYXRyaXguZ2V0KHhTdGFydCwgeVN0YXJ0ICsgeSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcigpO1xuICAgICAgfVxuICAgICAgbWF0cml4LnNldCh4U3RhcnQsIHlTdGFydCArIHksIDApO1xuICAgIH1cbiAgfTtcblxuICBfLmVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybiA9IGZ1bmN0aW9uKHhTdGFydCwgeVN0YXJ0LCBtYXRyaXgpIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyArK3gpIHtcbiAgICAgICAgbWF0cml4LnNldCh4U3RhcnQgKyB4LCB5U3RhcnQgKyB5LFxuICAgICAgICAgIF8uUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOW3ldW3hdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXy5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybiA9IGZ1bmN0aW9uKHhTdGFydCwgeVN0YXJ0LCBtYXRyaXgpIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDc7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA3OyArK3gpIHtcbiAgICAgICAgbWF0cml4LnNldCh4U3RhcnQgKyB4LCB5U3RhcnQgKyB5LCBfLlBPU0lUSU9OX0RFVEVDVElPTl9QQVRURVJOW3ldW3hdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtYmVkIHBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJucyBhbmQgc3Vycm91bmRpbmcgdmVydGljYWwvaG9yaXpvbnRhbFxuICAgKiBzZXBhcmF0b3JzLlxuICAgKiBAcGFyYW0ge0J5dGVNYXRyaXh9IG1hdHJpeCB3b3JraW5nIG1hdHJpeC5cbiAgICovXG4gIF8uZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm5zQW5kU2VwYXJhdG9ycyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIC8vIEVtYmVkIHRocmVlIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgdmFyIHBkcFdpZHRoID0gXy5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlswXS5sZW5ndGg7XG4gICAgLy8gTGVmdCB0b3AgY29ybmVyLlxuICAgIF8uZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4oMCwgMCwgbWF0cml4KTtcbiAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgIF8uZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBwZHBXaWR0aCwgMCwgbWF0cml4KTtcbiAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgXy5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCBtYXRyaXgpO1xuXG4gICAgLy8gRW1iZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICB2YXIgaHNwV2lkdGggPSA4O1xuICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICBfLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKDAsIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcbiAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgIF8uZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBoc3BXaWR0aCxcbiAgICAgIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcbiAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgXy5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLFxuICAgICAgbWF0cml4KTtcblxuICAgIC8vIEVtYmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gcGF0dGVybnMgYXJvdW5kIHRoZSBzcXVhcmVzLlxuICAgIHZhciB2c3BTaXplID0gNztcbiAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgXy5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4odnNwU2l6ZSwgMCwgbWF0cml4KTtcbiAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgIF8uZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIHZzcFNpemUgLSAxLCAwLFxuICAgICAgbWF0cml4KTtcbiAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgXy5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4odnNwU2l6ZSwgbWF0cml4LmdldEhlaWdodCgpIC0gdnNwU2l6ZSxcbiAgICAgIG1hdHJpeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtYmVkIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgaWYgbmVlZGVkLlxuICAgKi9cbiAgXy5tYXliZUVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybnMgPSBmdW5jdGlvbih2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAvLyBUaGUgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMlxuICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gdmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgLSAxO1xuICAgIHZhciBjb29yZGluYXRlcyA9IF8uUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOX0NPT1JESU5BVEVfVEFCTEVbaW5kZXhdO1xuICAgIHZhciBudW1Db29yZGluYXRlcyA9XG4gICAgICBfLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTl9DT09SRElOQVRFX1RBQkxFW2luZGV4XS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db29yZGluYXRlczsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNvb3JkaW5hdGVzOyArK2opIHtcbiAgICAgICAgdmFyIHkgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1tqXTtcbiAgICAgICAgaWYgKHggPT0gLTEgfHwgeSA9PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjZWxsIGlzIHVuc2V0LCB3ZSBlbWJlZCB0aGUgcG9zaXRpb24gYWRqdXN0bWVudCBwYXR0ZXJuIGhlcmUuXG4gICAgICAgIGlmIChfLmlzRW1wdHkobWF0cml4LmdldCh4LCB5KSkpIHtcbiAgICAgICAgICAvLyAtMiBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHgveSBjb29yZGluYXRlcyBwb2ludCB0byB0aGUgY2VudGVyIG9mXG4gICAgICAgICAgLy8gdGhlIHBhdHRlcm4sIG5vdCB0aGVcbiAgICAgICAgICAvLyBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgXy5lbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeCAtIDIsIHkgLSAyLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuZW5jb2Rlci5FbmNvZGVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQml0QXJyYXknKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5DaGFyYWN0ZXJTZXRFQ0knKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5FbmNvZGVIaW50VHlwZScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkVycm9yQ29ycmVjdGlvbkxldmVsJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR0YyNTYnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Nb2RlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuTW9kZUVudW0nKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5SZWVkU29sb21vbkVuY29kZXInKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5WZXJzaW9uJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5CbG9ja1BhaXInKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5lbmNvZGVyLk1hc2tVdGlsJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5NYXRyaXhVdGlsJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZW5jb2Rlci5RUkNvZGUnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5zdHJpbmd1dGlscycpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSB3NjliLnFyLkVycm9yQ29ycmVjdGlvbkxldmVsO1xuICB2YXIgQml0QXJyYXkgPSB3NjliLnFyLkJpdEFycmF5O1xuICB2YXIgQnl0ZU1hdHJpeCA9IHc2OWIucXIuZW5jb2Rlci5CeXRlTWF0cml4O1xuICB2YXIgTWF0cml4VXRpbCA9IHc2OWIucXIuZW5jb2Rlci5NYXRyaXhVdGlsO1xuICB2YXIgVmVyc2lvbiA9IHc2OWIucXIuVmVyc2lvbjtcbiAgdmFyIFdyaXRlckVycm9yID0gdzY5Yi5xci5Xcml0ZXJFcnJvcjtcbiAgdmFyIEJsb2NrUGFpciA9IHc2OWIucXIuZW5jb2Rlci5CbG9ja1BhaXI7XG4gIHZhciBRUkNvZGUgPSB3NjliLnFyLmVuY29kZXIuUVJDb2RlO1xuICB2YXIgTWFza1V0aWwgPSB3NjliLnFyLmVuY29kZXIuTWFza1V0aWw7XG4gIHZhciBNb2RlID0gdzY5Yi5xci5Nb2RlO1xuICB2YXIgTW9kZUVudW0gPSB3NjliLnFyLk1vZGVFbnVtO1xuICB2YXIgRW5jb2RlSGludFR5cGUgPSB3NjliLnFyLkVuY29kZUhpbnRUeXBlO1xuICB2YXIgQ2hhcmFjdGVyU2V0RUNJID0gdzY5Yi5xci5DaGFyYWN0ZXJTZXRFQ0k7XG4gIHZhciBSZWVkU29sb21vbkVuY29kZXIgPSB3NjliLnFyLlJlZWRTb2xvbW9uRW5jb2RlcjtcbiAgdmFyIHN0cmluZ3V0aWxzID0gdzY5Yi5xci5zdHJpbmd1dGlscztcblxuXG4gIC8qKlxuICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDK1xuICAgKiBAYXV0aG9yIG1iQHc2OWIuY29tIChNYW51ZWwgQnJhdW4pIC0gcG9ydGVkIHRvIGpzXG4gICAqL1xuICB2YXIgXyA9IHc2OWIucXIuZW5jb2Rlci5FbmNvZGVyO1xuXG4gIC8vIFRoZSBvcmlnaW5hbCB0YWJsZSBpcyBkZWZpbmVkIGluIHRoZSB0YWJsZSA1IG9mIEpJU1gwNTEwOjIwMDQgKHAuMTkpLlxuICBfLkFMUEhBTlVNRVJJQ19UQUJMRSA9IFtcbiAgICAvLyAweDAwLTB4MGZcbiAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAvLyAweDEwLTB4MWZcbiAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAvLyAweDIwLTB4MmZcbiAgICAzNiwgLTEsIC0xLCAtMSwgMzcsIDM4LCAtMSwgLTEsIC0xLCAtMSwgMzksIDQwLCAtMSwgNDEsIDQyLCA0MyxcbiAgICAvLyAweDMwLTB4M2ZcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCA0NCwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC8vIDB4NDAtMHg0ZlxuICAgIC0xLCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LFxuICAgIC8vIDB4NTAtMHg1ZlxuICAgIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgLTEsIC0xLCAtMSwgLTEsIC0xXG4gIF07XG5cbiAgXy5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORyA9ICdVVEYtOCc7XG5cbiAgLyoqIFRoZSBtYXNrIHBlbmFsdHkgY2FsY3VsYXRpb24gaXMgY29tcGxpY2F0ZWQuICBTZWUgVGFibGUgMjEgb2ZcbiAgICogSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuICBCYXNpY2FsbHkgaXQgYXBwbGllcyBmb3VyIHJ1bGVzIGFuZFxuICAgKiBzdW1tYXRlIGFsbCBwZW5hbHRpZXMuXG4gICAqL1xuICBfLmNhbGN1bGF0ZU1hc2tQZW5hbHR5ID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMShtYXRyaXgpICtcbiAgICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpICtcbiAgICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMyhtYXRyaXgpICtcbiAgICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlNChtYXRyaXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAgRW5jb2RlIFwiYnl0ZXNcIiB3aXRoIHRoZSBlcnJvciBjb3JyZWN0aW9uIGxldmVsIFwiZWNMZXZlbFwiLiBUaGUgZW5jb2RpbmdcbiAgICogIG1vZGUgd2lsbCBiZSBjaG9zZW4gaW50ZXJuYWxseSBieSBjaG9vc2VNb2RlKCkuIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZVxuICAgKiAgcmVzdWx0IGluIFwicXJDb2RlXCIuXG4gICAqXG4gICAqIFdlIHJlY29tbWVuZCB5b3UgdG8gdXNlIFFSQ29kZS5FQ19MRVZFTF9MICh0aGUgbG93ZXN0IGxldmVsKSBmb3JcbiAgICogXCJnZXRFQ0xldmVsXCIgc2luY2Ugb3VyIHByaW1hcnkgdXNlIGlzIHRvIHNob3cgUVIgY29kZSBvbiBkZXNrdG9wIHNjcmVlbnMuXG4gICAqIFdlIGRvbid0IG5lZWQgdmVyeSBzdHJvbmcgZXJyb3IgY29ycmVjdGlvbiBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gd2F5IHRvIGVuY29kZSBieXRlcyBpbiBNT0RFX0tBTkpJLiBXZSBtaWdodCB3YW50IHRvXG4gICAqIGFkZCBFbmNvZGVXaXRoTW9kZSgpIHdpdGggd2hpY2ggY2xpZW50cyBjYW4gc3BlY2lmeSB0aGUgZW5jb2RpbmcgbW9kZS4gRm9yXG4gICAqIG5vdywgd2UgZG9uJ3QgbmVlZCB0aGUgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Vycm9yQ29ycmVjdGlvbkxldmVsfSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2hpbnRzIGVuY29kaW5nIGhpbnRzLlxuICAgKlxuICAgKi9cblxuICBfLmVuY29kZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIGVjTGV2ZWwsIG9wdF9oaW50cykge1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIGhhcyBiZWVuIHNwZWNpZmllZCBieSB0aGUgY2FsbGVyLCBpZlxuICAgIC8vIGFueVxuICAgIHZhciBlbmNvZGluZyA9IG9wdF9oaW50cyA/IG9wdF9oaW50c1tFbmNvZGVIaW50VHlwZS5DSEFSQUNURVJfU0VUXSA6IG51bGw7XG4gICAgdmFyIGZvcmNlRUNJID0gb3B0X2hpbnRzID8gb3B0X2hpbnRzW0VuY29kZUhpbnRUeXBlLkZPUkNFX0FERF9FQ0ldIDogZmFsc2U7XG4gICAgaWYgKGVuY29kaW5nID09IG51bGwpIHtcbiAgICAgIGVuY29kaW5nID0gXy5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORztcbiAgICB9XG5cbiAgICAvLyBQaWNrIGFuIGVuY29kaW5nIG1vZGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgdGhpcyB3aWxsXG4gICAgLy8gbm90IGF0dGVtcHQgdG8gdXNlIG11bHRpcGxlIG1vZGVzIC8gc2VnbWVudHMgZXZlbiBpZiB0aGF0IHdlcmUgbW9yZVxuICAgIC8vIGVmZmljaWVudC4gVHdvdWxkIGJlIG5pY2UuXG4gICAgdmFyIG1vZGUgPSBfLmNob29zZU1vZGUoY29udGVudCwgZW5jb2RpbmcpO1xuXG4gICAgLy8gVGhpcyB3aWxsIHN0b3JlIHRoZSBoZWFkZXIgaW5mb3JtYXRpb24sIGxpa2UgbW9kZSBhbmRcbiAgICAvLyBsZW5ndGgsIGFzIHdlbGwgYXMgXCJoZWFkZXJcIiBzZWdtZW50cyBsaWtlIGFuIEVDSSBzZWdtZW50LlxuICAgIHZhciBoZWFkZXJCaXRzID0gbmV3IEJpdEFycmF5KCk7XG5cbiAgICAvLyBBcHBlbmQgRUNJIHNlZ21lbnQgaWYgYXBwbGljYWJsZVxuICAgIC8vIERpc2FibGVkIGluIGNvbXBhdCBtb2RlIGFzIHNvbWUgc2Nhbm5lcnMgc2VlbSB0byBoYXZlIHByb2JsZW1zIHdpdGggaXQuXG4gICAgaWYgKGZvcmNlRUNJIHx8XG4gICAgICAobW9kZSA9PSBNb2RlRW51bS5CWVRFICYmIF8uREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgIT0gZW5jb2RpbmcpKSB7XG4gICAgICB2YXIgZWNpID0gQ2hhcmFjdGVyU2V0RUNJLmdldFZhbHVlKGVuY29kaW5nKTtcbiAgICAgIGlmIChlY2kpIHtcbiAgICAgICAgXy5hcHBlbmRFQ0koZWNpLCBoZWFkZXJCaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAoV2l0aCBFQ0kgaW4gcGxhY2UsKSBXcml0ZSB0aGUgbW9kZSBtYXJrZXJcbiAgICBfLmFwcGVuZE1vZGVJbmZvKG1vZGUsIGhlYWRlckJpdHMpO1xuXG4gICAgLy8gQ29sbGVjdCBkYXRhIHdpdGhpbiB0aGUgbWFpbiBzZWdtZW50LCBzZXBhcmF0ZWx5LCB0byBjb3VudCBpdHMgc2l6ZSBpZlxuICAgIC8vIG5lZWRlZC4gRG9uJ3QgYWRkIGl0IHRvIG1haW4gcGF5bG9hZCB5ZXQuXG4gICAgdmFyIGRhdGFCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgXy5hcHBlbmRCeXRlcyhjb250ZW50LCBtb2RlLCBkYXRhQml0cywgZW5jb2RpbmcpO1xuXG4gICAgLy8gSGFyZCBwYXJ0OiBuZWVkIHRvIGtub3cgdmVyc2lvbiB0byBrbm93IGhvdyBtYW55IGJpdHMgbGVuZ3RoIHRha2VzLiBCdXRcbiAgICAvLyBuZWVkIHRvIGtub3cgaG93IG1hbnkgYml0cyBpdCB0YWtlcyB0byBrbm93IHZlcnNpb24uIEZpcnN0IHdlIHRha2UgYVxuICAgIC8vIGd1ZXNzIGF0IHZlcnNpb24gYnkgYXNzdW1pbmcgdmVyc2lvbiB3aWxsIGJlIHRoZSBtaW5pbXVtLCAxOlxuXG4gICAgdmFyIHByb3Zpc2lvbmFsQml0c05lZWRlZCA9IGhlYWRlckJpdHMuZ2V0U2l6ZSgpICtcbiAgICAgIG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlcigxKSkgK1xuICAgICAgZGF0YUJpdHMuZ2V0U2l6ZSgpO1xuICAgIHZhciBwcm92aXNpb25hbFZlcnNpb24gPSBfLmNob29zZVZlcnNpb24ocHJvdmlzaW9uYWxCaXRzTmVlZGVkLCBlY0xldmVsKTtcblxuICAgIC8vIFVzZSB0aGF0IGd1ZXNzIHRvIGNhbGN1bGF0ZSB0aGUgcmlnaHQgdmVyc2lvbi4gSSBhbSBzdGlsbCBub3Qgc3VyZSB0aGlzXG4gICAgLy8gd29ya3MgaW4gMTAwJSBvZiBjYXNlcy5cblxuICAgIHZhciBiaXRzTmVlZGVkID0gaGVhZGVyQml0cy5nZXRTaXplKCkgK1xuICAgICAgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHMocHJvdmlzaW9uYWxWZXJzaW9uKSArXG4gICAgICBkYXRhQml0cy5nZXRTaXplKCk7XG4gICAgdmFyIHZlcnNpb24gPSBfLmNob29zZVZlcnNpb24oYml0c05lZWRlZCwgZWNMZXZlbCk7XG5cbiAgICB2YXIgaGVhZGVyQW5kRGF0YUJpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICBoZWFkZXJBbmREYXRhQml0cy5hcHBlbmRCaXRBcnJheShoZWFkZXJCaXRzKTtcbiAgICAvLyBGaW5kIFwibGVuZ3RoXCIgb2YgbWFpbiBzZWdtZW50IGFuZCB3cml0ZSBpdFxuICAgIHZhciBudW1MZXR0ZXJzID1cbiAgICAgIChtb2RlID09IE1vZGVFbnVtLkJZVEUgPyBkYXRhQml0cy5nZXRTaXplSW5CeXRlcygpIDogY29udGVudC5sZW5ndGgpO1xuICAgIF8uYXBwZW5kTGVuZ3RoSW5mbyhudW1MZXR0ZXJzLCB2ZXJzaW9uLCBtb2RlLCBoZWFkZXJBbmREYXRhQml0cyk7XG4gICAgLy8gUHV0IGRhdGEgdG9nZXRoZXIgaW50byB0aGUgb3ZlcmFsbCBwYXlsb2FkXG4gICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoZGF0YUJpdHMpO1xuXG4gICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgIHZhciBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLVxuICAgICAgZWNCbG9ja3MuZ2V0VG90YWxFQ0NvZGV3b3JkcygpO1xuXG4gICAgLy8gVGVybWluYXRlIHRoZSBiaXRzIHByb3Blcmx5LlxuICAgIF8udGVybWluYXRlQml0cyhudW1EYXRhQnl0ZXMsIGhlYWRlckFuZERhdGFCaXRzKTtcblxuICAgIC8vIEludGVybGVhdmUgZGF0YSBiaXRzIHdpdGggZXJyb3IgY29ycmVjdGlvbiBjb2RlLlxuICAgIHZhciBmaW5hbEJpdHMgPSBfLmludGVybGVhdmVXaXRoRUNCeXRlcyhoZWFkZXJBbmREYXRhQml0cyxcbiAgICAgIHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSxcbiAgICAgIG51bURhdGFCeXRlcyxcbiAgICAgIGVjQmxvY2tzLmdldE51bUJsb2NrcygpKTtcblxuICAgIHZhciBxckNvZGUgPSBuZXcgUVJDb2RlKCk7XG5cbiAgICBxckNvZGUuc2V0RUNMZXZlbChlY0xldmVsKTtcbiAgICBxckNvZGUuc2V0TW9kZShtb2RlKTtcbiAgICBxckNvZGUuc2V0VmVyc2lvbih2ZXJzaW9uKTtcblxuICAgIC8vICBDaG9vc2UgdGhlIG1hc2sgcGF0dGVybiBhbmQgc2V0IHRvIFwicXJDb2RlXCIuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgIHZhciBtYXRyaXggPSBuZXcgQnl0ZU1hdHJpeChkaW1lbnNpb24sIGRpbWVuc2lvbik7XG4gICAgdmFyIG1hc2tQYXR0ZXJuID0gXy5jaG9vc2VNYXNrUGF0dGVybihmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hdHJpeCk7XG4gICAgcXJDb2RlLnNldE1hc2tQYXR0ZXJuKG1hc2tQYXR0ZXJuKTtcblxuICAgIC8vIEJ1aWxkIHRoZSBtYXRyaXggYW5kIHNldCBpdCB0byBcInFyQ29kZVwiLlxuICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoZmluYWxCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICBxckNvZGUuc2V0TWF0cml4KG1hdHJpeCk7XG5cbiAgICByZXR1cm4gcXJDb2RlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSBhc2NpaSBjb2RlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjb2RlIHBvaW50IG9mIHRoZSB0YWJsZSB1c2VkIGluIGFscGhhbnVtZXJpYyBtb2RlIG9yXG4gICAqICAtMSBpZiB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGNvZGUgaW4gdGhlIHRhYmxlLlxuICAgKi9cbiAgXy5nZXRBbHBoYW51bWVyaWNDb2RlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGNvZGUgPSBOdW1iZXIoY29kZSk7XG4gICAgaWYgKGNvZGUgPCBfLkFMUEhBTlVNRVJJQ19UQUJMRS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBfLkFMUEhBTlVNRVJJQ19UQUJMRVtjb2RlXTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENob29zZSB0aGUgYmVzdCBtb2RlIGJ5IGV4YW1pbmluZyB0aGUgY29udGVudC4gTm90ZSB0aGF0ICdlbmNvZGluZycgaXNcbiAgICogdXNlZCBhcyBhIGhpbnQ7XG4gICAqIGlmIGl0IGlzIFNoaWZ0X0pJUywgYW5kIHRoZSBpbnB1dCBpcyBvbmx5IGRvdWJsZS1ieXRlIEthbmppLCB0aGVuIHdlXG4gICAqIHJldHVybiB7QGxpbmsgTW9kZSNLQU5KSX0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZW5jb2Rpbmcgb3B0aW9uYWwgZW5jb2RpbmcuLlxuICAgKi9cbiAgXy5jaG9vc2VNb2RlID0gZnVuY3Rpb24oY29udGVudCwgb3B0X2VuY29kaW5nKSB7XG4gICAgaWYgKCdTSElGVF9KSVMnID09IG9wdF9lbmNvZGluZykge1xuICAgICAgLy8gQ2hvb3NlIEthbmppIG1vZGUgaWYgYWxsIGlucHV0IGFyZSBkb3VibGUtYnl0ZSBjaGFyYWN0ZXJzXG4gICAgICByZXR1cm4gXy5pc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkgPyBNb2RlRW51bS5LQU5KSSA6IE1vZGVFbnVtLkJZVEU7XG4gICAgfVxuICAgIHZhciBoYXNOdW1lcmljID0gZmFsc2U7XG4gICAgdmFyIGhhc0FscGhhbnVtZXJpYyA9IGZhbHNlO1xuICAgIHZhciB6ZXJvQ2hhciA9ICcwJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBuaW5lQ2hhciA9ICc5Jy5jaGFyQ29kZUF0KDApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGMgPSBjb250ZW50LmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoYyA+PSB6ZXJvQ2hhciAmJiBjIDw9IG5pbmVDaGFyKSB7XG4gICAgICAgIGhhc051bWVyaWMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChfLmdldEFscGhhbnVtZXJpY0NvZGUoYykgIT0gLTEpIHtcbiAgICAgICAgaGFzQWxwaGFudW1lcmljID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNb2RlRW51bS5CWVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQWxwaGFudW1lcmljKSB7XG4gICAgICByZXR1cm4gTW9kZUVudW0uQUxQSEFOVU1FUklDO1xuICAgIH1cbiAgICBpZiAoaGFzTnVtZXJpYykge1xuICAgICAgcmV0dXJuIE1vZGVFbnVtLk5VTUVSSUM7XG4gICAgfVxuICAgIHJldHVybiBNb2RlRW51bS5CWVRFO1xuICB9O1xuXG4gIF8uaXNPbmx5RG91YmxlQnl0ZUthbmppID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBieXRlcyA9IHN0cmluZ3V0aWxzLnN0cmluZ1RvQnl0ZXMoY29udGVudCwgJ1NISUZUX0pJUycpO1xuICAgIH0gY2F0Y2ggKHVlZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggJSAyICE9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgaWYgKChieXRlMSA8IDB4ODEgfHwgYnl0ZTEgPiAweDlGKSAmJiAoYnl0ZTEgPCAweEUwIHx8IGJ5dGUxID4gMHhFQikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfLmNob29zZU1hc2tQYXR0ZXJuID0gZnVuY3Rpb24oYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KSB7XG5cbiAgICB2YXIgbWluUGVuYWx0eSA9IE51bWJlci5NQVhfVkFMVUU7ICAvLyBMb3dlciBwZW5hbHR5IGlzIGJldHRlci5cbiAgICB2YXIgYmVzdE1hc2tQYXR0ZXJuID0gLTE7XG4gICAgLy8gV2UgdHJ5IGFsbCBtYXNrIHBhdHRlcm5zIHRvIGNob29zZSB0aGUgYmVzdCBvbmUuXG4gICAgZm9yICh2YXIgbWFza1BhdHRlcm4gPSAwOyBtYXNrUGF0dGVybiA8IFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUztcbiAgICAgICAgIG1hc2tQYXR0ZXJuKyspIHtcbiAgICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICB2YXIgcGVuYWx0eSA9IF8uY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcbiAgICAgIGlmIChwZW5hbHR5IDwgbWluUGVuYWx0eSkge1xuICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgYmVzdE1hc2tQYXR0ZXJuID0gbWFza1BhdHRlcm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XG4gIH07XG5cbiAgXy5jaG9vc2VWZXJzaW9uID0gZnVuY3Rpb24obnVtSW5wdXRCaXRzLCBlY0xldmVsKSB7XG4gICAgLy8gSW4gdGhlIGZvbGxvd2luZyBjb21tZW50cywgd2UgdXNlIG51bWJlcnMgb2YgVmVyc2lvbiA3LUguXG4gICAgZm9yICh2YXIgdmVyc2lvbk51bSA9IDE7IHZlcnNpb25OdW0gPD0gNDA7IHZlcnNpb25OdW0rKykge1xuICAgICAgdmFyIHZlcnNpb24gPSBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bSk7XG4gICAgICAvLyBudW1CeXRlcyA9IDE5NlxuICAgICAgdmFyIG51bUJ5dGVzID0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpO1xuICAgICAgLy8gZ2V0TnVtRUNCeXRlcyA9IDEzMFxuICAgICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgdmFyIG51bUVjQnl0ZXMgPSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAvLyBnZXROdW1EYXRhQnl0ZXMgPSAxOTYgLSAxMzAgPSA2NlxuICAgICAgdmFyIG51bURhdGFCeXRlcyA9IG51bUJ5dGVzIC0gbnVtRWNCeXRlcztcbiAgICAgIHZhciB0b3RhbElucHV0Qnl0ZXMgPSBNYXRoLmZsb29yKChudW1JbnB1dEJpdHMgKyA3KSAvIDgpO1xuICAgICAgaWYgKG51bURhdGFCeXRlcyA+PSB0b3RhbElucHV0Qnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignRGF0YSB0b28gYmlnJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZSBiaXRzIGFzIGRlc2NyaWJlZCBpbiA4LjQuOCBhbmQgOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4yNCkuXG4gICAqL1xuICBfLnRlcm1pbmF0ZUJpdHMgPSBmdW5jdGlvbihudW1EYXRhQnl0ZXMsIGJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgY2FwYWNpdHkgPSBudW1EYXRhQnl0ZXMgPDwgMztcbiAgICBpZiAoYml0cy5nZXRTaXplKCkgPiBjYXBhY2l0eSkge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCdkYXRhIGJpdHMgY2Fubm90IGZpdCBpbiB0aGUgUVIgQ29kZScgK1xuICAgICAgICBiaXRzLmdldFNpemUoKSArICcgPiAnICsgY2FwYWNpdHkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgNCAmJiBiaXRzLmdldFNpemUoKSA8IGNhcGFjaXR5OyArK2kpIHtcbiAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICB9XG4gICAgLy8gQXBwZW5kIHRlcm1pbmF0aW9uIGJpdHMuIFNlZSA4LjQuOCBvZiBKSVNYMDUxMDoyMDA0IChwLjI0KSBmb3IgZGV0YWlscy5cbiAgICAvLyBJZiB0aGUgbGFzdCBieXRlIGlzbid0IDgtYml0IGFsaWduZWQsIHdlJ2xsIGFkZCBwYWRkaW5nIGJpdHMuXG4gICAgdmFyIG51bUJpdHNJbkxhc3RCeXRlID0gYml0cy5nZXRTaXplKCkgJiAweDA3O1xuICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcbiAgICAgIGZvciAoaSA9IG51bUJpdHNJbkxhc3RCeXRlOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHNwYWNlLCB3ZSdsbCBmaWxsIHRoZSBzcGFjZSB3aXRoIHBhZGRpbmcgcGF0dGVybnNcbiAgICAvLyBkZWZpbmVkIGluIDguNC45IChwLjI0KS5cbiAgICB2YXIgbnVtUGFkZGluZ0J5dGVzID0gbnVtRGF0YUJ5dGVzIC0gYml0cy5nZXRTaXplSW5CeXRlcygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1QYWRkaW5nQnl0ZXM7ICsraSkge1xuICAgICAgYml0cy5hcHBlbmRCaXRzKChpICYgMHgwMSkgPT0gMCA/IDB4RUMgOiAweDExLCA4KTtcbiAgICB9XG4gICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9IGNhcGFjaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgV3JpdGVyRXJyb3IoJ0JpdHMgc2l6ZSBkb2VzIG5vdCBlcXVhbCBjYXBhY2l0eScpO1xuICAgIH1cbiAgfTtcblxuICAvKiogR2V0IG51bWJlciBvZiBkYXRhIGJ5dGVzIGFuZCBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBieXRlcyBmb3IgYmxvY2tcbiAgICogaWQgXCJibG9ja0lEXCIuIFN0b3JlIHRoZSByZXN1bHQgaW4gXCJudW1EYXRhQnl0ZXNJbkJsb2NrXCIsIGFuZFxuICAgKiBcIm51bUVDQnl0ZXNJbkJsb2NrXCIuIFNlZSB0YWJsZSAxMiBpbiA4LjUuMSBvZiBKSVNYMDUxMDoyMDA0IChwLjMwKVxuICAgKi9cbiAgXy5nZXROdW1EYXRhQnl0ZXNBbmROdW1FQ0J5dGVzRm9yQmxvY2tJRCA9IGZ1bmN0aW9uKG51bVRvdGFsQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1EYXRhQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1SU0Jsb2NrcywgYmxvY2tJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bURhdGFCeXRlc0luQmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1FQ0J5dGVzSW5CbG9jaykge1xuICAgIGlmIChibG9ja0lEID49IG51bVJTQmxvY2tzKSB7XG4gICAgICB0aHJvdyBuZXcgV3JpdGVyRXJyb3IoJ0Jsb2NrIElEIHRvbyBsYXJnZScpO1xuICAgIH1cbiAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAyID0gMTk2ICUgNSA9IDFcbiAgICB2YXIgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcbiAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAxID0gNSAtIDEgPSA0XG4gICAgdmFyIG51bVJzQmxvY2tzSW5Hcm91cDEgPSBudW1SU0Jsb2NrcyAtIG51bVJzQmxvY2tzSW5Hcm91cDI7XG4gICAgLy8gbnVtVG90YWxCeXRlc0luR3JvdXAxID0gMTk2IC8gNSA9IDM5XG4gICAgdmFyIG51bVRvdGFsQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtVG90YWxCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSAzOSArIDEgPSA0MFxuICAgIHZhciBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAxID0gNjYgLyA1ID0gMTNcbiAgICB2YXIgbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bURhdGFCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAvLyBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IDEzICsgMSA9IDE0XG4gICAgdmFyIG51bURhdGFCeXRlc0luR3JvdXAyID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMSA9IDM5IC0gMTMgPSAyNlxuICAgIHZhciBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAvLyBudW1FY0J5dGVzSW5Hcm91cDIgPSA0MCAtIDE0ID0gMjZcbiAgICB2YXIgbnVtRWNCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAyIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XG4gICAgLy8gU2FuaXR5IGNoZWNrcy5cbiAgICAvLyAyNiA9IDI2XG4gICAgaWYgKG51bUVjQnl0ZXNJbkdyb3VwMSAhPSBudW1FY0J5dGVzSW5Hcm91cDIpIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignRUMgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgLy8gNSA9IDQgKyAxLlxuICAgIGlmIChudW1SU0Jsb2NrcyAhPSBudW1Sc0Jsb2Nrc0luR3JvdXAxICsgbnVtUnNCbG9ja3NJbkdyb3VwMikge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCdSUyBibG9ja3MgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgLy8gMTk2ID0gKDEzICsgMjYpICogNCArICgxNCArIDI2KSAqIDFcbiAgICBpZiAobnVtVG90YWxCeXRlcyAhPVxuICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMSArIG51bUVjQnl0ZXNJbkdyb3VwMSkgKlxuICAgICAgICBudW1Sc0Jsb2Nrc0luR3JvdXAxKSArXG4gICAgICAgICgobnVtRGF0YUJ5dGVzSW5Hcm91cDIgKyBudW1FY0J5dGVzSW5Hcm91cDIpICpcbiAgICAgICAgICBudW1Sc0Jsb2Nrc0luR3JvdXAyKSkge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCdUb3RhbCBieXRlcyBtaXNtYXRjaCcpO1xuICAgIH1cblxuICAgIGlmIChibG9ja0lEIDwgbnVtUnNCbG9ja3NJbkdyb3VwMSkge1xuICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAxO1xuICAgICAgbnVtRUNCeXRlc0luQmxvY2tbMF0gPSBudW1FY0J5dGVzSW5Hcm91cDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bURhdGFCeXRlc0luQmxvY2tbMF0gPSBudW1EYXRhQnl0ZXNJbkdyb3VwMjtcbiAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJsZWF2ZSBcImJpdHNcIiB3aXRoIGNvcnJlc3BvbmRpbmcgZXJyb3IgY29ycmVjdGlvbiBieXRlcy4gT24gc3VjY2VzcyxcbiAgICogc3RvcmUgdGhlIHJlc3VsdCBpbiBcInJlc3VsdFwiLiBUaGUgaW50ZXJsZWF2ZSBydWxlIGlzIGNvbXBsaWNhdGVkLiBTZWUgOC42XG4gICAqIG9mIEpJU1gwNTEwOjIwMDQgKHAuMzcpIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgXy5pbnRlcmxlYXZlV2l0aEVDQnl0ZXMgPSBmdW5jdGlvbihiaXRzLCBudW1Ub3RhbEJ5dGVzLCBudW1EYXRhQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUlNCbG9ja3MpIHtcblxuICAgIC8vIFwiYml0c1wiIG11c3QgaGF2ZSBcImdldE51bURhdGFCeXRlc1wiIGJ5dGVzIG9mIGRhdGEuXG4gICAgaWYgKGJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSAhPSBudW1EYXRhQnl0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignTnVtYmVyIG9mIGJpdHMgYW5kIGRhdGEgYnl0ZXMgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDEuICBEaXZpZGUgZGF0YSBieXRlcyBpbnRvIGJsb2NrcyBhbmQgZ2VuZXJhdGUgZXJyb3IgY29ycmVjdGlvblxuICAgIC8vIGJ5dGVzIGZvciB0aGVtLiBXZSdsbCBzdG9yZSB0aGUgZGl2aWRlZCBkYXRhIGJ5dGVzIGJsb2NrcyBhbmQgZXJyb3JcbiAgICAvLyBjb3JyZWN0aW9uIGJ5dGVzIGJsb2NrcyBpbnRvIFwiYmxvY2tzXCIuXG4gICAgdmFyIGRhdGFCeXRlc09mZnNldCA9IDA7XG4gICAgdmFyIG1heE51bURhdGFCeXRlcyA9IDA7XG4gICAgdmFyIG1heE51bUVjQnl0ZXMgPSAwO1xuXG4gICAgLy8gU2luY2UsIHdlIGtub3cgdGhlIG51bWJlciBvZiByZWVkc29sbW9uIGJsb2Nrcywgd2UgY2FuIGluaXRpYWxpemUgdGhlXG4gICAgLy8gdmVjdG9yIHdpdGggdGhlIG51bWJlci5cbiAgICB2YXIgYmxvY2tzID0gW107XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUlNCbG9ja3M7ICsraSkge1xuICAgICAgdmFyIG51bURhdGFCeXRlc0luQmxvY2sgPSBbMF07XG4gICAgICB2YXIgbnVtRWNCeXRlc0luQmxvY2sgPSBbMF07XG4gICAgICBfLmdldE51bURhdGFCeXRlc0FuZE51bUVDQnl0ZXNGb3JCbG9ja0lEKFxuICAgICAgICBudW1Ub3RhbEJ5dGVzLCBudW1EYXRhQnl0ZXMsIG51bVJTQmxvY2tzLCBpLFxuICAgICAgICBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FY0J5dGVzSW5CbG9jayk7XG5cbiAgICAgIHZhciBzaXplID0gbnVtRGF0YUJ5dGVzSW5CbG9ja1swXTtcbiAgICAgIHZhciBkYXRhQnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBiaXRzLnRvQnl0ZXMoOCAqIGRhdGFCeXRlc09mZnNldCwgZGF0YUJ5dGVzLCAwLCBzaXplKTtcbiAgICAgIHZhciBlY0J5dGVzID0gXy5nZW5lcmF0ZUVDQnl0ZXMoZGF0YUJ5dGVzLCBudW1FY0J5dGVzSW5CbG9ja1swXSk7XG4gICAgICBibG9ja3MucHVzaChuZXcgQmxvY2tQYWlyKGRhdGFCeXRlcywgZWNCeXRlcykpO1xuXG4gICAgICBtYXhOdW1EYXRhQnl0ZXMgPSBNYXRoLm1heChtYXhOdW1EYXRhQnl0ZXMsIHNpemUpO1xuICAgICAgbWF4TnVtRWNCeXRlcyA9IE1hdGgubWF4KG1heE51bUVjQnl0ZXMsIGVjQnl0ZXMubGVuZ3RoKTtcbiAgICAgIGRhdGFCeXRlc09mZnNldCArPSBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdO1xuICAgIH1cbiAgICBpZiAobnVtRGF0YUJ5dGVzICE9IGRhdGFCeXRlc09mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCdEYXRhIGJ5dGVzIGRvZXMgbm90IG1hdGNoIG9mZnNldCcpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBuZXcgQml0QXJyYXkoKTtcblxuICAgIC8vIEZpcnN0LCBwbGFjZSBkYXRhIGJsb2Nrcy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4TnVtRGF0YUJ5dGVzOyArK2kpIHtcbiAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgIHZhciBkYXRhQnl0ZXMgPSBibG9jay5nZXREYXRhQnl0ZXMoKTtcbiAgICAgICAgaWYgKGkgPCBkYXRhQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0LmFwcGVuZEJpdHMoZGF0YUJ5dGVzW2ldLCA4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoZW4sIHBsYWNlIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhOdW1FY0J5dGVzOyArK2kpIHtcbiAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgIHZhciBlY0J5dGVzID0gYmxvY2suZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMoKTtcbiAgICAgICAgaWYgKGkgPCBlY0J5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGVjQnl0ZXNbaV0sIDgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG51bVRvdGFsQnl0ZXMgIT0gcmVzdWx0LmdldFNpemVJbkJ5dGVzKCkpIHsgIC8vIFNob3VsZCBiZSBzYW1lLlxuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKCdJbnRlcmxlYXZpbmcgZXJyb3I6ICcgKyBudW1Ub3RhbEJ5dGVzICtcbiAgICAgICAgJyBhbmQgJyArIHJlc3VsdC5nZXRTaXplSW5CeXRlcygpICsgJyBkaWZmZXIuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUJ5dGVzIGJ5dGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtRWNCeXRlc0luQmxvY2sgbnVtLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gYnl0ZXMuXG4gICAqL1xuICBfLmdlbmVyYXRlRUNCeXRlcyA9IGZ1bmN0aW9uKGRhdGFCeXRlcywgbnVtRWNCeXRlc0luQmxvY2spIHtcbiAgICB2YXIgbnVtRGF0YUJ5dGVzID0gZGF0YUJ5dGVzLmxlbmd0aDtcbiAgICB2YXIgdG9FbmNvZGUgPSBuZXcgQXJyYXkobnVtRGF0YUJ5dGVzICsgbnVtRWNCeXRlc0luQmxvY2spO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1EYXRhQnl0ZXM7IGkrKykge1xuICAgICAgdG9FbmNvZGVbaV0gPSBkYXRhQnl0ZXNbaV0gJiAweEZGO1xuICAgIH1cbiAgICBuZXcgUmVlZFNvbG9tb25FbmNvZGVyKHc2OWIucXIuR0YyNTYuUVJfQ09ERV9GSUVMRCkuZW5jb2RlKHRvRW5jb2RlLFxuICAgICAgbnVtRWNCeXRlc0luQmxvY2spO1xuXG4gICAgdmFyIGVjQnl0ZXMgPSBuZXcgQXJyYXkobnVtRWNCeXRlc0luQmxvY2spO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1FY0J5dGVzSW5CbG9jazsgaSsrKSB7XG4gICAgICBlY0J5dGVzW2ldID0gdG9FbmNvZGVbbnVtRGF0YUJ5dGVzICsgaV07XG4gICAgfVxuICAgIHJldHVybiBlY0J5dGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgbW9kZSBpbmZvLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgKi9cbiAgXy5hcHBlbmRNb2RlSW5mbyA9IGZ1bmN0aW9uKG1vZGUsIGJpdHMpIHtcbiAgICBiaXRzLmFwcGVuZEJpdHMobW9kZS5nZXRCaXRzKCksIDQpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFwcGVuZCBsZW5ndGggaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICovXG4gIF8uYXBwZW5kTGVuZ3RoSW5mbyA9IGZ1bmN0aW9uKG51bUxldHRlcnMsIHZlcnNpb24sIG1vZGUsIGJpdHMpIHtcbiAgICB2YXIgbnVtQml0cyA9IG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pO1xuICAgIGlmIChudW1MZXR0ZXJzID49ICgxIDw8IG51bUJpdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgV3JpdGVyRXJyb3IobnVtTGV0dGVycyArICcgaXMgYmlnZ2VyIHRoYW4gJyArXG4gICAgICAgICgoMSA8PCBudW1CaXRzKSAtIDEpKTtcbiAgICB9XG4gICAgYml0cy5hcHBlbmRCaXRzKG51bUxldHRlcnMsIG51bUJpdHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgXCJieXRlc1wiIGluIFwibW9kZVwiIG1vZGUgKGVuY29kaW5nKSBpbnRvIFwiYml0c1wiLlxuICAgKiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgKi9cbiAgXy5hcHBlbmRCeXRlcyA9IGZ1bmN0aW9uKGNvbnRlbnQsIG1vZGUsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIE1vZGVFbnVtLk5VTUVSSUM6XG4gICAgICAgIF8uYXBwZW5kTnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTW9kZUVudW0uQUxQSEFOVU1FUklDOlxuICAgICAgICBfLmFwcGVuZEFscGhhbnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTW9kZUVudW0uQllURTpcbiAgICAgICAgXy5hcHBlbmQ4Qml0Qnl0ZXMoY29udGVudCwgYml0cywgZW5jb2RpbmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTW9kZUVudW0uS0FOSkk6XG4gICAgICAgIF8uYXBwZW5kS2FuamlCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXJyb3IoJ0ludmFsaWQgbW9kZTogJyArIG1vZGUpO1xuICAgIH1cbiAgfTtcblxuICBfLmFwcGVuZE51bWVyaWNCeXRlcyA9IGZ1bmN0aW9uKGNvbnRlbnQsIGJpdHMpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBudW0yO1xuICAgIHZhciBjb2RlWmVybyA9ICcwJy5jaGFyQ29kZUF0KDApO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgbnVtMSA9IGNvbnRlbnQuY2hhckNvZGVBdChpKSAtIGNvZGVaZXJvO1xuICAgICAgaWYgKGkgKyAyIDwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIEVuY29kZSB0aHJlZSBudW1lcmljIGxldHRlcnMgaW4gdGVuIGJpdHMuXG4gICAgICAgIG51bTIgPSBjb250ZW50LmNoYXJDb2RlQXQoaSArIDEpIC0gY29kZVplcm87XG4gICAgICAgIHZhciBudW0zID0gY29udGVudC5jaGFyQ29kZUF0KGkgKyAyKSAtIGNvZGVaZXJvO1xuICAgICAgICBiaXRzLmFwcGVuZEJpdHMobnVtMSAqIDEwMCArIG51bTIgKiAxMCArIG51bTMsIDEwKTtcbiAgICAgICAgaSArPSAzO1xuICAgICAgfSBlbHNlIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAvLyBFbmNvZGUgdHdvIG51bWVyaWMgbGV0dGVycyBpbiBzZXZlbiBiaXRzLlxuICAgICAgICBudW0yID0gY29udGVudC5jaGFyQ29kZUF0KGkgKyAxKSAtIGNvZGVaZXJvO1xuICAgICAgICBiaXRzLmFwcGVuZEJpdHMobnVtMSAqIDEwICsgbnVtMiwgNyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuY29kZSBvbmUgbnVtZXJpYyBsZXR0ZXIgaW4gZm91ciBiaXRzLlxuICAgICAgICBiaXRzLmFwcGVuZEJpdHMobnVtMSwgNCk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXy5hcHBlbmRBbHBoYW51bWVyaWNCeXRlcyA9IGZ1bmN0aW9uKGNvbnRlbnQsIGJpdHMpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZTEgPSBfLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgIGlmIChjb2RlMSA9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgY29kZTIgPSBfLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgIGlmIChjb2RlMiA9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuY29kZSB0d28gYWxwaGFudW1lcmljIGxldHRlcnMgaW4gMTEgYml0cy5cbiAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxICogNDUgKyBjb2RlMiwgMTEpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbmNvZGUgb25lIGFscGhhbnVtZXJpYyBsZXR0ZXIgaW4gc2l4IGJpdHMuXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhjb2RlMSwgNik7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXy5hcHBlbmQ4Qml0Qnl0ZXMgPSBmdW5jdGlvbihjb250ZW50LCBiaXRzLCBlbmNvZGluZykge1xuICAgIHZhciBieXRlcztcbiAgICB0cnkge1xuICAgICAgYnl0ZXMgPSBzdHJpbmd1dGlscy5zdHJpbmdUb0J5dGVzKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICB9IGNhdGNoICh1ZWUpIHtcbiAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcih1ZWUpO1xuICAgIH1cbiAgICBieXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgIGJpdHMuYXBwZW5kQml0cyhiLCA4KTtcbiAgICB9KTtcbiAgfTtcblxuICBfLmFwcGVuZEthbmppQnl0ZXMgPSBmdW5jdGlvbihjb250ZW50LCBiaXRzKSB7XG4gICAgdmFyIGJ5dGVzO1xuICAgIHRyeSB7XG4gICAgICBieXRlcyA9IHN0cmluZ3V0aWxzLnN0cmluZ1RvQnl0ZXMoY29udGVudCwgJ1NoaWZ0X0pJUycpO1xuICAgIH0gY2F0Y2ggKHVlZSkge1xuICAgICAgdGhyb3cgbmV3IFdyaXRlckVycm9yKHVlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgdmFyIGJ5dGUyID0gYnl0ZXNbaSArIDFdICYgMHhGRjtcbiAgICAgIHZhciBjb2RlID0gKGJ5dGUxIDw8IDgpIHwgYnl0ZTI7XG4gICAgICB2YXIgc3VidHJhY3RlZCA9IC0xO1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MTQwICYmIGNvZGUgPD0gMHg5ZmZjKSB7XG4gICAgICAgIHN1YnRyYWN0ZWQgPSBjb2RlIC0gMHg4MTQwO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID49IDB4ZTA0MCAmJiBjb2RlIDw9IDB4ZWJiZikge1xuICAgICAgICBzdWJ0cmFjdGVkID0gY29kZSAtIDB4YzE0MDtcbiAgICAgIH1cbiAgICAgIGlmIChzdWJ0cmFjdGVkID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBXcml0ZXJFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZW5jb2RlZCA9ICgoc3VidHJhY3RlZCA+PiA4KSAqIDB4YzApICsgKHN1YnRyYWN0ZWQgJiAweGZmKTtcbiAgICAgIGJpdHMuYXBwZW5kQml0cyhlbmNvZGVkLCAxMyk7XG4gICAgfVxuICB9O1xuXG4gIF8uYXBwZW5kRUNJID0gZnVuY3Rpb24oZWNpLCBiaXRzKSB7XG4gICAgYml0cy5hcHBlbmRCaXRzKE1vZGVFbnVtLkVDSS5nZXRCaXRzKCksIDQpO1xuICAgIC8vIFRoaXMgaXMgY29ycmVjdCBmb3IgdmFsdWVzIHVwIHRvIDEyNywgd2hpY2ggaXMgYWxsIHdlIG5lZWQgbm93LlxuICAgIGJpdHMuYXBwZW5kQml0cyhlY2ksIDgpO1xuICB9O1xuXG59KTtcbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkJpbmFyaXplcicpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaGllcmFyY2h5IHByb3ZpZGVzIGEgc2V0IG9mIG1ldGhvZHMgdG8gY29udmVydCBsdW1pbmFuY2UgZGF0YSB0b1xuICogMSBiaXQgZGF0YS4gIEl0IGFsbG93cyB0aGUgYWxnb3JpdGhtIHRvIHZhcnkgcG9seW1vcnBoaWNhbGx5LCBmb3IgZXhhbXBsZVxuICogYWxsb3dpbmcgYSB2ZXJ5IGV4cGVuc2l2ZSB0aHJlc2hvbGRpbmcgdGVjaG5pcXVlIGZvciBzZXJ2ZXJzIGFuZCBhIGZhc3Qgb25lXG4gKiBmb3IgbW9iaWxlLiBJdCBhbHNvIHBlcm1pdHMgdGhlIGltcGxlbWVudGF0aW9uIHRvIHZhcnksIGUuZy4gYSBKTkkgdmVyc2lvblxuICogZm9yIEFuZHJvaWQgYW5kIGEgSmF2YSBmYWxsYmFjayB2ZXJzaW9uIGZvciBvdGhlciBwbGF0Zm9ybXMuXG4gKlxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAqIFBvcnRlZCB0byBqcyBieSBNYW51ZWwgQnJhdW5cbiAqXG4gKiAgQHBhcmFtIHt3NjliLnFyLlFSSW1hZ2V9IHNvdXJjZSBncmF5IHZhbHVlcyAuXG4gKiAgQGNvbnN0cnVjdG9yXG4gKi9cbnc2OWIucXIuQmluYXJpemVyID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHt3NjliLnFyLlFSSW1hZ2V9XG4gICAqL1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbn07XG4gIHZhciBCaW5hcml6ZXIgPSB3NjliLnFyLkJpbmFyaXplcjtcbiAgdmFyIHBybyA9IEJpbmFyaXplci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3c2OWIucXIuUVJJbWFnZX0gaW1hZ2UuXG4gICAqL1xuICBwcm8uZ2V0THVtaW5hbmNlU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBvbmUgcm93IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuIE1heSBhY3R1YWxseSBkbyB0aGVcbiAgICogY29udmVyc2lvbiwgb3IgcmV0dXJuIGNhY2hlZCBkYXRhLiBDYWxsZXJzIHNob3VsZCBhc3N1bWUgdGhpcyBtZXRob2QgaXNcbiAgICogZXhwZW5zaXZlIGFuZCBjYWxsIGl0IGFzIHNlbGRvbSBhcyBwb3NzaWJsZS4gIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvclxuICAgKiBkZWNvZGluZyAxRCBiYXJjb2RlcyBhbmQgbWF5IGNob29zZSB0byBhcHBseSBzaGFycGVuaW5nLiAgRm9yIGNhbGxlcnNcbiAgICogd2hpY2ggb25seSBleGFtaW5lIG9uZSByb3cgb2YgcGl4ZWxzIGF0IGEgdGltZSwgdGhlIHNhbWUgQml0QXJyYXkgc2hvdWxkXG4gICAqIGJlIHJldXNlZCBhbmQgcGFzc2VkIGluIHdpdGggZWFjaCBjYWxsIGZvciBwZXJmb3JtYW5jZS4gSG93ZXZlciBpdCBpc1xuICAgKiBsZWdhbCB0byBrZWVwIG1vcmUgdGhhbiBvbmUgcm93IGF0IGEgdGltZSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSByb3cgdG8gZmV0Y2gsIDAgPD0geSA8IGJpdG1hcCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5CaXRBcnJheX0gb3B0X3JvdyBBbiBvcHRpb25hbCBwcmVhbGxvY2F0ZWQgYXJyYXkuIElmIG51bGxcbiAgICogb3IgdG9vIHNtYWxsLCBpdCB3aWxsIGJlIGlnbm9yZWQuICBJZiB1c2VkLCB0aGUgQmluYXJpemVyIHdpbGwgY2FsbFxuICAgKiBCaXRBcnJheS5jbGVhcigpLiBBbHdheXMgdXNlIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAqIEByZXR1cm4geyF3NjliLnFyLkJpdEFycmF5fSBUaGUgYXJyYXkgb2YgYml0cyBmb3IgdGhpcyByb3cgKHRydWUgbWVhbnNcbiAgICogYmxhY2spLlxuICAgKi9cbiAgcHJvLmdldEJsYWNrUm93ID0gZnVuY3Rpb24oeSwgb3B0X3JvdykgeyB0aHJvdyBFcnJvcigpOyB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIDJEIGFycmF5IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuIEFzIGFib3ZlLCBhc3N1bWUgdGhpc1xuICAgKiBtZXRob2QgaXMgZXhwZW5zaXZlIGFuZCBkbyBub3QgY2FsbCBpdCByZXBlYXRlZGx5LiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZFxuICAgKiBmb3IgZGVjb2RpbmcgMkQgYmFyY29kZXMgYW5kIG1heSBvciBtYXkgbm90IGFwcGx5IHNoYXJwZW5pbmcuIFRoZXJlZm9yZSwgYVxuICAgKiByb3cgZnJvbSB0aGlzIG1hdHJpeCBtYXkgbm90IGJlIGlkZW50aWNhbCB0byBvbmUgZmV0Y2hlZCB1c2luZ1xuICAgKiBnZXRCbGFja1JvdygpLCBzbyBkb24ndCBtaXggYW5kIG1hdGNoIGJldHdlZW4gdGhlbS5cbiAgICpcbiAgICogQHJldHVybiB7IXc2OWIucXIuQml0TWF0cml4fSBUaGUgMkQgYXJyYXkgb2YgYml0cyBmb3IgdGhlIGltYWdlXG4gICAqICh0cnVlIG1lYW5zIGJsYWNrKS5cbiAgICovXG4gIHByby5nZXRCbGFja01hdHJpeCA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBFcnJvcigpOyB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHR5cGUgYXMgdGhpcyBCaW5hcml6ZXIgaW1wbGVtZW50YXRpb24sXG4gICAqIGJ1dCB3aXRoIHByaXN0aW5lIHN0YXRlLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEJpbmFyaXplciBpbXBsZW1lbnRhdGlvbnNcbiAgICogbWF5IGJlIHN0YXRlZnVsLCBlLmcuIGtlZXBpbmcgYSBjYWNoZSBvZiAxIGJpdCBkYXRhLiBTZWUgRWZmZWN0aXZlIEphdmFcbiAgICogZm9yIHdoeSB3ZSBjYW4ndCB1c2UgSmF2YSdzIGNsb25lKCkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge3c2OWIucXIuUVJJbWFnZX0gc291cmNlIFRoZSBMdW1pbmFuY2VTb3VyY2UgdGhpcyBCaW5hcml6ZXJcbiAgICogd2lsbCBvcGVyYXRlIG9uLlxuICAgKiBAcmV0dXJuIHt3NjliLnFyLkJpbmFyaXplcn0gQSBuZXcgY29uY3JldGUgQmluYXJpemVyIGltcGxlbWVudGF0aW9uXG4gICAqIG9iamVjdC5cbiAgICovXG4gIHByby5jcmVhdGVCaW5hcml6ZXIgPSBmdW5jdGlvbihzb3VyY2UpIHsgdGhyb3cgRXJyb3IoKTsgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aC5cbiAgICovXG4gIHByby5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS53aWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHQuXG4gICAqL1xuICBwcm8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmhlaWdodDtcbiAgfTtcblxufSk7XG5cbiIsIi8vIGphdmFzY3JpcHQgKGNsb3N1cmUpIHBvcnQgKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5nb29nLnByb3ZpZGUoJ3c2OWIucXIuR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQmluYXJpemVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQml0QXJyYXknKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5CaXRNYXRyaXgnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5Ob3RGb3VuZEVycm9yJyk7XG5cblxuZ29vZy5zY29wZShmdW5jdGlvbigpIHtcbiAgdmFyIEJpdE1hdHJpeCA9IHc2OWIucXIuQml0TWF0cml4O1xuICB2YXIgQml0QXJyYXkgPSB3NjliLnFyLkJpdEFycmF5O1xuICAgLyoqXG4gICAqIFRoaXMgQmluYXJpemVyIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIG9sZCBaWGluZyBnbG9iYWwgaGlzdG9ncmFtXG4gICAqIGFwcHJvYWNoLiBJdCBpcyBzdWl0YWJsZSBmb3IgbG93LWVuZCBtb2JpbGUgZGV2aWNlcyB3aGljaCBkb24ndCBoYXZlXG4gICAqIGVub3VnaCBDUFUgb3IgbWVtb3J5IHRvIHVzZSBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0uIEhvd2V2ZXIsXG4gICAqIGJlY2F1c2UgaXQgcGlja3MgYSBnbG9iYWwgYmxhY2sgcG9pbnQsIGl0IGNhbm5vdCBoYW5kbGUgZGlmZmljdWx0IHNoYWRvd3NcbiAgICogYW5kIGdyYWRpZW50cy5cbiAgICpcbiAgICogRmFzdGVyIG1vYmlsZSBkZXZpY2VzIGFuZCBhbGwgZGVza3RvcCBhcHBsaWNhdGlvbnMgc2hvdWxkIHByb2JhYmx5IHVzZVxuICAgKiBIeWJyaWRCaW5hcml6ZXIgaW5zdGVhZC5cbiAgICpcbiAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICogUG9ydGVkIHRvIGpzIGJ5IE1hbnVlbCBCcmF1blxuICAgKlxuICAgICogQHBhcmFtIHt3NjliLnFyLlFSSW1hZ2V9IHNvdXJjZSBncmF5IHZhbHVlcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHt3NjliLnFyLkJpbmFyaXplcn1cbiAgICovXG4gIHc2OWIucXIuR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgZ29vZy5iYXNlKHRoaXMsIHNvdXJjZSk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmx1bWluYW5jZXNfID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJ1Y2tldHNfID0gbmV3IFVpbnQ4QXJyYXkoXy5MVU1JTkFOQ0VfQlVDS0VUUyk7XG4gIH07XG4gIHZhciBfID0gdzY5Yi5xci5HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXI7XG4gIGdvb2cuaW5oZXJpdHMoXywgdzY5Yi5xci5CaW5hcml6ZXIpO1xuICB2YXIgcHJvID0gXy5wcm90b3R5cGU7XG5cblxuICBfLkxVTUlOQU5DRV9CSVRTID0gNTtcbiAgXy5MVU1JTkFOQ0VfU0hJRlQgPSA4IC0gXy5MVU1JTkFOQ0VfQklUUztcbiAgXy5MVU1JTkFOQ0VfQlVDS0VUUyA9IDEgPDwgXy5MVU1JTkFOQ0VfQklUUztcblxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHNpbXBsZSBzaGFycGVuaW5nIHRvIHRoZSByb3cgZGF0YSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSAxRFxuICAgKiBSZWFkZXJzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gICAgcHJvLmdldEJsYWNrUm93ID0gZnVuY3Rpb24oeSwgcm93KSB7XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgdmFyIHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICBpZiAocm93ID09IG51bGwgfHwgcm93LmdldFNpemUoKSA8IHdpZHRoKSB7XG4gICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheSh3aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3cuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgIHZhciBsb2NhbEx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0Um93KHksIHRoaXMubHVtaW5hbmNlc18pO1xuICAgICAgdmFyIGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0c187XG4gICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICB2YXIgcGl4ZWwgPSBsb2NhbEx1bWluYW5jZXNbeF0gJiAweGZmO1xuICAgICAgICBsb2NhbEJ1Y2tldHNbcGl4ZWwgPj4gXy5MVU1JTkFOQ0VfU0hJRlRdKys7XG4gICAgICB9XG4gICAgICB2YXIgYmxhY2tQb2ludCA9IF8uZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG5cbiAgICAgIHZhciBsZWZ0ID0gbG9jYWxMdW1pbmFuY2VzWzBdICYgMHhmZjtcbiAgICAgIHZhciBjZW50ZXIgPSBsb2NhbEx1bWluYW5jZXNbMV0gJiAweGZmO1xuICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgIHZhciByaWdodCA9IGxvY2FsTHVtaW5hbmNlc1t4ICsgMV0gJiAweGZmO1xuICAgICAgICAvLyBBIHNpbXBsZSAtMSA0IC0xIGJveCBmaWx0ZXIgd2l0aCBhIHdlaWdodCBvZiAyLlxuICAgICAgICB2YXIgbHVtaW5hbmNlID0gKChjZW50ZXIgPDwgMikgLSBsZWZ0IC0gcmlnaHQpID4+IDE7XG4gICAgICAgIGlmIChsdW1pbmFuY2UgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgcm93LnNldCh4KTtcbiAgICAgICAgfVxuICAgICAgICBsZWZ0ID0gY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHNoYXJwZW4gdGhlIGRhdGEsIGFzIHRoaXMgY2FsbCBpcyBpbnRlbmRlZCB0byBvbmx5IGJlIHVzZWQgYnlcbiAgICAgKiAyRCBSZWFkZXJzLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHByby5nZXRCbGFja01hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0THVtaW5hbmNlU291cmNlKCk7XG4gICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICB2YXIgbWF0cml4ID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgLy8gbmFzdHkganMgc2NvcGVzLlxuICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlcywgcGl4ZWwsIHgsIHk7XG4gICAgICAvLyBRdWlja2x5IGNhbGN1bGF0ZXMgdGhlIGhpc3RvZ3JhbSBieSBzYW1wbGluZyBmb3VyIHJvd3MgZnJvbSB0aGUgaW1hZ2UuXG4gICAgICAvLyBUaGlzIHByb3ZlZCB0byBiZSBtb3JlIHJvYnVzdCBvbiB0aGUgYmxhY2tib3ggdGVzdHMgdGhhbiBzYW1wbGluZyBhXG4gICAgICAvLyBkaWFnb25hbCBhcyB3ZSB1c2VkIHRvIGRvLlxuICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgIHZhciBsb2NhbEJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHNfO1xuICAgICAgZm9yICh5ID0gMTsgeSA8IDU7IHkrKykge1xuICAgICAgICB2YXIgcm93ID0gaGVpZ2h0ICogeSAvIDU7XG4gICAgICAgIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3cocm93LCB0aGlzLmx1bWluYW5jZXNfKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gKHdpZHRoIDw8IDIpIC8gNTtcbiAgICAgICAgZm9yICh4ID0gd2lkdGggLyA1OyB4IDwgcmlnaHQ7IHgrKykge1xuICAgICAgICAgIHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZjtcbiAgICAgICAgICBsb2NhbEJ1Y2tldHNbcGl4ZWwgPj4gXy5MVU1JTkFOQ0VfU0hJRlRdKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBibGFja1BvaW50ID0gXy5lc3RpbWF0ZUJsYWNrUG9pbnQobG9jYWxCdWNrZXRzKTtcblxuICAgICAgLy8gV2UgZGVsYXkgcmVhZGluZyB0aGUgZW50aXJlIGltYWdlIGx1bWluYW5jZSB1bnRpbCB0aGUgYmxhY2sgcG9pbnRcbiAgICAgIC8vIGVzdGltYXRpb24gc3VjY2VlZHMuICBBbHRob3VnaCB3ZSBlbmQgdXAgcmVhZGluZyBmb3VyIHJvd3MgdHdpY2UsIGl0XG4gICAgICAvLyBpcyBjb25zaXN0ZW50IHdpdGggb3VyIG1vdHRvIG9mIFwiZmFpbCBxdWlja2x5XCIgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvclxuICAgICAgLy8gY29udGludW91cyBzY2FubmluZy5cbiAgICAgIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhmZjtcbiAgICAgICAgICBpZiAocGl4ZWwgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICBtYXRyaXguc2V0KHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgICBwcm8uY3JlYXRlQmluYXJpemVyID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICByZXR1cm4gbmV3IF8oc291cmNlKTtcbiAgICB9O1xuXG4gICAgcHJvLmluaXRBcnJheXMgPSBmdW5jdGlvbihsdW1pbmFuY2VTaXplKSB7XG4gICAgICBpZiAodGhpcy5sdW1pbmFuY2VzXy5sZW5ndGggPCBsdW1pbmFuY2VTaXplKSB7XG4gICAgICAgIHRoaXMubHVtaW5hbmNlc18gPSBuZXcgVWludDhBcnJheShsdW1pbmFuY2VTaXplKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgXy5MVU1JTkFOQ0VfQlVDS0VUUzsgeCsrKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c19beF0gPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfLmVzdGltYXRlQmxhY2tQb2ludCA9IGZ1bmN0aW9uKGJ1Y2tldHMpIHtcbiAgICAgIHZhciB4LCBzY29yZTtcbiAgICAgIC8vIEZpbmQgdGhlIHRhbGxlc3QgcGVhayBpbiB0aGUgaGlzdG9ncmFtLlxuICAgICAgdmFyIG51bUJ1Y2tldHMgPSBidWNrZXRzLmxlbmd0aDtcbiAgICAgIHZhciBtYXhCdWNrZXRDb3VudCA9IDA7XG4gICAgICB2YXIgZmlyc3RQZWFrID0gMDtcbiAgICAgIHZhciBmaXJzdFBlYWtTaXplID0gMDtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBudW1CdWNrZXRzOyB4KyspIHtcbiAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBmaXJzdFBlYWtTaXplKSB7XG4gICAgICAgICAgZmlyc3RQZWFrID0geDtcbiAgICAgICAgICBmaXJzdFBlYWtTaXplID0gYnVja2V0c1t4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVja2V0c1t4XSA+IG1heEJ1Y2tldENvdW50KSB7XG4gICAgICAgICAgbWF4QnVja2V0Q291bnQgPSBidWNrZXRzW3hdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIHNlY29uZC10YWxsZXN0IHBlYWsgd2hpY2ggaXMgc29tZXdoYXQgZmFyIGZyb20gdGhlIHRhbGxlc3RcbiAgICAgIC8vIHBlYWsuXG4gICAgICB2YXIgc2Vjb25kUGVhayA9IDA7XG4gICAgICB2YXIgc2Vjb25kUGVha1Njb3JlID0gMDtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBudW1CdWNrZXRzOyB4KyspIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9CaWdnZXN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgLy8gRW5jb3VyYWdlIG1vcmUgZGlzdGFudCBzZWNvbmQgcGVha3MgYnkgbXVsdGlwbHlpbmcgYnkgc3F1YXJlIG9mXG4gICAgICAgIC8vIGRpc3RhbmNlLlxuICAgICAgICBzY29yZSA9IGJ1Y2tldHNbeF0gKiBkaXN0YW5jZVRvQmlnZ2VzdCAqIGRpc3RhbmNlVG9CaWdnZXN0O1xuICAgICAgICBpZiAoc2NvcmUgPiBzZWNvbmRQZWFrU2NvcmUpIHtcbiAgICAgICAgICBzZWNvbmRQZWFrID0geDtcbiAgICAgICAgICBzZWNvbmRQZWFrU2NvcmUgPSBzY29yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgZmlyc3RQZWFrIGNvcnJlc3BvbmRzIHRvIHRoZSBibGFjayBwZWFrLlxuICAgICAgaWYgKGZpcnN0UGVhayA+IHNlY29uZFBlYWspIHtcbiAgICAgICAgdmFyIHRlbXAgPSBmaXJzdFBlYWs7XG4gICAgICAgIGZpcnN0UGVhayA9IHNlY29uZFBlYWs7XG4gICAgICAgIHNlY29uZFBlYWsgPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyB0b28gbGl0dGxlIGNvbnRyYXN0IGluIHRoZSBpbWFnZSB0byBwaWNrIGEgbWVhbmluZ2Z1bFxuICAgICAgLy8gYmxhY2sgcG9pbnQsIHRocm93IHJhdGhlciB0aGFuIHdhc3RlIHRpbWUgdHJ5aW5nIHRvIGRlY29kZSB0aGUgaW1hZ2UsXG4gICAgICAvLyBhbmQgcmlzayBmYWxzZSBwb3NpdGl2ZXMuXG4gICAgICBpZiAoc2Vjb25kUGVhayAtIGZpcnN0UGVhayA8PSBudW1CdWNrZXRzID4+IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IHc2OWIucXIuTm90Rm91bmRFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGEgdmFsbGV5IGJldHdlZW4gdGhlbSB0aGF0IGlzIGxvdyBhbmQgY2xvc2VyIHRvIHRoZSB3aGl0ZSBwZWFrLlxuICAgICAgdmFyIGJlc3RWYWxsZXkgPSBzZWNvbmRQZWFrIC0gMTtcbiAgICAgIHZhciBiZXN0VmFsbGV5U2NvcmUgPSAtMTtcbiAgICAgIGZvciAoeCA9IHNlY29uZFBlYWsgLSAxOyB4ID4gZmlyc3RQZWFrOyB4LS0pIHtcbiAgICAgICAgdmFyIGZyb21GaXJzdCA9IHggLSBmaXJzdFBlYWs7XG4gICAgICAgIHNjb3JlID0gZnJvbUZpcnN0ICogZnJvbUZpcnN0ICogKHNlY29uZFBlYWsgLSB4KSAqXG4gICAgICAgICAgKG1heEJ1Y2tldENvdW50IC0gYnVja2V0c1t4XSk7XG4gICAgICAgIGlmIChzY29yZSA+IGJlc3RWYWxsZXlTY29yZSkge1xuICAgICAgICAgIGJlc3RWYWxsZXkgPSB4O1xuICAgICAgICAgIGJlc3RWYWxsZXlTY29yZSA9IHNjb3JlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiZXN0VmFsbGV5IDw8IF8uTFVNSU5BTkNFX1NISUZUO1xuICAgIH07XG59KTtcblxuIiwiLy8gamF2YXNjcmlwdCAoY2xvc3VyZSkgcG9ydCAoYykgMjAxMyBNYW51ZWwgQnJhdW4gKG1iQHc2OWIuY29tKVxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkludEFycmF5MkQnKTtcbmdvb2cuc2NvcGUoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHByZS1hbGxvY2F0ZWQgcm93LWZpcnN0IDJkIGludGVnZXIgYXJyYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplMSBzaXplIG9mIGZpcnN0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUyIHNpemUgb2ZzZWNvbmQgZGltZW5zaW9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHc2OWIucXIuSW50QXJyYXkyRCA9IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuICAgIHRoaXMuc2l6ZTEgPSBzaXplMTtcbiAgICB0aGlzLnNpemUyID0gc2l6ZTI7XG4gICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoc2l6ZTEgKiBzaXplMik7XG4gIH07XG4gIHZhciBwcm8gPSB3NjliLnFyLkludEFycmF5MkQucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaW0xIGZpcnN0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbTIgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSBhdCBnaXZlbiBwb3NpdGlvbi5cbiAgICovXG4gIHByby5nZXRBdCA9IGZ1bmN0aW9uKGRpbTEsIGRpbTIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuc2l6ZTIgKiBkaW0xICsgZGltMl07XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaW0xIGZpcnN0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbTIgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGF0IGdpdmVuIHBvc2l0aW9uLlxuICAgKi9cbiAgcHJvLnNldEF0ID0gZnVuY3Rpb24oZGltMSwgZGltMiwgdmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbdGhpcy5zaXplMiAqIGRpbTEgKyBkaW0yXSA9IHZhbHVlO1xuICB9O1xufSk7XG4iLCIvLyBqYXZhc2NyaXB0IChjbG9zdXJlKSBwb3J0IChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG4vKlxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZ29vZy5wcm92aWRlKCd3NjliLnFyLkh5YnJpZEJpbmFyaXplcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkJpdEFycmF5Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuQml0TWF0cml4Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuSW50QXJyYXkyRCcpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgQml0TWF0cml4ID0gdzY5Yi5xci5CaXRNYXRyaXg7XG4gIHZhciBJbnRBcnJheTJEID0gdzY5Yi5xci5JbnRBcnJheTJEO1xuICAvKipcbiAgICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgbG9jYWwgdGhyZXNob2xkaW5nIGFsZ29yaXRobSwgd2hpY2ggd2hpbGUgc2xvd2VyXG4gICAqIHRoYW4gdGhlIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgaXMgZmFpcmx5IGVmZmljaWVudCBmb3Igd2hhdCBpdCBkb2VzLlxuICAgKiBJdCBpcyBkZXNpZ25lZCBmb3IgaGlnaCBmcmVxdWVuY3kgaW1hZ2VzIG9mIGJhcmNvZGVzIHdpdGggYmxhY2sgZGF0YSBvblxuICAgKiB3aGl0ZSBiYWNrZ3JvdW5kcy4gRm9yIHRoaXMgYXBwbGljYXRpb24sIGl0IGRvZXMgYSBtdWNoIGJldHRlciBqb2IgdGhhbiBhXG4gICAqIGdsb2JhbCBibGFja3BvaW50IHdpdGggc2V2ZXJlIHNoYWRvd3MgYW5kIGdyYWRpZW50cy4gIEhvd2V2ZXIgaXQgdGVuZHMgdG9cbiAgICogcHJvZHVjZSBhcnRpZmFjdHMgb24gbG93ZXIgZnJlcXVlbmN5IGltYWdlcyBhbmQgaXMgdGhlcmVmb3JlIG5vdCBhIGdvb2RcbiAgICogZ2VuZXJhbCBwdXJwb3NlIGJpbmFyaXplciBmb3IgdXNlcyBvdXRzaWRlIFpYaW5nLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGV4dGVuZHMgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCB1c2luZyB0aGUgb2xkZXIgaGlzdG9ncmFtXG4gICAqIGFwcHJvYWNoIGZvciAxRCByZWFkZXJzLCBhbmQgdGhlIG5ld2VyIGxvY2FsIGFwcHJvYWNoIGZvciAyRCByZWFkZXJzLiAxRFxuICAgKiBkZWNvZGluZyB1c2luZyBhIHBlci1yb3cgaGlzdG9ncmFtIGlzIGFscmVhZHkgaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHlcbiAgICogZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsIGJ1dCBmb3JcbiAgICogbm93IGl0IHdhcyBub3QgYSB3aW4gdG8gdXNlIGxvY2FsIGJsb2NrcyBmb3IgMUQuXG4gICAqXG4gICAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzXG4gICAqIGZvciBsaWJyYXJ5IHVzZXJzLlxuICAgKlxuICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgKiBwb3J0ZWQgdG8ganMgYnkgTWFudWVsIEJyYXVuXG4gICAqXG4gICAqIEBwYXJhbSB7dzY5Yi5xci5RUkltYWdlfSBzb3VyY2UgZ3JheSB2YWx1ZXMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7dzY5Yi5xci5HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJ9XG4gICAqL1xuICB3NjliLnFyLkh5YnJpZEJpbmFyaXplciA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGdvb2cuYmFzZSh0aGlzLCBzb3VyY2UpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKHc2OWIucXIuSHlicmlkQmluYXJpemVyLCB3NjliLnFyLkdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcik7XG4gIHZhciBfID0gdzY5Yi5xci5IeWJyaWRCaW5hcml6ZXI7XG4gIHZhciBwcm8gPSBfLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0JpdE1hdHJpeH1cbiAgICovXG4gIHByby5tYXRyaXhfO1xuXG4gIC8vIFRoaXMgY2xhc3MgdXNlcyA1eDUgYmxvY2tzIHRvIGNvbXB1dGUgbG9jYWwgbHVtaW5hbmNlLCB3aGVyZSBlYWNoIGJsb2NrIGlzXG4gIC8vIDh4OCBwaXhlbHMuICBTbyB0aGlzIGlzIHRoZSBzbWFsbGVzdCBkaW1lbnNpb24gaW4gZWFjaCBheGlzIHdlIGNhbiBhY2NlcHQuXG4gIF8uQkxPQ0tfU0laRV9QT1dFUiA9IDM7XG4gIF8uQkxPQ0tfU0laRSA9IDEgPDwgXy5CTE9DS19TSVpFX1BPV0VSOyAvLyAuLi4wMTAwLi4uMDBcbiAgXy5CTE9DS19TSVpFX01BU0sgPSBfLkJMT0NLX1NJWkUgLSAxOyAgIC8vIC4uLjAwMTEuLi4xMVxuICBfLk1JTklNVU1fRElNRU5TSU9OID0gXy5CTE9DS19TSVpFICogNTtcbiAgXy5NSU5fRFlOQU1JQ19SQU5HRSA9IDI0O1xuXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZpbmFsIEJpdE1hdHJpeCBvbmNlIGZvciBhbGwgcmVxdWVzdHMuIFRoaXMgY291bGQgYmUgY2FsbGVkXG4gICAqIG9uY2UgZnJvbSB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCwgYnV0IHRoZXJlIGFyZSBzb21lIGFkdmFudGFnZXMgdG8gZG9pbmdcbiAgICogaXQgbGF6aWx5LCBzdWNoIGFzIG1ha2luZyBwcm9maWxpbmcgZWFzaWVyLCBhbmQgbm90IGRvaW5nIGhlYXZ5IGxpZnRpbmdcbiAgICogd2hlbiBjYWxsZXJzIGRvbid0IGV4cGVjdCBpdC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBwcm8uZ2V0QmxhY2tNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXRyaXhfICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdHJpeF87XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgIHZhciB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgaWYgKHdpZHRoID49IF8uTUlOSU1VTV9ESU1FTlNJT04gJiYgaGVpZ2h0ID49IF8uTUlOSU1VTV9ESU1FTlNJT04pIHtcbiAgICAgIHZhciBsdW1pbmFuY2VzID0gc291cmNlLmdldE1hdHJpeCgpO1xuICAgICAgLy8gZGl2ZWQgYnkgOFxuICAgICAgdmFyIHN1YldpZHRoID0gd2lkdGggPj4gXy5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgLy8gb25seSBldmVuIG51bWJlcnNcbiAgICAgIGlmICgod2lkdGggJiBfLkJMT0NLX1NJWkVfTUFTSykgIT0gMCkge1xuICAgICAgICBzdWJXaWR0aCsrO1xuICAgICAgfVxuICAgICAgdmFyIHN1YkhlaWdodCA9IGhlaWdodCA+PiBfLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICBpZiAoKGhlaWdodCAmIF8uQkxPQ0tfU0laRV9NQVNLKSAhPSAwKSB7XG4gICAgICAgIHN1YkhlaWdodCsrO1xuICAgICAgfVxuICAgICAgdmFyIGJsYWNrUG9pbnRzID0gXy5jYWxjdWxhdGVCbGFja1BvaW50cyhsdW1pbmFuY2VzLCBzdWJXaWR0aCxcbiAgICAgICAgc3ViSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyBCaXRNYXRyaXgod2lkdGgsIGhlaWdodCk7XG4gICAgICBfLmNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrKGx1bWluYW5jZXMsIHN1YldpZHRoLCBzdWJIZWlnaHQsXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGJsYWNrUG9pbnRzLCBuZXdNYXRyaXgpO1xuICAgICAgdGhpcy5tYXRyaXhfID0gbmV3TWF0cml4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgdG9vIHNtYWxsLCBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guXG4gICAgICB0aGlzLm1hdHJpeF8gPSBnb29nLmJhc2UodGhpcywgJ2dldEJsYWNrTWF0cml4Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdHJpeF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcHJvLmNyZWF0ZUJpbmFyaXplciA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgXyhzb3VyY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGUgaW1hZ2UsIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSBibGFjayBwb2ludCB1c2luZyBhIDV4NVxuICAgKiBncmlkIG9mIHRoZSBibG9ja3MgYXJvdW5kIGl0LiBBbHNvIGhhbmRsZXMgdGhlIGNvcm5lciBjYXNlcyAoZnJhY3Rpb25hbFxuICAgKiBibG9ja3MgYXJlIGNvbXB1dGVkIGJhc2VkIG9uIHRoZSBsYXN0IHBpeGVscyBpbiB0aGUgcm93L2NvbHVtbiB3aGljaCBhcmVcbiAgICogYWxzbyB1c2VkIGluIHRoZSBwcmV2aW91cyBibG9jaykuXG4gICAqL1xuICBfLmNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrID0gZnVuY3Rpb24obHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsIGJsYWNrUG9pbnRzLCBtYXRyaXgpIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHN1YkhlaWdodDsgeSsrKSB7XG4gICAgICB2YXIgeW9mZnNldCA9IHkgPDwgXy5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgdmFyIG1heFlPZmZzZXQgPSBoZWlnaHQgLSBfLkJMT0NLX1NJWkU7XG4gICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcbiAgICAgICAgeW9mZnNldCA9IG1heFlPZmZzZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgdmFyIHhvZmZzZXQgPSB4IDw8IF8uQkxPQ0tfU0laRV9QT1dFUjtcbiAgICAgICAgdmFyIG1heFhPZmZzZXQgPSB3aWR0aCAtIF8uQkxPQ0tfU0laRTtcbiAgICAgICAgaWYgKHhvZmZzZXQgPiBtYXhYT2Zmc2V0KSB7XG4gICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBfLmNhcCh4LCAyLCBzdWJXaWR0aCAtIDMpO1xuICAgICAgICB2YXIgdG9wID0gXy5jYXAoeSwgMiwgc3ViSGVpZ2h0IC0gMyk7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciB6ID0gLTI7IHogPD0gMjsgeisrKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9ICh0b3AgKyB6KSAqIGJsYWNrUG9pbnRzLnNpemUyO1xuICAgICAgICAgIHZhciByYXcgPSBibGFja1BvaW50cy5kYXRhO1xuICAgICAgICAgIHN1bSArPSByYXdbb2Zmc2V0ICsgbGVmdCAtIDJdICsgcmF3W29mZnNldCArIGxlZnQgLSAxXSArXG4gICAgICAgICAgICByYXdbb2Zmc2V0ICsgbGVmdF0gKyByYXdbb2Zmc2V0ICsgbGVmdCArIDFdICtcbiAgICAgICAgICAgIHJhd1tvZmZzZXQgKyBsZWZ0ICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSBzdW0gLyAyNTtcbiAgICAgICAgXy50aHJlc2hvbGRCbG9jayhsdW1pbmFuY2VzLCB4b2Zmc2V0LCB5b2Zmc2V0LCBhdmVyYWdlLCB3aWR0aCwgbWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGNhcHBlZCB2YWx1ZS5cbiAgICovXG4gIF8uY2FwID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyBhIHNpbmdsZSB0aHJlc2hvbGQgdG8gYSBibG9jayBvZiBwaXhlbHMuXG4gICAqL1xuICBfLnRocmVzaG9sZEJsb2NrID0gZnVuY3Rpb24obHVtaW5hbmNlcywgeG9mZnNldCwgeW9mZnNldCwgdGhyZXNob2xkLCBzdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXgpIHtcbiAgICBmb3IgKHZhciB5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHN0cmlkZSArIHhvZmZzZXQ7IHkgPCBfLkJMT0NLX1NJWkU7XG4gICAgICAgICB5KyssIG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgXy5CTE9DS19TSVpFOyB4KyspIHtcbiAgICAgICAgLy8gQ29tcGFyaXNvbiBuZWVkcyB0byBiZSA8PSBzbyB0aGF0IGJsYWNrID09IDAgcGl4ZWxzIGFyZVxuICAgICAgICAvLyBibGFjayBldmVuIGlmIHRoZSB0aHJlc2hvbGQgaXMgMC5cbiAgICAgICAgaWYgKChsdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhGRikgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgbWF0cml4LnNldCh4b2Zmc2V0ICsgeCwgeW9mZnNldCArIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGEgc2luZ2xlIGJsYWNrIHBvaW50IGZvciBlYWNoIGJsb2NrIG9mIHBpeGVscyBhbmQgc2F2ZXMgaXQgYXdheS5cbiAgICogU2VlIHRoZSBmb2xsb3dpbmcgdGhyZWFkIGZvciBhIGRpc2N1c3Npb24gb2YgdGhpcyBhbGdvcml0aG06XG4gICAqICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvenhpbmcvYnJvd3NlX3RocmVhZC90aHJlYWQvZDA2ZWZhMmMzNWE3ZGRjMFxuICAgKi9cbiAgXy5jYWxjdWxhdGVCbGFja1BvaW50cyA9IGZ1bmN0aW9uKGx1bWluYW5jZXMsIHN1YldpZHRoLCBzdWJIZWlnaHQsIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0KSB7XG4gICAgdmFyIHh4O1xuICAgIHZhciBibGFja1BvaW50cyA9IG5ldyBJbnRBcnJheTJEKHN1YkhlaWdodCwgc3ViV2lkdGgpO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHtcbiAgICAgIHZhciB5b2Zmc2V0ID0geSA8PCBfLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICB2YXIgbWF4WU9mZnNldCA9IGhlaWdodCAtIF8uQkxPQ0tfU0laRTtcbiAgICAgIGlmICh5b2Zmc2V0ID4gbWF4WU9mZnNldCkge1xuICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xuICAgICAgICB2YXIgeG9mZnNldCA9IHggPDwgXy5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICB2YXIgbWF4WE9mZnNldCA9IHdpZHRoIC0gXy5CTE9DS19TSVpFO1xuICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICB4b2Zmc2V0ID0gbWF4WE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIG1pbiA9IDB4RkY7XG4gICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICBmb3IgKHZhciB5eSA9IDAsIG9mZnNldCA9IHlvZmZzZXQgKiB3aWR0aCArIHhvZmZzZXQ7XG4gICAgICAgICAgICAgeXkgPCBfLkJMT0NLX1NJWkU7IHl5KyssIG9mZnNldCArPSB3aWR0aCkge1xuICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IF8uQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgdmFyIHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXQgKyB4eF0gJiAweEZGO1xuICAgICAgICAgICAgc3VtICs9IHBpeGVsO1xuICAgICAgICAgICAgLy8gc3RpbGwgbG9va2luZyBmb3IgZ29vZCBjb250cmFzdFxuICAgICAgICAgICAgaWYgKHBpeGVsIDwgbWluKSB7XG4gICAgICAgICAgICAgIG1pbiA9IHBpeGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4KSB7XG4gICAgICAgICAgICAgIG1heCA9IHBpeGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IG1pbi9tYXggdGVzdHMgb25jZSBkeW5hbWljIHJhbmdlIGlzIG1ldFxuICAgICAgICAgIGlmIChtYXggLSBtaW4gPiBfLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2ggdGhlIHJlc3Qgb2YgdGhlIHJvd3MgcXVpY2tseVxuICAgICAgICAgICAgZm9yICh5eSsrLCBvZmZzZXQgKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgIHl5IDwgXy5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgXy5CTE9DS19TSVpFOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGVzdGltYXRlIGlzIHRoZSBhdmVyYWdlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGJsb2NrLlxuICAgICAgICB2YXIgYXZlcmFnZSA9IHN1bSA+PiAoXy5CTE9DS19TSVpFX1BPV0VSICogMik7XG4gICAgICAgIGlmIChtYXggLSBtaW4gPD0gXy5NSU5fRFlOQU1JQ19SQU5HRSkge1xuICAgICAgICAgIC8vIElmIHZhcmlhdGlvbiB3aXRoaW4gdGhlIGJsb2NrIGlzIGxvdywgYXNzdW1lIHRoaXMgaXMgYSBibG9jayB3aXRoXG4gICAgICAgICAgLy8gb25seSBsaWdodCBvciBvbmx5IGRhcmsgcGl4ZWxzLiBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gdXNlXG4gICAgICAgICAgLy8gdGhlIGF2ZXJhZ2UsIGFzIGl0IHdvdWxkIGRpdmlkZSB0aGlzIGxvdyBjb250cmFzdCBhcmVhIGludG8gYmxhY2tcbiAgICAgICAgICAvLyBhbmQgd2hpdGUgcGl4ZWxzLCBlc3NlbnRpYWxseSBjcmVhdGluZyBkYXRhIG91dCBvZiBub2lzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgYmxvY2sgaXMgbGlnaHQvYmFja2dyb3VuZC5cbiAgICAgICAgICAvLyBTaW5jZSBubyBlc3RpbWF0ZSBmb3IgdGhlIGxldmVsIG9mIGRhcmsgcGl4ZWxzIGV4aXN0cyBsb2NhbGx5LCB1c2VcbiAgICAgICAgICAvLyBoYWxmIHRoZSBtaW4gZm9yIHRoZSBibG9jay5cbiAgICAgICAgICBhdmVyYWdlID0gbWluID4+IDE7XG5cbiAgICAgICAgICBpZiAoeSA+IDAgJiYgeCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvcnJlY3QgdGhlIFwid2hpdGUgYmFja2dyb3VuZFwiIGFzc3VtcHRpb24gZm9yIGJsb2NrcyB0aGF0IGhhdmVcbiAgICAgICAgICAgIC8vIG5laWdoYm9ycyBieSBjb21wYXJpbmcgdGhlIHBpeGVscyBpbiB0aGlzIGJsb2NrIHRvIHRoZVxuICAgICAgICAgICAgLy8gcHJldmlvdXNseSBjYWxjdWxhdGVkIGJsYWNrIHBvaW50cy4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgZmFjdFxuICAgICAgICAgICAgLy8gdGhhdCBkYXJrIGJhcmNvZGUgc3ltYm9sb2d5IGlzIGFsd2F5cyBzdXJyb3VuZGVkIGJ5IHNvbWUgYW1vdW50XG4gICAgICAgICAgICAvLyBvZiBsaWdodCBiYWNrZ3JvdW5kIGZvciB3aGljaCByZWFzb25hYmxlIGJsYWNrIHBvaW50IGVzdGltYXRlc1xuICAgICAgICAgICAgLy8gd2VyZSBtYWRlLiBUaGUgYnAgZXN0aW1hdGVkIGF0IHRoZSBib3VuZGFyaWVzIGlzIHVzZWQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJpb3IuXG5cbiAgICAgICAgICAgIC8vIFRoZSAobWluIDwgYnApIGlzIGFyYml0cmFyeSBidXQgd29ya3MgYmV0dGVyIHRoYW4gb3RoZXJcbiAgICAgICAgICAgIC8vIGhldXJpc3RpY3MgdGhhdCB3ZXJlIHRyaWVkLlxuICAgICAgICAgICAgdmFyIGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQgPSAoYmxhY2tQb2ludHMuZ2V0QXQoeSAtIDEsIHgpICtcbiAgICAgICAgICAgICAgKDIgKiBibGFja1BvaW50cy5nZXRBdCh5LCB4IC0gMSkpICtcbiAgICAgICAgICAgICAgYmxhY2tQb2ludHMuZ2V0QXQoeSAtIDEsIHggLSAxKSkgPj4gMjtcbiAgICAgICAgICAgIGlmIChtaW4gPCBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50KSB7XG4gICAgICAgICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBibGFja1BvaW50cy5zZXRBdCh5LCB4LCBhdmVyYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJsYWNrUG9pbnRzO1xuICB9O1xufSk7XG5cbiIsIi8vIChjKSAyMDEzIE1hbnVlbCBCcmF1biAobWJAdzY5Yi5jb20pXG5cbmdvb2cucHJvdmlkZSgndzY5Yi5xci5uYXRpdmVwcmVwcm9jZXNzaW5nJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuSHlicmlkQmluYXJpemVyJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUVJJbWFnZScpO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgXyA9IHc2OWIucXIubmF0aXZlcHJlcHJvY2Vzc2luZztcbiAgdmFyIFFSSW1hZ2UgPSB3NjliLnFyLlFSSW1hZ2U7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KCFJbWFnZURhdGF8IXc2OWIucXIuUVJJbWFnZSl9IGltYWdlRGF0YSBmcm9tIGNhbnZhcy5cbiAgICogQHJldHVybiB7IXc2OWIucXIuQml0TWF0cml4fSBiaW5hcnkgZGF0YS5cbiAgICovXG4gIF8uYmluYXJpemVJbWFnZURhdGEgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZ3JheSA9IF8uZ3JheXNjYWxlKGltYWdlRGF0YSk7XG4gICAgdmFyIGJpbmFyaXplciA9IG5ldyB3NjliLnFyLkh5YnJpZEJpbmFyaXplcihncmF5KTtcbiAgICByZXR1cm4gYmluYXJpemVyLmdldEJsYWNrTWF0cml4KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZ3JheXNjYWxlIHZlcnNpb24gb2YgaW1hZ2UuXG4gICAqIEBwYXJhbSB7KCFJbWFnZURhdGF8IXc2OWIucXIuUVJJbWFnZSl9IGltYWdlRGF0YSBmcm9tIGNhbnZhcy5cbiAgICogQHJldHVybiB7IXc2OWIucXIuUVJJbWFnZX0gYmluYXJ5IGRhdGEuXG4gICAqL1xuICBfLmdyYXlzY2FsZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBncmF5SW1nID0gUVJJbWFnZS5uZXdFbXB0eShpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgIHZhciBncmF5RGF0YSA9IGdyYXlJbWcuZGF0YTtcbiAgICB2YXIgcmdiYURhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JheURhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciByZ2JhUG9zID0gaSAqIDQ7XG4gICAgICBncmF5RGF0YVtpXSA9IChyZ2JhRGF0YVtyZ2JhUG9zXSAqIDMzICtcbiAgICAgICAgcmdiYURhdGFbcmdiYVBvcyArIDFdICogMzQgK1xuICAgICAgICByZ2JhRGF0YVtyZ2JhUG9zICsgMl0gKiAzMykgLyAxMDA7XG4gICAgfVxuICAgIHJldHVybiBncmF5SW1nO1xuICB9O1xuXG59KTtcblxuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbmdvb2cucHJvdmlkZSgndzY5Yi5xci5pbWFnZWRlY29kaW5nJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIuaW1nLlJHQkFCaXRNYXRyaXgnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWcuV2ViR0xCaW5hcml6ZXInKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5pbWd0b29scycpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkRlY29kZVJlc3VsdCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLkRldGVjdG9yJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuUVJJbWFnZScpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLlJlYWRlckVycm9yJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuZGVjb2RlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLmVuY29kZXIuRW5jb2RlcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLm5hdGl2ZXByZXByb2Nlc3NpbmcnKTtcblxuLyoqXG4gKiBTaW1wbGUgaGlnaC1sZXZlbCBpbnRlcmZhY2UgdG8gZGVjb2RlIHFyIGNvZGVzLlxuICogQGF1dGhvciBtYkB3NjliLmNvbSAoTWFudWVsIEJyYXVuKVxuICovXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgRGV0ZWN0b3IgPSB3NjliLnFyLkRldGVjdG9yO1xuICB2YXIgUkdCQUJpdE1hdHJpeCA9IHc2OWIuaW1nLlJHQkFCaXRNYXRyaXg7XG4gIHZhciBEZWNvZGVSZXN1bHQgPSB3NjliLnFyLkRlY29kZVJlc3VsdDtcbiAgdmFyIFdlYkdMQmluYXJpemVyID0gdzY5Yi5pbWcuV2ViR0xCaW5hcml6ZXI7XG4gIHZhciBpbWd0b29scyA9IHc2OWIuaW1ndG9vbHM7XG4gIHZhciBwcmVwcm9jZXNzaW5nID0gdzY5Yi5xci5uYXRpdmVwcmVwcm9jZXNzaW5nO1xuXG4gIHZhciBfID0gdzY5Yi5xci5pbWFnZWRlY29kaW5nO1xuXG4gIF8ud2ViR0xCaW5hcml6ZXJfID0gbnVsbDtcblxuICBfLmdldFdlYkdMQmluYXJpemVyXyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghXy53ZWJHTEJpbmFyaXplcl8pIHtcbiAgICAgIF8ud2ViR0xCaW5hcml6ZXJfID0gbmV3IFdlYkdMQmluYXJpemVyKCk7XG4gICAgfVxuICAgIHJldHVybiBfLndlYkdMQmluYXJpemVyXztcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIHFyIGNvZGUgaW4gbWFpbiB0aHJlYWQuXG4gICAqIEBwYXJhbSB7KEltYWdlfEhUTUxWaWRlb0VsZW1lbnQpfSBpbWcgaW1hZ2Ugb3IgdmlkZW8uXG4gICAqIEBwYXJhbSB7P3c2OWIucXIuUmVzdWx0UG9pbnRDYWxsYmFjaz19IGNhbGxiYWNrIGNhbGxiYWNrIGZvciBwYXR0ZXJucy5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYmdsIHdoZXRoZXIgdG8gdXNlIFdlYkdsIGJpbmFyaXplciBpZiBzdXBwb3J0ZWQuXG4gICAqIEByZXR1cm4ge0RlY29kZVJlc3VsdH0gcmVzdWx0LlxuICAgKi9cbiAgXy5kZWNvZGUgPSBmdW5jdGlvbihpbWcsIGNhbGxiYWNrLCBvcHRfd2ViZ2wpIHtcbiAgICB2YXIgaW1nRGF0YTtcbiAgICBpZiAob3B0X3dlYmdsICYmIFdlYkdMQmluYXJpemVyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHZhciBiaW5hcml6ZXIgPSBfLmdldFdlYkdMQmluYXJpemVyXygpO1xuICAgICAgYmluYXJpemVyLnNldHVwKGltZy53aWR0aCB8fCBpbWcudmlkZW9IZWlnaHQsIGltZy5oZWlnaHQgfHwgaW1nLnZpZGVvSGVpZ2h0KTtcbiAgICAgIGJpbmFyaXplci5yZW5kZXIoaW1nKTtcbiAgICAgIGltZ0RhdGEgPSBiaW5hcml6ZXIuZ2V0Qml0TWF0cml4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltZ0RhdGEgPSBpbWd0b29scy5nZXRJbWFnZURhdGEoaW1nLCA3MDApO1xuICAgIH1cbiAgICByZXR1cm4gXy5kZWNvZGVGcm9tSW1hZ2VEYXRhKGltZ0RhdGEsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIHFyIGNvZGUgZnJvbSBJbWFnZURhdGEgb3IgcHJlcHJvY2Vzc2VkIFJHQkFCaXRNYXRyaXguXG4gICAqIEBwYXJhbSB7KCFJbWFnZURhdGF8IXc2OWIucXIuUVJJbWFnZXwhUkdCQUJpdE1hdHJpeCl9IGltZ2RhdGEgZnJvbSBjYW52YXMuXG4gICAqIEBwYXJhbSB7P3c2OWIucXIuUmVzdWx0UG9pbnRDYWxsYmFjaz19IG9wdF9jYWxsYmFjayBjYWxsYmFjay5cbiAgICogQHJldHVybiB7RGVjb2RlUmVzdWx0fSBkZWNvZGVkIHFyIGNvZGUuXG4gICAqL1xuICBfLmRlY29kZUZyb21JbWFnZURhdGEgPSBmdW5jdGlvbihpbWdkYXRhLCBvcHRfY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBfLmRlY29kZUZyb21JbWFnZURhdGFUaHJvd2luZyhpbWdkYXRhLCBvcHRfY2FsbGJhY2spO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVzdWx0ID0gbmV3IERlY29kZVJlc3VsdChlcnIpO1xuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgdzY5Yi5xci5SZWFkZXJFcnJvcikpXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogVGhyb3dzIFJlYWRlckVycm9yIGlmIGRldGVjdGlvbiBmYWlscy5cbiAgICogQHBhcmFtIHsoIUltYWdlRGF0YXwhdzY5Yi5xci5RUkltYWdlfCFSR0JBQml0TWF0cml4KX0gaW1nZGF0YSBmcm9tIGNhbnZhcy5cbiAgICogQHBhcmFtIHs/dzY5Yi5xci5SZXN1bHRQb2ludENhbGxiYWNrPX0gb3B0X2NhbGxiYWNrIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHtEZWNvZGVSZXN1bHR9IGRlY29kZWQgcXIgY29kZS5cbiAgICovXG4gIF8uZGVjb2RlRnJvbUltYWdlRGF0YVRocm93aW5nID0gZnVuY3Rpb24oaW1nZGF0YSwgb3B0X2NhbGxiYWNrKSB7XG4gICAgdmFyIGJpdG1hcDtcbiAgICBpZiAoaW1nZGF0YSBpbnN0YW5jZW9mIFJHQkFCaXRNYXRyaXgpIHtcbiAgICAgIGJpdG1hcCA9IGltZ2RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpdG1hcCA9IHByZXByb2Nlc3NpbmcuYmluYXJpemVJbWFnZURhdGEoaW1nZGF0YSk7XG4gICAgfVxuICAgIHZhciBkZXRlY3RvciA9IG5ldyBEZXRlY3RvcihiaXRtYXAsIG9wdF9jYWxsYmFjayk7XG5cbiAgICB2YXIgZGV0ZWN0b3JSZXN1bHQgPSBkZXRlY3Rvci5kZXRlY3QoKTtcbiAgICB2YXIgdGV4dCA9IHc2OWIucXIuZGVjb2Rlci5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQuYml0cyk7XG5cbiAgICByZXR1cm4gbmV3IERlY29kZVJlc3VsdCh0ZXh0LCBkZXRlY3RvclJlc3VsdC5wb2ludHMpO1xuICB9O1xuXG59KTtcblxuZ29vZy5leHBvcnRTeW1ib2woJ3c2OWIucXIuaW1hZ2VkZWNvZGluZy5kZWNvZGVGcm9tSW1hZ2VEYXRhJyxcbiAgdzY5Yi5xci5pbWFnZWRlY29kaW5nLmRlY29kZUZyb21JbWFnZURhdGEpO1xuIiwiLy8gKGMpIDIwMTMgTWFudWVsIEJyYXVuIChtYkB3NjliLmNvbSlcbmdvb2cucHJvdmlkZSgndzY5Yi5xci5EZWNvZGVXb3JrZXInKTtcbmdvb2cucmVxdWlyZSgnZ29vZy51c2VyQWdlbnQucHJvZHVjdCcpO1xuZ29vZy5yZXF1aXJlKCd3NjliLmltZy5SR0JBQml0TWF0cml4Jyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuSW52YWxpZENoYXJzZXRFcnJvcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLlFSSW1hZ2UnKTtcbmdvb2cucmVxdWlyZSgndzY5Yi5xci5SZWFkZXJFcnJvcicpO1xuZ29vZy5yZXF1aXJlKCd3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlJyk7XG5nb29nLnJlcXVpcmUoJ3c2OWIucXIuaW1hZ2VkZWNvZGluZycpO1xuXG4vLyBIYWNrIHRvIHdvcmsgYXJyb3VuZCBjbG9zdXJlIHdhcm5pbmdzLlxudmFyIGhvc3QgPSBzZWxmO1xuXG5nb29nLnNjb3BlKGZ1bmN0aW9uKCkge1xuICB2YXIgcXJjb2RlID0gdzY5Yi5xci5pbWFnZWRlY29kaW5nO1xuICB2YXIgUmVhZGVyRXJyb3IgPSB3NjliLnFyLlJlYWRlckVycm9yO1xuICB2YXIgV29ya2VyTWVzc2FnZVR5cGUgPSB3NjliLnFyLldvcmtlck1lc3NhZ2VUeXBlO1xuXG4gIHZhciBfID0gdzY5Yi5xci5EZWNvZGVXb3JrZXI7XG4gIF8uaWNvbnZQYXRoID0gJ2ljb252LmpzJztcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ1R5cGUgbWVzc3NhZ2UgdHlwZS5cbiAgICogQHBhcmFtIHsqPX0gb3B0X3Jlc3VsdCB2YWx1ZS5cbiAgICovXG4gIF8uc2VuZCA9IGZ1bmN0aW9uKG1zZ1R5cGUsIG9wdF9yZXN1bHQpIHtcbiAgICBob3N0LnBvc3RNZXNzYWdlKFttc2dUeXBlLCBob3N0WydKU09OJ10uc3RyaW5naWZ5KG9wdF9yZXN1bHQpXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KCF3NjliLnFyLlFSSW1hZ2V8IXc2OWIuaW1nLlJHQkFCaXRNYXRyaXgpfSBpbWdkYXRhIGltYWdlIHRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZhaWxPbkNoYXJzZXQgaW1tZWRpYXRlbHkgZmFpbCBvbiBjaGFyc2V0IGVycm9yIGlmIHRydWUsXG4gICAqIGRvIG5vdCB0cnkgdG8gbG9hZCBpY29udi5cbiAgICogZGVjb2RlLlxuICAgKi9cbiAgXy5kZWNvZGUgPSBmdW5jdGlvbihpbWdkYXRhLCBmYWlsT25DaGFyc2V0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gcXJjb2RlLmRlY29kZUZyb21JbWFnZURhdGEoaW1nZGF0YSwgXy5vblBhdHRlcm5Gb3VuZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgdzY5Yi5xci5JbnZhbGlkQ2hhcnNldEVycm9yICYmICFzZWxmLmljb252ICYmXG4gICAgICAgIF8uaWNvbnZQYXRoICYmICFmYWlsT25DaGFyc2V0KSB7XG4gICAgICAgIC8vIGxvYWQgaWNvbnYuXG4gICAgICAgIGltcG9ydFNjcmlwdHMoXy5pY29udlBhdGgpO1xuICAgICAgICAvLyBhbmQgdHJ5IGFnYWluLlxuICAgICAgICBfLmRlY29kZShpbWdkYXRhLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0LmlzRXJyb3IoKSkge1xuICAgICAgdmFyIGVyciA9IHJlc3VsdC5nZXRFcnJvcigpO1xuICAgICAgXy5zZW5kKFdvcmtlck1lc3NhZ2VUeXBlLk5PVEZPVU5ELCBlcnIgJiYgZXJyLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfLnNlbmQoV29ya2VyTWVzc2FnZVR5cGUuREVDT0RFRCwgcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHc2OWIucXIuQWxpZ25tZW50UGF0dGVybnx3NjliLnFyLkZpbmRlclBhdHRlcm4pfSBwYXR0ZXJuIGZvdW5kLlxuICAgKi9cbiAgXy5vblBhdHRlcm5Gb3VuZCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAvLyBCdWlsZCBwbGFpbiBqc29uIG9iamVjdC5cbiAgICBfLnNlbmQoV29ya2VyTWVzc2FnZVR5cGUuUEFUVEVSTiwgcGF0dGVybik7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIGhvc3QuXG4gICAqL1xuICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgIC8vIE1lc3NhZ2Ugb25seSBzZW50IGZvciBmZWF0dXJlIGRldGVjdGlvbiBvZiB0cmFuc2ZlcmFibGUgb2JqZWN0cy5cbiAgICBpZiAoZGF0YVsnaXNmZWF0dXJlZGV0ZWN0J10pIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmIChkYXRhWydzZXRJY29udlVybCddKSB7XG4gICAgICBfLmljb252UGF0aCA9IGRhdGFbJ3NldEljb252VXJsJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlY29kZVxuICAgICAgdmFyIHdpZHRoID0gZGF0YVsnd2lkdGgnXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhWydoZWlnaHQnXTtcbiAgICAgIHZhciBidWZmZXIgPSBkYXRhWydidWZmZXInXTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IGRhdGFbJ2lzQmluYXJ5J107XG4gICAgICBpZiAoIWJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCd3b3JrZXIgY29tbW11bmljYXRpb24gZmFpbGVkJyk7XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2U7XG4gICAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgaW1hZ2UgPSBuZXcgdzY5Yi5pbWcuUkdCQUJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gbmV3IHc2OWIucXIuUVJJbWFnZSh3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpKTtcbiAgICAgIH1cbiAgICAgIF8uZGVjb2RlKGltYWdlKTtcbiAgICAgIC8vIEhhY2sgZm9yIEZGIG1lbW9yeSBsZWFrIC0gaWYgd2ViZ2wgaXMgdXNlZCwgd2UgdHJhbmZlciBiYWNrIHRoZVxuICAgICAgLy8gYnVmZmVyIGFzIGEgd29ya2Fyb3VuZC5cbiAgICAgIGlmIChnb29nLnVzZXJBZ2VudC5wcm9kdWN0LkZJUkVGT1gpIHtcbiAgICAgICAgaG9zdC5wb3N0TWVzc2FnZShbJ2ZmbWVtb3J5aGFjaycsIG51bGxdLCBbYnVmZmVyXSk7XG4gICAgICAgIGV2ZW50LmRhdGFbJ2J1ZmZlciddID0gbnVsbDtcbiAgICAgICAgLy8gZXZlbnQuZGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG5cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
